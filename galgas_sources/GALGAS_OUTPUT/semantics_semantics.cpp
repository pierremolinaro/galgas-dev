//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 16th, 2008, at 20h33'50"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semantics_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeCplusPlusNameList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeCplusPlusNameList * _p = dynamic_cast <const elementOf_GGS_typeCplusPlusNameList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCppName._operator_isEqual (_p->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
_operator_concat (const GGS_typeCplusPlusNameList & inOperand) const {
  GGS_typeCplusPlusNameList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeCplusPlusNameList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppName ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCppName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalSubListWithRange (GGS_typeCplusPlusNameList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mCppName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeCplusPlusNameList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_first (C_Compiler & _inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_last (C_Compiler & _inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeCplusPlusNameList::
reader_mCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_setMCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExpression::
cPtr_typeExpression (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExpression * GGS_typeExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeExpression (& typeid (cPtr_typeExpression), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeExpression GGS_typeExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeExpression::actualTypeName (void) const {
  return "typeExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeExpression ("typeExpression") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_typeClassMessagesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeClassMessagesMap::e_typeClassMessagesMap (void) :
mMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeClassMessagesMap * _p = dynamic_cast <const elementOf_GGS_typeClassMessagesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMessage._operator_isEqual (_p->mInfo.mMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeClassMessagesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
_operator_isEqual (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
_operator_isNotEqual (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the message '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeClassMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mGalgasVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticsTypesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeSemanticsTypesList * _p = dynamic_cast <const elementOf_GGS_typeSemanticsTypesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mGalgasVariableName._operator_isEqual (_p->mGalgasVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
_operator_concat (const GGS_typeSemanticsTypesList & inOperand) const {
  GGS_typeSemanticsTypesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeSemanticsTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mGalgasVariableName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mGalgasVariableName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalSubListWithRange (GGS_typeSemanticsTypesList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType, _p->mGalgasVariableName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeSemanticsTypesList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeSemanticsTypesList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeSemanticsTypesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_first (C_Compiler & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_last (C_Compiler & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeSemanticsTypesList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSemanticsTypesList::
reader_mGalgasVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGalgasVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_setMGalgasVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGalgasVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

e_typeVariablesMap::e_typeVariablesMap (void) :
mArgumentType (),
mCplusPlusName () {
}

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map '@typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadOnlyAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForDestructiveReadAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertListOfEntitiesLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertListOfEntitiesLocalVariableGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertSingleEntityLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertSingleEntityLocalVariableGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertEntityAttributeLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertEntityAttributeLocalVariableGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadow (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgumentNoShadow (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadowGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUsedConstInArgumentNoShadow (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariable (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariableGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutProperty (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutPropertyGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgument (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgumentGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
aNomVariableCible (argument_0),
aNomAttributSource (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_assignedVariables::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_assignedVariables * _p = dynamic_cast <const elementOf_GGS_L_assignedVariables *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomVariableCible._operator_isEqual (_p->aNomVariableCible).boolValue ()
         && aNomAttributSource._operator_isEqual (_p->aNomAttributSource).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomVariableCible.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomAttributSource.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
_operator_concat (const GGS_L_assignedVariables & inOperand) const {
  GGS_L_assignedVariables result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_assignedVariables * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->aNomVariableCible ;
          GGS_lstring  p_1 = p->aNomAttributSource ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aNomVariableCible,
                                _p->aNomAttributSource
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalSubListWithRange (GGS_L_assignedVariables & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->aNomVariableCible, _p->aNomAttributSource) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_assignedVariables result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_assignedVariables result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_assignedVariables", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_first (C_Compiler & _inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_last (C_Compiler & _inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_L_assignedVariables::
reader_aNomVariableCibleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aNomVariableCible ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_assignedVariables::
reader_aNomAttributSourceAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aNomAttributSource ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_setANomVariableCibleAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aNomVariableCible = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_setANomAttributSourceAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aNomAttributSource = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCible *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCible *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCible::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCible:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCible::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCible::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCible (& typeid (cPtr_typeCible), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCible GGS_typeCible::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCible _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCible *> (inPointer) != NULL)
      : (typeid (cPtr_typeCible) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCible (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCible),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCible::actualTypeName (void) const {
  return "typeCible" ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeCible ("typeCible") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
aCible (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCibles::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCibles * _p = dynamic_cast <const elementOf_GGS_typeListeCibles *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aCible._operator_isEqual (_p->aCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aCible.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalAppendValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalPrependValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_addAssign_operation (const GGS_typeCible & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
_operator_concat (const GGS_typeListeCibles & inOperand) const {
  GGS_typeListeCibles result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeCibles * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCible  p_0 = p->aCible ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCible & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aCible
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeCible & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalSubListWithRange (GGS_typeListeCibles & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->aCible) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCibles result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCibles result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeCibles", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_first (C_Compiler & _inLexique,
              GGS_typeCible & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_last (C_Compiler & _inLexique,
             GGS_typeCible & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeCible & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeCible & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCible  GGS_typeListeCibles::
reader_aCibleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCible  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aCible ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_setACibleAtIndex (C_Compiler & inLexique,
                              const GGS_typeCible  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aCible = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_nameWithType::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_nameWithType * _p = dynamic_cast <const elementOf_GGS_L_nameWithType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mName._operator_isEqual (_p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
_operator_concat (const GGS_L_nameWithType & inOperand) const {
  GGS_L_nameWithType result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_nameWithType * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalSubListWithRange (GGS_L_nameWithType & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mType, _p->mName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_nameWithType result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_nameWithType result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_nameWithType", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_nameWithType::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_nameWithType::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

e_typeTableMethodesAimplementer::e_typeTableMethodesAimplementer (void) :
aListeTypesParametres (),
aListeTypeEtNomsArguments (),
mInstructionList () {
}

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableMethodesAimplementer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstract (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstractGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 attributeIndex = insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstract (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstractGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 attributeIndex = insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeExpressionList * _p = dynamic_cast <const elementOf_GGS_typeExpressionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalAppendValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalPrependValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_addAssign_operation (const GGS_typeExpression & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
_operator_concat (const GGS_typeExpressionList & inOperand) const {
  GGS_typeExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mExpression ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeExpression & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeExpression & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalSubListWithRange (GGS_typeExpressionList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeExpressionList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeExpressionList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_typeExpression & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_typeExpression & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeExpression & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeExpression & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeExpressionList::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_varToDropList::
elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mVarToDrop (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_varToDropList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_varToDropList * _p = dynamic_cast <const elementOf_GGS_varToDropList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVarToDrop._operator_isEqual (_p->mVarToDrop).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_varToDropList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarToDrop.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
_operator_concat (const GGS_varToDropList & inOperand) const {
  GGS_varToDropList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_varToDropList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mVarToDrop ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVarToDrop
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
internalSubListWithRange (GGS_varToDropList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mVarToDrop) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_varToDropList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_varToDropList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varToDropList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@varToDropList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_first (C_Compiler & _inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_last (C_Compiler & _inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_varToDropList::
reader_mVarToDropAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVarToDrop ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_setMVarToDropAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVarToDrop = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::
cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2),
mVarToDropList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeErrorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeErrorInstruction * _p = dynamic_cast <const cPtr_typeErrorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue ()
         && mErrorMessageExpression._operator_isEqual (_p->mErrorMessageExpression).boolValue ()
         && mLocation._operator_isEqual (_p->mLocation).boolValue ()
         && mVarToDropList._operator_isEqual (_p->mVarToDropList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeErrorInstruction:"
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVarToDropList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeErrorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeErrorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeErrorInstruction (& typeid (cPtr_typeErrorInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeErrorInstruction GGS_typeErrorInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeErrorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeErrorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeErrorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeErrorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction GGS_typeErrorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2,
                 const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeErrorInstruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_typeErrorInstruction::
reader_mVarToDropList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_varToDropList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mVarToDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeErrorInstruction::actualTypeName (void) const {
  return "typeErrorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeErrorInstruction ("typeErrorInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeSendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSendInstruction::
cPtr_typeSendInstruction (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSendInstruction * GGS_typeSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSendInstruction * _p = dynamic_cast <const cPtr_typeSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSendInstruction:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSendInstruction (& typeid (cPtr_typeSendInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSendInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSendInstruction::
GGS_typeSendInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction::
GGS_typeSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeSendInstruction GGS_typeSendInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction GGS_typeSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSendInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSendInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSendInstruction::actualTypeName (void) const {
  return "typeSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSendInstruction ("typeSendInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeWarningInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::
cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeWarningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeWarningInstruction * _p = dynamic_cast <const cPtr_typeWarningInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mWarningLocationExpression._operator_isEqual (_p->mWarningLocationExpression).boolValue ()
         && mWarningMessageExpression._operator_isEqual (_p->mWarningMessageExpression).boolValue ()
         && mLocation._operator_isEqual (_p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeWarningInstruction:"
           << mWarningLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWarningMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeWarningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeWarningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeWarningInstruction (& typeid (cPtr_typeWarningInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeWarningInstruction GGS_typeWarningInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeWarningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeWarningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeWarningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeWarningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction GGS_typeWarningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeWarningInstruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeWarningInstruction::actualTypeName (void) const {
  return "typeWarningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeWarningInstruction ("typeWarningInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeMessageInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::
cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMessageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMessageInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMessageInstruction * _p = dynamic_cast <const cPtr_typeMessageInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMessageExpression._operator_isEqual (_p->mMessageExpression).boolValue ()
         && mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMessageInstruction:"
           << mMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMessageInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMessageInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMessageInstruction (& typeid (cPtr_typeMessageInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMessageInstruction GGS_typeMessageInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMessageInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMessageInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMessageInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMessageInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction GGS_typeMessageInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMessageInstruction::
reader_mMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMessageInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMessageInstruction::actualTypeName (void) const {
  return "typeMessageInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMessageInstruction ("typeMessageInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeMethodCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodCallInstruction::
cPtr_typeMethodCallInstruction (const GGS_AC_galgasType & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mExpressionType (argument_0),
mExpression (argument_1),
aNomMethodeSimple (argument_2),
mExpressionsList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodCallInstruction * GGS_typeMethodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMethodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodCallInstruction * _p = dynamic_cast <const cPtr_typeMethodCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpressionType._operator_isEqual (_p->mExpressionType).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && aNomMethodeSimple._operator_isEqual (_p->aNomMethodeSimple).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMethodCallInstruction:"
           << mExpressionType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodCallInstruction (& typeid (cPtr_typeMethodCallInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMethodCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMethodCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeMethodCallInstruction::
reader_mExpressionType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMethodCallInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodCallInstruction::
reader_aNomMethodeSimple (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->aNomMethodeSimple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMethodCallInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodCallInstruction::actualTypeName (void) const {
  return "typeMethodCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMethodCallInstruction ("typeMethodCallInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeCallOfTypeMethodInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCallOfTypeMethodInstruction::
cPtr_typeCallOfTypeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTypeName (argument_0),
mTypeMethodName (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCallOfTypeMethodInstruction * GGS_typeCallOfTypeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCallOfTypeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCallOfTypeMethodInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCallOfTypeMethodInstruction * _p = dynamic_cast <const cPtr_typeCallOfTypeMethodInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mTypeMethodName._operator_isEqual (_p->mTypeMethodName).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCallOfTypeMethodInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCallOfTypeMethodInstruction:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTypeMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCallOfTypeMethodInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCallOfTypeMethodInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCallOfTypeMethodInstruction (& typeid (cPtr_typeCallOfTypeMethodInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeCallOfTypeMethodInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeCallOfTypeMethodInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCallOfTypeMethodInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCallOfTypeMethodInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeCallOfTypeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeCallOfTypeMethodInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCallOfTypeMethodInstruction::actualTypeName (void) const {
  return "typeCallOfTypeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCallOfTypeMethodInstruction ("typeCallOfTypeMethodInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeModifierCallInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::
cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
mStructAttributeList (argument_1),
aNomMethodeSimple (argument_2),
mExpressionsList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModifierCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModifierCallInstruction * _p = dynamic_cast <const cPtr_typeModifierCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomCppVariable._operator_isEqual (_p->aNomCppVariable).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && aNomMethodeSimple._operator_isEqual (_p->aNomMethodeSimple).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModifierCallInstruction:"
           << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeModifierCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeModifierCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeModifierCallInstruction (& typeid (cPtr_typeModifierCallInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeModifierCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeModifierCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeModifierCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeModifierCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeModifierCallInstruction::
reader_aNomCppVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeModifierCallInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeModifierCallInstruction::
reader_aNomMethodeSimple (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomMethodeSimple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeModifierCallInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeModifierCallInstruction::actualTypeName (void) const {
  return "typeModifierCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeModifierCallInstruction ("typeModifierCallInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeInstructionAppelMethodeListe'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::
cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelMethodeListe *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelMethodeListe::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelMethodeListe * _p = dynamic_cast <const cPtr_typeInstructionAppelMethodeListe *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomCppAttribut._operator_isEqual (_p->aNomCppAttribut).boolValue ()
         && aMethodeDeListe._operator_isEqual (_p->aMethodeDeListe).boolValue ()
         && aListeNomsCppArguments._operator_isEqual (_p->aListeNomsCppArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelMethodeListe:"
           << aNomCppAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aMethodeDeListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeNomsCppArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelMethodeListe::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelMethodeListe::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionAppelMethodeListe (& typeid (cPtr_typeInstructionAppelMethodeListe), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionAppelMethodeListe) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeInstructionAppelMethodeListe (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionAppelMethodeListe),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionAppelMethodeListe::
reader_aNomCppAttribut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aNomCppAttribut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelMethodeListe::
reader_aMethodeDeListe (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aMethodeDeListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeInstructionAppelMethodeListe::
reader_aListeNomsCppArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aListeNomsCppArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionAppelMethodeListe::actualTypeName (void) const {
  return "typeInstructionAppelMethodeListe" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInstructionAppelMethodeListe ("typeInstructionAppelMethodeListe", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_typeInstructionDeclarationVarLocale'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::
cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionDeclarationVarLocale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionDeclarationVarLocale::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionDeclarationVarLocale * _p = dynamic_cast <const cPtr_typeInstructionDeclarationVarLocale *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomCppVariable._operator_isEqual (_p->aNomCppVariable).boolValue ()
         && aTypeVariable._operator_isEqual (_p->aTypeVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionDeclarationVarLocale:"
           << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTypeVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionDeclarationVarLocale::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionDeclarationVarLocale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionDeclarationVarLocale (& typeid (cPtr_typeInstructionDeclarationVarLocale), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionDeclarationVarLocale) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeInstructionDeclarationVarLocale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionDeclarationVarLocale),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionDeclarationVarLocale::
reader_aNomCppVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeInstructionDeclarationVarLocale::
reader_aTypeVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aTypeVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionDeclarationVarLocale::actualTypeName (void) const {
  return "typeInstructionDeclarationVarLocale" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInstructionDeclarationVarLocale ("typeInstructionDeclarationVarLocale", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeMapBlockPrologueInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::
cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockPrologueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockPrologueInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockPrologueInstruction * _p = dynamic_cast <const cPtr_typeMapBlockPrologueInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomVariableTable._operator_isEqual (_p->aNomVariableTable).boolValue ()
         && aNomMethodeBloc._operator_isEqual (_p->aNomMethodeBloc).boolValue ()
         && mPrologueExpressionList._operator_isEqual (_p->mPrologueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockPrologueInstruction:"
           << aNomVariableTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPrologueExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockPrologueInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockPrologueInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMapBlockPrologueInstruction (& typeid (cPtr_typeMapBlockPrologueInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMapBlockPrologueInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMapBlockPrologueInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMapBlockPrologueInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockPrologueInstruction::
reader_aNomVariableTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockPrologueInstruction::
reader_aNomMethodeBloc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockPrologueInstruction::
reader_mPrologueExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->mPrologueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMapBlockPrologueInstruction::actualTypeName (void) const {
  return "typeMapBlockPrologueInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMapBlockPrologueInstruction ("typeMapBlockPrologueInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeMapBlockEpilogueInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::
cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockEpilogueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockEpilogueInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockEpilogueInstruction * _p = dynamic_cast <const cPtr_typeMapBlockEpilogueInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomVariableTable._operator_isEqual (_p->aNomVariableTable).boolValue ()
         && aNomMethodeBloc._operator_isEqual (_p->aNomMethodeBloc).boolValue ()
         && mEpilogueExpressionList._operator_isEqual (_p->mEpilogueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockEpilogueInstruction:"
           << aNomVariableTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEpilogueExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockEpilogueInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockEpilogueInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMapBlockEpilogueInstruction (& typeid (cPtr_typeMapBlockEpilogueInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMapBlockEpilogueInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMapBlockEpilogueInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMapBlockEpilogueInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockEpilogueInstruction::
reader_aNomVariableTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockEpilogueInstruction::
reader_aNomMethodeBloc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockEpilogueInstruction::
reader_mEpilogueExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->mEpilogueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMapBlockEpilogueInstruction::actualTypeName (void) const {
  return "typeMapBlockEpilogueInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMapBlockEpilogueInstruction ("typeMapBlockEpilogueInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeReaderCallInExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::
cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2),
mConversionMethod (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeReaderCallInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeReaderCallInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeReaderCallInExpression * _p = dynamic_cast <const cPtr_typeReaderCallInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpressionValue._operator_isEqual (_p->mExpressionValue).boolValue ()
         && mReaderName._operator_isEqual (_p->mReaderName).boolValue ()
         && mExpressionList._operator_isEqual (_p->mExpressionList).boolValue ()
         && mConversionMethod._operator_isEqual (_p->mConversionMethod).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeReaderCallInExpression:"
           << mExpressionValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConversionMethod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeReaderCallInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeReaderCallInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeReaderCallInExpression (& typeid (cPtr_typeReaderCallInExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeReaderCallInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeReaderCallInExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeReaderCallInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeReaderCallInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeReaderCallInExpression::
reader_mExpressionValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeReaderCallInExpression::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeReaderCallInExpression::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_mConversionMethod (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mConversionMethod ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeReaderCallInExpression::actualTypeName (void) const {
  return "typeReaderCallInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeReaderCallInExpression ("typeReaderCallInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeFileWrapperWithStaticPath'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperWithStaticPath::
cPtr_typeFileWrapperWithStaticPath (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0),
mFileIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperWithStaticPath * GGS_typeFileWrapperWithStaticPath::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFileWrapperWithStaticPath *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperWithStaticPath::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperWithStaticPath * _p = dynamic_cast <const cPtr_typeFileWrapperWithStaticPath *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFileWrapperName._operator_isEqual (_p->mFileWrapperName).boolValue ()
         && mFileIndex._operator_isEqual (_p->mFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperWithStaticPath::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFileWrapperWithStaticPath:"
           << mFileWrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFileIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperWithStaticPath::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperWithStaticPath::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperWithStaticPath (& typeid (cPtr_typeFileWrapperWithStaticPath), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFileWrapperWithStaticPath'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath::
GGS_typeFileWrapperWithStaticPath (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath::
GGS_typeFileWrapperWithStaticPath (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperWithStaticPath) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFileWrapperWithStaticPath (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperWithStaticPath),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperWithStaticPath (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperWithStaticPath::
reader_mFileWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperWithStaticPath *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeFileWrapperWithStaticPath::
reader_mFileIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperWithStaticPath *) mPointer)->mFileIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperWithStaticPath::actualTypeName (void) const {
  return "typeFileWrapperWithStaticPath" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFileWrapperWithStaticPath ("typeFileWrapperWithStaticPath", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeFileWrapperTemplateCall'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperTemplateCall::
cPtr_typeFileWrapperTemplateCall (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0),
mTemplateName (argument_1),
mOutExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperTemplateCall * GGS_typeFileWrapperTemplateCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFileWrapperTemplateCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperTemplateCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperTemplateCall * _p = dynamic_cast <const cPtr_typeFileWrapperTemplateCall *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFileWrapperName._operator_isEqual (_p->mFileWrapperName).boolValue ()
         && mTemplateName._operator_isEqual (_p->mTemplateName).boolValue ()
         && mOutExpressionList._operator_isEqual (_p->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperTemplateCall::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFileWrapperTemplateCall:"
           << mFileWrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOutExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperTemplateCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperTemplateCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperTemplateCall (& typeid (cPtr_typeFileWrapperTemplateCall), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeFileWrapperTemplateCall'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall::
GGS_typeFileWrapperTemplateCall (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall::
GGS_typeFileWrapperTemplateCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperTemplateCall) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFileWrapperTemplateCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperTemplateCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperTemplateCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperTemplateCall::
reader_mFileWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperTemplateCall::
reader_mTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeFileWrapperTemplateCall::
reader_mOutExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperTemplateCall::actualTypeName (void) const {
  return "typeFileWrapperTemplateCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFileWrapperTemplateCall ("typeFileWrapperTemplateCall", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_typeFileWrapperObjectInstanciation'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperObjectInstanciation::
cPtr_typeFileWrapperObjectInstanciation (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperObjectInstanciation * GGS_typeFileWrapperObjectInstanciation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFileWrapperObjectInstanciation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperObjectInstanciation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperObjectInstanciation * _p = dynamic_cast <const cPtr_typeFileWrapperObjectInstanciation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFileWrapperName._operator_isEqual (_p->mFileWrapperName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperObjectInstanciation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFileWrapperObjectInstanciation:"
           << mFileWrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperObjectInstanciation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperObjectInstanciation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperObjectInstanciation (& typeid (cPtr_typeFileWrapperObjectInstanciation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeFileWrapperObjectInstanciation'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation::
GGS_typeFileWrapperObjectInstanciation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation::
GGS_typeFileWrapperObjectInstanciation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperObjectInstanciation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFileWrapperObjectInstanciation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperObjectInstanciation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperObjectInstanciation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperObjectInstanciation::
reader_mFileWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperObjectInstanciation *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperObjectInstanciation::actualTypeName (void) const {
  return "typeFileWrapperObjectInstanciation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFileWrapperObjectInstanciation ("typeFileWrapperObjectInstanciation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeDescriptionInExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDescriptionInExpression::
cPtr_typeDescriptionInExpression (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mOperatorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDescriptionInExpression * GGS_typeDescriptionInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDescriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDescriptionInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDescriptionInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDescriptionInExpression * _p = dynamic_cast <const cPtr_typeDescriptionInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpressionValue._operator_isEqual (_p->mExpressionValue).boolValue ()
         && mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDescriptionInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDescriptionInExpression:"
           << mExpressionValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDescriptionInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDescriptionInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDescriptionInExpression (& typeid (cPtr_typeDescriptionInExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeDescriptionInExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDescriptionInExpression::
GGS_typeDescriptionInExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDescriptionInExpression::
GGS_typeDescriptionInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDescriptionInExpression GGS_typeDescriptionInExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDescriptionInExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDescriptionInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeDescriptionInExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDescriptionInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDescriptionInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDescriptionInExpression GGS_typeDescriptionInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeDescriptionInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeDescriptionInExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDescriptionInExpression::
reader_mExpressionValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDescriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDescriptionInExpression *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDescriptionInExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDescriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDescriptionInExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDescriptionInExpression::actualTypeName (void) const {
  return "typeDescriptionInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDescriptionInExpression ("typeDescriptionInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeCastInExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCastInExpression::
cPtr_typeCastInExpression (const GGS_typeExpression & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCastedExpression (argument_0),
mCheckForKindOfClass (argument_1),
mCastTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCastInExpression * GGS_typeCastInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCastInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCastInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCastInExpression * _p = dynamic_cast <const cPtr_typeCastInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCastedExpression._operator_isEqual (_p->mCastedExpression).boolValue ()
         && mCheckForKindOfClass._operator_isEqual (_p->mCheckForKindOfClass).boolValue ()
         && mCastTypeName._operator_isEqual (_p->mCastTypeName).boolValue ()
         && mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCastInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCastInExpression:"
           << mCastedExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCheckForKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCastTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCastInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCastInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCastInExpression (& typeid (cPtr_typeCastInExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCastInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCastInExpression::
GGS_typeCastInExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression::
GGS_typeCastInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCastInExpression GGS_typeCastInExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCastInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeCastInExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCastInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCastInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression GGS_typeCastInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeCastInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCastInExpression::
reader_mCastedExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCastedExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCastInExpression::
reader_mCheckForKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCheckForKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCastInExpression::
reader_mCastTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCastTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCastInExpression::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCastInExpression::actualTypeName (void) const {
  return "typeCastInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCastInExpression ("typeCastInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeAndOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::
cPtr_typeAndOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAndOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAndOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAndOperation * _p = dynamic_cast <const cPtr_typeAndOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAndOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAndOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAndOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAndOperation (& typeid (cPtr_typeAndOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeAndOperation GGS_typeAndOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAndOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeAndOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeAndOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAndOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation GGS_typeAndOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAndOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAndOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAndOperation::actualTypeName (void) const {
  return "typeAndOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAndOperation ("typeAndOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeOrOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::
cPtr_typeOrOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOrOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOrOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOrOperation * _p = dynamic_cast <const cPtr_typeOrOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOrOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOrOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOrOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOrOperation (& typeid (cPtr_typeOrOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeOrOperation GGS_typeOrOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOrOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeOrOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeOrOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOrOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation GGS_typeOrOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  macroMyNew (result.mPointer, cPtr_typeOrOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeOrOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOrOperation::actualTypeName (void) const {
  return "typeOrOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeOrOperation ("typeOrOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeXorOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeXorOperation::
cPtr_typeXorOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeXorOperation * GGS_typeXorOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeXorOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeXorOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeXorOperation * _p = dynamic_cast <const cPtr_typeXorOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeXorOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeXorOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeXorOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeXorOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeXorOperation (& typeid (cPtr_typeXorOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeXorOperation GGS_typeXorOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeXorOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeXorOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeXorOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeXorOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation GGS_typeXorOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  macroMyNew (result.mPointer, cPtr_typeXorOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeXorOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeXorOperation::actualTypeName (void) const {
  return "typeXorOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeXorOperation ("typeXorOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeConcatOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::
cPtr_typeConcatOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConcatOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConcatOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConcatOperation * _p = dynamic_cast <const cPtr_typeConcatOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConcatOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConcatOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConcatOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConcatOperation (& typeid (cPtr_typeConcatOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeConcatOperation GGS_typeConcatOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConcatOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeConcatOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeConcatOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConcatOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation GGS_typeConcatOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  macroMyNew (result.mPointer, cPtr_typeConcatOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeConcatOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConcatOperation::actualTypeName (void) const {
  return "typeConcatOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeConcatOperation ("typeConcatOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeTrueBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::
cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTrueBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTrueBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTrueBool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeTrueBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTrueBool::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTrueBool::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTrueBool (& typeid (cPtr_typeTrueBool), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeTrueBool GGS_typeTrueBool::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTrueBool *> (inPointer) != NULL)
      : (typeid (cPtr_typeTrueBool) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeTrueBool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTrueBool),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeTrueBool * gSingleton_typeTrueBool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeTrueBool (void) {
  macroDetachPointer (gSingleton_typeTrueBool, cPtr_typeTrueBool) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool GGS_typeTrueBool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  if (NULL == gSingleton_typeTrueBool) {
    macroMyNew (gSingleton_typeTrueBool, cPtr_typeTrueBool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeTrueBool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeTrueBool) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTrueBool::actualTypeName (void) const {
  return "typeTrueBool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeTrueBool ("typeTrueBool", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFalseBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::
cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFalseBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFalseBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFalseBool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFalseBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFalseBool::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFalseBool::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFalseBool (& typeid (cPtr_typeFalseBool), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFalseBool GGS_typeFalseBool::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFalseBool *> (inPointer) != NULL)
      : (typeid (cPtr_typeFalseBool) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFalseBool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFalseBool),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeFalseBool * gSingleton_typeFalseBool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeFalseBool (void) {
  macroDetachPointer (gSingleton_typeFalseBool, cPtr_typeFalseBool) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool GGS_typeFalseBool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  if (NULL == gSingleton_typeFalseBool) {
    macroMyNew (gSingleton_typeFalseBool, cPtr_typeFalseBool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeFalseBool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeFalseBool) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFalseBool::actualTypeName (void) const {
  return "typeFalseBool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFalseBool ("typeFalseBool", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralStringExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::
cPtr_typeLiteralStringExpression (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralStringList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralStringExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralStringExpression * _p = dynamic_cast <const cPtr_typeLiteralStringExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralStringList._operator_isEqual (_p->mLiteralStringList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralStringExpression:"
           << mLiteralStringList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralStringExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralStringExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralStringExpression (& typeid (cPtr_typeLiteralStringExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralStringExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralStringExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralStringExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralStringExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_typeLiteralStringExpression::
reader_mLiteralStringList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralStringExpression *) mPointer)->mLiteralStringList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralStringExpression::actualTypeName (void) const {
  return "typeLiteralStringExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralStringExpression ("typeLiteralStringExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLiteralUIntExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::
cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUIntExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUIntExpression * _p = dynamic_cast <const cPtr_typeLiteralUIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralInt._operator_isEqual (_p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUIntExpression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUIntExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUIntExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralUIntExpression (& typeid (cPtr_typeLiteralUIntExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralUIntExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralUIntExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralUIntExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralUIntExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeLiteralUIntExpression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralUIntExpression::actualTypeName (void) const {
  return "typeLiteralUIntExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralUIntExpression ("typeLiteralUIntExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLiteralSIntExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::
cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSIntExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSIntExpression * _p = dynamic_cast <const cPtr_typeLiteralSIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralInt._operator_isEqual (_p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSIntExpression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSIntExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSIntExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralSIntExpression (& typeid (cPtr_typeLiteralSIntExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralSIntExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralSIntExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralSIntExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralSIntExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_typeLiteralSIntExpression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralSIntExpression::actualTypeName (void) const {
  return "typeLiteralSIntExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralSIntExpression ("typeLiteralSIntExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralUInt64Expression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUInt64Expression::
cPtr_typeLiteralUInt64Expression (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUInt64Expression * GGS_typeLiteralUInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUInt64Expression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUInt64Expression * _p = dynamic_cast <const cPtr_typeLiteralUInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralInt._operator_isEqual (_p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUInt64Expression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUInt64Expression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUInt64Expression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUInt64Expression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralUInt64Expression (& typeid (cPtr_typeLiteralUInt64Expression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralUInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralUInt64Expression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralUInt64Expression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralUInt64Expression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_typeLiteralUInt64Expression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralUInt64Expression::actualTypeName (void) const {
  return "typeLiteralUInt64Expression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralUInt64Expression ("typeLiteralUInt64Expression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralSInt64Expression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSInt64Expression::
cPtr_typeLiteralSInt64Expression (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSInt64Expression * GGS_typeLiteralSInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSInt64Expression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSInt64Expression * _p = dynamic_cast <const cPtr_typeLiteralSInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralInt._operator_isEqual (_p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSInt64Expression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSInt64Expression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSInt64Expression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSInt64Expression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralSInt64Expression (& typeid (cPtr_typeLiteralSInt64Expression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralSInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralSInt64Expression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralSInt64Expression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralSInt64Expression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_typeLiteralSInt64Expression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralSInt64Expression::actualTypeName (void) const {
  return "typeLiteralSInt64Expression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralSInt64Expression ("typeLiteralSInt64Expression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLiteralCharExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::
cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralCharExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralCharExpression * _p = dynamic_cast <const cPtr_typeLiteralCharExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralChar._operator_isEqual (_p->mLiteralChar).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralCharExpression:"
           << mLiteralChar.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralCharExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralCharExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralCharExpression (& typeid (cPtr_typeLiteralCharExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralCharExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralCharExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralCharExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralCharExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeLiteralCharExpression::
reader_mLiteralChar (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralCharExpression *) mPointer)->mLiteralChar ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralCharExpression::actualTypeName (void) const {
  return "typeLiteralCharExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralCharExpression ("typeLiteralCharExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralDoubleExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralDoubleExpression::
cPtr_typeLiteralDoubleExpression (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralDouble (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralDoubleExpression * GGS_typeLiteralDoubleExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralDoubleExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralDoubleExpression * _p = dynamic_cast <const cPtr_typeLiteralDoubleExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLiteralDouble._operator_isEqual (_p->mLiteralDouble).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralDoubleExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralDoubleExpression:"
           << mLiteralDouble.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralDoubleExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralDoubleExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralDoubleExpression (& typeid (cPtr_typeLiteralDoubleExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralDoubleExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralDoubleExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLiteralDoubleExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralDoubleExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralDoubleExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_typeLiteralDoubleExpression::
reader_mLiteralDouble (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralDoubleExpression *) mPointer)->mLiteralDouble ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralDoubleExpression::actualTypeName (void) const {
  return "typeLiteralDoubleExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralDoubleExpression ("typeLiteralDoubleExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeHereExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::
cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeHereExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeHereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeHereExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeHereExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeHereExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeHereExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeHereExpression (& typeid (cPtr_typeHereExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeHereExpression GGS_typeHereExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeHereExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeHereExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeHereExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeHereExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeHereExpression * gSingleton_typeHereExpression = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeHereExpression (void) {
  macroDetachPointer (gSingleton_typeHereExpression, cPtr_typeHereExpression) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression GGS_typeHereExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  if (NULL == gSingleton_typeHereExpression) {
    macroMyNew (gSingleton_typeHereExpression, cPtr_typeHereExpression (THERE)) ;
    registerReleaseRoutine (cleanUp_typeHereExpression) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeHereExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeHereExpression::actualTypeName (void) const {
  return "typeHereExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeHereExpression ("typeHereExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeConstructorExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::
cPtr_typeConstructorExpression (const GGS_AC_galgasType & argument_0,
                                const GGS_string& argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mType (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConstructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConstructorExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConstructorExpression * _p = dynamic_cast <const cPtr_typeConstructorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mType._operator_isEqual (_p->mType).boolValue ()
         && mClassMethodName._operator_isEqual (_p->mClassMethodName).boolValue ()
         && mExpressionList._operator_isEqual (_p->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConstructorExpression:"
           << mType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConstructorExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConstructorExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConstructorExpression (& typeid (cPtr_typeConstructorExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeConstructorExpression GGS_typeConstructorExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConstructorExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeConstructorExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeConstructorExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConstructorExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression GGS_typeConstructorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_string& argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  macroMyNew (result.mPointer, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeConstructorExpression::
reader_mType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConstructorExpression::
reader_mClassMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mClassMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeConstructorExpression::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConstructorExpression::actualTypeName (void) const {
  return "typeConstructorExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeConstructorExpression ("typeConstructorExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeTestComplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::
cPtr_typeTestComplement (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTestComplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTestComplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTestComplement * _p = dynamic_cast <const cPtr_typeTestComplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTestComplement:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTestComplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTestComplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTestComplement (& typeid (cPtr_typeTestComplement), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeTestComplement GGS_typeTestComplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTestComplement *> (inPointer) != NULL)
      : (typeid (cPtr_typeTestComplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeTestComplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTestComplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement GGS_typeTestComplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  macroMyNew (result.mPointer, cPtr_typeTestComplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeTestComplement::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTestComplement::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTestComplement::actualTypeName (void) const {
  return "typeTestComplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeTestComplement ("typeTestComplement", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeLogicalNegate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogicalNegate::
cPtr_typeLogicalNegate (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogicalNegate * GGS_typeLogicalNegate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogicalNegate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogicalNegate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogicalNegate * _p = dynamic_cast <const cPtr_typeLogicalNegate *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogicalNegate::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLogicalNegate:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLogicalNegate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLogicalNegate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLogicalNegate (& typeid (cPtr_typeLogicalNegate), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeLogicalNegate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLogicalNegate GGS_typeLogicalNegate::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLogicalNegate *> (inPointer) != NULL)
      : (typeid (cPtr_typeLogicalNegate) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLogicalNegate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLogicalNegate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate GGS_typeLogicalNegate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  macroMyNew (result.mPointer, cPtr_typeLogicalNegate (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLogicalNegate::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLogicalNegate::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLogicalNegate::actualTypeName (void) const {
  return "typeLogicalNegate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLogicalNegate ("typeLogicalNegate", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeBoolOption'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::
cPtr_typeBoolOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeBoolOption * GGS_typeBoolOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeBoolOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeBoolOption::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeBoolOption * _p = dynamic_cast <const cPtr_typeBoolOption *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOptionComponentName._operator_isEqual (_p->mOptionComponentName).boolValue ()
         && mOptionName._operator_isEqual (_p->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeBoolOption::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeBoolOption:"
           << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeBoolOption::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeBoolOption::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeBoolOption (& typeid (cPtr_typeBoolOption), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeBoolOption GGS_typeBoolOption::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeBoolOption _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeBoolOption *> (inPointer) != NULL)
      : (typeid (cPtr_typeBoolOption) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeBoolOption (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeBoolOption),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption GGS_typeBoolOption::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeBoolOption result ;
  macroMyNew (result.mPointer, cPtr_typeBoolOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeBoolOption::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeBoolOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeBoolOption::
reader_mOptionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeBoolOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeBoolOption::actualTypeName (void) const {
  return "typeBoolOption" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeBoolOption ("typeBoolOption", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeUIntOption'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::
cPtr_typeUIntOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUIntOption * GGS_typeUIntOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUIntOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUIntOption::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUIntOption * _p = dynamic_cast <const cPtr_typeUIntOption *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOptionComponentName._operator_isEqual (_p->mOptionComponentName).boolValue ()
         && mOptionName._operator_isEqual (_p->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUIntOption::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUIntOption:"
           << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUIntOption::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUIntOption::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUIntOption (& typeid (cPtr_typeUIntOption), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeUIntOption GGS_typeUIntOption::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUIntOption _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUIntOption *> (inPointer) != NULL)
      : (typeid (cPtr_typeUIntOption) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeUIntOption (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUIntOption),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption GGS_typeUIntOption::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUIntOption result ;
  macroMyNew (result.mPointer, cPtr_typeUIntOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUIntOption::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUIntOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeUIntOption::
reader_mOptionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUIntOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUIntOption::actualTypeName (void) const {
  return "typeUIntOption" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeUIntOption ("typeUIntOption", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeStringOption'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStringOption::
cPtr_typeStringOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStringOption * GGS_typeStringOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStringOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStringOption::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStringOption * _p = dynamic_cast <const cPtr_typeStringOption *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOptionComponentName._operator_isEqual (_p->mOptionComponentName).boolValue ()
         && mOptionName._operator_isEqual (_p->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStringOption::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStringOption:"
           << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStringOption::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStringOption::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStringOption (& typeid (cPtr_typeStringOption), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeStringOption GGS_typeStringOption::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStringOption _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStringOption *> (inPointer) != NULL)
      : (typeid (cPtr_typeStringOption) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeStringOption (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStringOption),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption GGS_typeStringOption::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeStringOption result ;
  macroMyNew (result.mPointer, cPtr_typeStringOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStringOption::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStringOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStringOption::
reader_mOptionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStringOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStringOption::actualTypeName (void) const {
  return "typeStringOption" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStringOption ("typeStringOption", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeVarInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::
cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeVarInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeVarInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeVarInExpression * _p = dynamic_cast <const cPtr_typeVarInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCppVarName._operator_isEqual (_p->mCppVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeVarInExpression:"
           << mCppVarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeVarInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVarInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeVarInExpression (& typeid (cPtr_typeVarInExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeVarInExpression GGS_typeVarInExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeVarInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeVarInExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeVarInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeVarInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression GGS_typeVarInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeVarInExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeVarInExpression::
reader_mCppVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeVarInExpression *) mPointer)->mCppVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeVarInExpression::actualTypeName (void) const {
  return "typeVarInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeVarInExpression ("typeVarInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeJokerInExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::
cPtr_typeJokerInExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJokerInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJokerInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJokerInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJokerInExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeJokerInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeJokerInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeJokerInExpression (& typeid (cPtr_typeJokerInExpression), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeJokerInExpression GGS_typeJokerInExpression::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeJokerInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeJokerInExpression) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeJokerInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeJokerInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeJokerInExpression * gSingleton_typeJokerInExpression = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeJokerInExpression (void) {
  macroDetachPointer (gSingleton_typeJokerInExpression, cPtr_typeJokerInExpression) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression GGS_typeJokerInExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  if (NULL == gSingleton_typeJokerInExpression) {
    macroMyNew (gSingleton_typeJokerInExpression, cPtr_typeJokerInExpression (THERE)) ;
    registerReleaseRoutine (cleanUp_typeJokerInExpression) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeJokerInExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeJokerInExpression::actualTypeName (void) const {
  return "typeJokerInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeJokerInExpression ("typeJokerInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeAddOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::
cPtr_typeAddOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAddOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAddOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAddOperation * _p = dynamic_cast <const cPtr_typeAddOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAddOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAddOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAddOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAddOperation (& typeid (cPtr_typeAddOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeAddOperation GGS_typeAddOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAddOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeAddOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeAddOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAddOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation GGS_typeAddOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAddOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAddOperation::actualTypeName (void) const {
  return "typeAddOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAddOperation ("typeAddOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeSubOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::
cPtr_typeSubOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSubOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSubOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSubOperation * _p = dynamic_cast <const cPtr_typeSubOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSubOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSubOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSubOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSubOperation (& typeid (cPtr_typeSubOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeSubOperation GGS_typeSubOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSubOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeSubOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeSubOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSubOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation GGS_typeSubOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  macroMyNew (result.mPointer, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSubOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSubOperation::actualTypeName (void) const {
  return "typeSubOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSubOperation ("typeSubOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeMultiplyOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::
cPtr_typeMultiplyOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMultiplyOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMultiplyOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMultiplyOperation * _p = dynamic_cast <const cPtr_typeMultiplyOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMultiplyOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMultiplyOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMultiplyOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMultiplyOperation (& typeid (cPtr_typeMultiplyOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMultiplyOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeMultiplyOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMultiplyOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMultiplyOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  macroMyNew (result.mPointer, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMultiplyOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMultiplyOperation::actualTypeName (void) const {
  return "typeMultiplyOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMultiplyOperation ("typeMultiplyOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeDivideOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::
cPtr_typeDivideOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDivideOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDivideOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDivideOperation * _p = dynamic_cast <const cPtr_typeDivideOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDivideOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDivideOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDivideOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDivideOperation (& typeid (cPtr_typeDivideOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDivideOperation GGS_typeDivideOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDivideOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeDivideOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDivideOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDivideOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation GGS_typeDivideOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  macroMyNew (result.mPointer, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDivideOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDivideOperation::actualTypeName (void) const {
  return "typeDivideOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDivideOperation ("typeDivideOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeModuloOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::
cPtr_typeModuloOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModuloOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModuloOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModuloOperation * _p = dynamic_cast <const cPtr_typeModuloOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModuloOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeModuloOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeModuloOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeModuloOperation (& typeid (cPtr_typeModuloOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeModuloOperation GGS_typeModuloOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeModuloOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeModuloOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeModuloOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeModuloOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation GGS_typeModuloOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  macroMyNew (result.mPointer, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeModuloOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeModuloOperation::actualTypeName (void) const {
  return "typeModuloOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeModuloOperation ("typeModuloOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeUnaryMinusOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::
cPtr_typeUnaryMinusOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUnaryMinusOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUnaryMinusOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUnaryMinusOperation * _p = dynamic_cast <const cPtr_typeUnaryMinusOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUnaryMinusOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUnaryMinusOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUnaryMinusOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUnaryMinusOperation (& typeid (cPtr_typeUnaryMinusOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUnaryMinusOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeUnaryMinusOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeUnaryMinusOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUnaryMinusOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  macroMyNew (result.mPointer, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeUnaryMinusOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeUnaryMinusOperation::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUnaryMinusOperation::actualTypeName (void) const {
  return "typeUnaryMinusOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeUnaryMinusOperation ("typeUnaryMinusOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::
cPtr_typeEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEqualTest * _p = dynamic_cast <const cPtr_typeEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEqualTest:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEqualTest (& typeid (cPtr_typeEqualTest), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeEqualTest GGS_typeEqualTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest GGS_typeEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEqualTest::actualTypeName (void) const {
  return "typeEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEqualTest ("typeEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeNonEqualTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::
cPtr_typeNonEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonEqualTest * _p = dynamic_cast <const cPtr_typeNonEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonEqualTest:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNonEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNonEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNonEqualTest (& typeid (cPtr_typeNonEqualTest), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeNonEqualTest GGS_typeNonEqualTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNonEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeNonEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeNonEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNonEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest GGS_typeNonEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeNonEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeNonEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNonEqualTest::actualTypeName (void) const {
  return "typeNonEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeNonEqualTest ("typeNonEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeStrictInfTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::
cPtr_typeStrictInfTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictInfTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictInfTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictInfTest * _p = dynamic_cast <const cPtr_typeStrictInfTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictInfTest:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStrictInfTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStrictInfTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStrictInfTest (& typeid (cPtr_typeStrictInfTest), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeStrictInfTest GGS_typeStrictInfTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStrictInfTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeStrictInfTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeStrictInfTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStrictInfTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest GGS_typeStrictInfTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictInfTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStrictInfTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStrictInfTest::actualTypeName (void) const {
  return "typeStrictInfTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStrictInfTest ("typeStrictInfTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeInfOrEqualTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::
cPtr_typeInfOrEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInfOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInfOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInfOrEqualTest * _p = dynamic_cast <const cPtr_typeInfOrEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInfOrEqualTest:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInfOrEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInfOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInfOrEqualTest (& typeid (cPtr_typeInfOrEqualTest), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInfOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeInfOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeInfOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInfOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeInfOrEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInfOrEqualTest::actualTypeName (void) const {
  return "typeInfOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInfOrEqualTest ("typeInfOrEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeStrictSupTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::
cPtr_typeStrictSupTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictSupTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictSupTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictSupTest * _p = dynamic_cast <const cPtr_typeStrictSupTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictSupTest:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStrictSupTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStrictSupTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStrictSupTest (& typeid (cPtr_typeStrictSupTest), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeStrictSupTest GGS_typeStrictSupTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStrictSupTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeStrictSupTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeStrictSupTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStrictSupTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest GGS_typeStrictSupTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictSupTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStrictSupTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStrictSupTest::actualTypeName (void) const {
  return "typeStrictSupTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStrictSupTest ("typeStrictSupTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeSupOrEqualTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::
cPtr_typeSupOrEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSupOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSupOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSupOrEqualTest * _p = dynamic_cast <const cPtr_typeSupOrEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSupOrEqualTest:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSupOrEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSupOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSupOrEqualTest (& typeid (cPtr_typeSupOrEqualTest), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSupOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeSupOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeSupOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSupOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSupOrEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSupOrEqualTest::actualTypeName (void) const {
  return "typeSupOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSupOrEqualTest ("typeSupOrEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeLeftShiftOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLeftShiftOperation::
cPtr_typeLeftShiftOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLeftShiftOperation * GGS_typeLeftShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLeftShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLeftShiftOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLeftShiftOperation * _p = dynamic_cast <const cPtr_typeLeftShiftOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLeftShiftOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLeftShiftOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLeftShiftOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLeftShiftOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLeftShiftOperation (& typeid (cPtr_typeLeftShiftOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeLeftShiftOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLeftShiftOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeLeftShiftOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLeftShiftOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLeftShiftOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeLeftShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLeftShiftOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLeftShiftOperation::actualTypeName (void) const {
  return "typeLeftShiftOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLeftShiftOperation ("typeLeftShiftOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeRightShiftOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRightShiftOperation::
cPtr_typeRightShiftOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRightShiftOperation * GGS_typeRightShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRightShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRightShiftOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRightShiftOperation * _p = dynamic_cast <const cPtr_typeRightShiftOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRightShiftOperation::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRightShiftOperation:"
           << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRightShiftOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRightShiftOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRightShiftOperation (& typeid (cPtr_typeRightShiftOperation), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeRightShiftOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRightShiftOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeRightShiftOperation) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeRightShiftOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRightShiftOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeRightShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeRightShiftOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRightShiftOperation::actualTypeName (void) const {
  return "typeRightShiftOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRightShiftOperation ("typeRightShiftOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeTextTableCall'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::
cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTextTableCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTextTableCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTextTableCall * _p = dynamic_cast <const cPtr_typeTextTableCall *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && aNomMethodeTest._operator_isEqual (_p->aNomMethodeTest).boolValue ()
         && aNomCppClef._operator_isEqual (_p->aNomCppClef).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTextTableCall:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeTest.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppClef.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTextTableCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTextTableCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTextTableCall (& typeid (cPtr_typeTextTableCall), & typeid (cPtr_typeExpression), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeTextTableCall GGS_typeTextTableCall::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTextTableCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeTextTableCall) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeTextTableCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTextTableCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall GGS_typeTextTableCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  macroMyNew (result.mPointer, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTextTableCall::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeTextTableCall::
reader_aNomMethodeTest (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomMethodeTest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeTextTableCall::
reader_aNomCppClef (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomCppClef ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTextTableCall::actualTypeName (void) const {
  return "typeTextTableCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeTextTableCall ("typeTextTableCall", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_C_assignmentInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::
cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_assignmentInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_assignmentInstruction * _p = dynamic_cast <const cPtr_C_assignmentInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_assignmentInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_assignmentInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_assignmentInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_assignmentInstruction (& typeid (cPtr_C_assignmentInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_assignmentInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_assignmentInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_assignmentInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_assignmentInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_assignmentInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_assignmentInstruction::actualTypeName (void) const {
  return "C_assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_assignmentInstruction ("C_assignmentInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_dotEqualInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_dotEqualInstruction::
cPtr_C_dotEqualInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2),
mSourceExpressionConverter (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_dotEqualInstruction * GGS_C_dotEqualInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_dotEqualInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_dotEqualInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_dotEqualInstruction * _p = dynamic_cast <const cPtr_C_dotEqualInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue ()
         && mSourceExpressionConverter._operator_isEqual (_p->mSourceExpressionConverter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_dotEqualInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_dotEqualInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionConverter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_dotEqualInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_dotEqualInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_dotEqualInstruction (& typeid (cPtr_C_dotEqualInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_dotEqualInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_dotEqualInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_dotEqualInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_dotEqualInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_dotEqualInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_dotEqualInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_dotEqualInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_C_dotEqualInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_dotEqualInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_dotEqualInstruction::
reader_mSourceExpressionConverter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpressionConverter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_dotEqualInstruction::actualTypeName (void) const {
  return "C_dotEqualInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_dotEqualInstruction ("C_dotEqualInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//       abstract class 'cPtr_C_declarationInstructionWithAssignment'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::
cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_declarationInstructionWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_declarationInstructionWithAssignment::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_declarationInstructionWithAssignment * _p = dynamic_cast <const cPtr_C_declarationInstructionWithAssignment *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableType._operator_isEqual (_p->mVariableType).boolValue ()
         && mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_declarationInstructionWithAssignment:"
           << mVariableType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_declarationInstructionWithAssignment::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_declarationInstructionWithAssignment::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_declarationInstructionWithAssignment (& typeid (cPtr_C_declarationInstructionWithAssignment), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (inPointer) != NULL)
      : (typeid (cPtr_C_declarationInstructionWithAssignment) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_declarationInstructionWithAssignment (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_declarationInstructionWithAssignment),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_C_declarationInstructionWithAssignment::
reader_mVariableType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mVariableType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_declarationInstructionWithAssignment::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_declarationInstructionWithAssignment::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_declarationInstructionWithAssignment::actualTypeName (void) const {
  return "C_declarationInstructionWithAssignment" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_declarationInstructionWithAssignment ("C_declarationInstructionWithAssignment", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_while_instruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_while_instruction::
cPtr_C_while_instruction (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariantExpression (argument_0),
mInstructionList1 (argument_1),
mWhileExpression (argument_2),
mInstructionList2 (argument_3),
mLocation (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_while_instruction * GGS_C_while_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_while_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_while_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_while_instruction * _p = dynamic_cast <const cPtr_C_while_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariantExpression._operator_isEqual (_p->mVariantExpression).boolValue ()
         && mInstructionList1._operator_isEqual (_p->mInstructionList1).boolValue ()
         && mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mInstructionList2._operator_isEqual (_p->mInstructionList2).boolValue ()
         && mLocation._operator_isEqual (_p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_while_instruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_while_instruction:"
           << mVariantExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_while_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_while_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_while_instruction (& typeid (cPtr_C_while_instruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_while_instruction GGS_C_while_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_while_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_while_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_while_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_while_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction GGS_C_while_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeInstructionList & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_while_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_while_instruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_while_instruction::actualTypeName (void) const {
  return "C_while_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_while_instruction ("C_while_instruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_expression_instructionsList_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_expression_instructionsList_list * _p = dynamic_cast <const elementOf_GGS_L_expression_instructionsList_list *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIFexpression._operator_isEqual (_p->mIFexpression).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
_operator_concat (const GGS_L_expression_instructionsList_list & inOperand) const {
  GGS_L_expression_instructionsList_list result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_expression_instructionsList_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mIFexpression ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIFexpression,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeExpression & argument_0,
                           const GGS_typeInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalSubListWithRange (GGS_L_expression_instructionsList_list & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mIFexpression, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_expression_instructionsList_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_first (C_Compiler & _inLexique,
              GGS_typeExpression & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_last (C_Compiler & _inLexique,
             GGS_typeExpression & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeExpression & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_L_expression_instructionsList_list::
reader_mIFexpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_expression_instructionsList_list::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMIFexpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_if_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::
cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_if_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_if_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_if_instruction * _p = dynamic_cast <const cPtr_C_if_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIFbranchesList._operator_isEqual (_p->mIFbranchesList).boolValue ()
         && mElseInstructionsList._operator_isEqual (_p->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_if_instruction:"
           << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_if_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_if_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_if_instruction (& typeid (cPtr_C_if_instruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_if_instruction GGS_C_if_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_if_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_if_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_if_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_if_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction GGS_C_if_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_if_instruction::
reader_mIFbranchesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_if_instruction::
reader_mElseInstructionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_if_instruction::actualTypeName (void) const {
  return "C_if_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_if_instruction ("C_if_instruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_switchBranchlist'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_switchBranchlist::
elementOf_GGS_L_switchBranchlist (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantSet (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_switchBranchlist::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_switchBranchlist * _p = dynamic_cast <const elementOf_GGS_L_switchBranchlist *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mConstantSet._operator_isEqual (_p->mConstantSet).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_switchBranchlist::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantSet.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_switchBranchlist'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalAppendValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalPrependValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_addAssign_operation (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
_operator_concat (const GGS_L_switchBranchlist & inOperand) const {
  GGS_L_switchBranchlist result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_switchBranchlist * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_stringset  p_0 = p->mConstantSet ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_stringset & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantSet,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_stringset & argument_0,
                           const GGS_typeInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
internalSubListWithRange (GGS_L_switchBranchlist & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mConstantSet, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_switchBranchlist result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_switchBranchlist result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_switchBranchlist::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_switchBranchlist", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_first (C_Compiler & _inLexique,
              GGS_stringset & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_last (C_Compiler & _inLexique,
             GGS_stringset & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_stringset & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popLast (C_Compiler & _inLexique,
                GGS_stringset & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_L_switchBranchlist::
reader_mConstantSetAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_stringset  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantSet ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_switchBranchlist::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_setMConstantSetAtIndex (C_Compiler & inLexique,
                              const GGS_stringset  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantSet = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_switch_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_switch_instruction::
cPtr_C_switch_instruction (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSwitchExpression (argument_0),
mEnumTypeName (argument_1),
mBranchList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_switch_instruction * GGS_C_switch_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_switch_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_switch_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_switch_instruction * _p = dynamic_cast <const cPtr_C_switch_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSwitchExpression._operator_isEqual (_p->mSwitchExpression).boolValue ()
         && mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mBranchList._operator_isEqual (_p->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_switch_instruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_switch_instruction:"
           << mSwitchExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_switch_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_switch_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_switch_instruction (& typeid (cPtr_C_switch_instruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_switch_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_switch_instruction GGS_C_switch_instruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_switch_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_switch_instruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_switch_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_switch_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction GGS_C_switch_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_switch_instruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_switch_instruction::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_switch_instruction::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_C_switch_instruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_switchBranchlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_switch_instruction::actualTypeName (void) const {
  return "C_switch_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_switch_instruction ("C_switch_instruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableRoutinesAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableRoutinesAimplementer::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableRoutinesAimplementer info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
_operator_isEqual (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
_operator_isNotEqual (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'e_typeTableAttributsSemantiques'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableAttributsSemantiques::e_typeTableAttributsSemantiques (void) :
aNomCppAttribut (),
mAttributType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableAttributsSemantiques'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aNomCppAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableAttributsSemantiques::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableAttributsSemantiques * _p = dynamic_cast <const elementOf_GGS_typeTableAttributsSemantiques *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aNomCppAttribut._operator_isEqual (_p->mInfo.aNomCppAttribut)).boolValue ()
           && (mInfo.mAttributType._operator_isEqual (_p->mInfo.mAttributType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableAttributsSemantiques info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
_operator_isEqual (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
_operator_isNotEqual (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeCplusPlusName & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the attribute '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the attribute '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableAttributsSemantiques & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Compiler & _inLexique,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildMapWithLocalConstants at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle)._operator_isNotEqual (GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE)) ;
  GGS_bool var_cas_firstOne ;
  var_cas_firstOne = GGS_bool (true, true) ;
  {
    GGS_L_nameWithType::cEnumerator enumerator_31800 (var_cas_inLocalDeclarationsList, true) ;
    const GGS_L_nameWithType::cElement * operand_31800 = NULL ;
    GGS_typeListeAttributsSemantiques::cEnumerator enumerator_31875 (var_cas_inSemanticAttributsList, true) ;
    const GGS_typeListeAttributsSemantiques::cElement * operand_31875 = NULL ;
    while (((operand_31800 = (GGS_L_nameWithType::cElement *) enumerator_31800.nextObject ()))
        && ((operand_31875 = enumerator_31875.nextObject ()))) {
      macroValidPointer (operand_31800) ;
      macroValidPointer (operand_31875) ;
      if (((operand_31800->mName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (769)))._operator_isNotEqual (GGS_string (true, ""))).isBuiltAndTrue ()) {
        GGS_string var_cas_typeName ;
        const GGS_AC_galgasType  _temp_32029 = operand_31875->mAttributType ;
        if (_temp_32029._isBuilt ()) {
          _temp_32029 (HERE)->method_getTypeName (_inLexique, var_cas_typeName COMMA_SOURCE_FILE_AT_LINE (771)) ;
        }
        if (((operand_31800->mType.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (772)))._operator_isEqual (var_cas_typeName)).isBuiltAndTrue ()) {
          GGS_typeCplusPlusName  var_cas_cppName ;
          if ((((var_cas_inLocalConstantStyle)._operator_isEqual (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE)))._operator_and (var_cas_firstOne)).isBuiltAndTrue ()) {
            var_cas_cppName = GGS_typeKeyName ::constructor_new (_inLexique, var_cas_inLocation COMMA_HERE) ;
          }else{
            var_cas_cppName = GGS_typeOperandName ::constructor_new (_inLexique, var_cas_inLocation, operand_31875->aNomAttribut.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (777)), var_cas_mapStyle COMMA_HERE) ;
          }
          var_cas_ioVariablesMap.modifier_insertUsedConstInArgument (_inLexique, operand_31800->mName, operand_31875->mAttributType, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (779)) ;
        }else{
          operand_31800->mType.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "I have found the '@"))._operator_concat (operand_31800->mType.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (781))))._operator_concat (GGS_string (true, "' type, I was expected the '@")))._operator_concat (var_cas_typeName))._operator_concat (GGS_string (true, "' type")) COMMA_SOURCE_FILE_AT_LINE (782)) ;
        }
      }
      var_cas_firstOne = GGS_bool (true, false) ;
    }
  }
  if ((((var_cas_inLocalDeclarationsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (788)))._operator_strictInf (var_cas_inSemanticAttributsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (788))))._operator_and ((var_cas_inEllipsisFound)._operator_not ())).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "one or more parameters missing: found "))._operator_concat (var_cas_inLocalDeclarationsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (790)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (790))))._operator_concat (GGS_string (true, " effective parameters, while ")))._operator_concat (var_cas_inSemanticAttributsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (791)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (791))))._operator_concat (GGS_string (true, " are needed")) COMMA_SOURCE_FILE_AT_LINE (791)) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (792)))._operator_strictSup (var_cas_inSemanticAttributsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (792)))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "too much parameters: found "))._operator_concat (var_cas_inLocalDeclarationsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (794)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (794))))._operator_concat (GGS_string (true, " effective parameters, while ")))._operator_concat (var_cas_inSemanticAttributsList.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (795)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (795))))._operator_concat (GGS_string (true, " are needed")) COMMA_SOURCE_FILE_AT_LINE (795)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildMapWithLocalConstants\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Compiler & _inLexique,
                                const GGS_typeSemanticsTypesList   var_cas_t1,
                                const GGS_typeListeAttributsSemantiques   var_cas_t2,
                                const GGS_location   var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_t1.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (811)))._operator_strictInf (var_cas_t2.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (811)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more identifiers missing") COMMA_SOURCE_FILE_AT_LINE (812)) ;
  }else if (((var_cas_t1.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (813)))._operator_strictSup (var_cas_t2.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (813)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much identifiers") COMMA_SOURCE_FILE_AT_LINE (814)) ;
  }else{
    {
      GGS_typeSemanticsTypesList::cEnumerator enumerator_34222 (var_cas_t1, true) ;
      const GGS_typeSemanticsTypesList::cElement * operand_34222 = NULL ;
      GGS_typeListeAttributsSemantiques::cEnumerator enumerator_34291 (var_cas_t2, true) ;
      const GGS_typeListeAttributsSemantiques::cElement * operand_34291 = NULL ;
      while (((operand_34222 = (GGS_typeSemanticsTypesList::cElement *) enumerator_34222.nextObject ()))
          && ((operand_34291 = enumerator_34291.nextObject ()))) {
        macroValidPointer (operand_34222) ;
        macroValidPointer (operand_34291) ;
        ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_34222->mType,  operand_34291->mAttributType,  operand_34222->mGalgasVariableName.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (821)),  GGS_bool (true, false) COMMA_SOURCE_FILE_AT_LINE (817)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Compiler & _inLexique,
                                const GGS_L_EXsignature   var_cas_signatureReference,
                                const GGS_L_actualParametersSignature   var_cas_inEffectiveArgumentsSignature,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteArgEffectifsSignature at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_signatureReference.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (841)))._operator_strictSup (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (841)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more arguments missing") COMMA_SOURCE_FILE_AT_LINE (842)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (843)))._operator_strictInf (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (843)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much arguments") COMMA_SOURCE_FILE_AT_LINE (844)) ;
  }else{
    {
      GGS_L_EXsignature::cEnumerator enumerator_35561 (var_cas_signatureReference, true) ;
      const GGS_L_EXsignature::cElement * operand_35561 = NULL ;
      GGS_L_actualParametersSignature::cEnumerator enumerator_35665 (var_cas_inEffectiveArgumentsSignature, true) ;
      const GGS_L_actualParametersSignature::cElement * operand_35665 = NULL ;
      while (((operand_35561 = (GGS_L_EXsignature::cElement *) enumerator_35561.nextObject ()))
          && ((operand_35665 = enumerator_35665.nextObject ()))) {
        macroValidPointer (operand_35561) ;
        macroValidPointer (operand_35665) ;
        if (operand_35561->mFormalArgumentPassingMode._isBuilt () && operand_35665->mFormalArgumentPassingMode._isBuilt ()) {
          if ((operand_35561->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentConstantIn) && (operand_35665->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOut)) {
            ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35561->mType,  operand_35665->mType,  var_cas_inErrorLocation,  GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (850)) ;
          }else{
            if ((operand_35561->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentIn) && (operand_35665->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOut)) {
              ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35561->mType,  operand_35665->mType,  var_cas_inErrorLocation,  GGS_bool (true, true) COMMA_SOURCE_FILE_AT_LINE (852)) ;
            }else{
              if ((operand_35561->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentInOut) && (operand_35665->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOutIn)) {
                ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35561->mType,  operand_35665->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) COMMA_SOURCE_FILE_AT_LINE (854)) ;
              }else{
                if ((operand_35561->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentOut) && (operand_35665->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterIn)) {
                  { const GGS_AC_galgasType _var_36539 = operand_35665->mType ; // CAST instruction
                    if (_var_36539.getPtr () != NULL) {
                      macroValidPointer (_var_36539.getPtr ()) ;
                      if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (_var_36539.getPtr ()) != NULL) {
                      }else{
                        ::routine_checkAssignmentTypesCompatibility (_inLexique,  operand_35561->mType,  operand_35665->mType,  var_cas_inErrorLocation,  GGS_bool (true, false) COMMA_SOURCE_FILE_AT_LINE (859)) ;
                      }
                    }
                  }
                }else{
                  var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((operand_35665->mFormalArgumentPassingMode.reader_actualArgumentMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (863)))._operator_concat (GGS_string (true, " is not compatible with ")))._operator_concat (operand_35561->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (864))) COMMA_SOURCE_FILE_AT_LINE (864)) ;
                }
              }
            }
          }
        }
      }
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList ::constructor_emptyList (_inLexique COMMA_HERE) ;
    {
      GGS_L_EXsignature::cEnumerator enumerator_36952 (var_cas_signatureReference, true) ;
      const GGS_L_EXsignature::cElement * operand_36952 = NULL ;
      GGS_typeExpressionList::cEnumerator enumerator_37008 (var_cas_expressionList, true) ;
      const GGS_typeExpressionList::cElement * operand_37008 = NULL ;
      while (((operand_36952 = (GGS_L_EXsignature::cElement *) enumerator_36952.nextObject ()))
          && ((operand_37008 = enumerator_37008.nextObject ()))) {
        macroValidPointer (operand_36952) ;
        macroValidPointer (operand_37008) ;
        { const GGS_typeExpression _var_37554 = operand_37008->mExpression ; // CAST instruction
          if (_var_37554.getPtr () != NULL) {
            macroValidPointer (_var_37554.getPtr ()) ;
            if (dynamic_cast <cPtr_typeJokerInExpression *> (_var_37554.getPtr ()) != NULL) {
              GGS_typeCplusPlusName  var_cas_cppVarName ;
              var_cas_cppVarName = GGS_typeLocationAutomaticName ::constructor_new (_inLexique, GGS_location (_inLexique), GGS_uint ::constructor_sequenceNumber (_inLexique COMMA_HERE) COMMA_HERE) ;
              GGS_typeExpression  var_cas_e ;
              var_cas_e = GGS_typeVarInExpression ::constructor_new (_inLexique, var_cas_cppVarName COMMA_HERE) ;
              var_cas_ioExpressionList._addAssign_operation (var_cas_e) ;
              GGS_typeInstruction  var_cas_i ;
              var_cas_i = GGS_typeInstructionDeclarationVarLocale ::constructor_new (_inLexique, var_cas_cppVarName, operand_36952->mType COMMA_HERE) ;
              var_cas_ioInstructionsList._addAssign_operation (var_cas_i) ;
            }else{
              var_cas_ioExpressionList._addAssign_operation (operand_37008->mExpression) ;
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteArgEffectifsSignature\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeJoker'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::
cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJoker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
method_verifierType (C_Compiler & _inLexique,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outAllVariablesList._addAssign_operation (GGS_typeNullName ::constructor_new (_inLexique, GGS_location (_inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeJoker::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeJoker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeJoker (& typeid (cPtr_typeJoker), & typeid (cPtr_typeCible), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeJoker GGS_typeJoker::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeJoker _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeJoker *> (inPointer) != NULL)
      : (typeid (cPtr_typeJoker) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeJoker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeJoker),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeJoker * gSingleton_typeJoker = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeJoker (void) {
  macroDetachPointer (gSingleton_typeJoker, cPtr_typeJoker) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker GGS_typeJoker::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  if (NULL == gSingleton_typeJoker) {
    macroMyNew (gSingleton_typeJoker, cPtr_typeJoker (THERE)) ;
    registerReleaseRoutine (cleanUp_typeJoker) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeJoker) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeJoker::actualTypeName (void) const {
  return "typeJoker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeJoker ("typeJoker", gClassInfoFor__typeCible) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeEntiteDest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::
cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteDest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteDest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteDest * _p = dynamic_cast <const cPtr_typeEntiteDest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aTypeVarDest._operator_isEqual (_p->aTypeVarDest).boolValue ()
         && mCppName._operator_isEqual (_p->mCppName).boolValue ()
         && aPositionVariableCible._operator_isEqual (_p->aPositionVariableCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
method_verifierType (C_Compiler & _inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_ioAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  ::routine_checkAssignmentTypesCompatibility (_inLexique,  aTypeVarDest,  var_cas_typeArgumentFormel,  aPositionVariableCible,  GGS_bool (true, false) COMMA_SOURCE_FILE_AT_LINE (916)) ;
  var_cas_listeAffectations._addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_ioAllVariablesList._addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteDest:"
           << aTypeVarDest.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aPositionVariableCible.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteDest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteDest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteDest (& typeid (cPtr_typeEntiteDest), & typeid (cPtr_typeCible), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeEntiteDest GGS_typeEntiteDest::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteDest *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteDest) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeEntiteDest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteDest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest GGS_typeEntiteDest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteDest::
reader_aTypeVarDest (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aTypeVarDest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeEntiteDest::
reader_mCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->mCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEntiteDest::
reader_aPositionVariableCible (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aPositionVariableCible ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteDest::actualTypeName (void) const {
  return "typeEntiteDest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteDest ("typeEntiteDest", gClassInfoFor__typeCible) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_M_nonTerminalSymbolForSyntax'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonTerminalSymbolForSyntax::e_M_nonTerminalSymbolForSyntax (void) :
mAltParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAltParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonTerminalSymbolForSyntax::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonTerminalSymbolForSyntax * _p = dynamic_cast <const elementOf_GGS_M_nonTerminalSymbolForSyntax *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAltParametersMap._operator_isEqual (_p->mInfo.mAltParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonTerminalSymbolForSyntax info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
_operator_isEqual (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
_operator_isNotEqual (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAlts & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' non terminal symbol is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' non terminal symbol is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_grammarInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::
cPtr_C_grammarInstruction (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_typeCplusPlusName & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceIsFile (argument_0),
mSourceExpression (argument_1),
mGrammarName (argument_2),
mExpressionsList (argument_3),
mAltSymbol (argument_4),
mMetamodelClassVariableName (argument_5),
mLexiqueClassName (argument_6),
mSentStringName (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarInstruction * _p = dynamic_cast <const cPtr_C_grammarInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceIsFile._operator_isEqual (_p->mSourceIsFile).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue ()
         && mGrammarName._operator_isEqual (_p->mGrammarName).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue ()
         && mAltSymbol._operator_isEqual (_p->mAltSymbol).boolValue ()
         && mMetamodelClassVariableName._operator_isEqual (_p->mMetamodelClassVariableName).boolValue ()
         && mLexiqueClassName._operator_isEqual (_p->mLexiqueClassName).boolValue ()
         && mSentStringName._operator_isEqual (_p->mSentStringName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarInstruction:"
           << mSourceIsFile.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mGrammarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAltSymbol.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMetamodelClassVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSentStringName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_grammarInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_grammarInstruction (& typeid (cPtr_C_grammarInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_grammarInstruction GGS_C_grammarInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_grammarInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_grammarInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_grammarInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_grammarInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction GGS_C_grammarInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_lstring & argument_6,
                 const GGS_typeCplusPlusName & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarInstruction::
reader_mSourceIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mGrammarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mGrammarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_C_grammarInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mAltSymbol (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mAltSymbol ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mMetamodelClassVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mMetamodelClassVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_grammarInstruction::
reader_mSentStringName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSentStringName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_grammarInstruction::actualTypeName (void) const {
  return "C_grammarInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_grammarInstruction ("C_grammarInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_C_treewalkingInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_treewalkingInstruction::
cPtr_C_treewalkingInstruction (const GGS_lstring & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTreeWalkingComponentName (argument_0),
mModelVariableCppName (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_treewalkingInstruction * GGS_C_treewalkingInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_treewalkingInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_treewalkingInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_treewalkingInstruction * _p = dynamic_cast <const cPtr_C_treewalkingInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTreeWalkingComponentName._operator_isEqual (_p->mTreeWalkingComponentName).boolValue ()
         && mModelVariableCppName._operator_isEqual (_p->mModelVariableCppName).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_treewalkingInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_treewalkingInstruction:"
           << mTreeWalkingComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModelVariableCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_treewalkingInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_treewalkingInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_treewalkingInstruction (& typeid (cPtr_C_treewalkingInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_treewalkingInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_treewalkingInstruction::
GGS_C_treewalkingInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_treewalkingInstruction::
GGS_C_treewalkingInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_treewalkingInstruction GGS_C_treewalkingInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_treewalkingInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_treewalkingInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_treewalkingInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_treewalkingInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_treewalkingInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_treewalkingInstruction GGS_C_treewalkingInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_treewalkingInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_treewalkingInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_treewalkingInstruction::
reader_mTreeWalkingComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_treewalkingInstruction *) mPointer)->mTreeWalkingComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_treewalkingInstruction::
reader_mModelVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_treewalkingInstruction *) mPointer)->mModelVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_C_treewalkingInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_treewalkingInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_treewalkingInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_treewalkingInstruction::actualTypeName (void) const {
  return "C_treewalkingInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_treewalkingInstruction ("C_treewalkingInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeAppendInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::
cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAppendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAppendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAppendInstruction * _p = dynamic_cast <const cPtr_typeAppendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mSourceExpressions._operator_isEqual (_p->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAppendInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAppendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAppendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAppendInstruction (& typeid (cPtr_typeAppendInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeAppendInstruction GGS_typeAppendInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAppendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeAppendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeAppendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAppendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction GGS_typeAppendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeAppendInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeAppendInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeAppendInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeAppendInstruction::
reader_mSourceExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAppendInstruction::actualTypeName (void) const {
  return "typeAppendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAppendInstruction ("typeAppendInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeRemoveInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRemoveInstruction::
cPtr_typeRemoveInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRemoveInstruction * GGS_typeRemoveInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRemoveInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRemoveInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRemoveInstruction * _p = dynamic_cast <const cPtr_typeRemoveInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mSourceExpressions._operator_isEqual (_p->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRemoveInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRemoveInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRemoveInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRemoveInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRemoveInstruction (& typeid (cPtr_typeRemoveInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRemoveInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeRemoveInstruction GGS_typeRemoveInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRemoveInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRemoveInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeRemoveInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeRemoveInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRemoveInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction GGS_typeRemoveInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRemoveInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRemoveInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeRemoveInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeRemoveInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRemoveInstruction::
reader_mSourceExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRemoveInstruction::actualTypeName (void) const {
  return "typeRemoveInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRemoveInstruction ("typeRemoveInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeIncrementInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::
cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeIncrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeIncrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeIncrementInstruction * _p = dynamic_cast <const cPtr_typeIncrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeIncrementInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeIncrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeIncrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeIncrementInstruction (& typeid (cPtr_typeIncrementInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeIncrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeIncrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeIncrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeIncrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeIncrementInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeIncrementInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeIncrementInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeIncrementInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeIncrementInstruction::actualTypeName (void) const {
  return "typeIncrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeIncrementInstruction ("typeIncrementInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDecrementInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::
cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDecrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDecrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDecrementInstruction * _p = dynamic_cast <const cPtr_typeDecrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTargetVarCppName._operator_isEqual (_p->mTargetVarCppName).boolValue ()
         && mStructAttributeList._operator_isEqual (_p->mStructAttributeList).boolValue ()
         && mInstructionLocation._operator_isEqual (_p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDecrementInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDecrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDecrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDecrementInstruction (& typeid (cPtr_typeDecrementInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDecrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeDecrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDecrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDecrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDecrementInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDecrementInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeDecrementInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDecrementInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDecrementInstruction::actualTypeName (void) const {
  return "typeDecrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDecrementInstruction ("typeDecrementInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCase1_name (argument_0),
mCase2_name (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_matchInstructionCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_matchInstructionCasesList * _p = dynamic_cast <const elementOf_GGS_L_matchInstructionCasesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCase1_name._operator_isEqual (_p->mCase1_name).boolValue ()
         && mCase2_name._operator_isEqual (_p->mCase2_name).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase1_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase2_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
_operator_concat (const GGS_L_matchInstructionCasesList & inOperand) const {
  GGS_L_matchInstructionCasesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_matchInstructionCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCase1_name ;
          GGS_lstring  p_1 = p->mCase2_name ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCase1_name,
                                _p->mCase2_name,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_typeInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalSubListWithRange (GGS_L_matchInstructionCasesList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mCase1_name, _p->mCase2_name, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_matchInstructionCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_matchInstructionCasesList::
reader_mCase1_nameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCase1_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_matchInstructionCasesList::
reader_mCase2_nameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCase2_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_matchInstructionCasesList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMCase1_nameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCase1_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMCase2_nameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCase2_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeMatchInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::
cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMatchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMatchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMatchInstruction * _p = dynamic_cast <const cPtr_typeMatchInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aIndicatif1._operator_isEqual (_p->aIndicatif1).boolValue ()
         && aIndicatif2._operator_isEqual (_p->aIndicatif2).boolValue ()
         && aNomCppVariable1._operator_isEqual (_p->aNomCppVariable1).boolValue ()
         && aNomCppVariable2._operator_isEqual (_p->aNomCppVariable2).boolValue ()
         && aNomTypeBase1._operator_isEqual (_p->aNomTypeBase1).boolValue ()
         && aNomTypeBase2._operator_isEqual (_p->aNomTypeBase2).boolValue ()
         && mOperand1_isEnumeration._operator_isEqual (_p->mOperand1_isEnumeration).boolValue ()
         && mOperand2_isEnumeration._operator_isEqual (_p->mOperand2_isEnumeration).boolValue ()
         && aListeCas._operator_isEqual (_p->aListeCas).boolValue ()
         && mElseInstructionsList._operator_isEqual (_p->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMatchInstruction:"
           << aIndicatif1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aIndicatif2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppVariable1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppVariable2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomTypeBase1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomTypeBase2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand1_isEnumeration.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2_isEnumeration.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeCas.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMatchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMatchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMatchInstruction (& typeid (cPtr_typeMatchInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeMatchInstruction GGS_typeMatchInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMatchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMatchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeMatchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMatchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction GGS_typeMatchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_location & argument_1,
                 const GGS_typeCplusPlusName & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_bool& argument_7,
                 const GGS_L_matchInstructionCasesList & argument_8,
                 const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand1_isEnumeration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand1_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand2_isEnumeration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand2_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_typeMatchInstruction::
reader_aListeCas (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aListeCas ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeMatchInstruction::
reader_mElseInstructionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMatchInstruction::actualTypeName (void) const {
  return "typeMatchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMatchInstruction ("typeMatchInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceExpression (argument_0),
mLocationOffset (argument_1),
mCppTypeName (argument_2),
mAscending (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachEnumerationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachEnumerationList * _p = dynamic_cast <const elementOf_GGS_foreachEnumerationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue ()
         && mLocationOffset._operator_isEqual (_p->mLocationOffset).boolValue ()
         && mCppTypeName._operator_isEqual (_p->mCppTypeName).boolValue ()
         && mAscending._operator_isEqual (_p->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
_operator_concat (const GGS_foreachEnumerationList & inOperand) const {
  GGS_foreachEnumerationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_foreachEnumerationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mSourceExpression ;
          GGS_location  p_1 = p->mLocationOffset ;
          GGS_string p_2 = p->mCppTypeName ;
          GGS_bool p_3 = p->mAscending ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_location & argument_1,
                     const GGS_string& argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceExpression,
                                _p->mLocationOffset,
                                _p->mCppTypeName,
                                _p->mAscending
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeExpression & argument_0,
                           const GGS_location & argument_1,
                           const GGS_string& argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalSubListWithRange (GGS_foreachEnumerationList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSourceExpression, _p->mLocationOffset, _p->mCppTypeName, _p->mAscending) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachEnumerationList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachEnumerationList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachEnumerationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_first (C_Compiler & _inLexique,
              GGS_typeExpression & _out_0,
              GGS_location & _out_1,
              GGS_string& _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExpression ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _out_3 = _p->mAscending ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_last (C_Compiler & _inLexique,
             GGS_typeExpression & _out_0,
             GGS_location & _out_1,
             GGS_string& _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExpression ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _out_3 = _p->mAscending ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_location & _out_1,
                 GGS_string& _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExpression ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _out_3 = _p->mAscending ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeExpression & _out_0,
                GGS_location & _out_1,
                GGS_string& _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExpression ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _out_3 = _p->mAscending ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_foreachEnumerationList::
reader_mSourceExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachEnumerationList::
reader_mLocationOffsetAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationOffset ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_mCppTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMSourceExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMLocationOffsetAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationOffset = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMCppTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeForeachInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::
cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_typeInstructionList & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mIndexVariable (argument_1),
mWhileExpression (argument_2),
mBeforeInstructionList (argument_3),
mDoInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mAfterInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeForeachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeForeachInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeForeachInstruction * _p = dynamic_cast <const cPtr_typeForeachInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mForeachEnumerationList._operator_isEqual (_p->mForeachEnumerationList).boolValue ()
         && mIndexVariable._operator_isEqual (_p->mIndexVariable).boolValue ()
         && mWhileExpression._operator_isEqual (_p->mWhileExpression).boolValue ()
         && mBeforeInstructionList._operator_isEqual (_p->mBeforeInstructionList).boolValue ()
         && mDoInstructionList._operator_isEqual (_p->mDoInstructionList).boolValue ()
         && mBetweenInstructionList._operator_isEqual (_p->mBetweenInstructionList).boolValue ()
         && mAfterInstructionList._operator_isEqual (_p->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeForeachInstruction:"
           << mForeachEnumerationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIndexVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBeforeInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDoInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBetweenInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfterInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeForeachInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeForeachInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeForeachInstruction (& typeid (cPtr_typeForeachInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeForeachInstruction GGS_typeForeachInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeForeachInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeForeachInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeForeachInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeForeachInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction GGS_typeForeachInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_foreachEnumerationList & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_typeInstructionList & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_typeForeachInstruction::
reader_mForeachEnumerationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachEnumerationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mForeachEnumerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeForeachInstruction::
reader_mIndexVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mIndexVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeForeachInstruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeForeachInstruction::actualTypeName (void) const {
  return "typeForeachInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeForeachInstruction ("typeForeachInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeSimpleExtractInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::
cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSimpleExtractInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSimpleExtractInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSimpleExtractInstruction * _p = dynamic_cast <const cPtr_typeSimpleExtractInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomVariable._operator_isEqual (_p->aNomVariable).boolValue ()
         && aNomClasse._operator_isEqual (_p->aNomClasse).boolValue ()
         && aListeAffectationParametresEffectifs._operator_isEqual (_p->aListeAffectationParametresEffectifs).boolValue ()
         && mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue ()
         && aNomMessage._operator_isEqual (_p->aNomMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSimpleExtractInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSimpleExtractInstruction:"
           << aNomVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeAffectationParametresEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSimpleExtractInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSimpleExtractInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSimpleExtractInstruction (& typeid (cPtr_typeSimpleExtractInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeSimpleExtractInstruction GGS_typeSimpleExtractInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSimpleExtractInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeSimpleExtractInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeSimpleExtractInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSimpleExtractInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction GGS_typeSimpleExtractInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_assignedVariables & argument_2,
                 const GGS_typeExpression & argument_3,
                 const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeSimpleExtractInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeSimpleExtractInstruction::
reader_aNomVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSimpleExtractInstruction::
reader_aNomClasse (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_typeSimpleExtractInstruction::
reader_aListeAffectationParametresEffectifs (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_assignedVariables   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aListeAffectationParametresEffectifs ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSimpleExtractInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSimpleExtractInstruction::
reader_aNomMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSimpleExtractInstruction::actualTypeName (void) const {
  return "typeSimpleExtractInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSimpleExtractInstruction ("typeSimpleExtractInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mClassName (argument_0),
mResultVarID (argument_1),
mInstructionList (argument_2),
mNoUsedParameter (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredExtractCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredExtractCasesList * _p = dynamic_cast <const elementOf_GGS_typeStructuredExtractCasesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mResultVarID._operator_isEqual (_p->mResultVarID).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue ()
         && mNoUsedParameter._operator_isEqual (_p->mNoUsedParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mResultVarID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNoUsedParameter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
_operator_concat (const GGS_typeStructuredExtractCasesList & inOperand) const {
  GGS_typeStructuredExtractCasesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeStructuredExtractCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mClassName ;
          GGS_location  p_1 = p->mResultVarID ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          GGS_bool p_3 = p->mNoUsedParameter ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_location & argument_1,
                     const GGS_typeInstructionList & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mClassName,
                                _p->mResultVarID,
                                _p->mInstructionList,
                                _p->mNoUsedParameter
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_location & argument_1,
                           const GGS_typeInstructionList & argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalSubListWithRange (GGS_typeStructuredExtractCasesList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mClassName, _p->mResultVarID, _p->mInstructionList, _p->mNoUsedParameter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeStructuredExtractCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_location & _out_1,
              GGS_typeInstructionList & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_location & _out_1,
             GGS_typeInstructionList & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_location & _out_1,
                 GGS_typeInstructionList & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_location & _out_1,
                GGS_typeInstructionList & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredExtractCasesList::
reader_mClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStructuredExtractCasesList::
reader_mResultVarIDAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mResultVarID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractCasesList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractCasesList::
reader_mNoUsedParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNoUsedParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMResultVarIDAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mResultVarID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMNoUsedParameterAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNoUsedParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      abstract class 'cPtr_typeStructuredExtractInstructionWithElse'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::
cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStructuredExtractInstructionWithElse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredExtractInstructionWithElse::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredExtractInstructionWithElse * _p = dynamic_cast <const cPtr_typeStructuredExtractInstructionWithElse *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableName._operator_isEqual (_p->mVariableName).boolValue ()
         && mCasesList._operator_isEqual (_p->mCasesList).boolValue ()
         && mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStructuredExtractInstructionWithElse:"
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCasesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredExtractInstructionWithElse::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredExtractInstructionWithElse::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStructuredExtractInstructionWithElse (& typeid (cPtr_typeStructuredExtractInstructionWithElse), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (inPointer) != NULL)
      : (typeid (cPtr_typeStructuredExtractInstructionWithElse) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeStructuredExtractInstructionWithElse (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStructuredExtractInstructionWithElse),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeStructuredExtractCasesList & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeStructuredExtractInstructionWithElse::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractInstructionWithElse::
reader_mCasesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mCasesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractInstructionWithElse::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStructuredExtractInstructionWithElse::actualTypeName (void) const {
  return "typeStructuredExtractInstructionWithElse" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStructuredExtractInstructionWithElse ("typeStructuredExtractInstructionWithElse", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_AC_elseOrDefaultForCastInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_elseOrDefaultForCastInstruction::
cPtr_AC_elseOrDefaultForCastInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_elseOrDefaultForCastInstruction * GGS_AC_elseOrDefaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_elseOrDefaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_elseOrDefaultForCastInstruction::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_elseOrDefaultForCastInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_elseOrDefaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_elseOrDefaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_elseOrDefaultForCastInstruction (& typeid (cPtr_AC_elseOrDefaultForCastInstruction), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_AC_elseOrDefaultForCastInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction::
GGS_AC_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction::
GGS_AC_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_AC_elseOrDefaultForCastInstruction GGS_AC_elseOrDefaultForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_elseOrDefaultForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_elseOrDefaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_AC_elseOrDefaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_AC_elseOrDefaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_elseOrDefaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_elseOrDefaultForCastInstruction::actualTypeName (void) const {
  return "AC_elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_elseOrDefaultForCastInstruction ("AC_elseOrDefaultForCastInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_C_elseForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_elseForCastInstruction::
cPtr_C_elseForCastInstruction (const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_elseForCastInstruction * GGS_C_elseForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_elseForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_elseForCastInstruction * _p = dynamic_cast <const cPtr_C_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mElseInstructionList._operator_isEqual (_p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_elseForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_elseForCastInstruction:"
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_elseForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_elseForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_elseForCastInstruction (& typeid (cPtr_C_elseForCastInstruction), & typeid (cPtr_AC_elseOrDefaultForCastInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_elseForCastInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction::
GGS_C_elseForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction::
GGS_C_elseForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_elseForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_elseForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_elseForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_elseForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_elseForCastInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_elseForCastInstruction::actualTypeName (void) const {
  return "C_elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_elseForCastInstruction ("C_elseForCastInstruction", gClassInfoFor__AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_C_defaultForCastInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_defaultForCastInstruction::
cPtr_C_defaultForCastInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_defaultForCastInstruction * GGS_C_defaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_defaultForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_defaultForCastInstruction * _p = dynamic_cast <const cPtr_C_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue ()
         && mLocation._operator_isEqual (_p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_defaultForCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_defaultForCastInstruction:"
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_defaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_defaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_defaultForCastInstruction (& typeid (cPtr_C_defaultForCastInstruction), & typeid (cPtr_AC_elseOrDefaultForCastInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_defaultForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction::
GGS_C_defaultForCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction::
GGS_C_defaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_defaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_defaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_defaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_defaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_defaultForCastInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_defaultForCastInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_defaultForCastInstruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_defaultForCastInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_defaultForCastInstruction::actualTypeName (void) const {
  return "C_defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_defaultForCastInstruction ("C_defaultForCastInstruction", gClassInfoFor__AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeStructuredCastBranchList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredCastBranchList::
elementOf_GGS_typeStructuredCastBranchList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCastClassName (argument_0),
mCheckForKindOfClass (argument_1),
mLocalConstantName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredCastBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredCastBranchList * _p = dynamic_cast <const elementOf_GGS_typeStructuredCastBranchList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCastClassName._operator_isEqual (_p->mCastClassName).boolValue ()
         && mCheckForKindOfClass._operator_isEqual (_p->mCheckForKindOfClass).boolValue ()
         && mLocalConstantName._operator_isEqual (_p->mLocalConstantName).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredCastBranchList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCheckForKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocalConstantName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeStructuredCastBranchList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_typeCplusPlusNameList & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_typeCplusPlusNameList & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
_operator_concat (const GGS_typeStructuredCastBranchList & inOperand) const {
  GGS_typeStructuredCastBranchList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeStructuredCastBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCastClassName ;
          GGS_bool p_1 = p->mCheckForKindOfClass ;
          GGS_typeCplusPlusNameList  p_2 = p->mLocalConstantName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1,
                     const GGS_typeCplusPlusNameList & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCastClassName,
                                _p->mCheckForKindOfClass,
                                _p->mLocalConstantName,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastBranchList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredCastBranchList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastBranchList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_bool& argument_1,
                           const GGS_typeCplusPlusNameList & argument_2,
                           const GGS_typeInstructionList & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredCastBranchList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
internalSubListWithRange (GGS_typeStructuredCastBranchList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mCastClassName, _p->mCheckForKindOfClass, _p->mLocalConstantName, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredCastBranchList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeStructuredCastBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1,
              GGS_typeCplusPlusNameList & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCastClassName ;
    _out_1 = _p->mCheckForKindOfClass ;
    _out_2 = _p->mLocalConstantName ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1,
             GGS_typeCplusPlusNameList & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCastClassName ;
    _out_1 = _p->mCheckForKindOfClass ;
    _out_2 = _p->mLocalConstantName ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1,
                 GGS_typeCplusPlusNameList & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCastClassName ;
    _out_1 = _p->mCheckForKindOfClass ;
    _out_2 = _p->mLocalConstantName ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1,
                GGS_typeCplusPlusNameList & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCastClassName ;
    _out_1 = _p->mCheckForKindOfClass ;
    _out_2 = _p->mLocalConstantName ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredCastBranchList::
reader_mCastClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredCastBranchList::
reader_mCheckForKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCheckForKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeStructuredCastBranchList::
reader_mLocalConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocalConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredCastBranchList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMCastClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMCheckForKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCheckForKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMLocalConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusNameList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocalConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeStructuredCastInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredCastInstruction::
cPtr_typeStructuredCastInstruction (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeStructuredCastBranchList & argument_3,
                                const GGS_AC_elseOrDefaultForCastInstruction & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCastInstructionLocation (argument_0),
mSourceExpression (argument_1),
mSourceExpressionTypeName (argument_2),
mBranchList (argument_3),
mElseOrDefault (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredCastInstruction * GGS_typeStructuredCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStructuredCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredCastInstruction * _p = dynamic_cast <const cPtr_typeStructuredCastInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCastInstructionLocation._operator_isEqual (_p->mCastInstructionLocation).boolValue ()
         && mSourceExpression._operator_isEqual (_p->mSourceExpression).boolValue ()
         && mSourceExpressionTypeName._operator_isEqual (_p->mSourceExpressionTypeName).boolValue ()
         && mBranchList._operator_isEqual (_p->mBranchList).boolValue ()
         && mElseOrDefault._operator_isEqual (_p->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredCastInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStructuredCastInstruction:"
           << mCastInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseOrDefault.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStructuredCastInstruction (& typeid (cPtr_typeStructuredCastInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeStructuredCastInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction::
GGS_typeStructuredCastInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction::
GGS_typeStructuredCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStructuredCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeStructuredCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeStructuredCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStructuredCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeStructuredCastBranchList & argument_3,
                 const GGS_AC_elseOrDefaultForCastInstruction & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredCastInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStructuredCastInstruction::
reader_mCastInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mCastInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStructuredCastInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredCastInstruction::
reader_mSourceExpressionTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mSourceExpressionTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastInstruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction  GGS_typeStructuredCastInstruction::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStructuredCastInstruction::actualTypeName (void) const {
  return "typeStructuredCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStructuredCastInstruction ("typeStructuredCastInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeRoutineCallInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::
cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mRoutineName (argument_0),
mExpressionsList (argument_1),
mFormalParameterList (argument_2),
mIsExternActionCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineCallInstruction * _p = dynamic_cast <const cPtr_typeRoutineCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue ()
         && mFormalParameterList._operator_isEqual (_p->mFormalParameterList).boolValue ()
         && mIsExternActionCall._operator_isEqual (_p->mIsExternActionCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineCallInstruction:"
           << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIsExternActionCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineCallInstruction (& typeid (cPtr_typeRoutineCallInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeRoutineCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_L_EXsignature & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeRoutineCallInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRoutineCallInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeRoutineCallInstruction::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineCallInstruction::
reader_mIsExternActionCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mIsExternActionCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineCallInstruction::actualTypeName (void) const {
  return "typeRoutineCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRoutineCallInstruction ("typeRoutineCallInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogInstruction::
cPtr_typeLogInstruction (const GGS_lstring & argument_0,
                                const GGS_typeCplusPlusName & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mGalgasVariableName (argument_0),
mLoggedVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogInstruction * GGS_typeLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogInstruction * _p = dynamic_cast <const cPtr_typeLogInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGalgasVariableName._operator_isEqual (_p->mGalgasVariableName).boolValue ()
         && mLoggedVariable._operator_isEqual (_p->mLoggedVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLogInstruction:"
           << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLoggedVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLogInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLogInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLogInstruction (& typeid (cPtr_typeLogInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeLogInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeLogInstruction GGS_typeLogInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLogInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLogInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeLogInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLogInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction GGS_typeLogInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeCplusPlusName & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLogInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLogInstruction::
reader_mGalgasVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mGalgasVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeLogInstruction::
reader_mLoggedVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mLoggedVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLogInstruction::actualTypeName (void) const {
  return "typeLogInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLogInstruction ("typeLogInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::
cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDropInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDropInstruction * _p = dynamic_cast <const cPtr_typeDropInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aVariableConsommee._operator_isEqual (_p->aVariableConsommee).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDropInstruction:"
           << aVariableConsommee.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDropInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDropInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDropInstruction (& typeid (cPtr_typeDropInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDropInstruction GGS_typeDropInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDropInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeDropInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDropInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDropInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction GGS_typeDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDropInstruction::
reader_aVariableConsommee (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDropInstruction *) mPointer)->aVariableConsommee ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDropInstruction::actualTypeName (void) const {
  return "typeDropInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDropInstruction ("typeDropInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableNomRoutinesDeclarees'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableNomRoutinesDeclarees::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableNomRoutinesDeclarees info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
_operator_isEqual (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
_operator_isNotEqual (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntityToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntityToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeEntityToGenerate::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeEntityToGenerate:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntityToGenerate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntityToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntityToGenerate (& typeid (cPtr_typeEntityToGenerate), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeEntityToGenerate GGS_typeEntityToGenerate::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntityToGenerate _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntityToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntityToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeEntityToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntityToGenerate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntityToGenerate::actualTypeName (void) const {
  return "typeEntityToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeEntityToGenerate ("typeEntityToGenerate") ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeExternTypeToGenerate'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::
cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_externTypeConstructorMap & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mConstructorMap (argument_1),
mModifiersMap (argument_2),
mReadersInInstructionMap (argument_3),
mAcceptAddAssignOperatorCall (argument_4),
mAddAssignOperatorCallTypeList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeExternTypeToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeExternTypeToGenerate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeExternTypeToGenerate * _p = dynamic_cast <const cPtr_typeExternTypeToGenerate *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mGalgasName._operator_isEqual (_p->mGalgasName).boolValue ()
         && mConstructorMap._operator_isEqual (_p->mConstructorMap).boolValue ()
         && mModifiersMap._operator_isEqual (_p->mModifiersMap).boolValue ()
         && mReadersInInstructionMap._operator_isEqual (_p->mReadersInInstructionMap).boolValue ()
         && mAcceptAddAssignOperatorCall._operator_isEqual (_p->mAcceptAddAssignOperatorCall).boolValue ()
         && mAddAssignOperatorCallTypeList._operator_isEqual (_p->mAddAssignOperatorCallTypeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeExternTypeToGenerate:"
           << mGalgasName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mModifiersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReadersInInstructionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAcceptAddAssignOperatorCall.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAddAssignOperatorCallTypeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeExternTypeToGenerate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeExternTypeToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeExternTypeToGenerate (& typeid (cPtr_typeExternTypeToGenerate), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeExternTypeToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeExternTypeToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeExternTypeToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeExternTypeToGenerate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_externTypeConstructorMap & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeExternTypeToGenerate::
reader_mGalgasName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mGalgasName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_externTypeConstructorMap  GGS_typeExternTypeToGenerate::
reader_mConstructorMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_externTypeConstructorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mConstructorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeExternTypeToGenerate::
reader_mModifiersMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mModifiersMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_typeExternTypeToGenerate::
reader_mReadersInInstructionMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mReadersInInstructionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExternTypeToGenerate::
reader_mAcceptAddAssignOperatorCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mAcceptAddAssignOperatorCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeExternTypeToGenerate::
reader_mAddAssignOperatorCallTypeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mAddAssignOperatorCallTypeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeExternTypeToGenerate::actualTypeName (void) const {
  return "typeExternTypeToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeExternTypeToGenerate ("typeExternTypeToGenerate", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeRoutineAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::
cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineAengendrer * _p = dynamic_cast <const cPtr_typeRoutineAengendrer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomRoutine._operator_isEqual (_p->aNomRoutine).boolValue ()
         && aListeTypeEtNomsArguments._operator_isEqual (_p->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineAengendrer:"
           << aNomRoutine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineAengendrer (& typeid (cPtr_typeRoutineAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeRoutineAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeRoutineAengendrer::
reader_aNomRoutine (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineAengendrer *) mPointer)->aNomRoutine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeRoutineAengendrer::
reader_aListeTypeEtNomsArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineAengendrer *) mPointer)->aListeTypeEtNomsArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeRoutineAengendrer::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineAengendrer *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineAengendrer::actualTypeName (void) const {
  return "typeRoutineAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRoutineAengendrer ("typeRoutineAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_categoryMethodToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryMethodToImplement::
cPtr_categoryMethodToImplement (const GGS_bool& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_location & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mOverride (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryMethodToImplement * GGS_categoryMethodToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_categoryMethodToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryMethodToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryMethodToImplement * _p = dynamic_cast <const cPtr_categoryMethodToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOverride._operator_isEqual (_p->mOverride).boolValue ()
         && mBaseClassName._operator_isEqual (_p->mBaseClassName).boolValue ()
         && mClassName._operator_isEqual (_p->mClassName).boolValue ()
         && mMethodName._operator_isEqual (_p->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments._operator_isEqual (_p->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue ()
         && mMagicNumber._operator_isEqual (_p->mMagicNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryMethodToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@categoryMethodToImplement:"
           << mOverride.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBaseClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMagicNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryMethodToImplement (& typeid (cPtr_categoryMethodToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_categoryMethodToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement::
GGS_categoryMethodToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement::
GGS_categoryMethodToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_categoryMethodToImplement GGS_categoryMethodToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryMethodToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryMethodToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_categoryMethodToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryMethodToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement GGS_categoryMethodToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_location & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryMethodToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodToImplement::
reader_mOverride (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->mOverride ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodToImplement::
reader_mBaseClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->mBaseClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryMethodToImplement::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_categoryMethodToImplement::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_categoryMethodToImplement::
reader_aListeTypeEtNomsArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->aListeTypeEtNomsArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_categoryMethodToImplement::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_categoryMethodToImplement::
reader_mMagicNumber (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_categoryMethodToImplement *) mPointer)->mMagicNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodToImplement::actualTypeName (void) const {
  return "categoryMethodToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__categoryMethodToImplement ("categoryMethodToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_listTypeToImplement'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::
cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_listTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_listTypeToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_listTypeToImplement * _p = dynamic_cast <const cPtr_C_listTypeToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomListe._operator_isEqual (_p->aNomListe).boolValue ()
         && mNonExternAttributesList._operator_isEqual (_p->mNonExternAttributesList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_listTypeToImplement:"
           << aNomListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_listTypeToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_listTypeToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_listTypeToImplement (& typeid (cPtr_C_listTypeToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_listTypeToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_listTypeToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_listTypeToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_listTypeToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_listTypeToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_listTypeToImplement::
reader_aNomListe (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_listTypeToImplement *) mPointer)->aNomListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_listTypeToImplement::
reader_mNonExternAttributesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_listTypeToImplement *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_listTypeToImplement::actualTypeName (void) const {
  return "C_listTypeToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_listTypeToImplement ("C_listTypeToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@EXsortDescriptorList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_EXsortDescriptorList::
elementOf_GGS_EXsortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSortAttribute (argument_0),
mAscendingOrder (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXsortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_EXsortDescriptorList * _p = dynamic_cast <const elementOf_GGS_EXsortDescriptorList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSortAttribute._operator_isEqual (_p->mSortAttribute).boolValue ()
         && mAscendingOrder._operator_isEqual (_p->mAscendingOrder).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXsortDescriptorList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortAttribute.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscendingOrder.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@EXsortDescriptorList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
_operator_concat (const GGS_EXsortDescriptorList & inOperand) const {
  GGS_EXsortDescriptorList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_EXsortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortAttribute ;
          GGS_bool p_1 = p->mAscendingOrder ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortAttribute,
                                _p->mAscendingOrder
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_EXsortDescriptorList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXsortDescriptorList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_EXsortDescriptorList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_bool& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXsortDescriptorList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
internalSubListWithRange (GGS_EXsortDescriptorList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSortAttribute, _p->mAscendingOrder) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsortDescriptorList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@EXsortDescriptorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_EXsortDescriptorList::
reader_mSortAttributeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortAttribute ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsortDescriptorList::
reader_mAscendingOrderAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscendingOrder ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_setMSortAttributeAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortAttribute = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_setMAscendingOrderAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscendingOrder = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_C_sortedListTypeToImplement'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_sortedListTypeToImplement::
cPtr_C_sortedListTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_EXsortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_sortedListTypeToImplement * GGS_C_sortedListTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_sortedListTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_sortedListTypeToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_sortedListTypeToImplement * _p = dynamic_cast <const cPtr_C_sortedListTypeToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomListe._operator_isEqual (_p->aNomListe).boolValue ()
         && mNonExternAttributesList._operator_isEqual (_p->mNonExternAttributesList).boolValue ()
         && mSortDescriptorList._operator_isEqual (_p->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_sortedListTypeToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_sortedListTypeToImplement:"
           << aNomListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSortDescriptorList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_sortedListTypeToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_sortedListTypeToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_sortedListTypeToImplement (& typeid (cPtr_C_sortedListTypeToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_sortedListTypeToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_sortedListTypeToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_sortedListTypeToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_sortedListTypeToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_EXsortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_sortedListTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_sortedListTypeToImplement::
reader_aNomListe (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_sortedListTypeToImplement *) mPointer)->aNomListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_sortedListTypeToImplement::
reader_mNonExternAttributesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_sortedListTypeToImplement *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_C_sortedListTypeToImplement::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_sortedListTypeToImplement *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_sortedListTypeToImplement::actualTypeName (void) const {
  return "C_sortedListTypeToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_sortedListTypeToImplement ("C_sortedListTypeToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeDefinitionTableAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::
cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
aNomClasseGenerique (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
aTableMethodesSurcharger (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefinitionTableAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDefinitionTableAimplementer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDefinitionTableAimplementer * _p = dynamic_cast <const cPtr_typeDefinitionTableAimplementer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomTable._operator_isEqual (_p->aNomTable).boolValue ()
         && mNonExternAttributesList._operator_isEqual (_p->mNonExternAttributesList).boolValue ()
         && aNomClasseGenerique._operator_isEqual (_p->aNomClasseGenerique).boolValue ()
         && mInsertMethodList._operator_isEqual (_p->mInsertMethodList).boolValue ()
         && mSearchMethodList._operator_isEqual (_p->mSearchMethodList).boolValue ()
         && aTableMethodesSurcharger._operator_isEqual (_p->aTableMethodesSurcharger).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDefinitionTableAimplementer:"
           << aNomTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomClasseGenerique.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDefinitionTableAimplementer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefinitionTableAimplementer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDefinitionTableAimplementer (& typeid (cPtr_typeDefinitionTableAimplementer), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (inPointer) != NULL)
      : (typeid (cPtr_typeDefinitionTableAimplementer) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDefinitionTableAimplementer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDefinitionTableAimplementer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  macroMyNew (result.mPointer, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeDefinitionTableAimplementer::
reader_aNomTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->aNomTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeDefinitionTableAimplementer::
reader_mNonExternAttributesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeDefinitionTableAimplementer::
reader_aNomClasseGenerique (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->aNomClasseGenerique ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_typeDefinitionTableAimplementer::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_typeDefinitionTableAimplementer::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable  GGS_typeDefinitionTableAimplementer::
reader_aTableMethodesSurcharger (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->aTableMethodesSurcharger ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDefinitionTableAimplementer::actualTypeName (void) const {
  return "typeDefinitionTableAimplementer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDefinitionTableAimplementer ("typeDefinitionTableAimplementer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_mapToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::
cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeListeAttributsSemantiques & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_insertOrSearchMethodList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapTypeName (argument_0),
mEnumTypeName (argument_1),
mCheckFinalStateMethod (argument_2),
mNonExternAttributesList (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
mRemoveMethodList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapToImplement * _p = dynamic_cast <const cPtr_C_mapToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mCheckFinalStateMethod._operator_isEqual (_p->mCheckFinalStateMethod).boolValue ()
         && mNonExternAttributesList._operator_isEqual (_p->mNonExternAttributesList).boolValue ()
         && mInsertMethodList._operator_isEqual (_p->mInsertMethodList).boolValue ()
         && mSearchMethodList._operator_isEqual (_p->mSearchMethodList).boolValue ()
         && mRemoveMethodList._operator_isEqual (_p->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapToImplement:"
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCheckFinalStateMethod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRemoveMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_mapToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_mapToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_mapToImplement (& typeid (cPtr_C_mapToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_mapToImplement GGS_C_mapToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_mapToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_mapToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_mapToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_mapToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement GGS_C_mapToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeListeAttributsSemantiques & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_insertOrSearchMethodList & argument_5,
                 const GGS_insertOrSearchMethodList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapToImplement::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapToImplement::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapToImplement::
reader_mCheckFinalStateMethod (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mCheckFinalStateMethod ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_mapToImplement::
reader_mNonExternAttributesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_C_mapToImplement::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_C_mapToImplement::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_C_mapToImplement::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_mapToImplement::actualTypeName (void) const {
  return "C_mapToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_mapToImplement ("C_mapToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_classToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_classToImplement::
cPtr_C_classToImplement (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_string& argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
mIsAbstract (argument_1),
aListeTousAttributsNonExternes (argument_2),
aTableToutesMethodes (argument_3),
mMethodsMap (argument_4),
aListeAttributsCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7),
mClassMessage (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_classToImplement * GGS_C_classToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_classToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_classToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_classToImplement * _p = dynamic_cast <const cPtr_C_classToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomClasse._operator_isEqual (_p->aNomClasse).boolValue ()
         && mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && aListeTousAttributsNonExternes._operator_isEqual (_p->aListeTousAttributsNonExternes).boolValue ()
         && aTableToutesMethodes._operator_isEqual (_p->aTableToutesMethodes).boolValue ()
         && mMethodsMap._operator_isEqual (_p->mMethodsMap).boolValue ()
         && aListeAttributsCourants._operator_isEqual (_p->aListeAttributsCourants).boolValue ()
         && mAncestorClassesMap._operator_isEqual (_p->mAncestorClassesMap).boolValue ()
         && mMessagesMap._operator_isEqual (_p->mMessagesMap).boolValue ()
         && mClassMessage._operator_isEqual (_p->mClassMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_classToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_classToImplement:"
           << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableToutesMethodes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_classToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_classToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_classToImplement (& typeid (cPtr_C_classToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_classToImplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_classToImplement GGS_C_classToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_classToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_classToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_classToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_classToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement GGS_C_classToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_typeTableMethodesAimplementer & argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5,
                 const GGS_typeSuperClassesMap & argument_6,
                 const GGS_typeClassMessagesMap & argument_7,
                 const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_classToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_classToImplement::
reader_aNomClasse (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_classToImplement::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_classToImplement::
reader_aListeTousAttributsNonExternes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aListeTousAttributsNonExternes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_C_classToImplement::
reader_aTableToutesMethodes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aTableToutesMethodes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer  GGS_C_classToImplement::
reader_mMethodsMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodesAimplementer   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mMethodsMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_classToImplement::
reader_aListeAttributsCourants (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aListeAttributsCourants ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap  GGS_C_classToImplement::
reader_mAncestorClassesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mAncestorClassesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap  GGS_C_classToImplement::
reader_mMessagesMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_classToImplement::
reader_mClassMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mClassMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_classToImplement::actualTypeName (void) const {
  return "C_classToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_classToImplement ("C_classToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_mapindexToImplement'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapindexToImplement::
cPtr_C_mapindexToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_mapIndexSearchReaderMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapindexTypeName (argument_0),
mMapTypeName (argument_1),
mMapAttributesList (argument_2),
mMapIndexSearchReaderMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapindexToImplement * GGS_C_mapindexToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapindexToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapindexToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapindexToImplement * _p = dynamic_cast <const cPtr_C_mapindexToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMapindexTypeName._operator_isEqual (_p->mMapindexTypeName).boolValue ()
         && mMapTypeName._operator_isEqual (_p->mMapTypeName).boolValue ()
         && mMapAttributesList._operator_isEqual (_p->mMapAttributesList).boolValue ()
         && mMapIndexSearchReaderMap._operator_isEqual (_p->mMapIndexSearchReaderMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapindexToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapindexToImplement:"
           << mMapindexTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapIndexSearchReaderMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_mapindexToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_mapindexToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_mapindexToImplement (& typeid (cPtr_C_mapindexToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_mapindexToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_mapindexToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_mapindexToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_mapindexToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_mapindexToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_mapIndexSearchReaderMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapindexToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapindexToImplement::
reader_mMapindexTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapindexTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapindexToImplement::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_mapindexToImplement::
reader_mMapAttributesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap  GGS_C_mapindexToImplement::
reader_mMapIndexSearchReaderMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapIndexSearchReaderMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapIndexSearchReaderMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_mapindexToImplement::actualTypeName (void) const {
  return "C_mapindexToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_mapindexToImplement ("C_mapindexToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_domainRelationMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_domainRelationMap::e_domainRelationMap (void) :
mDomains () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@domainRelationMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_domainRelationMap::
elementOf_GGS_domainRelationMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_domainRelationMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainRelationMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDomains.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainRelationMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_domainRelationMap * _p = dynamic_cast <const elementOf_GGS_domainRelationMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mDomains._operator_isEqual (_p->mInfo.mDomains)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainRelationMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainRelationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainRelationMap * info = (e_domainRelationMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainRelationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_domainRelationMap * info = (e_domainRelationMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainRelationMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainRelationMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainRelationMap::
_operator_isEqual (const GGS_domainRelationMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainRelationMap::
_operator_isNotEqual (const GGS_domainRelationMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_stringlist & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_domainRelationMap info  ;
    info.mDomains = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringlist   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomains ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringlist   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' domain relation is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringlist & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' domain relation has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_domainRelationMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainRelationMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainRelationMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainRelationMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @domainRelationMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_domainToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_domainToImplement::
cPtr_C_domainToImplement (const GGS_lstring & argument_0,
                                const GGS_domainAttributeMap & argument_1,
                                const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mDomainName (argument_0),
mAttributeMap (argument_1),
mRelationMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_domainToImplement * GGS_C_domainToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_domainToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_domainToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_domainToImplement * _p = dynamic_cast <const cPtr_C_domainToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDomainName._operator_isEqual (_p->mDomainName).boolValue ()
         && mAttributeMap._operator_isEqual (_p->mAttributeMap).boolValue ()
         && mRelationMap._operator_isEqual (_p->mRelationMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_domainToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_domainToImplement:"
           << mDomainName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRelationMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_domainToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_domainToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_domainToImplement (& typeid (cPtr_C_domainToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_domainToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_domainToImplement GGS_C_domainToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_domainToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_domainToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_domainToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_domainToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement GGS_C_domainToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_domainAttributeMap & argument_1,
                 const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_domainToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_domainToImplement::
reader_mDomainName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_domainToImplement *) mPointer)->mDomainName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap  GGS_C_domainToImplement::
reader_mAttributeMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainAttributeMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_domainToImplement *) mPointer)->mAttributeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap  GGS_C_domainToImplement::
reader_mRelationMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainRelationMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_domainToImplement *) mPointer)->mRelationMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_domainToImplement::actualTypeName (void) const {
  return "C_domainToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_domainToImplement ("C_domainToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeEntiteActionExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::
cPtr_typeEntiteActionExterne (const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteActionExterne::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteActionExterne * _p = dynamic_cast <const cPtr_typeEntiteActionExterne *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aSignature._operator_isEqual (_p->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteActionExterne::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteActionExterne:"
           << aSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteActionExterne::
static_string_message_messageTypeEntite (void) {
  return "an external extern routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteActionExterne::
message_messageTypeEntite (void) const {
  return "an external extern routine" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteActionExterne::
_message (void) const {
  return "an external extern routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteActionExterne::
_static_message (void) {
  return "an external extern routine" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteActionExterne (& typeid (cPtr_typeEntiteActionExterne), & typeid (cPtr_AC_semanticsEntity), "an external extern routine") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne::
GGS_typeEntiteActionExterne (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne::
GGS_typeEntiteActionExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeEntiteActionExterne GGS_typeEntiteActionExterne::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteActionExterne _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteActionExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteActionExterne) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeEntiteActionExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteActionExterne),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne GGS_typeEntiteActionExterne::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteActionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteActionExterne (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteActionExterne::
reader_messageTypeEntite (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteActionExterne * p = (cPtr_typeEntiteActionExterne *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteActionExterne::
reader_aSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteActionExterne *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteActionExterne::actualTypeName (void) const {
  return "typeEntiteActionExterne" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteActionExterne ("typeEntiteActionExterne", gClassInfoFor__AC_semanticsEntity) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeActionExterneAengendrer'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::
cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeActionExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeActionExterneAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeActionExterneAengendrer * _p = dynamic_cast <const cPtr_typeActionExterneAengendrer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomAction._operator_isEqual (_p->aNomAction).boolValue ()
         && aSignature._operator_isEqual (_p->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeActionExterneAengendrer::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeActionExterneAengendrer:"
           << aNomAction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeActionExterneAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeActionExterneAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeActionExterneAengendrer (& typeid (cPtr_typeActionExterneAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer::
GGS_typeActionExterneAengendrer (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer::
GGS_typeActionExterneAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeActionExterneAengendrer GGS_typeActionExterneAengendrer::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeActionExterneAengendrer _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeActionExterneAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeActionExterneAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeActionExterneAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeActionExterneAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer GGS_typeActionExterneAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeActionExterneAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeActionExterneAengendrer::
reader_aNomAction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeActionExterneAengendrer *) mPointer)->aNomAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeActionExterneAengendrer::
reader_aSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeActionExterneAengendrer *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeActionExterneAengendrer::actualTypeName (void) const {
  return "typeActionExterneAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeActionExterneAengendrer ("typeActionExterneAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntityToGenerate (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEntitiesToGenerateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeEntitiesToGenerateList * _p = dynamic_cast <const elementOf_GGS_typeEntitiesToGenerateList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntityToGenerate._operator_isEqual (_p->mEntityToGenerate).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityToGenerate.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalAppendValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalPrependValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
_operator_concat (const GGS_typeEntitiesToGenerateList & inOperand) const {
  GGS_typeEntitiesToGenerateList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeEntitiesToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeEntityToGenerate  p_0 = p->mEntityToGenerate ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeEntityToGenerate & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntityToGenerate
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeEntityToGenerate & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalSubListWithRange (GGS_typeEntitiesToGenerateList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mEntityToGenerate) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeEntitiesToGenerateList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeEntitiesToGenerateList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeEntitiesToGenerateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_first (C_Compiler & _inLexique,
              GGS_typeEntityToGenerate & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_last (C_Compiler & _inLexique,
             GGS_typeEntityToGenerate & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeEntityToGenerate & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeEntityToGenerate & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate  GGS_typeEntitiesToGenerateList::
reader_mEntityToGenerateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeEntityToGenerate  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntityToGenerate ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_setMEntityToGenerateAtIndex (C_Compiler & inLexique,
                              const GGS_typeEntityToGenerate  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntityToGenerate = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_typeEnumCstMessageStringMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeEnumCstMessageStringMap::e_typeEnumCstMessageStringMap (void) :
mMessageString () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@typeEnumCstMessageStringMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumCstMessageStringMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumCstMessageStringMap * _p = dynamic_cast <const elementOf_GGS_typeEnumCstMessageStringMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMessageString._operator_isEqual (_p->mInfo.mMessageString)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeEnumCstMessageStringMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
_operator_isEqual (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
_operator_isNotEqual (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the message for '%K' constant is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the message for '%K' constant is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_enumGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::
cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2,
                                const GGS_enumModifierMap & argument_3,
                                const GGS_enumMethodMap & argument_4,
                                const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2),
mEnumActionMap (argument_3),
mMethodMap (argument_4),
mOperatorMap (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumGalgasType * _p = dynamic_cast <const cPtr_enumGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEnumTypeName._operator_isEqual (_p->mEnumTypeName).boolValue ()
         && mConstantMap._operator_isEqual (_p->mConstantMap).boolValue ()
         && mEnumMessageMap._operator_isEqual (_p->mEnumMessageMap).boolValue ()
         && mEnumActionMap._operator_isEqual (_p->mEnumActionMap).boolValue ()
         && mMethodMap._operator_isEqual (_p->mMethodMap).boolValue ()
         && mOperatorMap._operator_isEqual (_p->mOperatorMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumGalgasType:"
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstantMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumMessageMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumActionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperatorMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumGalgasType (& typeid (cPtr_enumGalgasType), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_enumGalgasType GGS_enumGalgasType::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_enumGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_enumGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType GGS_enumGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2,
                 const GGS_enumModifierMap & argument_3,
                 const GGS_enumMethodMap & argument_4,
                 const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  macroMyNew (result.mPointer, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumGalgasType::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_enumGalgasType::
reader_mConstantMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mConstantMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap  GGS_enumGalgasType::
reader_mEnumMessageMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mEnumMessageMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumModifierMap  GGS_enumGalgasType::
reader_mEnumActionMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumModifierMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mEnumActionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMethodMap  GGS_enumGalgasType::
reader_mMethodMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMethodMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumOperatorMap  GGS_enumGalgasType::
reader_mOperatorMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumOperatorMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mOperatorMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumGalgasType::actualTypeName (void) const {
  return "enumGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__enumGalgasType ("enumGalgasType", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_treewalkingRoutineHeaderMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_treewalkingRoutineHeaderMap::e_treewalkingRoutineHeaderMap (void) :
mRoutineSignature (),
mFormalArgumentList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@treewalkingRoutineHeaderMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_treewalkingRoutineHeaderMap::
elementOf_GGS_treewalkingRoutineHeaderMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_treewalkingRoutineHeaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_treewalkingRoutineHeaderMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRoutineSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_treewalkingRoutineHeaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_treewalkingRoutineHeaderMap * _p = dynamic_cast <const elementOf_GGS_treewalkingRoutineHeaderMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRoutineSignature._operator_isEqual (_p->mInfo.mRoutineSignature)).boolValue ()
           && (mInfo.mFormalArgumentList._operator_isEqual (_p->mInfo.mFormalArgumentList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_treewalkingRoutineHeaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_treewalkingRoutineHeaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_treewalkingRoutineHeaderMap * info = (e_treewalkingRoutineHeaderMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_treewalkingRoutineHeaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_treewalkingRoutineHeaderMap * info = (e_treewalkingRoutineHeaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineHeaderMap GGS_treewalkingRoutineHeaderMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineHeaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_treewalkingRoutineHeaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_treewalkingRoutineHeaderMap::
_operator_isEqual (const GGS_treewalkingRoutineHeaderMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_treewalkingRoutineHeaderMap::
_operator_isNotEqual (const GGS_treewalkingRoutineHeaderMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_treewalkingRoutineHeaderMap info  ;
    info.mRoutineSignature = inParameter0 ;
    info.mFormalArgumentList = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    outParameter1 = node->mInfo.mFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' treewalking routine is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' treewalking routine has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineHeaderMap GGS_treewalkingRoutineHeaderMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_treewalkingRoutineHeaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineHeaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineHeaderMap GGS_treewalkingRoutineHeaderMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_treewalkingRoutineHeaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_treewalkingRoutineHeaderMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @treewalkingRoutineHeaderMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@treewalkingRoutineToGenerateList'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_treewalkingRoutineToGenerateList::
elementOf_GGS_treewalkingRoutineToGenerateList (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMetamodelClass (argument_0),
mFormalArgumentList (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_treewalkingRoutineToGenerateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_treewalkingRoutineToGenerateList * _p = dynamic_cast <const elementOf_GGS_treewalkingRoutineToGenerateList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMetamodelClass._operator_isEqual (_p->mMetamodelClass).boolValue ()
         && mFormalArgumentList._operator_isEqual (_p->mFormalArgumentList).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_treewalkingRoutineToGenerateList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@treewalkingRoutineToGenerateList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList GGS_treewalkingRoutineToGenerateList::
_operator_concat (const GGS_treewalkingRoutineToGenerateList & inOperand) const {
  GGS_treewalkingRoutineToGenerateList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_treewalkingRoutineToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMetamodelClass ;
          GGS_typeListeTypesEtNomsArgMethode  p_1 = p->mFormalArgumentList ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMetamodelClass,
                                _p->mFormalArgumentList,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList  GGS_treewalkingRoutineToGenerateList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineToGenerateList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList  GGS_treewalkingRoutineToGenerateList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                           const GGS_typeInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineToGenerateList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
internalSubListWithRange (GGS_treewalkingRoutineToGenerateList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mMetamodelClass, _p->mFormalArgumentList, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList GGS_treewalkingRoutineToGenerateList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_treewalkingRoutineToGenerateList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList GGS_treewalkingRoutineToGenerateList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_treewalkingRoutineToGenerateList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_treewalkingRoutineToGenerateList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@treewalkingRoutineToGenerateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_typeListeTypesEtNomsArgMethode & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_typeListeTypesEtNomsArgMethode & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_typeListeTypesEtNomsArgMethode & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_typeListeTypesEtNomsArgMethode & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_treewalkingRoutineToGenerateList::
reader_mMetamodelClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMetamodelClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_treewalkingRoutineToGenerateList::
reader_mFormalArgumentListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_treewalkingRoutineToGenerateList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_setMMetamodelClassAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMetamodelClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_setMFormalArgumentListAtIndex (C_Compiler & inLexique,
                              const GGS_typeListeTypesEtNomsArgMethode  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@routineDispatcherSortedList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDispatcherSortedList::
elementOf_GGS_routineDispatcherSortedList (const GGS_string& argument_0,
                                const GGS_uint & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4):
mMetamodelClassIDString (argument_0),
mMetamodelClassID (argument_1),
mRoutineName (argument_2),
mEntityName (argument_3),
mMetamodelName (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDispatcherSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_routineDispatcherSortedList * _p = dynamic_cast <const elementOf_GGS_routineDispatcherSortedList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMetamodelClassIDString._operator_isEqual (_p->mMetamodelClassIDString).boolValue ()
         && mMetamodelClassID._operator_isEqual (_p->mMetamodelClassID).boolValue ()
         && mRoutineName._operator_isEqual (_p->mRoutineName).boolValue ()
         && mEntityName._operator_isEqual (_p->mEntityName).boolValue ()
         && mMetamodelName._operator_isEqual (_p->mMetamodelName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

sint32 elementOf_GGS_routineDispatcherSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  elementOf_GGS_routineDispatcherSortedList * operand = (elementOf_GGS_routineDispatcherSortedList *) inOperand ;
  sint32 result = mMetamodelName.compare (operand->mMetamodelName) ;
  if (result == 0) {
    result = mMetamodelClassIDString.compare (operand->mMetamodelClassIDString) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDispatcherSortedList::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelClassIDString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelClassID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@routineDispatcherSortedList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList::GGS_routineDispatcherSortedList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList::
GGS_routineDispatcherSortedList (const GGS_routineDispatcherSortedList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDispatcherSortedList::
_operator_isEqual (const GGS_routineDispatcherSortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDispatcherSortedList::
_operator_isNotEqual (const GGS_routineDispatcherSortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1,
                    const GGS_string& argument_2,
                    const GGS_string& argument_3,
                    const GGS_string& argument_4) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_uint & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList GGS_routineDispatcherSortedList::
_operator_concat (const GGS_routineDispatcherSortedList & inOperand) const {
  GGS_routineDispatcherSortedList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_routineDispatcherSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mMetamodelClassIDString ;
          GGS_uint  p_1 = p->mMetamodelClassID ;
          GGS_string p_2 = p->mRoutineName ;
          GGS_string p_3 = p->mEntityName ;
          GGS_string p_4 = p->mMetamodelName ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMetamodelClassIDString,
                                _p->mMetamodelClassID,
                                _p->mRoutineName,
                                _p->mEntityName,
                                _p->mMetamodelName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList  GGS_routineDispatcherSortedList::
constructor_emptySortedList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineDispatcherSortedList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList  GGS_routineDispatcherSortedList::
constructor_sortedListWithValue (C_Compiler & /* _inLexique */,
                           const GGS_string& argument_0,
                           const GGS_uint & argument_1,
                           const GGS_string& argument_2,
                           const GGS_string& argument_3,
                           const GGS_string& argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineDispatcherSortedList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDispatcherSortedList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@routineDispatcherSortedList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
method_smallest (C_Compiler & _inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1,
                 GGS_string& _out_2,
                 GGS_string& _out_3,
                 GGS_string& _out_4
                 COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
    _out_4 = _p->mMetamodelName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
method_greatest (C_Compiler & _inLexique,
             GGS_string& _out_0,
             GGS_uint & _out_1,
             GGS_string& _out_2,
             GGS_string& _out_3,
             GGS_string& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
    _out_4 = _p->mMetamodelName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
modifier_popSmallest (C_Compiler & _inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1,
                 GGS_string& _out_2,
                 GGS_string& _out_3,
                 GGS_string& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
    _out_4 = _p->mMetamodelName ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
modifier_popGreatest (C_Compiler & _inLexique,
                GGS_string& _out_0,
                GGS_uint & _out_1,
                GGS_string& _out_2,
                GGS_string& _out_3,
                GGS_string& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
    _out_4 = _p->mMetamodelName ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_callInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_callInstruction::
cPtr_callInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_AC_galgasType & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCalledPropertyName (argument_0),
mEntityName (argument_1),
mPropertyType (argument_2),
mExpressionsList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_callInstruction * GGS_callInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_callInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_callInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_callInstruction * _p = dynamic_cast <const cPtr_callInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCalledPropertyName._operator_isEqual (_p->mCalledPropertyName).boolValue ()
         && mEntityName._operator_isEqual (_p->mEntityName).boolValue ()
         && mPropertyType._operator_isEqual (_p->mPropertyType).boolValue ()
         && mExpressionsList._operator_isEqual (_p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_callInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@callInstruction:"
           << mCalledPropertyName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPropertyType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_callInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_callInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_callInstruction (& typeid (cPtr_callInstruction), & typeid (cPtr_typeInstruction), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_callInstruction::
GGS_callInstruction (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_callInstruction::
GGS_callInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_callInstruction GGS_callInstruction::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_callInstruction _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_callInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_callInstruction) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_callInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_callInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_callInstruction GGS_callInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_AC_galgasType & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_callInstruction result ;
  macroMyNew (result.mPointer, cPtr_callInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_callInstruction::
reader_mCalledPropertyName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mCalledPropertyName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_callInstruction::
reader_mEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_callInstruction::
reader_mPropertyType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mPropertyType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_callInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_callInstruction::actualTypeName (void) const {
  return "callInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__callInstruction ("callInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_C_metamodelEntityToImplement'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_metamodelEntityToImplement::
cPtr_C_metamodelEntityToImplement (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeListeAttributsSemantiques & argument_3,
                                const GGS_string& argument_4,
                                const GGS_uint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
mIsAbstract (argument_1),
aListeTousAttributsNonExternes (argument_2),
aListeAttributsCourants (argument_3),
mSuperClassName (argument_4),
mMetamodelClassID (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_metamodelEntityToImplement * GGS_C_metamodelEntityToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_metamodelEntityToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_metamodelEntityToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_metamodelEntityToImplement * _p = dynamic_cast <const cPtr_C_metamodelEntityToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = aNomClasse._operator_isEqual (_p->aNomClasse).boolValue ()
         && mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && aListeTousAttributsNonExternes._operator_isEqual (_p->aListeTousAttributsNonExternes).boolValue ()
         && aListeAttributsCourants._operator_isEqual (_p->aListeAttributsCourants).boolValue ()
         && mSuperClassName._operator_isEqual (_p->mSuperClassName).boolValue ()
         && mMetamodelClassID._operator_isEqual (_p->mMetamodelClassID).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_metamodelEntityToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_metamodelEntityToImplement:"
           << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMetamodelClassID.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_metamodelEntityToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_metamodelEntityToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_metamodelEntityToImplement (& typeid (cPtr_C_metamodelEntityToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_metamodelEntityToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement::
GGS_C_metamodelEntityToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement::
GGS_C_metamodelEntityToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_metamodelEntityToImplement GGS_C_metamodelEntityToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_metamodelEntityToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_metamodelEntityToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_metamodelEntityToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_metamodelEntityToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement GGS_C_metamodelEntityToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeListeAttributsSemantiques & argument_3,
                 const GGS_string& argument_4,
                 const GGS_uint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_C_metamodelEntityToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_metamodelEntityToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_metamodelEntityToImplement::
reader_aNomClasse (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_metamodelEntityToImplement::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_metamodelEntityToImplement::
reader_aListeTousAttributsNonExternes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->aListeTousAttributsNonExternes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_metamodelEntityToImplement::
reader_aListeAttributsCourants (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->aListeAttributsCourants ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_metamodelEntityToImplement::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_metamodelEntityToImplement::
reader_mMetamodelClassID (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->mMetamodelClassID ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_metamodelEntityToImplement::actualTypeName (void) const {
  return "C_metamodelEntityToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_metamodelEntityToImplement ("C_metamodelEntityToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@ruleDescriptorForProgramList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ruleDescriptorForProgramList::
elementOf_GGS_ruleDescriptorForProgramList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceExtension (argument_0),
mHelpMessage (argument_1),
mSourceFileName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ruleDescriptorForProgramList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ruleDescriptorForProgramList * _p = dynamic_cast <const elementOf_GGS_ruleDescriptorForProgramList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSourceExtension._operator_isEqual (_p->mSourceExtension).boolValue ()
         && mHelpMessage._operator_isEqual (_p->mHelpMessage).boolValue ()
         && mSourceFileName._operator_isEqual (_p->mSourceFileName).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ruleDescriptorForProgramList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExtension.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHelpMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceFileName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@ruleDescriptorForProgramList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
_operator_concat (const GGS_ruleDescriptorForProgramList & inOperand) const {
  GGS_ruleDescriptorForProgramList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_ruleDescriptorForProgramList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceExtension ;
          GGS_string p_1 = p->mHelpMessage ;
          GGS_lstring  p_2 = p->mSourceFileName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceExtension,
                                _p->mHelpMessage,
                                _p->mSourceFileName,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ruleDescriptorForProgramList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_string& argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_typeInstructionList & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ruleDescriptorForProgramList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
internalSubListWithRange (GGS_ruleDescriptorForProgramList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    cElement * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mSourceExtension, _p->mHelpMessage, _p->mSourceFileName, _p->mInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ruleDescriptorForProgramList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ruleDescriptorForProgramList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ruleDescriptorForProgramList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_lstring & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_lstring & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_lstring & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_lstring & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ruleDescriptorForProgramList::
reader_mSourceExtensionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceExtension ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_mHelpMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHelpMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ruleDescriptorForProgramList::
reader_mSourceFileNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceFileName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_ruleDescriptorForProgramList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMSourceExtensionAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceExtension = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMHelpMessageAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHelpMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMSourceFileNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceFileName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (_isBuilt () && inIndex._isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "performMetamodelInclusion"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_performMetamodelInclusion (C_Compiler & _inLexique,
                                const GGS_M_metamodelsComponents   var_cas_inMetamodelComponentMap,
                                const GGS_lstring   var_cas_inSuperMetamodelName,
                                GGS_stringset  & var_cas_ioSuperMetamodels,
                                GGS_entityToImplementMap  & var_cas_ioAllEntityMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_performMetamodelInclusion at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_ioSuperMetamodels.reader_hasKey (_inLexique, var_cas_inSuperMetamodelName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1523)) COMMA_SOURCE_FILE_AT_LINE (1523)))._operator_not ()).isBuiltAndTrue ()) {
    var_cas_ioSuperMetamodels._addAssign_operation (var_cas_inSuperMetamodelName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1524))) ;
    GGS_entityToImplementMap  var_cas_superMetamodelEntityMap ;
    GGS_stringset  var_cas_superMetamodelsOfSuperMetamodels ;
    GGS_lstring  automatic_var_0 ;
    const GGS_M_metamodelsComponents  _temp_62675 = var_cas_inMetamodelComponentMap ;
    if (_temp_62675._isBuilt ()) {
      _temp_62675 (HERE)->method_searchKey (_inLexique, var_cas_inSuperMetamodelName, automatic_var_0, var_cas_superMetamodelEntityMap, var_cas_superMetamodelsOfSuperMetamodels COMMA_SOURCE_FILE_AT_LINE (1527)) ;
    }
    {
      GGS_stringset::cEnumerator enumerator_62784 (var_cas_superMetamodelsOfSuperMetamodels, true) ;
      const GGS_stringset::cElement * operand_62784 = NULL ;
      while (((operand_62784 = (GGS_stringset::cElement *) enumerator_62784.nextObject ()))) {
        macroValidPointer (operand_62784) ;
        ::routine_performMetamodelInclusion (_inLexique,  var_cas_inMetamodelComponentMap,  GGS_lstring ::constructor_new (_inLexique, operand_62784->mKey, GGS_location (_inLexique) COMMA_HERE),  var_cas_ioSuperMetamodels,  var_cas_ioAllEntityMap COMMA_SOURCE_FILE_AT_LINE (1528)) ;
      }
    }
    {
      GGS_entityToImplementMap::cEnumerator enumerator_63049 (var_cas_superMetamodelEntityMap, true) ;
      const GGS_entityToImplementMap::cElement * operand_63049 = NULL ;
      while (((operand_63049 = (GGS_entityToImplementMap::cElement *) enumerator_63049.nextObject ()))) {
        macroValidPointer (operand_63049) ;
        if ((var_cas_ioAllEntityMap.reader_hasKey (_inLexique, operand_63049->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1545)) COMMA_SOURCE_FILE_AT_LINE (1545))).isBuiltAndTrue ()) {
          GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "the '@"))._operator_concat (operand_63049->mKey.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (1546))))._operator_concat (GGS_string (true, "' is already defined in a previously imported metamodel")) COMMA_SOURCE_FILE_AT_LINE (1546)) ;
        }else{
          var_cas_ioAllEntityMap.modifier_insertKey (_inLexique, operand_63049->mKey, operand_63049->mInfo.mAllMetamodelPropertyMap, operand_63049->mInfo.mIsAbstract, operand_63049->mInfo.mCurrentMetamodelPropertyMap, operand_63049->mInfo.mSuperEntityName, operand_63049->mInfo.mAncestorClassesMap, operand_63049->mInfo.mPropertyList, operand_63049->mInfo.mMetamodelName, operand_63049->mInfo.mID COMMA_SOURCE_FILE_AT_LINE (1548)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_performMetamodelInclusion\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@wrapperFileSortedList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperFileSortedList::
elementOf_GGS_wrapperFileSortedList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3):
mRegularFileName (argument_0),
mAbsoluteFilePath (argument_1),
mWrapperDirectoryIndex (argument_2),
mWrapperFileIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperFileSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_wrapperFileSortedList * _p = dynamic_cast <const elementOf_GGS_wrapperFileSortedList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRegularFileName._operator_isEqual (_p->mRegularFileName).boolValue ()
         && mAbsoluteFilePath._operator_isEqual (_p->mAbsoluteFilePath).boolValue ()
         && mWrapperDirectoryIndex._operator_isEqual (_p->mWrapperDirectoryIndex).boolValue ()
         && mWrapperFileIndex._operator_isEqual (_p->mWrapperFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

sint32 elementOf_GGS_wrapperFileSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  elementOf_GGS_wrapperFileSortedList * operand = (elementOf_GGS_wrapperFileSortedList *) inOperand ;
  sint32 result = mRegularFileName.compare (operand->mRegularFileName) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperFileSortedList::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRegularFileName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbsoluteFilePath.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperDirectoryIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperFileIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@wrapperFileSortedList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList::GGS_wrapperFileSortedList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList::
GGS_wrapperFileSortedList (const GGS_wrapperFileSortedList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileSortedList::
_operator_isEqual (const GGS_wrapperFileSortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileSortedList::
_operator_isNotEqual (const GGS_wrapperFileSortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList GGS_wrapperFileSortedList::
_operator_concat (const GGS_wrapperFileSortedList & inOperand) const {
  GGS_wrapperFileSortedList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_wrapperFileSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mRegularFileName ;
          GGS_string p_1 = p->mAbsoluteFilePath ;
          GGS_uint  p_2 = p->mWrapperDirectoryIndex ;
          GGS_uint  p_3 = p->mWrapperFileIndex ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRegularFileName,
                                _p->mAbsoluteFilePath,
                                _p->mWrapperDirectoryIndex,
                                _p->mWrapperFileIndex) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList  GGS_wrapperFileSortedList::
constructor_emptySortedList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperFileSortedList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList  GGS_wrapperFileSortedList::
constructor_sortedListWithValue (C_Compiler & /* _inLexique */,
                           const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_uint & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperFileSortedList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperFileSortedList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@wrapperFileSortedList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
method_smallest (C_Compiler & _inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRegularFileName ;
    _out_1 = _p->mAbsoluteFilePath ;
    _out_2 = _p->mWrapperDirectoryIndex ;
    _out_3 = _p->mWrapperFileIndex ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
method_greatest (C_Compiler & _inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRegularFileName ;
    _out_1 = _p->mAbsoluteFilePath ;
    _out_2 = _p->mWrapperDirectoryIndex ;
    _out_3 = _p->mWrapperFileIndex ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
modifier_popSmallest (C_Compiler & _inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRegularFileName ;
    _out_1 = _p->mAbsoluteFilePath ;
    _out_2 = _p->mWrapperDirectoryIndex ;
    _out_3 = _p->mWrapperFileIndex ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
modifier_popGreatest (C_Compiler & _inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mRegularFileName ;
    _out_1 = _p->mAbsoluteFilePath ;
    _out_2 = _p->mWrapperDirectoryIndex ;
    _out_3 = _p->mWrapperFileIndex ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@wrapperDirectorySortedList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperDirectorySortedList::
elementOf_GGS_wrapperDirectorySortedList (const GGS_string& argument_0,
                                const GGS_wrapperFileSortedList & argument_1,
                                const GGS_wrapperDirectorySortedList & argument_2,
                                const GGS_uint & argument_3):
mDirectoryName (argument_0),
mRegularFileSortedList (argument_1),
mDirectorySortedList (argument_2),
mWrapperDirectoryIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperDirectorySortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_wrapperDirectorySortedList * _p = dynamic_cast <const elementOf_GGS_wrapperDirectorySortedList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDirectoryName._operator_isEqual (_p->mDirectoryName).boolValue ()
         && mRegularFileSortedList._operator_isEqual (_p->mRegularFileSortedList).boolValue ()
         && mDirectorySortedList._operator_isEqual (_p->mDirectorySortedList).boolValue ()
         && mWrapperDirectoryIndex._operator_isEqual (_p->mWrapperDirectoryIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

sint32 elementOf_GGS_wrapperDirectorySortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  elementOf_GGS_wrapperDirectorySortedList * operand = (elementOf_GGS_wrapperDirectorySortedList *) inOperand ;
  sint32 result = mDirectoryName.compare (operand->mDirectoryName) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperDirectorySortedList::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDirectoryName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRegularFileSortedList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDirectorySortedList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperDirectoryIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@wrapperDirectorySortedList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList::GGS_wrapperDirectorySortedList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList::
GGS_wrapperDirectorySortedList (const GGS_wrapperDirectorySortedList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectorySortedList::
_operator_isEqual (const GGS_wrapperDirectorySortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectorySortedList::
_operator_isNotEqual (const GGS_wrapperDirectorySortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_wrapperFileSortedList & argument_1,
                    const GGS_wrapperDirectorySortedList & argument_2,
                    const GGS_uint & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_wrapperFileSortedList & argument_1,
                                const GGS_wrapperDirectorySortedList & argument_2,
                                const GGS_uint & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList GGS_wrapperDirectorySortedList::
_operator_concat (const GGS_wrapperDirectorySortedList & inOperand) const {
  GGS_wrapperDirectorySortedList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_wrapperDirectorySortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDirectoryName ;
          GGS_wrapperFileSortedList  p_1 = p->mRegularFileSortedList ;
          GGS_wrapperDirectorySortedList  p_2 = p->mDirectorySortedList ;
          GGS_uint  p_3 = p->mWrapperDirectoryIndex ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mDirectoryName,
                                _p->mRegularFileSortedList,
                                _p->mDirectorySortedList,
                                _p->mWrapperDirectoryIndex) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList  GGS_wrapperDirectorySortedList::
constructor_emptySortedList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperDirectorySortedList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList  GGS_wrapperDirectorySortedList::
constructor_sortedListWithValue (C_Compiler & /* _inLexique */,
                           const GGS_string& argument_0,
                           const GGS_wrapperFileSortedList & argument_1,
                           const GGS_wrapperDirectorySortedList & argument_2,
                           const GGS_uint & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperDirectorySortedList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperDirectorySortedList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@wrapperDirectorySortedList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
method_smallest (C_Compiler & _inLexique,
                 GGS_string& _out_0,
                 GGS_wrapperFileSortedList & _out_1,
                 GGS_wrapperDirectorySortedList & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mDirectoryName ;
    _out_1 = _p->mRegularFileSortedList ;
    _out_2 = _p->mDirectorySortedList ;
    _out_3 = _p->mWrapperDirectoryIndex ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
method_greatest (C_Compiler & _inLexique,
             GGS_string& _out_0,
             GGS_wrapperFileSortedList & _out_1,
             GGS_wrapperDirectorySortedList & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mDirectoryName ;
    _out_1 = _p->mRegularFileSortedList ;
    _out_2 = _p->mDirectorySortedList ;
    _out_3 = _p->mWrapperDirectoryIndex ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
modifier_popSmallest (C_Compiler & _inLexique,
                 GGS_string& _out_0,
                 GGS_wrapperFileSortedList & _out_1,
                 GGS_wrapperDirectorySortedList & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mDirectoryName ;
    _out_1 = _p->mRegularFileSortedList ;
    _out_2 = _p->mDirectorySortedList ;
    _out_3 = _p->mWrapperDirectoryIndex ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
modifier_popGreatest (C_Compiler & _inLexique,
                GGS_string& _out_0,
                GGS_wrapperFileSortedList & _out_1,
                GGS_wrapperDirectorySortedList & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mDirectoryName ;
    _out_1 = _p->mRegularFileSortedList ;
    _out_2 = _p->mDirectorySortedList ;
    _out_3 = _p->mWrapperDirectoryIndex ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@wrapperExtensionMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperExtensionMap::
elementOf_GGS_wrapperExtensionMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_wrapperExtensionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperExtensionMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperExtensionMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_wrapperExtensionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_wrapperExtensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_wrapperExtensionMap * info = (e_wrapperExtensionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_wrapperExtensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_wrapperExtensionMap * info = (e_wrapperExtensionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_wrapperExtensionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->_mRoot,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMap::
_operator_isEqual (const GGS_wrapperExtensionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMap::
_operator_isNotEqual (const GGS_wrapperExtensionMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo,mSharedMapRoot->_mRoot, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_wrapperExtensionMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' extension has been already declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_wrapperExtensionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperExtensionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperExtensionMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @wrapperExtensionMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_wrapperToImplement'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_wrapperToImplement::
cPtr_C_wrapperToImplement (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_wrapperExtensionMap & argument_2,
                                const GGS_wrapperFileSortedList & argument_3,
                                const GGS_wrapperDirectorySortedList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mWrapperName (argument_0),
mSourceDirectory (argument_1),
mExtensionMap (argument_2),
mRegularFileSortedList (argument_3),
mDirectorySortedList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_wrapperToImplement * GGS_C_wrapperToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_wrapperToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_wrapperToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_wrapperToImplement * _p = dynamic_cast <const cPtr_C_wrapperToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mWrapperName._operator_isEqual (_p->mWrapperName).boolValue ()
         && mSourceDirectory._operator_isEqual (_p->mSourceDirectory).boolValue ()
         && mExtensionMap._operator_isEqual (_p->mExtensionMap).boolValue ()
         && mRegularFileSortedList._operator_isEqual (_p->mRegularFileSortedList).boolValue ()
         && mDirectorySortedList._operator_isEqual (_p->mDirectorySortedList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_wrapperToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_wrapperToImplement:"
           << mWrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceDirectory.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExtensionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRegularFileSortedList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDirectorySortedList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_wrapperToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_wrapperToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_wrapperToImplement (& typeid (cPtr_C_wrapperToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_wrapperToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement::
GGS_C_wrapperToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement::
GGS_C_wrapperToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_wrapperToImplement GGS_C_wrapperToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_wrapperToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_wrapperToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_wrapperToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_wrapperToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement GGS_C_wrapperToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_string& argument_1,
                 const GGS_wrapperExtensionMap & argument_2,
                 const GGS_wrapperFileSortedList & argument_3,
                 const GGS_wrapperDirectorySortedList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_wrapperToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_wrapperToImplement::
reader_mWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_wrapperToImplement *) mPointer)->mWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_wrapperToImplement::
reader_mSourceDirectory (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_wrapperToImplement *) mPointer)->mSourceDirectory ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap  GGS_C_wrapperToImplement::
reader_mExtensionMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperExtensionMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_wrapperToImplement *) mPointer)->mExtensionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList  GGS_C_wrapperToImplement::
reader_mRegularFileSortedList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperFileSortedList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_wrapperToImplement *) mPointer)->mRegularFileSortedList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList  GGS_C_wrapperToImplement::
reader_mDirectorySortedList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperDirectorySortedList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_wrapperToImplement *) mPointer)->mDirectorySortedList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_wrapperToImplement::actualTypeName (void) const {
  return "C_wrapperToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_wrapperToImplement ("C_wrapperToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_structToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_structToImplement::
cPtr_C_structToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mStructName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_structToImplement * GGS_C_structToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_structToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_structToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_structToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_structToImplement * _p = dynamic_cast <const cPtr_C_structToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStructName._operator_isEqual (_p->mStructName).boolValue ()
         && mAttributeList._operator_isEqual (_p->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_structToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_structToImplement:"
           << mStructName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_structToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_structToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_structToImplement (& typeid (cPtr_C_structToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_structToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_structToImplement::
GGS_C_structToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement::
GGS_C_structToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_structToImplement GGS_C_structToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_structToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_structToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_structToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_structToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement GGS_C_structToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_structToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_structToImplement::
reader_mStructName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_structToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_structToImplement *) mPointer)->mStructName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_structToImplement::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_structToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_structToImplement *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_structToImplement::actualTypeName (void) const {
  return "C_structToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_structToImplement ("C_structToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_C_filewrapperTemplateToImplement'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_filewrapperTemplateToImplement::
cPtr_C_filewrapperTemplateToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_2,
                                const GGS_templateInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mFilewrapperName (argument_0),
mTemplateName (argument_1),
mTemplateArgumentList (argument_2),
mTemplateInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_filewrapperTemplateToImplement * GGS_C_filewrapperTemplateToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_filewrapperTemplateToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_filewrapperTemplateToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_filewrapperTemplateToImplement * _p = dynamic_cast <const cPtr_C_filewrapperTemplateToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mFilewrapperName._operator_isEqual (_p->mFilewrapperName).boolValue ()
         && mTemplateName._operator_isEqual (_p->mTemplateName).boolValue ()
         && mTemplateArgumentList._operator_isEqual (_p->mTemplateArgumentList).boolValue ()
         && mTemplateInstructionList._operator_isEqual (_p->mTemplateInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_filewrapperTemplateToImplement::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_filewrapperTemplateToImplement:"
           << mFilewrapperName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_filewrapperTemplateToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_filewrapperTemplateToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_filewrapperTemplateToImplement (& typeid (cPtr_C_filewrapperTemplateToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_filewrapperTemplateToImplement'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement::
GGS_C_filewrapperTemplateToImplement (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement::
GGS_C_filewrapperTemplateToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_filewrapperTemplateToImplement) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C_filewrapperTemplateToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_filewrapperTemplateToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_2,
                 const GGS_templateInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_filewrapperTemplateToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_filewrapperTemplateToImplement::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_filewrapperTemplateToImplement *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_filewrapperTemplateToImplement::
reader_mTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_filewrapperTemplateToImplement *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_C_filewrapperTemplateToImplement::
reader_mTemplateArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_filewrapperTemplateToImplement *) mPointer)->mTemplateArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionList  GGS_C_filewrapperTemplateToImplement::
reader_mTemplateInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_filewrapperTemplateToImplement *) mPointer)->mTemplateInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_filewrapperTemplateToImplement::actualTypeName (void) const {
  return "C_filewrapperTemplateToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_filewrapperTemplateToImplement ("C_filewrapperTemplateToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

