//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 7th, 2009, at 14h43'51"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semantics_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeCplusPlusNameList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeCplusPlusNameList * ptr = dynamic_cast <const elementOf_GGS_typeCplusPlusNameList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppName.operator_isEqual (ptr->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
operator_concat (const GGS_typeCplusPlusNameList & inOperand) const {
  GGS_typeCplusPlusNameList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
dotAssign_operation (const GGS_typeCplusPlusNameList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeCplusPlusNameList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppName ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_emptyList (void) {
  GGS_typeCplusPlusNameList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_listWithValue (const GGS_typeCplusPlusName & argument_0) {
  GGS_typeCplusPlusNameList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalSubListWithRange (GGS_typeCplusPlusNameList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeCplusPlusNameList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_first (C_Compiler & inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_last (C_Compiler & inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeCplusPlusNameList::
reader_mCppNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_setMCppNameAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_typeCplusPlusNameList::cEnumerator::_mCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_typeClassMessagesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeClassMessagesMap::e_typeClassMessagesMap (void) :
mMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessage.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeClassMessagesMap * ptr = dynamic_cast <const elementOf_GGS_typeClassMessagesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMessage.operator_isEqual (ptr->mInfo.mMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeClassMessagesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
operator_isEqual (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
operator_isNotEqual (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeClassMessagesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeClassMessagesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeClassMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeClassMessagesMap::cEnumerator::_mMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessage ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mGalgasVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticsTypesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeSemanticsTypesList * ptr = dynamic_cast <const elementOf_GGS_typeSemanticsTypesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mGalgasVariableName.operator_isEqual (ptr->mGalgasVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasVariableName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
operator_concat (const GGS_typeSemanticsTypesList & inOperand) const {
  GGS_typeSemanticsTypesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
dotAssign_operation (const GGS_typeSemanticsTypesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeSemanticsTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mGalgasVariableName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mType,
                                ptr->mGalgasVariableName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_emptyList (void) {
  GGS_typeSemanticsTypesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typeSemanticsTypesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalSubListWithRange (GGS_typeSemanticsTypesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mGalgasVariableName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeSemanticsTypesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeSemanticsTypesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeSemanticsTypesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_first (C_Compiler & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_last (C_Compiler & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popLast (C_Compiler & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeSemanticsTypesList::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSemanticsTypesList::
reader_mGalgasVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGalgasVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_setMGalgasVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGalgasVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeSemanticsTypesList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeSemanticsTypesList::cEnumerator::_mGalgasVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGalgasVariableName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

e_typeVariablesMap::e_typeVariablesMap (void) :
mArgumentType (),
mCplusPlusName () {
}

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map '@typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadOnlyAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForDestructiveReadAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForWriteAccess (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccessGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUnusedInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUsedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadow (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgumentNoShadow (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadowGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUsedConstInArgumentNoShadow (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUnusedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariable (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariableGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertWithInstructionLocalVariable (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertWithInstructionLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertWithInstructionLocalVariableGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertWithInstructionLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUsedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgument (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgumentGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUnusedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
aNomVariableCible (argument_0),
aNomAttributSource (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_assignedVariables::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_assignedVariables * ptr = dynamic_cast <const elementOf_GGS_L_assignedVariables *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariableCible.operator_isEqual (ptr->aNomVariableCible).boolValue ()
         && aNomAttributSource.operator_isEqual (ptr->aNomAttributSource).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomVariableCible.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomAttributSource.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
operator_concat (const GGS_L_assignedVariables & inOperand) const {
  GGS_L_assignedVariables result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
dotAssign_operation (const GGS_L_assignedVariables inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_assignedVariables * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->aNomVariableCible ;
          GGS_lstring  p_1 = p->aNomAttributSource ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->aNomVariableCible,
                                ptr->aNomAttributSource
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_emptyList (void) {
  GGS_L_assignedVariables result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_listWithValue (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_L_assignedVariables result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalSubListWithRange (GGS_L_assignedVariables & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->aNomVariableCible, ptr->aNomAttributSource) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_assignedVariables result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_assignedVariables result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@L_assignedVariables", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_first (C_Compiler & inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_last (C_Compiler & inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_L_assignedVariables::
reader_aNomVariableCibleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aNomVariableCible ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_assignedVariables::
reader_aNomAttributSourceAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aNomAttributSource ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_setANomVariableCibleAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aNomVariableCible = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_setANomAttributSourceAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aNomAttributSource = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_L_assignedVariables::cEnumerator::_aNomVariableCible (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->aNomVariableCible ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_assignedVariables::cEnumerator::_aNomAttributSource (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->aNomAttributSource ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_typeCible'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCible *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCible *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCible::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCible:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCible::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCible::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCible (& typeid (cPtr_typeCible), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCible::galgasRTTI (void) const {
  return & gClassInfoFor__typeCible ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCible GGS_typeCible::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCible result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCible *> (inPointer) != NULL)
      : (typeid (cPtr_typeCible) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCible (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCible),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCible::actualTypeName (void) const {
  return "typeCible" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_typeCible::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeCible ("typeCible") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
aCible (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCibles::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCibles * ptr = dynamic_cast <const elementOf_GGS_typeListeCibles *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aCible.operator_isEqual (ptr->aCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aCible.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalAppendValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalPrependValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
addAssign_operation (const GGS_typeCible & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
operator_concat (const GGS_typeListeCibles & inOperand) const {
  GGS_typeListeCibles result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
dotAssign_operation (const GGS_typeListeCibles inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeListeCibles * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCible  p_0 = p->aCible ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCible & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->aCible
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_emptyList (void) {
  GGS_typeListeCibles result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_listWithValue (const GGS_typeCible & argument_0) {
  GGS_typeListeCibles result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalSubListWithRange (GGS_typeListeCibles & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->aCible) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCibles result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCibles result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeListeCibles", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_first (C_Compiler & inLexique,
              GGS_typeCible & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_last (C_Compiler & inLexique,
             GGS_typeCible & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeCible & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeCible & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCible  GGS_typeListeCibles::
reader_aCibleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCible  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aCible ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_setACibleAtIndex (C_Compiler & inLexique,
                              const GGS_typeCible  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aCible = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCible  & GGS_typeListeCibles::cEnumerator::_aCible (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->aCible ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_nameWithType::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_nameWithType * ptr = dynamic_cast <const elementOf_GGS_L_nameWithType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
operator_concat (const GGS_L_nameWithType & inOperand) const {
  GGS_L_nameWithType result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
dotAssign_operation (const GGS_L_nameWithType inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_nameWithType * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mName ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mType,
                                ptr->mName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_emptyList (void) {
  GGS_L_nameWithType result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_L_nameWithType result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalSubListWithRange (GGS_L_nameWithType & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_nameWithType result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_nameWithType result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@L_nameWithType", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_nameWithType::
reader_mTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_nameWithType::
reader_mNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_setMTypeAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_setMNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_nameWithType::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_nameWithType::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

e_typeTableMethodesAimplementer::e_typeTableMethodesAimplementer (void) :
aListeTypesParametres (),
aListeTypeEtNomsArguments (),
mInstructionList () {
}

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableMethodesAimplementer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstract (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstractGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const PMSInt32 attributeIndex = insertAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstract (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstractGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const PMSInt32 attributeIndex = insertNotAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::
reader_description (C_Compiler & /* inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeExpressionList * ptr = dynamic_cast <const elementOf_GGS_typeExpressionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalAppendValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalPrependValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
addAssign_operation (const GGS_typeExpression & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
operator_concat (const GGS_typeExpressionList & inOperand) const {
  GGS_typeExpressionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
dotAssign_operation (const GGS_typeExpressionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mExpression ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeExpression & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_emptyList (void) {
  GGS_typeExpressionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_listWithValue (const GGS_typeExpression & argument_0) {
  GGS_typeExpressionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalSubListWithRange (GGS_typeExpressionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeExpressionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeExpressionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_first (C_Compiler & inLexique,
              GGS_typeExpression & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_last (C_Compiler & inLexique,
             GGS_typeExpression & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeExpression & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeExpression & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeExpressionList::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_typeExpressionList::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_varToDropList::
elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mVarToDrop (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_varToDropList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_varToDropList * ptr = dynamic_cast <const elementOf_GGS_varToDropList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarToDrop.operator_isEqual (ptr->mVarToDrop).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_varToDropList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarToDrop.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
operator_concat (const GGS_varToDropList & inOperand) const {
  GGS_varToDropList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
dotAssign_operation (const GGS_varToDropList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_varToDropList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mVarToDrop ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mVarToDrop
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_emptyList (void) {
  GGS_varToDropList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_listWithValue (const GGS_typeCplusPlusName & argument_0) {
  GGS_varToDropList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
internalSubListWithRange (GGS_varToDropList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mVarToDrop) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_varToDropList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_varToDropList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varToDropList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@varToDropList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_first (C_Compiler & inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_last (C_Compiler & inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_varToDropList::
reader_mVarToDropAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVarToDrop ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_setMVarToDropAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVarToDrop = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_varToDropList::cEnumerator::_mVarToDrop (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mVarToDrop ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeErrorInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::
cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2),
mVarToDropList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeErrorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeErrorInstruction * ptr = dynamic_cast <const cPtr_typeErrorInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue ()
         && mErrorMessageExpression.operator_isEqual (ptr->mErrorMessageExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mVarToDropList.operator_isEqual (ptr->mVarToDropList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeErrorInstruction:"
           << mErrorLocationExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mErrorMessageExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVarToDropList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeErrorInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeErrorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeErrorInstruction (& typeid (cPtr_typeErrorInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeErrorInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeErrorInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeErrorInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeErrorInstruction (mErrorLocationExpression, mErrorMessageExpression, mLocation, mVarToDropList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeErrorInstruction GGS_typeErrorInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeErrorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeErrorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeErrorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeErrorInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction GGS_typeErrorInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2,
                 const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeErrorInstruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_typeErrorInstruction::
reader_mVarToDropList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_varToDropList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mVarToDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeErrorInstruction::actualTypeName (void) const {
  return "typeErrorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeErrorInstruction ("typeErrorInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeSendInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSendInstruction::
cPtr_typeSendInstruction (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSendInstruction * GGS_typeSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSendInstruction * ptr = dynamic_cast <const cPtr_typeSendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSendInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSendInstruction:"
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSendInstruction (& typeid (cPtr_typeSendInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSendInstruction (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSendInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSendInstruction::
GGS_typeSendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction::
GGS_typeSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSendInstruction GGS_typeSendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction GGS_typeSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSendInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSendInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSendInstruction::actualTypeName (void) const {
  return "typeSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSendInstruction ("typeSendInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeWithInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWithInstruction::
cPtr_typeWithInstruction (const GGS_string& argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_string& argument_3,
                                const GGS_typeExpression & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_typeInstructionList & argument_6,
                                const GGS_location & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMapTypeName (argument_0),
mAccessedVariableCppName (argument_1),
mStructAttributeList (argument_2),
mErrorMessageName (argument_3),
mKeyExpression (argument_4),
mDoBranchInstructionList (argument_5),
mElseBranchInstructionList (argument_6),
mInstructionLocation (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWithInstruction * GGS_typeWithInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeWithInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeWithInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeWithInstruction * ptr = dynamic_cast <const cPtr_typeWithInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAccessedVariableCppName.operator_isEqual (ptr->mAccessedVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mErrorMessageName.operator_isEqual (ptr->mErrorMessageName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructionList.operator_isEqual (ptr->mDoBranchInstructionList).boolValue ()
         && mElseBranchInstructionList.operator_isEqual (ptr->mElseBranchInstructionList).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeWithInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeWithInstruction:"
           << mMapTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAccessedVariableCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mErrorMessageName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mKeyExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDoBranchInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseBranchInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeWithInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeWithInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeWithInstruction (& typeid (cPtr_typeWithInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeWithInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeWithInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeWithInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeWithInstruction (mMapTypeName, mAccessedVariableCppName, mStructAttributeList, mErrorMessageName, mKeyExpression, mDoBranchInstructionList, mElseBranchInstructionList, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeWithInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeWithInstruction::
GGS_typeWithInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWithInstruction::
GGS_typeWithInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeWithInstruction GGS_typeWithInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeWithInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeWithInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeWithInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeWithInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeWithInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeWithInstruction GGS_typeWithInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_string& argument_3,
                 const GGS_typeExpression & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_typeInstructionList & argument_6,
                 const GGS_location & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_typeWithInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeWithInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeWithInstruction::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeWithInstruction::
reader_mAccessedVariableCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mAccessedVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeWithInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeWithInstruction::
reader_mErrorMessageName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWithInstruction::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeWithInstruction::
reader_mDoBranchInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mDoBranchInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeWithInstruction::
reader_mElseBranchInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mElseBranchInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeWithInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeWithInstruction::actualTypeName (void) const {
  return "typeWithInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeWithInstruction ("typeWithInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeWarningInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::
cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeWarningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeWarningInstruction * ptr = dynamic_cast <const cPtr_typeWarningInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWarningLocationExpression.operator_isEqual (ptr->mWarningLocationExpression).boolValue ()
         && mWarningMessageExpression.operator_isEqual (ptr->mWarningMessageExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeWarningInstruction:"
           << mWarningLocationExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWarningMessageExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeWarningInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeWarningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeWarningInstruction (& typeid (cPtr_typeWarningInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeWarningInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeWarningInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeWarningInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeWarningInstruction (mWarningLocationExpression, mWarningMessageExpression, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeWarningInstruction GGS_typeWarningInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeWarningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeWarningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeWarningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeWarningInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction GGS_typeWarningInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeWarningInstruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeWarningInstruction::actualTypeName (void) const {
  return "typeWarningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeWarningInstruction ("typeWarningInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeMessageInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::
cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMessageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMessageInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMessageInstruction * ptr = dynamic_cast <const cPtr_typeMessageInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessageExpression.operator_isEqual (ptr->mMessageExpression).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMessageInstruction:"
           << mMessageExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMessageInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMessageInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMessageInstruction (& typeid (cPtr_typeMessageInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMessageInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMessageInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMessageInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMessageInstruction (mMessageExpression, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMessageInstruction GGS_typeMessageInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMessageInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMessageInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMessageInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMessageInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction GGS_typeMessageInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMessageInstruction::
reader_mMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMessageInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMessageInstruction::actualTypeName (void) const {
  return "typeMessageInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMessageInstruction ("typeMessageInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeMethodCallInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodCallInstruction::
cPtr_typeMethodCallInstruction (const GGS_AC_galgasType & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3,
                                const GGS_typeExpressionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mExpressionType (argument_0),
mExpression (argument_1),
mMethodName (argument_2),
mCategoryMethodClassBaseName (argument_3),
mExpressionsList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodCallInstruction * GGS_typeMethodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMethodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodCallInstruction * ptr = dynamic_cast <const cPtr_typeMethodCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionType.operator_isEqual (ptr->mExpressionType).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mCategoryMethodClassBaseName.operator_isEqual (ptr->mCategoryMethodClassBaseName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodCallInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMethodCallInstruction:"
           << mExpressionType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCategoryMethodClassBaseName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodCallInstruction (& typeid (cPtr_typeMethodCallInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMethodCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodCallInstruction (mExpressionType, mExpression, mMethodName, mCategoryMethodClassBaseName, mExpressionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMethodCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_string& argument_3,
                 const GGS_typeExpressionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeMethodCallInstruction::
reader_mExpressionType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMethodCallInstruction::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodCallInstruction::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMethodCallInstruction::
reader_mCategoryMethodClassBaseName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mCategoryMethodClassBaseName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMethodCallInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodCallInstruction::actualTypeName (void) const {
  return "typeMethodCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMethodCallInstruction ("typeMethodCallInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeCallOfTypeMethodInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCallOfTypeMethodInstruction::
cPtr_typeCallOfTypeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTypeName (argument_0),
mTypeMethodName (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCallOfTypeMethodInstruction * GGS_typeCallOfTypeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCallOfTypeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCallOfTypeMethodInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCallOfTypeMethodInstruction * ptr = dynamic_cast <const cPtr_typeCallOfTypeMethodInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mTypeMethodName.operator_isEqual (ptr->mTypeMethodName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCallOfTypeMethodInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCallOfTypeMethodInstruction:"
           << mTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTypeMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCallOfTypeMethodInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCallOfTypeMethodInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCallOfTypeMethodInstruction (& typeid (cPtr_typeCallOfTypeMethodInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCallOfTypeMethodInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeCallOfTypeMethodInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCallOfTypeMethodInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCallOfTypeMethodInstruction (mTypeName, mTypeMethodName, mExpressionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeCallOfTypeMethodInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeCallOfTypeMethodInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCallOfTypeMethodInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCallOfTypeMethodInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeCallOfTypeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeCallOfTypeMethodInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCallOfTypeMethodInstruction::actualTypeName (void) const {
  return "typeCallOfTypeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCallOfTypeMethodInstruction ("typeCallOfTypeMethodInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeModifierCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::
cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
mStructAttributeList (argument_1),
aNomMethodeSimple (argument_2),
mExpressionsList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModifierCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModifierCallInstruction * ptr = dynamic_cast <const cPtr_typeModifierCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomCppVariable.operator_isEqual (ptr->aNomCppVariable).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && aNomMethodeSimple.operator_isEqual (ptr->aNomMethodeSimple).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModifierCallInstruction:"
           << aNomCppVariable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeSimple.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeModifierCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeModifierCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeModifierCallInstruction (& typeid (cPtr_typeModifierCallInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeModifierCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeModifierCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeModifierCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeModifierCallInstruction (aNomCppVariable, mStructAttributeList, aNomMethodeSimple, mExpressionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeModifierCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeModifierCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeModifierCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeModifierCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeModifierCallInstruction::
reader_aNomCppVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeModifierCallInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeModifierCallInstruction::
reader_aNomMethodeSimple (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomMethodeSimple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeModifierCallInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeModifierCallInstruction::actualTypeName (void) const {
  return "typeModifierCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeModifierCallInstruction ("typeModifierCallInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_typeInstructionAppelMethodeListe'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::
cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelMethodeListe *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelMethodeListe::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelMethodeListe * ptr = dynamic_cast <const cPtr_typeInstructionAppelMethodeListe *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomCppAttribut.operator_isEqual (ptr->aNomCppAttribut).boolValue ()
         && aMethodeDeListe.operator_isEqual (ptr->aMethodeDeListe).boolValue ()
         && aListeNomsCppArguments.operator_isEqual (ptr->aListeNomsCppArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelMethodeListe:"
           << aNomCppAttribut.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aMethodeDeListe.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeNomsCppArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelMethodeListe::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelMethodeListe::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionAppelMethodeListe (& typeid (cPtr_typeInstructionAppelMethodeListe), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeInstructionAppelMethodeListe::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionAppelMethodeListe ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionAppelMethodeListe::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionAppelMethodeListe (aNomCppAttribut, aMethodeDeListe, aListeNomsCppArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionAppelMethodeListe) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionAppelMethodeListe (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionAppelMethodeListe),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionAppelMethodeListe::
reader_aNomCppAttribut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aNomCppAttribut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelMethodeListe::
reader_aMethodeDeListe (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aMethodeDeListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeInstructionAppelMethodeListe::
reader_aListeNomsCppArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aListeNomsCppArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionAppelMethodeListe::actualTypeName (void) const {
  return "typeInstructionAppelMethodeListe" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInstructionAppelMethodeListe ("typeInstructionAppelMethodeListe", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeInstructionDeclarationVarLocale'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::
cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionDeclarationVarLocale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionDeclarationVarLocale::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionDeclarationVarLocale * ptr = dynamic_cast <const cPtr_typeInstructionDeclarationVarLocale *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomCppVariable.operator_isEqual (ptr->aNomCppVariable).boolValue ()
         && aTypeVariable.operator_isEqual (ptr->aTypeVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionDeclarationVarLocale:"
           << aNomCppVariable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aTypeVariable.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionDeclarationVarLocale::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionDeclarationVarLocale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionDeclarationVarLocale (& typeid (cPtr_typeInstructionDeclarationVarLocale), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeInstructionDeclarationVarLocale::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionDeclarationVarLocale ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionDeclarationVarLocale::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionDeclarationVarLocale (aNomCppVariable, aTypeVariable COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionDeclarationVarLocale) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionDeclarationVarLocale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionDeclarationVarLocale),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionDeclarationVarLocale::
reader_aNomCppVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeInstructionDeclarationVarLocale::
reader_aTypeVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aTypeVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionDeclarationVarLocale::actualTypeName (void) const {
  return "typeInstructionDeclarationVarLocale" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInstructionDeclarationVarLocale ("typeInstructionDeclarationVarLocale", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeMapBlockPrologueInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::
cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockPrologueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockPrologueInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockPrologueInstruction * ptr = dynamic_cast <const cPtr_typeMapBlockPrologueInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariableTable.operator_isEqual (ptr->aNomVariableTable).boolValue ()
         && aNomMethodeBloc.operator_isEqual (ptr->aNomMethodeBloc).boolValue ()
         && mPrologueExpressionList.operator_isEqual (ptr->mPrologueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockPrologueInstruction:"
           << aNomVariableTable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeBloc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mPrologueExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockPrologueInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockPrologueInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMapBlockPrologueInstruction (& typeid (cPtr_typeMapBlockPrologueInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMapBlockPrologueInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMapBlockPrologueInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMapBlockPrologueInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMapBlockPrologueInstruction (aNomVariableTable, aNomMethodeBloc, mPrologueExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMapBlockPrologueInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMapBlockPrologueInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMapBlockPrologueInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockPrologueInstruction::
reader_aNomVariableTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockPrologueInstruction::
reader_aNomMethodeBloc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockPrologueInstruction::
reader_mPrologueExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->mPrologueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMapBlockPrologueInstruction::actualTypeName (void) const {
  return "typeMapBlockPrologueInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMapBlockPrologueInstruction ("typeMapBlockPrologueInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeMapBlockEpilogueInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::
cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockEpilogueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockEpilogueInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockEpilogueInstruction * ptr = dynamic_cast <const cPtr_typeMapBlockEpilogueInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariableTable.operator_isEqual (ptr->aNomVariableTable).boolValue ()
         && aNomMethodeBloc.operator_isEqual (ptr->aNomMethodeBloc).boolValue ()
         && mEpilogueExpressionList.operator_isEqual (ptr->mEpilogueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockEpilogueInstruction:"
           << aNomVariableTable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeBloc.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEpilogueExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockEpilogueInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockEpilogueInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMapBlockEpilogueInstruction (& typeid (cPtr_typeMapBlockEpilogueInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMapBlockEpilogueInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMapBlockEpilogueInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMapBlockEpilogueInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMapBlockEpilogueInstruction (aNomVariableTable, aNomMethodeBloc, mEpilogueExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMapBlockEpilogueInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMapBlockEpilogueInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMapBlockEpilogueInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockEpilogueInstruction::
reader_aNomVariableTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockEpilogueInstruction::
reader_aNomMethodeBloc (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockEpilogueInstruction::
reader_mEpilogueExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->mEpilogueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMapBlockEpilogueInstruction::actualTypeName (void) const {
  return "typeMapBlockEpilogueInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMapBlockEpilogueInstruction ("typeMapBlockEpilogueInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeReaderCallInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::
cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2),
mConversionMethod (argument_3),
mCategoryReaderClassBaseName (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeReaderCallInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeReaderCallInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeReaderCallInExpression * ptr = dynamic_cast <const cPtr_typeReaderCallInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionValue.operator_isEqual (ptr->mExpressionValue).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue ()
         && mConversionMethod.operator_isEqual (ptr->mConversionMethod).boolValue ()
         && mCategoryReaderClassBaseName.operator_isEqual (ptr->mCategoryReaderClassBaseName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeReaderCallInExpression:"
           << mExpressionValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReaderName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConversionMethod.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCategoryReaderClassBaseName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeReaderCallInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeReaderCallInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeReaderCallInExpression (& typeid (cPtr_typeReaderCallInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeReaderCallInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeReaderCallInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeReaderCallInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeReaderCallInExpression (mExpressionValue, mReaderName, mExpressionList, mConversionMethod, mCategoryReaderClassBaseName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeReaderCallInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeReaderCallInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeReaderCallInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeReaderCallInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_string& argument_3,
                 const GGS_string& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeReaderCallInExpression::
reader_mExpressionValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeReaderCallInExpression::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeReaderCallInExpression::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_mConversionMethod (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mConversionMethod ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_mCategoryReaderClassBaseName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mCategoryReaderClassBaseName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeReaderCallInExpression::actualTypeName (void) const {
  return "typeReaderCallInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeReaderCallInExpression ("typeReaderCallInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeFileWrapperWithStaticPath'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperWithStaticPath::
cPtr_typeFileWrapperWithStaticPath (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0),
mFileIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperWithStaticPath * GGS_typeFileWrapperWithStaticPath::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFileWrapperWithStaticPath *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperWithStaticPath::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperWithStaticPath * ptr = dynamic_cast <const cPtr_typeFileWrapperWithStaticPath *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue ()
         && mFileIndex.operator_isEqual (ptr->mFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperWithStaticPath::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFileWrapperWithStaticPath:"
           << mFileWrapperName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFileIndex.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperWithStaticPath::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperWithStaticPath::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperWithStaticPath (& typeid (cPtr_typeFileWrapperWithStaticPath), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFileWrapperWithStaticPath::galgasRTTI (void) const {
  return & gClassInfoFor__typeFileWrapperWithStaticPath ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFileWrapperWithStaticPath::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFileWrapperWithStaticPath (mFileWrapperName, mFileIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFileWrapperWithStaticPath'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath::
GGS_typeFileWrapperWithStaticPath (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath::
GGS_typeFileWrapperWithStaticPath (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperWithStaticPath) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFileWrapperWithStaticPath (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperWithStaticPath),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperWithStaticPath (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperWithStaticPath::
reader_mFileWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperWithStaticPath *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeFileWrapperWithStaticPath::
reader_mFileIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperWithStaticPath *) mPointer)->mFileIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperWithStaticPath::actualTypeName (void) const {
  return "typeFileWrapperWithStaticPath" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFileWrapperWithStaticPath ("typeFileWrapperWithStaticPath", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeFileWrapperTemplateCall'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperTemplateCall::
cPtr_typeFileWrapperTemplateCall (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0),
mTemplateName (argument_1),
mOutExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperTemplateCall * GGS_typeFileWrapperTemplateCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFileWrapperTemplateCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperTemplateCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperTemplateCall * ptr = dynamic_cast <const cPtr_typeFileWrapperTemplateCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mOutExpressionList.operator_isEqual (ptr->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperTemplateCall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFileWrapperTemplateCall:"
           << mFileWrapperName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOutExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperTemplateCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperTemplateCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperTemplateCall (& typeid (cPtr_typeFileWrapperTemplateCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFileWrapperTemplateCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeFileWrapperTemplateCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFileWrapperTemplateCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFileWrapperTemplateCall (mFileWrapperName, mTemplateName, mOutExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeFileWrapperTemplateCall'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall::
GGS_typeFileWrapperTemplateCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall::
GGS_typeFileWrapperTemplateCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperTemplateCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFileWrapperTemplateCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperTemplateCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperTemplateCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperTemplateCall::
reader_mFileWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperTemplateCall::
reader_mTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeFileWrapperTemplateCall::
reader_mOutExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperTemplateCall::actualTypeName (void) const {
  return "typeFileWrapperTemplateCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFileWrapperTemplateCall ("typeFileWrapperTemplateCall", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeCategoryTemplateCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCategoryTemplateCall::
cPtr_typeCategoryTemplateCall (const GGS_typeExpression & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mCategoryTemplateClassBaseName (argument_1),
mTemplateName (argument_2),
mOutExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCategoryTemplateCall * GGS_typeCategoryTemplateCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCategoryTemplateCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCategoryTemplateCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCategoryTemplateCall * ptr = dynamic_cast <const cPtr_typeCategoryTemplateCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionValue.operator_isEqual (ptr->mExpressionValue).boolValue ()
         && mCategoryTemplateClassBaseName.operator_isEqual (ptr->mCategoryTemplateClassBaseName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mOutExpressionList.operator_isEqual (ptr->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCategoryTemplateCall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCategoryTemplateCall:"
           << mExpressionValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCategoryTemplateClassBaseName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOutExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCategoryTemplateCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCategoryTemplateCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCategoryTemplateCall (& typeid (cPtr_typeCategoryTemplateCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCategoryTemplateCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeCategoryTemplateCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCategoryTemplateCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCategoryTemplateCall (mExpressionValue, mCategoryTemplateClassBaseName, mTemplateName, mOutExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeCategoryTemplateCall'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall::
GGS_typeCategoryTemplateCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall::
GGS_typeCategoryTemplateCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCategoryTemplateCall GGS_typeCategoryTemplateCall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCategoryTemplateCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCategoryTemplateCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeCategoryTemplateCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCategoryTemplateCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCategoryTemplateCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall GGS_typeCategoryTemplateCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeCategoryTemplateCall result ;
  macroMyNew (result.mPointer, cPtr_typeCategoryTemplateCall (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCategoryTemplateCall::
reader_mExpressionValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCategoryTemplateCall::
reader_mCategoryTemplateClassBaseName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mCategoryTemplateClassBaseName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCategoryTemplateCall::
reader_mTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeCategoryTemplateCall::
reader_mOutExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCategoryTemplateCall::actualTypeName (void) const {
  return "typeCategoryTemplateCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCategoryTemplateCall ("typeCategoryTemplateCall", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeFileWrapperObjectInstanciation'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperObjectInstanciation::
cPtr_typeFileWrapperObjectInstanciation (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperObjectInstanciation * GGS_typeFileWrapperObjectInstanciation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFileWrapperObjectInstanciation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperObjectInstanciation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperObjectInstanciation * ptr = dynamic_cast <const cPtr_typeFileWrapperObjectInstanciation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperObjectInstanciation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFileWrapperObjectInstanciation:"
           << mFileWrapperName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperObjectInstanciation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperObjectInstanciation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperObjectInstanciation (& typeid (cPtr_typeFileWrapperObjectInstanciation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFileWrapperObjectInstanciation::galgasRTTI (void) const {
  return & gClassInfoFor__typeFileWrapperObjectInstanciation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFileWrapperObjectInstanciation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFileWrapperObjectInstanciation (mFileWrapperName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeFileWrapperObjectInstanciation'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation::
GGS_typeFileWrapperObjectInstanciation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation::
GGS_typeFileWrapperObjectInstanciation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperObjectInstanciation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFileWrapperObjectInstanciation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperObjectInstanciation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperObjectInstanciation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperObjectInstanciation::
reader_mFileWrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperObjectInstanciation *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperObjectInstanciation::actualTypeName (void) const {
  return "typeFileWrapperObjectInstanciation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFileWrapperObjectInstanciation ("typeFileWrapperObjectInstanciation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeDescriptionInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDescriptionInExpression::
cPtr_typeDescriptionInExpression (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mOperatorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDescriptionInExpression * GGS_typeDescriptionInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDescriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDescriptionInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDescriptionInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDescriptionInExpression * ptr = dynamic_cast <const cPtr_typeDescriptionInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionValue.operator_isEqual (ptr->mExpressionValue).boolValue ()
         && mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDescriptionInExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDescriptionInExpression:"
           << mExpressionValue.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDescriptionInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDescriptionInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDescriptionInExpression (& typeid (cPtr_typeDescriptionInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDescriptionInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeDescriptionInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDescriptionInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDescriptionInExpression (mExpressionValue, mOperatorLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeDescriptionInExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDescriptionInExpression::
GGS_typeDescriptionInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDescriptionInExpression::
GGS_typeDescriptionInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDescriptionInExpression GGS_typeDescriptionInExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDescriptionInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDescriptionInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeDescriptionInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDescriptionInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDescriptionInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDescriptionInExpression GGS_typeDescriptionInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeDescriptionInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeDescriptionInExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDescriptionInExpression::
reader_mExpressionValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDescriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDescriptionInExpression *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDescriptionInExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDescriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDescriptionInExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDescriptionInExpression::actualTypeName (void) const {
  return "typeDescriptionInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDescriptionInExpression ("typeDescriptionInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeCastInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCastInExpression::
cPtr_typeCastInExpression (const GGS_typeExpression & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCastedExpression (argument_0),
mCheckForKindOfClass (argument_1),
mCastTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCastInExpression * GGS_typeCastInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCastInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCastInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCastInExpression * ptr = dynamic_cast <const cPtr_typeCastInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastedExpression.operator_isEqual (ptr->mCastedExpression).boolValue ()
         && mCheckForKindOfClass.operator_isEqual (ptr->mCheckForKindOfClass).boolValue ()
         && mCastTypeName.operator_isEqual (ptr->mCastTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCastInExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCastInExpression:"
           << mCastedExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCheckForKindOfClass.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCastTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocationExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCastInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCastInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCastInExpression (& typeid (cPtr_typeCastInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeCastInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeCastInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCastInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCastInExpression (mCastedExpression, mCheckForKindOfClass, mCastTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCastInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCastInExpression::
GGS_typeCastInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression::
GGS_typeCastInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCastInExpression GGS_typeCastInExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCastInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeCastInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCastInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCastInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression GGS_typeCastInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeCastInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCastInExpression::
reader_mCastedExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCastedExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCastInExpression::
reader_mCheckForKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCheckForKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCastInExpression::
reader_mCastTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCastTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCastInExpression::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCastInExpression::actualTypeName (void) const {
  return "typeCastInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeCastInExpression ("typeCastInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAndOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::
cPtr_typeAndOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAndOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAndOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAndOperation * ptr = dynamic_cast <const cPtr_typeAndOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAndOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAndOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAndOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAndOperation (& typeid (cPtr_typeAndOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeAndOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeAndOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAndOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAndOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAndOperation GGS_typeAndOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAndOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeAndOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAndOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAndOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation GGS_typeAndOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAndOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAndOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAndOperation::actualTypeName (void) const {
  return "typeAndOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAndOperation ("typeAndOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeOrOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::
cPtr_typeOrOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOrOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOrOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOrOperation * ptr = dynamic_cast <const cPtr_typeOrOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOrOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOrOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOrOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOrOperation (& typeid (cPtr_typeOrOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeOrOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeOrOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeOrOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeOrOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeOrOperation GGS_typeOrOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOrOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeOrOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeOrOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOrOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation GGS_typeOrOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  macroMyNew (result.mPointer, cPtr_typeOrOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeOrOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOrOperation::actualTypeName (void) const {
  return "typeOrOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeOrOperation ("typeOrOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeXorOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeXorOperation::
cPtr_typeXorOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeXorOperation * GGS_typeXorOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeXorOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeXorOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeXorOperation * ptr = dynamic_cast <const cPtr_typeXorOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeXorOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeXorOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeXorOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeXorOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeXorOperation (& typeid (cPtr_typeXorOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeXorOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeXorOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeXorOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeXorOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeXorOperation GGS_typeXorOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeXorOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeXorOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeXorOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeXorOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation GGS_typeXorOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  macroMyNew (result.mPointer, cPtr_typeXorOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeXorOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeXorOperation::actualTypeName (void) const {
  return "typeXorOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeXorOperation ("typeXorOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeConcatOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::
cPtr_typeConcatOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConcatOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConcatOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConcatOperation * ptr = dynamic_cast <const cPtr_typeConcatOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConcatOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConcatOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConcatOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConcatOperation (& typeid (cPtr_typeConcatOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeConcatOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeConcatOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConcatOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConcatOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConcatOperation GGS_typeConcatOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConcatOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeConcatOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConcatOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConcatOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation GGS_typeConcatOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  macroMyNew (result.mPointer, cPtr_typeConcatOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeConcatOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConcatOperation::actualTypeName (void) const {
  return "typeConcatOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeConcatOperation ("typeConcatOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeTrueBool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::
cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTrueBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTrueBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTrueBool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeTrueBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTrueBool::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTrueBool::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTrueBool (& typeid (cPtr_typeTrueBool), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeTrueBool::galgasRTTI (void) const {
  return & gClassInfoFor__typeTrueBool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeTrueBool GGS_typeTrueBool::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTrueBool *> (inPointer) != NULL)
      : (typeid (cPtr_typeTrueBool) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeTrueBool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTrueBool),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeTrueBool * gSingleton_typeTrueBool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeTrueBool (void) {
  macroDetachPointer (gSingleton_typeTrueBool, cPtr_typeTrueBool) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool GGS_typeTrueBool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  if (NULL == gSingleton_typeTrueBool) {
    macroMyNew (gSingleton_typeTrueBool, cPtr_typeTrueBool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeTrueBool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeTrueBool) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTrueBool::actualTypeName (void) const {
  return "typeTrueBool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeTrueBool ("typeTrueBool", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeFalseBool'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::
cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFalseBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFalseBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFalseBool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFalseBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFalseBool::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFalseBool::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFalseBool (& typeid (cPtr_typeFalseBool), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFalseBool::galgasRTTI (void) const {
  return & gClassInfoFor__typeFalseBool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFalseBool GGS_typeFalseBool::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFalseBool *> (inPointer) != NULL)
      : (typeid (cPtr_typeFalseBool) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFalseBool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFalseBool),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeFalseBool * gSingleton_typeFalseBool = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeFalseBool (void) {
  macroDetachPointer (gSingleton_typeFalseBool, cPtr_typeFalseBool) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool GGS_typeFalseBool::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  if (NULL == gSingleton_typeFalseBool) {
    macroMyNew (gSingleton_typeFalseBool, cPtr_typeFalseBool (THERE)) ;
    registerReleaseRoutine (cleanUp_typeFalseBool) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeFalseBool) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFalseBool::actualTypeName (void) const {
  return "typeFalseBool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFalseBool ("typeFalseBool", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralStringExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::
cPtr_typeLiteralStringExpression (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralStringList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralStringExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralStringExpression * ptr = dynamic_cast <const cPtr_typeLiteralStringExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralStringList.operator_isEqual (ptr->mLiteralStringList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralStringExpression:"
           << mLiteralStringList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralStringExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralStringExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralStringExpression (& typeid (cPtr_typeLiteralStringExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralStringExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralStringExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralStringExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralStringExpression (mLiteralStringList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralStringExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralStringExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralStringExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralStringExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_typeLiteralStringExpression::
reader_mLiteralStringList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralStringExpression *) mPointer)->mLiteralStringList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralStringExpression::actualTypeName (void) const {
  return "typeLiteralStringExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralStringExpression ("typeLiteralStringExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLiteralUIntExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::
cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUIntExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUIntExpression * ptr = dynamic_cast <const cPtr_typeLiteralUIntExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUIntExpression:"
           << mLiteralInt.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUIntExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUIntExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralUIntExpression (& typeid (cPtr_typeLiteralUIntExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralUIntExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralUIntExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralUIntExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralUIntExpression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralUIntExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralUIntExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralUIntExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralUIntExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeLiteralUIntExpression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralUIntExpression::actualTypeName (void) const {
  return "typeLiteralUIntExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralUIntExpression ("typeLiteralUIntExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLiteralSIntExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::
cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSIntExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSIntExpression * ptr = dynamic_cast <const cPtr_typeLiteralSIntExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSIntExpression:"
           << mLiteralInt.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSIntExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSIntExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralSIntExpression (& typeid (cPtr_typeLiteralSIntExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralSIntExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralSIntExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralSIntExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralSIntExpression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralSIntExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralSIntExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralSIntExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralSIntExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_typeLiteralSIntExpression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralSIntExpression::actualTypeName (void) const {
  return "typeLiteralSIntExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralSIntExpression ("typeLiteralSIntExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralUInt64Expression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUInt64Expression::
cPtr_typeLiteralUInt64Expression (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUInt64Expression * GGS_typeLiteralUInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUInt64Expression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUInt64Expression * ptr = dynamic_cast <const cPtr_typeLiteralUInt64Expression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUInt64Expression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUInt64Expression:"
           << mLiteralInt.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUInt64Expression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUInt64Expression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralUInt64Expression (& typeid (cPtr_typeLiteralUInt64Expression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralUInt64Expression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralUInt64Expression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralUInt64Expression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralUInt64Expression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralUInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralUInt64Expression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralUInt64Expression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralUInt64Expression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_typeLiteralUInt64Expression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralUInt64Expression::actualTypeName (void) const {
  return "typeLiteralUInt64Expression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralUInt64Expression ("typeLiteralUInt64Expression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralSInt64Expression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSInt64Expression::
cPtr_typeLiteralSInt64Expression (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSInt64Expression * GGS_typeLiteralSInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSInt64Expression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSInt64Expression * ptr = dynamic_cast <const cPtr_typeLiteralSInt64Expression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSInt64Expression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSInt64Expression:"
           << mLiteralInt.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSInt64Expression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSInt64Expression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralSInt64Expression (& typeid (cPtr_typeLiteralSInt64Expression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralSInt64Expression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralSInt64Expression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralSInt64Expression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralSInt64Expression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralSInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralSInt64Expression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralSInt64Expression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralSInt64Expression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_typeLiteralSInt64Expression::
reader_mLiteralInt (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralSInt64Expression::actualTypeName (void) const {
  return "typeLiteralSInt64Expression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralSInt64Expression ("typeLiteralSInt64Expression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLiteralCharExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::
cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralCharExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralCharExpression * ptr = dynamic_cast <const cPtr_typeLiteralCharExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralChar.operator_isEqual (ptr->mLiteralChar).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralCharExpression:"
           << mLiteralChar.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralCharExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralCharExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralCharExpression (& typeid (cPtr_typeLiteralCharExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralCharExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralCharExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralCharExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralCharExpression (mLiteralChar COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralCharExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralCharExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralCharExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralCharExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeLiteralCharExpression::
reader_mLiteralChar (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralCharExpression *) mPointer)->mLiteralChar ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralCharExpression::actualTypeName (void) const {
  return "typeLiteralCharExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralCharExpression ("typeLiteralCharExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralDoubleExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralDoubleExpression::
cPtr_typeLiteralDoubleExpression (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralDouble (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralDoubleExpression * GGS_typeLiteralDoubleExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralDoubleExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralDoubleExpression * ptr = dynamic_cast <const cPtr_typeLiteralDoubleExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralDouble.operator_isEqual (ptr->mLiteralDouble).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralDoubleExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralDoubleExpression:"
           << mLiteralDouble.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralDoubleExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralDoubleExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralDoubleExpression (& typeid (cPtr_typeLiteralDoubleExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLiteralDoubleExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralDoubleExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralDoubleExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralDoubleExpression (mLiteralDouble COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralDoubleExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralDoubleExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralDoubleExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralDoubleExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralDoubleExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_typeLiteralDoubleExpression::
reader_mLiteralDouble (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralDoubleExpression *) mPointer)->mLiteralDouble ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralDoubleExpression::actualTypeName (void) const {
  return "typeLiteralDoubleExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLiteralDoubleExpression ("typeLiteralDoubleExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeHereExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::
cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeHereExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeHereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeHereExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeHereExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeHereExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeHereExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeHereExpression (& typeid (cPtr_typeHereExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeHereExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeHereExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeHereExpression GGS_typeHereExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeHereExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeHereExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeHereExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeHereExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeHereExpression * gSingleton_typeHereExpression = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeHereExpression (void) {
  macroDetachPointer (gSingleton_typeHereExpression, cPtr_typeHereExpression) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression GGS_typeHereExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  if (NULL == gSingleton_typeHereExpression) {
    macroMyNew (gSingleton_typeHereExpression, cPtr_typeHereExpression (THERE)) ;
    registerReleaseRoutine (cleanUp_typeHereExpression) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeHereExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeHereExpression::actualTypeName (void) const {
  return "typeHereExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeHereExpression ("typeHereExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeConstructorExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::
cPtr_typeConstructorExpression (const GGS_AC_galgasType & argument_0,
                                const GGS_string& argument_1,
                                const GGS_bool& argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mType (argument_0),
mClassMethodName (argument_1),
mHasLexiqueAndLocationArguments (argument_2),
mExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConstructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConstructorExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConstructorExpression * ptr = dynamic_cast <const cPtr_typeConstructorExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mClassMethodName.operator_isEqual (ptr->mClassMethodName).boolValue ()
         && mHasLexiqueAndLocationArguments.operator_isEqual (ptr->mHasLexiqueAndLocationArguments).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConstructorExpression:"
           << mType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mClassMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mHasLexiqueAndLocationArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConstructorExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConstructorExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConstructorExpression (& typeid (cPtr_typeConstructorExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeConstructorExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeConstructorExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConstructorExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConstructorExpression (mType, mClassMethodName, mHasLexiqueAndLocationArguments, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConstructorExpression GGS_typeConstructorExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConstructorExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeConstructorExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConstructorExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConstructorExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression GGS_typeConstructorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_string& argument_1,
                 const GGS_bool& argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  macroMyNew (result.mPointer, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeConstructorExpression::
reader_mType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConstructorExpression::
reader_mClassMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mClassMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConstructorExpression::
reader_mHasLexiqueAndLocationArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mHasLexiqueAndLocationArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeConstructorExpression::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConstructorExpression::actualTypeName (void) const {
  return "typeConstructorExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeConstructorExpression ("typeConstructorExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeIfThenElseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIfThenElseExpression::
cPtr_typeIfThenElseExpression (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mIfExpression (argument_0),
mThenExpression (argument_1),
mElseExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIfThenElseExpression * GGS_typeIfThenElseExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeIfThenElseExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeIfThenElseExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeIfThenElseExpression * ptr = dynamic_cast <const cPtr_typeIfThenElseExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeIfThenElseExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeIfThenElseExpression:"
           << mIfExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mThenExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeIfThenElseExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeIfThenElseExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeIfThenElseExpression (& typeid (cPtr_typeIfThenElseExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeIfThenElseExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeIfThenElseExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeIfThenElseExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeIfThenElseExpression (mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIfThenElseExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression::
GGS_typeIfThenElseExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression::
GGS_typeIfThenElseExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeIfThenElseExpression GGS_typeIfThenElseExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeIfThenElseExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeIfThenElseExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeIfThenElseExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeIfThenElseExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeIfThenElseExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression GGS_typeIfThenElseExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeIfThenElseExpression result ;
  macroMyNew (result.mPointer, cPtr_typeIfThenElseExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeIfThenElseExpression::
reader_mIfExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIfThenElseExpression *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeIfThenElseExpression::
reader_mThenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIfThenElseExpression *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeIfThenElseExpression::
reader_mElseExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIfThenElseExpression *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeIfThenElseExpression::actualTypeName (void) const {
  return "typeIfThenElseExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeIfThenElseExpression ("typeIfThenElseExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeTestComplement'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::
cPtr_typeTestComplement (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTestComplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTestComplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTestComplement * ptr = dynamic_cast <const cPtr_typeTestComplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTestComplement:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTestComplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTestComplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTestComplement (& typeid (cPtr_typeTestComplement), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeTestComplement::galgasRTTI (void) const {
  return & gClassInfoFor__typeTestComplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeTestComplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeTestComplement (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeTestComplement GGS_typeTestComplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTestComplement *> (inPointer) != NULL)
      : (typeid (cPtr_typeTestComplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeTestComplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTestComplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement GGS_typeTestComplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  macroMyNew (result.mPointer, cPtr_typeTestComplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeTestComplement::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTestComplement::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTestComplement::actualTypeName (void) const {
  return "typeTestComplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeTestComplement ("typeTestComplement", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeLogicalNegate'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogicalNegate::
cPtr_typeLogicalNegate (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogicalNegate * GGS_typeLogicalNegate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogicalNegate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogicalNegate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogicalNegate * ptr = dynamic_cast <const cPtr_typeLogicalNegate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogicalNegate::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLogicalNegate:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLogicalNegate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLogicalNegate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLogicalNegate (& typeid (cPtr_typeLogicalNegate), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLogicalNegate::galgasRTTI (void) const {
  return & gClassInfoFor__typeLogicalNegate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLogicalNegate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLogicalNegate (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeLogicalNegate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLogicalNegate GGS_typeLogicalNegate::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLogicalNegate *> (inPointer) != NULL)
      : (typeid (cPtr_typeLogicalNegate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLogicalNegate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLogicalNegate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate GGS_typeLogicalNegate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  macroMyNew (result.mPointer, cPtr_typeLogicalNegate (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLogicalNegate::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLogicalNegate::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLogicalNegate::actualTypeName (void) const {
  return "typeLogicalNegate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLogicalNegate ("typeLogicalNegate", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeBoolOption'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::
cPtr_typeBoolOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeBoolOption * GGS_typeBoolOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeBoolOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeBoolOption::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeBoolOption * ptr = dynamic_cast <const cPtr_typeBoolOption *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionName.operator_isEqual (ptr->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeBoolOption::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeBoolOption:"
           << mOptionComponentName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeBoolOption::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeBoolOption::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeBoolOption (& typeid (cPtr_typeBoolOption), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeBoolOption::galgasRTTI (void) const {
  return & gClassInfoFor__typeBoolOption ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeBoolOption::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeBoolOption (mOptionComponentName, mOptionName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeBoolOption GGS_typeBoolOption::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeBoolOption result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeBoolOption *> (inPointer) != NULL)
      : (typeid (cPtr_typeBoolOption) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeBoolOption (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeBoolOption),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption GGS_typeBoolOption::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeBoolOption result ;
  macroMyNew (result.mPointer, cPtr_typeBoolOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeBoolOption::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeBoolOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeBoolOption::
reader_mOptionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeBoolOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeBoolOption::actualTypeName (void) const {
  return "typeBoolOption" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeBoolOption ("typeBoolOption", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeUIntOption'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::
cPtr_typeUIntOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUIntOption * GGS_typeUIntOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUIntOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUIntOption::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUIntOption * ptr = dynamic_cast <const cPtr_typeUIntOption *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionName.operator_isEqual (ptr->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUIntOption::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUIntOption:"
           << mOptionComponentName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUIntOption::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUIntOption::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUIntOption (& typeid (cPtr_typeUIntOption), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeUIntOption::galgasRTTI (void) const {
  return & gClassInfoFor__typeUIntOption ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeUIntOption::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeUIntOption (mOptionComponentName, mOptionName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUIntOption GGS_typeUIntOption::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUIntOption result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUIntOption *> (inPointer) != NULL)
      : (typeid (cPtr_typeUIntOption) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUIntOption (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUIntOption),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption GGS_typeUIntOption::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUIntOption result ;
  macroMyNew (result.mPointer, cPtr_typeUIntOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUIntOption::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUIntOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeUIntOption::
reader_mOptionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUIntOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUIntOption::actualTypeName (void) const {
  return "typeUIntOption" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeUIntOption ("typeUIntOption", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeStringOption'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStringOption::
cPtr_typeStringOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStringOption * GGS_typeStringOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStringOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStringOption::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStringOption * ptr = dynamic_cast <const cPtr_typeStringOption *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionName.operator_isEqual (ptr->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStringOption::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStringOption:"
           << mOptionComponentName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStringOption::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStringOption::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStringOption (& typeid (cPtr_typeStringOption), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeStringOption::galgasRTTI (void) const {
  return & gClassInfoFor__typeStringOption ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStringOption::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStringOption (mOptionComponentName, mOptionName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStringOption GGS_typeStringOption::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStringOption result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStringOption *> (inPointer) != NULL)
      : (typeid (cPtr_typeStringOption) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStringOption (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStringOption),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption GGS_typeStringOption::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeStringOption result ;
  macroMyNew (result.mPointer, cPtr_typeStringOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStringOption::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStringOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStringOption::
reader_mOptionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStringOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStringOption::actualTypeName (void) const {
  return "typeStringOption" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStringOption ("typeStringOption", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeFunctionCall'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFunctionCall::
cPtr_typeFunctionCall (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFunctionName (argument_0),
mExpressionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFunctionCall * GGS_typeFunctionCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFunctionCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFunctionCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFunctionCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFunctionCall * ptr = dynamic_cast <const cPtr_typeFunctionCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFunctionCall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFunctionCall:"
           << mFunctionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFunctionCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFunctionCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFunctionCall (& typeid (cPtr_typeFunctionCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFunctionCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeFunctionCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFunctionCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFunctionCall (mFunctionName, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFunctionCall'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFunctionCall::
GGS_typeFunctionCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFunctionCall::
GGS_typeFunctionCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFunctionCall GGS_typeFunctionCall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFunctionCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFunctionCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeFunctionCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFunctionCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFunctionCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFunctionCall GGS_typeFunctionCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFunctionCall result ;
  macroMyNew (result.mPointer, cPtr_typeFunctionCall (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFunctionCall::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFunctionCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFunctionCall *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeFunctionCall::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFunctionCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFunctionCall *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFunctionCall::actualTypeName (void) const {
  return "typeFunctionCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFunctionCall ("typeFunctionCall", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeVarInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::
cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeVarInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeVarInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeVarInExpression * ptr = dynamic_cast <const cPtr_typeVarInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppVarName.operator_isEqual (ptr->mCppVarName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeVarInExpression:"
           << mCppVarName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeVarInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVarInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeVarInExpression (& typeid (cPtr_typeVarInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeVarInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeVarInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeVarInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeVarInExpression (mCppVarName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeVarInExpression GGS_typeVarInExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeVarInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeVarInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeVarInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeVarInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression GGS_typeVarInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeVarInExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeVarInExpression::
reader_mCppVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeVarInExpression *) mPointer)->mCppVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeVarInExpression::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeVarInExpression *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeVarInExpression::actualTypeName (void) const {
  return "typeVarInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeVarInExpression ("typeVarInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeJokerInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::
cPtr_typeJokerInExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJokerInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJokerInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJokerInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJokerInExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeJokerInExpression::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeJokerInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeJokerInExpression (& typeid (cPtr_typeJokerInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeJokerInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeJokerInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeJokerInExpression GGS_typeJokerInExpression::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeJokerInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeJokerInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeJokerInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeJokerInExpression),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeJokerInExpression * gSingleton_typeJokerInExpression = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeJokerInExpression (void) {
  macroDetachPointer (gSingleton_typeJokerInExpression, cPtr_typeJokerInExpression) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression GGS_typeJokerInExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  if (NULL == gSingleton_typeJokerInExpression) {
    macroMyNew (gSingleton_typeJokerInExpression, cPtr_typeJokerInExpression (THERE)) ;
    registerReleaseRoutine (cleanUp_typeJokerInExpression) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeJokerInExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeJokerInExpression::actualTypeName (void) const {
  return "typeJokerInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeJokerInExpression ("typeJokerInExpression", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAddOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::
cPtr_typeAddOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAddOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAddOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAddOperation * ptr = dynamic_cast <const cPtr_typeAddOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAddOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAddOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAddOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAddOperation (& typeid (cPtr_typeAddOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeAddOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeAddOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAddOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAddOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAddOperation GGS_typeAddOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAddOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeAddOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAddOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAddOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation GGS_typeAddOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAddOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAddOperation::actualTypeName (void) const {
  return "typeAddOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAddOperation ("typeAddOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeSubOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::
cPtr_typeSubOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSubOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSubOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSubOperation * ptr = dynamic_cast <const cPtr_typeSubOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSubOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSubOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSubOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSubOperation (& typeid (cPtr_typeSubOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeSubOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeSubOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSubOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSubOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSubOperation GGS_typeSubOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSubOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeSubOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSubOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSubOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation GGS_typeSubOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  macroMyNew (result.mPointer, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSubOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSubOperation::actualTypeName (void) const {
  return "typeSubOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSubOperation ("typeSubOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeMultiplyOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::
cPtr_typeMultiplyOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMultiplyOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMultiplyOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMultiplyOperation * ptr = dynamic_cast <const cPtr_typeMultiplyOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMultiplyOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMultiplyOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMultiplyOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMultiplyOperation (& typeid (cPtr_typeMultiplyOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMultiplyOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeMultiplyOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMultiplyOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMultiplyOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMultiplyOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeMultiplyOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMultiplyOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMultiplyOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  macroMyNew (result.mPointer, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMultiplyOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMultiplyOperation::actualTypeName (void) const {
  return "typeMultiplyOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMultiplyOperation ("typeMultiplyOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeDivideOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::
cPtr_typeDivideOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDivideOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDivideOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDivideOperation * ptr = dynamic_cast <const cPtr_typeDivideOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDivideOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDivideOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDivideOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDivideOperation (& typeid (cPtr_typeDivideOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDivideOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeDivideOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDivideOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDivideOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDivideOperation GGS_typeDivideOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDivideOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeDivideOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDivideOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDivideOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation GGS_typeDivideOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  macroMyNew (result.mPointer, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDivideOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDivideOperation::actualTypeName (void) const {
  return "typeDivideOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDivideOperation ("typeDivideOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeModuloOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::
cPtr_typeModuloOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModuloOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModuloOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModuloOperation * ptr = dynamic_cast <const cPtr_typeModuloOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModuloOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeModuloOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeModuloOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeModuloOperation (& typeid (cPtr_typeModuloOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeModuloOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeModuloOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeModuloOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeModuloOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeModuloOperation GGS_typeModuloOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeModuloOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeModuloOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeModuloOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeModuloOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation GGS_typeModuloOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  macroMyNew (result.mPointer, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeModuloOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeModuloOperation::actualTypeName (void) const {
  return "typeModuloOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeModuloOperation ("typeModuloOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeUnaryMinusOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::
cPtr_typeUnaryMinusOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUnaryMinusOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUnaryMinusOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUnaryMinusOperation * ptr = dynamic_cast <const cPtr_typeUnaryMinusOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUnaryMinusOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUnaryMinusOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUnaryMinusOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUnaryMinusOperation (& typeid (cPtr_typeUnaryMinusOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeUnaryMinusOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeUnaryMinusOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeUnaryMinusOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeUnaryMinusOperation (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUnaryMinusOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeUnaryMinusOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUnaryMinusOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUnaryMinusOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  macroMyNew (result.mPointer, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeUnaryMinusOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeUnaryMinusOperation::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUnaryMinusOperation::actualTypeName (void) const {
  return "typeUnaryMinusOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeUnaryMinusOperation ("typeUnaryMinusOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::
cPtr_typeEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEqualTest * ptr = dynamic_cast <const cPtr_typeEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEqualTest:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEqualTest (& typeid (cPtr_typeEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEqualTest GGS_typeEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest GGS_typeEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEqualTest::actualTypeName (void) const {
  return "typeEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEqualTest ("typeEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeNonEqualTest'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::
cPtr_typeNonEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonEqualTest * ptr = dynamic_cast <const cPtr_typeNonEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonEqualTest:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNonEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNonEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNonEqualTest (& typeid (cPtr_typeNonEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeNonEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeNonEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeNonEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeNonEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeNonEqualTest GGS_typeNonEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNonEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeNonEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeNonEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNonEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest GGS_typeNonEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeNonEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeNonEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNonEqualTest::actualTypeName (void) const {
  return "typeNonEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeNonEqualTest ("typeNonEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeStrictInfTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::
cPtr_typeStrictInfTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictInfTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictInfTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictInfTest * ptr = dynamic_cast <const cPtr_typeStrictInfTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictInfTest:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStrictInfTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStrictInfTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStrictInfTest (& typeid (cPtr_typeStrictInfTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeStrictInfTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeStrictInfTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStrictInfTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStrictInfTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStrictInfTest GGS_typeStrictInfTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStrictInfTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeStrictInfTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStrictInfTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStrictInfTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest GGS_typeStrictInfTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictInfTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStrictInfTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStrictInfTest::actualTypeName (void) const {
  return "typeStrictInfTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStrictInfTest ("typeStrictInfTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeInfOrEqualTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::
cPtr_typeInfOrEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInfOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInfOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInfOrEqualTest * ptr = dynamic_cast <const cPtr_typeInfOrEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInfOrEqualTest:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInfOrEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInfOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInfOrEqualTest (& typeid (cPtr_typeInfOrEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeInfOrEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeInfOrEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInfOrEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInfOrEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInfOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeInfOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInfOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInfOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeInfOrEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInfOrEqualTest::actualTypeName (void) const {
  return "typeInfOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInfOrEqualTest ("typeInfOrEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeStrictSupTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::
cPtr_typeStrictSupTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictSupTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictSupTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictSupTest * ptr = dynamic_cast <const cPtr_typeStrictSupTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictSupTest:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStrictSupTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStrictSupTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStrictSupTest (& typeid (cPtr_typeStrictSupTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeStrictSupTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeStrictSupTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStrictSupTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStrictSupTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStrictSupTest GGS_typeStrictSupTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStrictSupTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeStrictSupTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStrictSupTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStrictSupTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest GGS_typeStrictSupTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictSupTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStrictSupTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStrictSupTest::actualTypeName (void) const {
  return "typeStrictSupTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStrictSupTest ("typeStrictSupTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeSupOrEqualTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::
cPtr_typeSupOrEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSupOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSupOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSupOrEqualTest * ptr = dynamic_cast <const cPtr_typeSupOrEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSupOrEqualTest:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSupOrEqualTest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSupOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSupOrEqualTest (& typeid (cPtr_typeSupOrEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeSupOrEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeSupOrEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSupOrEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSupOrEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSupOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeSupOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSupOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSupOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSupOrEqualTest::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSupOrEqualTest::actualTypeName (void) const {
  return "typeSupOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSupOrEqualTest ("typeSupOrEqualTest", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeLeftShiftOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLeftShiftOperation::
cPtr_typeLeftShiftOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLeftShiftOperation * GGS_typeLeftShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLeftShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLeftShiftOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLeftShiftOperation * ptr = dynamic_cast <const cPtr_typeLeftShiftOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLeftShiftOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLeftShiftOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLeftShiftOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLeftShiftOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLeftShiftOperation (& typeid (cPtr_typeLeftShiftOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLeftShiftOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeLeftShiftOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLeftShiftOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLeftShiftOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeLeftShiftOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLeftShiftOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeLeftShiftOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLeftShiftOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLeftShiftOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeLeftShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLeftShiftOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLeftShiftOperation::actualTypeName (void) const {
  return "typeLeftShiftOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLeftShiftOperation ("typeLeftShiftOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeRightShiftOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRightShiftOperation::
cPtr_typeRightShiftOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRightShiftOperation * GGS_typeRightShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRightShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRightShiftOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRightShiftOperation * ptr = dynamic_cast <const cPtr_typeRightShiftOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRightShiftOperation::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRightShiftOperation:"
           << mOperatorLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLeftExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRightShiftOperation::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRightShiftOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRightShiftOperation (& typeid (cPtr_typeRightShiftOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeRightShiftOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeRightShiftOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRightShiftOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRightShiftOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeRightShiftOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRightShiftOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeRightShiftOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRightShiftOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRightShiftOperation),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeRightShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeRightShiftOperation::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRightShiftOperation::actualTypeName (void) const {
  return "typeRightShiftOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRightShiftOperation ("typeRightShiftOperation", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeTextTableCall'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::
cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTextTableCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTextTableCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTextTableCall * ptr = dynamic_cast <const cPtr_typeTextTableCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && aNomMethodeTest.operator_isEqual (ptr->aNomMethodeTest).boolValue ()
         && aNomCppClef.operator_isEqual (ptr->aNomCppClef).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTextTableCall:"
           << mExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeTest.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppClef.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTextTableCall::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTextTableCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTextTableCall (& typeid (cPtr_typeTextTableCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeTextTableCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeTextTableCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeTextTableCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeTextTableCall (mExpression, aNomMethodeTest, aNomCppClef COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeTextTableCall GGS_typeTextTableCall::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTextTableCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeTextTableCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeTextTableCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTextTableCall),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall GGS_typeTextTableCall::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  macroMyNew (result.mPointer, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTextTableCall::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeTextTableCall::
reader_aNomMethodeTest (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomMethodeTest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeTextTableCall::
reader_aNomCppClef (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomCppClef ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTextTableCall::actualTypeName (void) const {
  return "typeTextTableCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeTextTableCall ("typeTextTableCall", gClassInfoFor__typeExpression) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_assignmentInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::
cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_assignmentInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_assignmentInstruction * ptr = dynamic_cast <const cPtr_C_assignmentInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_assignmentInstruction:"
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_assignmentInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_assignmentInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_assignmentInstruction (& typeid (cPtr_C_assignmentInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_assignmentInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_assignmentInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_assignmentInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_assignmentInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_assignmentInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_assignmentInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_assignmentInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_assignmentInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_assignmentInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_assignmentInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_C_assignmentInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_assignmentInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_assignmentInstruction::actualTypeName (void) const {
  return "C_assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_assignmentInstruction ("C_assignmentInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_C_constantDeclarationInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_constantDeclarationInstruction::
cPtr_C_constantDeclarationInstruction (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_constantDeclarationInstruction * GGS_C_constantDeclarationInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_constantDeclarationInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_constantDeclarationInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_constantDeclarationInstruction * ptr = dynamic_cast <const cPtr_C_constantDeclarationInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_constantDeclarationInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_constantDeclarationInstruction:"
           << mTargetType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_constantDeclarationInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_constantDeclarationInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_constantDeclarationInstruction (& typeid (cPtr_C_constantDeclarationInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_constantDeclarationInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_constantDeclarationInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_constantDeclarationInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_constantDeclarationInstruction (mTargetType, mTargetVarCppName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_constantDeclarationInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction::
GGS_C_constantDeclarationInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction::
GGS_C_constantDeclarationInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_constantDeclarationInstruction GGS_C_constantDeclarationInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_constantDeclarationInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_constantDeclarationInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_constantDeclarationInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_constantDeclarationInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction GGS_C_constantDeclarationInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_constantDeclarationInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_constantDeclarationInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_C_constantDeclarationInstruction::
reader_mTargetType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_constantDeclarationInstruction *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_constantDeclarationInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_constantDeclarationInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_constantDeclarationInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_constantDeclarationInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_constantDeclarationInstruction::actualTypeName (void) const {
  return "C_constantDeclarationInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_constantDeclarationInstruction ("C_constantDeclarationInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_dotEqualInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_dotEqualInstruction::
cPtr_C_dotEqualInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2),
mSourceExpressionConverter (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_dotEqualInstruction * GGS_C_dotEqualInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_dotEqualInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_dotEqualInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_dotEqualInstruction * ptr = dynamic_cast <const cPtr_C_dotEqualInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionConverter.operator_isEqual (ptr->mSourceExpressionConverter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_dotEqualInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_dotEqualInstruction:"
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionConverter.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_dotEqualInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_dotEqualInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_dotEqualInstruction (& typeid (cPtr_C_dotEqualInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_dotEqualInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_dotEqualInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_dotEqualInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_dotEqualInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpression, mSourceExpressionConverter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_dotEqualInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_dotEqualInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_dotEqualInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_dotEqualInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_dotEqualInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_dotEqualInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_dotEqualInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_C_dotEqualInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_dotEqualInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_dotEqualInstruction::
reader_mSourceExpressionConverter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpressionConverter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_dotEqualInstruction::actualTypeName (void) const {
  return "C_dotEqualInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_dotEqualInstruction ("C_dotEqualInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_C_declarationInstructionWithAssignment'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::
cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_declarationInstructionWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_declarationInstructionWithAssignment::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_declarationInstructionWithAssignment * ptr = dynamic_cast <const cPtr_C_declarationInstructionWithAssignment *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableType.operator_isEqual (ptr->mVariableType).boolValue ()
         && mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_declarationInstructionWithAssignment:"
           << mVariableType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_declarationInstructionWithAssignment::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_declarationInstructionWithAssignment::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_declarationInstructionWithAssignment (& typeid (cPtr_C_declarationInstructionWithAssignment), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_declarationInstructionWithAssignment::galgasRTTI (void) const {
  return & gClassInfoFor__C_declarationInstructionWithAssignment ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_declarationInstructionWithAssignment::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_declarationInstructionWithAssignment (mVariableType, mTargetVarCppName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (inPointer) != NULL)
      : (typeid (cPtr_C_declarationInstructionWithAssignment) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_declarationInstructionWithAssignment (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_declarationInstructionWithAssignment),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_C_declarationInstructionWithAssignment::
reader_mVariableType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mVariableType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_declarationInstructionWithAssignment::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_declarationInstructionWithAssignment::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_declarationInstructionWithAssignment::actualTypeName (void) const {
  return "C_declarationInstructionWithAssignment" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_declarationInstructionWithAssignment ("C_declarationInstructionWithAssignment", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_while_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_while_instruction::
cPtr_C_while_instruction (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariantExpression (argument_0),
mInstructionList1 (argument_1),
mWhileExpression (argument_2),
mInstructionList2 (argument_3),
mLocation (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_while_instruction * GGS_C_while_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_while_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_while_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_while_instruction * ptr = dynamic_cast <const cPtr_C_while_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mInstructionList1.operator_isEqual (ptr->mInstructionList1).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mInstructionList2.operator_isEqual (ptr->mInstructionList2).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_while_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_while_instruction:"
           << mVariantExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList1.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList2.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_while_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_while_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_while_instruction (& typeid (cPtr_C_while_instruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_while_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_while_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_while_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_while_instruction (mVariantExpression, mInstructionList1, mWhileExpression, mInstructionList2, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_while_instruction GGS_C_while_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_while_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_while_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_while_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_while_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction GGS_C_while_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeInstructionList & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_while_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_while_instruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_while_instruction::actualTypeName (void) const {
  return "C_while_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_while_instruction ("C_while_instruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mInstructionList (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_expression_instructionsList_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_expression_instructionsList_list * ptr = dynamic_cast <const elementOf_GGS_L_expression_instructionsList_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_location & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
operator_concat (const GGS_L_expression_instructionsList_list & inOperand) const {
  GGS_L_expression_instructionsList_list result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
dotAssign_operation (const GGS_L_expression_instructionsList_list inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_expression_instructionsList_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mIFexpression ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          GGS_location  p_2 = p->mLocation ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_typeInstructionList & argument_1,
                     const GGS_location & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mIFexpression,
                                ptr->mInstructionList,
                                ptr->mLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_emptyList (void) {
  GGS_L_expression_instructionsList_list result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_listWithValue (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_location & argument_2) {
  GGS_L_expression_instructionsList_list result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalSubListWithRange (GGS_L_expression_instructionsList_list & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIFexpression, ptr->mInstructionList, ptr->mLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@L_expression_instructionsList_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_first (C_Compiler & inLexique,
              GGS_typeExpression & _out_0,
              GGS_typeInstructionList & _out_1,
              GGS_location & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_last (C_Compiler & inLexique,
             GGS_typeExpression & _out_0,
             GGS_typeInstructionList & _out_1,
             GGS_location & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_typeInstructionList & _out_1,
                 GGS_location & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeExpression & _out_0,
                GGS_typeInstructionList & _out_1,
                GGS_location & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_L_expression_instructionsList_list::
reader_mIFexpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_expression_instructionsList_list::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_expression_instructionsList_list::
reader_mLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMIFexpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_L_expression_instructionsList_list::cEnumerator::_mIFexpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFexpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_expression_instructionsList_list::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_expression_instructionsList_list::cEnumerator::_mLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_if_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::
cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_if_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_if_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_if_instruction * ptr = dynamic_cast <const cPtr_C_if_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFbranchesList.operator_isEqual (ptr->mIFbranchesList).boolValue ()
         && mElseInstructionsList.operator_isEqual (ptr->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_if_instruction:"
           << mIFbranchesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_if_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_if_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_if_instruction (& typeid (cPtr_C_if_instruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_if_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_if_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_if_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_if_instruction (mIFbranchesList, mElseInstructionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_if_instruction GGS_C_if_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_if_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_if_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_if_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_if_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction GGS_C_if_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_if_instruction::
reader_mIFbranchesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_if_instruction::
reader_mElseInstructionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_if_instruction::actualTypeName (void) const {
  return "C_if_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_if_instruction ("C_if_instruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_switchBranchlist'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_switchBranchlist::
elementOf_GGS_L_switchBranchlist (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantSet (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_switchBranchlist::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_switchBranchlist * ptr = dynamic_cast <const elementOf_GGS_L_switchBranchlist *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantSet.operator_isEqual (ptr->mConstantSet).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_switchBranchlist::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantSet.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_switchBranchlist'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalAppendValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalPrependValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
addAssign_operation (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
operator_concat (const GGS_L_switchBranchlist & inOperand) const {
  GGS_L_switchBranchlist result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
dotAssign_operation (const GGS_L_switchBranchlist inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_switchBranchlist * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_stringset  p_0 = p->mConstantSet ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_stringset & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mConstantSet,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_emptyList (void) {
  GGS_L_switchBranchlist result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_listWithValue (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  GGS_L_switchBranchlist result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
internalSubListWithRange (GGS_L_switchBranchlist & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantSet, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_switchBranchlist result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_switchBranchlist result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_switchBranchlist::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@L_switchBranchlist", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_first (C_Compiler & inLexique,
              GGS_stringset & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_last (C_Compiler & inLexique,
             GGS_stringset & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_stringset & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popLast (C_Compiler & inLexique,
                GGS_stringset & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_L_switchBranchlist::
reader_mConstantSetAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_stringset  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantSet ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_switchBranchlist::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_setMConstantSetAtIndex (C_Compiler & inLexique,
                              const GGS_stringset  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantSet = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_L_switchBranchlist::cEnumerator::_mConstantSet (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantSet ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_switchBranchlist::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_switch_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_switch_instruction::
cPtr_C_switch_instruction (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSwitchExpression (argument_0),
mEnumTypeName (argument_1),
mBranchList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_switch_instruction * GGS_C_switch_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_switch_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_switch_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_switch_instruction * ptr = dynamic_cast <const cPtr_C_switch_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_switch_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_switch_instruction:"
           << mSwitchExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEnumTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_switch_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_switch_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_switch_instruction (& typeid (cPtr_C_switch_instruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_switch_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_switch_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_switch_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_switch_instruction (mSwitchExpression, mEnumTypeName, mBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_switch_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_switch_instruction GGS_C_switch_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_switch_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_switch_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_switch_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_switch_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction GGS_C_switch_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_switch_instruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_switch_instruction::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_switch_instruction::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_C_switch_instruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_switchBranchlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_switch_instruction::actualTypeName (void) const {
  return "C_switch_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_switch_instruction ("C_switch_instruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableRoutinesAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableRoutinesAimplementer::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableRoutinesAimplementer info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
operator_isEqual (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
operator_isNotEqual (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableRoutinesAimplementer::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'e_typeTableAttributsSemantiques'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableAttributsSemantiques::e_typeTableAttributsSemantiques (void) :
aNomCppAttribut (),
mAttributType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableAttributsSemantiques'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aNomCppAttribut.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributType.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableAttributsSemantiques::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableAttributsSemantiques * ptr = dynamic_cast <const elementOf_GGS_typeTableAttributsSemantiques *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aNomCppAttribut.operator_isEqual (ptr->mInfo.aNomCppAttribut)).boolValue ()
           && (mInfo.mAttributType.operator_isEqual (ptr->mInfo.mAttributType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableAttributsSemantiques info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
operator_isEqual (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
operator_isNotEqual (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeCplusPlusName & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableAttributsSemantiques::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableAttributsSemantiques::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableAttributsSemantiques & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_typeTableAttributsSemantiques::cEnumerator::_aNomCppAttribut (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aNomCppAttribut ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeTableAttributsSemantiques::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Compiler & inLexique,
                                GGS_bool  var_cas_inEnumeratorNewStyle,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildMapWithLocalConstants at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mapStyle = (var_cas_inLocalConstantStyle).operator_isNotEqual (GGS_localConstantBuildStyleEnum::constructor_listStyle (inLexique COMMA_HERE)) ;
  GGS_bool var_cas_firstOne = GGS_bool (true) ;
  {
    GGS_L_nameWithType::cEnumerator enumerator_33736 (var_cas_inLocalDeclarationsList, true) ;
    const GGS_L_nameWithType::cElement * operand_33736 = NULL ;
    GGS_typeListeAttributsSemantiques::cEnumerator enumerator_33771 (var_cas_inSemanticAttributsList, true) ;
    const GGS_typeListeAttributsSemantiques::cElement * operand_33771 = NULL ;
    while (((operand_33736 = enumerator_33736.nextObject ()))
        && ((operand_33771 = enumerator_33771.nextObject ()))) {
      macroValidPointer (operand_33736) ;
      macroValidPointer (operand_33771) ;
      const GGS_bool cond_34535 = (operand_33736->mType.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (821))).operator_isNotEqual (GGS_string ("")) ;
      if (cond_34535.isBuiltAndTrue ()) {
        GGS_string var_cas_typeName ;
        const GGS_AC_galgasType  temp_33865 = operand_33771->mAttributType ;
        if (temp_33865.isBuilt ()) {
          temp_33865 (HERE)->method_getTypeName (inLexique, var_cas_typeName COMMA_SOURCE_FILE_AT_LINE (823)) ;
        }
        const GGS_bool cond_34383 = (operand_33736->mType.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (824))).operator_isEqual (var_cas_typeName) ;
        if (cond_34383.isBuiltAndTrue ()) {
          GGS_typeCplusPlusName  var_cas_cppName ;
          const GGS_bool cond_34154 = ((var_cas_inLocalConstantStyle).operator_isEqual (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (inLexique COMMA_HERE))).operator_and (var_cas_firstOne) ;
          if (cond_34154.isBuiltAndTrue ()) {
            var_cas_cppName = GGS_typeKeyName ::constructor_new (inLexique, var_cas_inLocation, var_cas_inEnumeratorNewStyle COMMA_HERE) ;
          }else if (cond_34154.isBuiltAndFalse ()) {
            var_cas_cppName = GGS_typeOperandName ::constructor_new (inLexique, var_cas_inLocation, operand_33771->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (829)), var_cas_mapStyle, var_cas_inEnumeratorNewStyle COMMA_HERE) ;
          }
          var_cas_ioVariablesMap.modifier_insertUsedConstInArgument (inLexique, operand_33736->mName, operand_33771->mAttributType, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (831)) ;
        }else if (cond_34383.isBuiltAndFalse ()) {
          operand_33736->mType.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I have found the '@")).operator_concat (operand_33736->mType.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (833)))).operator_concat (GGS_string ("' type, I was expected the '@"))).operator_concat (var_cas_typeName)).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (835)) ;
        }
      }
      var_cas_firstOne = GGS_bool (false) ;
    }
  }
  const GGS_bool cond_34940 = ((var_cas_inLocalDeclarationsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (840))).operator_strictInf (var_cas_inSemanticAttributsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (840)))).operator_and ((var_cas_inEllipsisFound).operator_not ()) ;
  if (cond_34940.isBuiltAndTrue ()) {
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("one or more parameters missing: found ")).operator_concat (var_cas_inLocalDeclarationsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (842)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (842)))).operator_concat (GGS_string (" effective parameters, while "))).operator_concat (var_cas_inSemanticAttributsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (843)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (843)))).operator_concat (GGS_string (" are needed")) COMMA_SOURCE_FILE_AT_LINE (844)) ;
  }else if (cond_34940.isBuiltAndFalse ()) {
    const GGS_bool cond_35214 = (var_cas_inLocalDeclarationsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (844))).operator_strictSup (var_cas_inSemanticAttributsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (844))) ;
    if (cond_35214.isBuiltAndTrue ()) {
      GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("too much parameters: found ")).operator_concat (var_cas_inLocalDeclarationsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (846)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (846)))).operator_concat (GGS_string (" effective parameters, while "))).operator_concat (var_cas_inSemanticAttributsList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (847)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (847)))).operator_concat (GGS_string (" are needed")) COMMA_SOURCE_FILE_AT_LINE (848)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildMapWithLocalConstants\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Compiler & inLexique,
                                const GGS_typeSemanticsTypesList   var_cas_t1,
                                const GGS_typeListeAttributsSemantiques   var_cas_t2,
                                const GGS_location   var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_35947 = (var_cas_t1.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (863))).operator_strictInf (var_cas_t2.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (863))) ;
  if (cond_35947.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more identifiers missing") COMMA_SOURCE_FILE_AT_LINE (865)) ;
  }else if (cond_35947.isBuiltAndFalse ()) {
    const GGS_bool cond_36038 = (var_cas_t1.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (865))).operator_strictSup (var_cas_t2.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (865))) ;
    if (cond_36038.isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("too much identifiers") COMMA_SOURCE_FILE_AT_LINE (867)) ;
    }else if (cond_36038.isBuiltAndFalse ()) {
      {
        GGS_typeSemanticsTypesList::cEnumerator enumerator_36053 (var_cas_t1, true) ;
        const GGS_typeSemanticsTypesList::cElement * operand_36053 = NULL ;
        GGS_typeListeAttributsSemantiques::cEnumerator enumerator_36057 (var_cas_t2, true) ;
        const GGS_typeListeAttributsSemantiques::cElement * operand_36057 = NULL ;
        while (((operand_36053 = enumerator_36053.nextObject ()))
            && ((operand_36057 = enumerator_36057.nextObject ()))) {
          macroValidPointer (operand_36053) ;
          macroValidPointer (operand_36057) ;
          ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_36053->mType,  operand_36057->mAttributType,  operand_36053->mGalgasVariableName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (872)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (869)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Compiler & inLexique,
                                const GGS_L_EXsignature   var_cas_signatureReference,
                                const GGS_L_actualParametersSignature   var_cas_inEffectiveArgumentsSignature,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteArgEffectifsSignature at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_37054 = (var_cas_signatureReference.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (892))).operator_strictSup (var_cas_inEffectiveArgumentsSignature.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (892))) ;
  if (cond_37054.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more arguments missing") COMMA_SOURCE_FILE_AT_LINE (894)) ;
  }else if (cond_37054.isBuiltAndFalse ()) {
    const GGS_bool cond_37186 = (var_cas_signatureReference.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (894))).operator_strictInf (var_cas_inEffectiveArgumentsSignature.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (894))) ;
    if (cond_37186.isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("too much arguments") COMMA_SOURCE_FILE_AT_LINE (896)) ;
    }else if (cond_37186.isBuiltAndFalse ()) {
      {
        GGS_L_EXsignature::cEnumerator enumerator_37241 (var_cas_signatureReference, true) ;
        const GGS_L_EXsignature::cElement * operand_37241 = NULL ;
        GGS_L_actualParametersSignature::cEnumerator enumerator_37284 (var_cas_inEffectiveArgumentsSignature, true) ;
        const GGS_L_actualParametersSignature::cElement * operand_37284 = NULL ;
        while (((operand_37241 = enumerator_37241.nextObject ()))
            && ((operand_37284 = enumerator_37284.nextObject ()))) {
          macroValidPointer (operand_37241) ;
          macroValidPointer (operand_37284) ;
          if (operand_37241->mFormalArgumentPassingMode.isBuilt () && operand_37284->mFormalArgumentPassingMode.isBuilt ()) {
            if ((operand_37241->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentConstantIn) && (operand_37284->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOut)) {
              ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37241->mType,  operand_37284->mType,  var_cas_inErrorLocation,  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (902)) ;
            }else{
              if ((operand_37241->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentIn) && (operand_37284->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOut)) {
                ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37241->mType,  operand_37284->mType,  var_cas_inErrorLocation,  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (904)) ;
              }else{
                if ((operand_37241->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentInOut) && (operand_37284->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOutIn)) {
                  ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37241->mType,  operand_37284->mType,  var_cas_inErrorLocation,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (906)) ;
                }else{
                  if ((operand_37241->mFormalArgumentPassingMode.enumValue () == GGS_EXformalArgumentPassingMode::enum_argumentOut) && (operand_37284->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterIn)) {
                    { const GGS_AC_galgasType _var_38009 = operand_37284->mType ; // CAST instruction
                      if (_var_38009.getPtr () != NULL) {
                        macroValidPointer (_var_38009.getPtr ()) ;
                        if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (_var_38009.getPtr ()) != NULL) {
                        }else{
                          ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37241->mType,  operand_37284->mType,  var_cas_inErrorLocation,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (911)) ;
                        }
                      }
                    }
                  }else{
                    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((operand_37284->mFormalArgumentPassingMode.reader_actualArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (914))).operator_concat (GGS_string (" is not compatible with "))).operator_concat (operand_37241->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (915))) COMMA_SOURCE_FILE_AT_LINE (916)) ;
                  }
                }
              }
            }
          }
        }
      }
      GGS_typeExpressionList  var_cas_expressionList = var_cas_ioExpressionList ;
      var_cas_ioExpressionList = GGS_typeExpressionList ::constructor_emptyList () ;
      {
        GGS_L_EXsignature::cEnumerator enumerator_38447 (var_cas_signatureReference, true) ;
        const GGS_L_EXsignature::cElement * operand_38447 = NULL ;
        GGS_typeExpressionList::cEnumerator enumerator_38463 (var_cas_expressionList, true) ;
        const GGS_typeExpressionList::cElement * operand_38463 = NULL ;
        while (((operand_38447 = enumerator_38447.nextObject ()))
            && ((operand_38463 = enumerator_38463.nextObject ()))) {
          macroValidPointer (operand_38447) ;
          macroValidPointer (operand_38463) ;
          { const GGS_typeExpression _var_38959 = operand_38463->mExpression ; // CAST instruction
            if (_var_38959.getPtr () != NULL) {
              macroValidPointer (_var_38959.getPtr ()) ;
              if (dynamic_cast <cPtr_typeJokerInExpression *> (_var_38959.getPtr ()) != NULL) {
                GGS_typeCplusPlusName  var_cas_cppVarName = GGS_typeLocationAutomaticName ::constructor_new (inLexique, GGS_location (inLexique), GGS_uint ::constructor_sequenceNumber (inLexique COMMA_HERE) COMMA_HERE) ;
                GGS_typeExpression  var_cas_e = GGS_typeVarInExpression ::constructor_new (inLexique, var_cas_cppVarName, GGS_lstringlist ::constructor_emptyList () COMMA_HERE) ;
                var_cas_ioExpressionList.addAssign_operation (var_cas_e) ;
                GGS_typeInstruction  var_cas_i = GGS_typeInstructionDeclarationVarLocale ::constructor_new (inLexique, var_cas_cppVarName, operand_38447->mType COMMA_HERE) ;
                var_cas_ioInstructionsList.addAssign_operation (var_cas_i) ;
              }else{
                var_cas_ioExpressionList.addAssign_operation (operand_38463->mExpression) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteArgEffectifsSignature\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_typeJoker'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::
cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJoker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
method_verifierType (C_Compiler & inLexique,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outAllVariablesList.addAssign_operation (GGS_typeNullName ::constructor_new (inLexique, GGS_location (inLexique) COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeJoker::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeJoker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeJoker (& typeid (cPtr_typeJoker), & typeid (cPtr_typeCible), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeJoker::galgasRTTI (void) const {
  return & gClassInfoFor__typeJoker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeJoker GGS_typeJoker::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeJoker *> (inPointer) != NULL)
      : (typeid (cPtr_typeJoker) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeJoker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeJoker),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeJoker * gSingleton_typeJoker = NULL ;

//---------------------------------------------------------------------------*

static void cleanUp_typeJoker (void) {
  macroDetachPointer (gSingleton_typeJoker, cPtr_typeJoker) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker GGS_typeJoker::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  if (NULL == gSingleton_typeJoker) {
    macroMyNew (gSingleton_typeJoker, cPtr_typeJoker (THERE)) ;
    registerReleaseRoutine (cleanUp_typeJoker) ;
  }
  macroAssignPointer (result.mPointer, gSingleton_typeJoker) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeJoker::actualTypeName (void) const {
  return "typeJoker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeJoker ("typeJoker", gClassInfoFor__typeCible) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeEntiteDest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::
cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteDest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteDest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteDest * ptr = dynamic_cast <const cPtr_typeEntiteDest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aTypeVarDest.operator_isEqual (ptr->aTypeVarDest).boolValue ()
         && mCppName.operator_isEqual (ptr->mCppName).boolValue ()
         && aPositionVariableCible.operator_isEqual (ptr->aPositionVariableCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
method_verifierType (C_Compiler & inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_ioAllVariablesList COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_checkAssignmentTypesCompatibility (inLexique,  aTypeVarDest,  var_cas_typeArgumentFormel,  aPositionVariableCible,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (967)) ;
  var_cas_listeAffectations.addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_ioAllVariablesList.addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteDest:"
           << aTypeVarDest.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aPositionVariableCible.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteDest::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteDest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteDest (& typeid (cPtr_typeEntiteDest), & typeid (cPtr_typeCible), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEntiteDest::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteDest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteDest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteDest (aTypeVarDest, mCppName, aPositionVariableCible COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteDest GGS_typeEntiteDest::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteDest *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteDest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteDest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteDest),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest GGS_typeEntiteDest::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteDest::
reader_aTypeVarDest (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aTypeVarDest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeEntiteDest::
reader_mCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->mCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEntiteDest::
reader_aPositionVariableCible (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aPositionVariableCible ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteDest::actualTypeName (void) const {
  return "typeEntiteDest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteDest ("typeEntiteDest", gClassInfoFor__typeCible) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_M_nonTerminalSymbolForSyntax'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonTerminalSymbolForSyntax::e_M_nonTerminalSymbolForSyntax (void) :
mAltParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAltParametersMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonTerminalSymbolForSyntax::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonTerminalSymbolForSyntax * ptr = dynamic_cast <const elementOf_GGS_M_nonTerminalSymbolForSyntax *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAltParametersMap.operator_isEqual (ptr->mInfo.mAltParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonTerminalSymbolForSyntax info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
operator_isEqual (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
operator_isNotEqual (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAlts & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_nonTerminalSymbolForSyntax::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_nonTerminalSymbolForSyntax::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonterminalSymbolAlts  & GGS_M_nonTerminalSymbolForSyntax::cEnumerator::_mAltParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAltParametersMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_grammarInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::
cPtr_C_grammarInstruction (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_typeCplusPlusName & argument_6,
                                const GGS_typeExpression & argument_7,
                                const GGS_typeExpression & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceIsFile (argument_0),
mSourceExpression (argument_1),
mGrammarName (argument_2),
mExpressionsList (argument_3),
mAltSymbol (argument_4),
mLexiqueClassName (argument_5),
mSentStringName (argument_6),
mDependencyFileExtension (argument_7),
mDependancyFilePath (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarInstruction * ptr = dynamic_cast <const cPtr_C_grammarInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceIsFile.operator_isEqual (ptr->mSourceIsFile).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mGrammarName.operator_isEqual (ptr->mGrammarName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue ()
         && mAltSymbol.operator_isEqual (ptr->mAltSymbol).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue ()
         && mSentStringName.operator_isEqual (ptr->mSentStringName).boolValue ()
         && mDependencyFileExtension.operator_isEqual (ptr->mDependencyFileExtension).boolValue ()
         && mDependancyFilePath.operator_isEqual (ptr->mDependancyFilePath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarInstruction:"
           << mSourceIsFile.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mGrammarName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAltSymbol.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSentStringName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDependencyFileExtension.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDependancyFilePath.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_grammarInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_grammarInstruction (& typeid (cPtr_C_grammarInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_grammarInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_grammarInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_grammarInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_grammarInstruction (mSourceIsFile, mSourceExpression, mGrammarName, mExpressionsList, mAltSymbol, mLexiqueClassName, mSentStringName, mDependencyFileExtension, mDependancyFilePath COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_grammarInstruction GGS_C_grammarInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_grammarInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_grammarInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_grammarInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_grammarInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction GGS_C_grammarInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_typeCplusPlusName & argument_6,
                 const GGS_typeExpression & argument_7,
                 const GGS_typeExpression & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarInstruction::
reader_mSourceIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mGrammarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mGrammarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_C_grammarInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mAltSymbol (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mAltSymbol ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_grammarInstruction::
reader_mSentStringName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSentStringName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mDependencyFileExtension (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mDependencyFileExtension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mDependancyFilePath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mDependancyFilePath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_grammarInstruction::actualTypeName (void) const {
  return "C_grammarInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_grammarInstruction ("C_grammarInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeAppendInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::
cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAppendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAppendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAppendInstruction * ptr = dynamic_cast <const cPtr_typeAppendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpressions.operator_isEqual (ptr->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAppendInstruction:"
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressions.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAppendInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAppendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAppendInstruction (& typeid (cPtr_typeAppendInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeAppendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeAppendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAppendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAppendInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAppendInstruction GGS_typeAppendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAppendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeAppendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAppendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAppendInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction GGS_typeAppendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeAppendInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeAppendInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeAppendInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeAppendInstruction::
reader_mSourceExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAppendInstruction::actualTypeName (void) const {
  return "typeAppendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeAppendInstruction ("typeAppendInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeRemoveInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRemoveInstruction::
cPtr_typeRemoveInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRemoveInstruction * GGS_typeRemoveInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRemoveInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRemoveInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRemoveInstruction * ptr = dynamic_cast <const cPtr_typeRemoveInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpressions.operator_isEqual (ptr->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRemoveInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRemoveInstruction:"
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressions.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRemoveInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRemoveInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRemoveInstruction (& typeid (cPtr_typeRemoveInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeRemoveInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeRemoveInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRemoveInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRemoveInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRemoveInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRemoveInstruction GGS_typeRemoveInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRemoveInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRemoveInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeRemoveInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRemoveInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRemoveInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction GGS_typeRemoveInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRemoveInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRemoveInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeRemoveInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeRemoveInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRemoveInstruction::
reader_mSourceExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRemoveInstruction::actualTypeName (void) const {
  return "typeRemoveInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRemoveInstruction ("typeRemoveInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeIncrementInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::
cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeIncrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeIncrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeIncrementInstruction * ptr = dynamic_cast <const cPtr_typeIncrementInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeIncrementInstruction:"
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeIncrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeIncrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeIncrementInstruction (& typeid (cPtr_typeIncrementInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeIncrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeIncrementInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeIncrementInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeIncrementInstruction (mTargetVarCppName, mStructAttributeList, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeIncrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeIncrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeIncrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeIncrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeIncrementInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeIncrementInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeIncrementInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeIncrementInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeIncrementInstruction::actualTypeName (void) const {
  return "typeIncrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeIncrementInstruction ("typeIncrementInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeDecrementInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::
cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDecrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDecrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDecrementInstruction * ptr = dynamic_cast <const cPtr_typeDecrementInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDecrementInstruction:"
           << mTargetVarCppName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mStructAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDecrementInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDecrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDecrementInstruction (& typeid (cPtr_typeDecrementInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDecrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeDecrementInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDecrementInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDecrementInstruction (mTargetVarCppName, mStructAttributeList, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDecrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeDecrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDecrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDecrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDecrementInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDecrementInstruction::
reader_mTargetVarCppName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeDecrementInstruction::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDecrementInstruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDecrementInstruction::actualTypeName (void) const {
  return "typeDecrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDecrementInstruction ("typeDecrementInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCase1_name (argument_0),
mCase2_name (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_matchInstructionCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_matchInstructionCasesList * ptr = dynamic_cast <const elementOf_GGS_L_matchInstructionCasesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCase1_name.operator_isEqual (ptr->mCase1_name).boolValue ()
         && mCase2_name.operator_isEqual (ptr->mCase2_name).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase1_name.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase2_name.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
operator_concat (const GGS_L_matchInstructionCasesList & inOperand) const {
  GGS_L_matchInstructionCasesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
dotAssign_operation (const GGS_L_matchInstructionCasesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_matchInstructionCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCase1_name ;
          GGS_lstring  p_1 = p->mCase2_name ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mCase1_name,
                                ptr->mCase2_name,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_emptyList (void) {
  GGS_L_matchInstructionCasesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  GGS_L_matchInstructionCasesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalSubListWithRange (GGS_L_matchInstructionCasesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCase1_name, ptr->mCase2_name, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@L_matchInstructionCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_matchInstructionCasesList::
reader_mCase1_nameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCase1_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_matchInstructionCasesList::
reader_mCase2_nameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCase2_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_matchInstructionCasesList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMCase1_nameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCase1_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMCase2_nameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCase2_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_matchInstructionCasesList::cEnumerator::_mCase1_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCase1_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_matchInstructionCasesList::cEnumerator::_mCase2_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCase2_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_matchInstructionCasesList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeMatchInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::
cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMatchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMatchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMatchInstruction * ptr = dynamic_cast <const cPtr_typeMatchInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aIndicatif1.operator_isEqual (ptr->aIndicatif1).boolValue ()
         && aIndicatif2.operator_isEqual (ptr->aIndicatif2).boolValue ()
         && aNomCppVariable1.operator_isEqual (ptr->aNomCppVariable1).boolValue ()
         && aNomCppVariable2.operator_isEqual (ptr->aNomCppVariable2).boolValue ()
         && aNomTypeBase1.operator_isEqual (ptr->aNomTypeBase1).boolValue ()
         && aNomTypeBase2.operator_isEqual (ptr->aNomTypeBase2).boolValue ()
         && mOperand1_isEnumeration.operator_isEqual (ptr->mOperand1_isEnumeration).boolValue ()
         && mOperand2_isEnumeration.operator_isEqual (ptr->mOperand2_isEnumeration).boolValue ()
         && aListeCas.operator_isEqual (ptr->aListeCas).boolValue ()
         && mElseInstructionsList.operator_isEqual (ptr->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMatchInstruction:"
           << aIndicatif1.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aIndicatif2.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppVariable1.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppVariable2.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomTypeBase1.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomTypeBase2.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOperand1_isEnumeration.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2_isEnumeration.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeCas.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMatchInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMatchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMatchInstruction (& typeid (cPtr_typeMatchInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeMatchInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMatchInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMatchInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMatchInstruction (aIndicatif1, aIndicatif2, aNomCppVariable1, aNomCppVariable2, aNomTypeBase1, aNomTypeBase2, mOperand1_isEnumeration, mOperand2_isEnumeration, aListeCas, mElseInstructionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMatchInstruction GGS_typeMatchInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMatchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMatchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMatchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMatchInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction GGS_typeMatchInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_location & argument_1,
                 const GGS_typeCplusPlusName & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_bool& argument_7,
                 const GGS_L_matchInstructionCasesList & argument_8,
                 const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand1_isEnumeration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand1_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand2_isEnumeration (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand2_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_typeMatchInstruction::
reader_aListeCas (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aListeCas ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeMatchInstruction::
reader_mElseInstructionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMatchInstruction::actualTypeName (void) const {
  return "typeMatchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeMatchInstruction ("typeMatchInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mNewStyle (argument_0),
mSourceExpression (argument_1),
mLocationOffset (argument_2),
mCppTypeName (argument_3),
mAscending (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachEnumerationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachEnumerationList * ptr = dynamic_cast <const elementOf_GGS_foreachEnumerationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNewStyle.operator_isEqual (ptr->mNewStyle).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mLocationOffset.operator_isEqual (ptr->mLocationOffset).boolValue ()
         && mCppTypeName.operator_isEqual (ptr->mCppTypeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNewStyle.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationOffset.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppTypeName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalAppendValues (const GGS_bool& argument_0,
                    const GGS_typeExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_string& argument_3,
                    const GGS_bool& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalPrependValues (const GGS_bool& argument_0,
                    const GGS_typeExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_string& argument_3,
                    const GGS_bool& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
operator_concat (const GGS_foreachEnumerationList & inOperand) const {
  GGS_foreachEnumerationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
dotAssign_operation (const GGS_foreachEnumerationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_foreachEnumerationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mNewStyle ;
          GGS_typeExpression  p_1 = p->mSourceExpression ;
          GGS_location  p_2 = p->mLocationOffset ;
          GGS_string p_3 = p->mCppTypeName ;
          GGS_bool p_4 = p->mAscending ;
          _internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_typeExpression & argument_1,
                     const GGS_location & argument_2,
                     const GGS_string& argument_3,
                     const GGS_bool& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mNewStyle,
                                ptr->mSourceExpression,
                                ptr->mLocationOffset,
                                ptr->mCppTypeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_emptyList (void) {
  GGS_foreachEnumerationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4) {
  GGS_foreachEnumerationList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalSubListWithRange (GGS_foreachEnumerationList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mNewStyle, ptr->mSourceExpression, ptr->mLocationOffset, ptr->mCppTypeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachEnumerationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachEnumerationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@foreachEnumerationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_typeExpression & _out_1,
              GGS_location & _out_2,
              GGS_string& _out_3,
              GGS_bool& _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_typeExpression & _out_1,
             GGS_location & _out_2,
             GGS_string& _out_3,
             GGS_bool& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_typeExpression & _out_1,
                 GGS_location & _out_2,
                 GGS_string& _out_3,
                 GGS_bool& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_typeExpression & _out_1,
                GGS_location & _out_2,
                GGS_string& _out_3,
                GGS_bool& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
reader_mNewStyleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNewStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_foreachEnumerationList::
reader_mSourceExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachEnumerationList::
reader_mLocationOffsetAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationOffset ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_mCppTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMNewStyleAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNewStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMSourceExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMLocationOffsetAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationOffset = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMCppTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachEnumerationList::cEnumerator::_mNewStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNewStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_foreachEnumerationList::cEnumerator::_mSourceExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_foreachEnumerationList::cEnumerator::_mLocationOffset (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocationOffset ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_foreachEnumerationList::cEnumerator::_mCppTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachEnumerationList::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeForeachInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::
cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_typeInstructionList & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mIndexVariable (argument_1),
mWhileExpression (argument_2),
mBeforeInstructionList (argument_3),
mDoInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mAfterInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeForeachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeForeachInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeForeachInstruction * ptr = dynamic_cast <const cPtr_typeForeachInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mForeachEnumerationList.operator_isEqual (ptr->mForeachEnumerationList).boolValue ()
         && mIndexVariable.operator_isEqual (ptr->mIndexVariable).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeForeachInstruction:"
           << mForeachEnumerationList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIndexVariable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBeforeInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDoInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBetweenInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAfterInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeForeachInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeForeachInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeForeachInstruction (& typeid (cPtr_typeForeachInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeForeachInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeForeachInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeForeachInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeForeachInstruction (mForeachEnumerationList, mIndexVariable, mWhileExpression, mBeforeInstructionList, mDoInstructionList, mBetweenInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeForeachInstruction GGS_typeForeachInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeForeachInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeForeachInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeForeachInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeForeachInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction GGS_typeForeachInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_foreachEnumerationList & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_typeInstructionList & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_typeForeachInstruction::
reader_mForeachEnumerationList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachEnumerationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mForeachEnumerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeForeachInstruction::
reader_mIndexVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mIndexVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeForeachInstruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeForeachInstruction::actualTypeName (void) const {
  return "typeForeachInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeForeachInstruction ("typeForeachInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeSimpleExtractInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::
cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSimpleExtractInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSimpleExtractInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSimpleExtractInstruction * ptr = dynamic_cast <const cPtr_typeSimpleExtractInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariable.operator_isEqual (ptr->aNomVariable).boolValue ()
         && aNomClasse.operator_isEqual (ptr->aNomClasse).boolValue ()
         && aListeAffectationParametresEffectifs.operator_isEqual (ptr->aListeAffectationParametresEffectifs).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue ()
         && aNomMessage.operator_isEqual (ptr->aNomMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSimpleExtractInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSimpleExtractInstruction:"
           << aNomVariable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomClasse.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeAffectationParametresEffectifs.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocationExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomMessage.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSimpleExtractInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSimpleExtractInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSimpleExtractInstruction (& typeid (cPtr_typeSimpleExtractInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeSimpleExtractInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeSimpleExtractInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSimpleExtractInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSimpleExtractInstruction (aNomVariable, aNomClasse, aListeAffectationParametresEffectifs, mErrorLocationExpression, aNomMessage COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSimpleExtractInstruction GGS_typeSimpleExtractInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSimpleExtractInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeSimpleExtractInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSimpleExtractInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSimpleExtractInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction GGS_typeSimpleExtractInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_assignedVariables & argument_2,
                 const GGS_typeExpression & argument_3,
                 const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeSimpleExtractInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeSimpleExtractInstruction::
reader_aNomVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSimpleExtractInstruction::
reader_aNomClasse (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_typeSimpleExtractInstruction::
reader_aListeAffectationParametresEffectifs (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_assignedVariables   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aListeAffectationParametresEffectifs ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSimpleExtractInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSimpleExtractInstruction::
reader_aNomMessage (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSimpleExtractInstruction::actualTypeName (void) const {
  return "typeSimpleExtractInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeSimpleExtractInstruction ("typeSimpleExtractInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mClassName (argument_0),
mResultVarID (argument_1),
mInstructionList (argument_2),
mNoUsedParameter (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredExtractCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredExtractCasesList * ptr = dynamic_cast <const elementOf_GGS_typeStructuredExtractCasesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mResultVarID.operator_isEqual (ptr->mResultVarID).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mNoUsedParameter.operator_isEqual (ptr->mNoUsedParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mResultVarID.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNoUsedParameter.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
operator_concat (const GGS_typeStructuredExtractCasesList & inOperand) const {
  GGS_typeStructuredExtractCasesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
dotAssign_operation (const GGS_typeStructuredExtractCasesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeStructuredExtractCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mClassName ;
          GGS_location  p_1 = p->mResultVarID ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          GGS_bool p_3 = p->mNoUsedParameter ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_location & argument_1,
                     const GGS_typeInstructionList & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mClassName,
                                ptr->mResultVarID,
                                ptr->mInstructionList,
                                ptr->mNoUsedParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_emptyList (void) {
  GGS_typeStructuredExtractCasesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  GGS_typeStructuredExtractCasesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalSubListWithRange (GGS_typeStructuredExtractCasesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mClassName, ptr->mResultVarID, ptr->mInstructionList, ptr->mNoUsedParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeStructuredExtractCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_location & _out_1,
              GGS_typeInstructionList & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_location & _out_1,
             GGS_typeInstructionList & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_location & _out_1,
                 GGS_typeInstructionList & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_location & _out_1,
                GGS_typeInstructionList & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredExtractCasesList::
reader_mClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStructuredExtractCasesList::
reader_mResultVarIDAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mResultVarID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractCasesList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractCasesList::
reader_mNoUsedParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNoUsedParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMResultVarIDAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mResultVarID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMNoUsedParameterAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNoUsedParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeStructuredExtractCasesList::cEnumerator::_mClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeStructuredExtractCasesList::cEnumerator::_mResultVarID (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mResultVarID ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeStructuredExtractCasesList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeStructuredExtractCasesList::cEnumerator::_mNoUsedParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNoUsedParameter ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_typeStructuredExtractInstructionWithElse'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::
cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStructuredExtractInstructionWithElse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredExtractInstructionWithElse::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredExtractInstructionWithElse * ptr = dynamic_cast <const cPtr_typeStructuredExtractInstructionWithElse *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mCasesList.operator_isEqual (ptr->mCasesList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStructuredExtractInstructionWithElse:"
           << mVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCasesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredExtractInstructionWithElse::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredExtractInstructionWithElse::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStructuredExtractInstructionWithElse (& typeid (cPtr_typeStructuredExtractInstructionWithElse), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeStructuredExtractInstructionWithElse::galgasRTTI (void) const {
  return & gClassInfoFor__typeStructuredExtractInstructionWithElse ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStructuredExtractInstructionWithElse::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStructuredExtractInstructionWithElse (mVariableName, mCasesList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (inPointer) != NULL)
      : (typeid (cPtr_typeStructuredExtractInstructionWithElse) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStructuredExtractInstructionWithElse (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStructuredExtractInstructionWithElse),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeStructuredExtractCasesList & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeStructuredExtractInstructionWithElse::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractInstructionWithElse::
reader_mCasesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mCasesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractInstructionWithElse::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStructuredExtractInstructionWithElse::actualTypeName (void) const {
  return "typeStructuredExtractInstructionWithElse" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStructuredExtractInstructionWithElse ("typeStructuredExtractInstructionWithElse", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_AC_elseOrDefaultForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_elseOrDefaultForCastInstruction::
cPtr_AC_elseOrDefaultForCastInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_elseOrDefaultForCastInstruction * GGS_AC_elseOrDefaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_AC_elseOrDefaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_AC_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_elseOrDefaultForCastInstruction::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@AC_elseOrDefaultForCastInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_elseOrDefaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_elseOrDefaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_elseOrDefaultForCastInstruction (& typeid (cPtr_AC_elseOrDefaultForCastInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_AC_elseOrDefaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__AC_elseOrDefaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_AC_elseOrDefaultForCastInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction::
GGS_AC_elseOrDefaultForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction::
GGS_AC_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_elseOrDefaultForCastInstruction GGS_AC_elseOrDefaultForCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_elseOrDefaultForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_elseOrDefaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_AC_elseOrDefaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_elseOrDefaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_elseOrDefaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_elseOrDefaultForCastInstruction::actualTypeName (void) const {
  return "AC_elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_AC_elseOrDefaultForCastInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__AC_elseOrDefaultForCastInstruction ("AC_elseOrDefaultForCastInstruction") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_elseForCastInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_elseForCastInstruction::
cPtr_C_elseForCastInstruction (const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_elseForCastInstruction * GGS_C_elseForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_elseForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_elseForCastInstruction * ptr = dynamic_cast <const cPtr_C_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_elseForCastInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_elseForCastInstruction:"
           << mElseInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_elseForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_elseForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_elseForCastInstruction (& typeid (cPtr_C_elseForCastInstruction), & typeid (cPtr_AC_elseOrDefaultForCastInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_elseForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_elseForCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_elseForCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_elseForCastInstruction (mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_elseForCastInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction::
GGS_C_elseForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction::
GGS_C_elseForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_elseForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_elseForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_elseForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_elseForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_elseForCastInstruction::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_elseForCastInstruction::actualTypeName (void) const {
  return "C_elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_elseForCastInstruction ("C_elseForCastInstruction", gClassInfoFor__AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_defaultForCastInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_defaultForCastInstruction::
cPtr_C_defaultForCastInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_defaultForCastInstruction * GGS_C_defaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_defaultForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_defaultForCastInstruction * ptr = dynamic_cast <const cPtr_C_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_defaultForCastInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_defaultForCastInstruction:"
           << mErrorLocationExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_defaultForCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_defaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_defaultForCastInstruction (& typeid (cPtr_C_defaultForCastInstruction), & typeid (cPtr_AC_elseOrDefaultForCastInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_defaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_defaultForCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_defaultForCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_defaultForCastInstruction (mErrorLocationExpression, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_defaultForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction::
GGS_C_defaultForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction::
GGS_C_defaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_defaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_defaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_defaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_defaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_defaultForCastInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_defaultForCastInstruction::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_defaultForCastInstruction::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_defaultForCastInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_defaultForCastInstruction::actualTypeName (void) const {
  return "C_defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_defaultForCastInstruction ("C_defaultForCastInstruction", gClassInfoFor__AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeStructuredCastBranchList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredCastBranchList::
elementOf_GGS_typeStructuredCastBranchList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCastClassName (argument_0),
mCheckForKindOfClass (argument_1),
mLocalConstantName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredCastBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredCastBranchList * ptr = dynamic_cast <const elementOf_GGS_typeStructuredCastBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastClassName.operator_isEqual (ptr->mCastClassName).boolValue ()
         && mCheckForKindOfClass.operator_isEqual (ptr->mCheckForKindOfClass).boolValue ()
         && mLocalConstantName.operator_isEqual (ptr->mLocalConstantName).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredCastBranchList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastClassName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCheckForKindOfClass.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocalConstantName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeStructuredCastBranchList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_typeCplusPlusNameList & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_typeCplusPlusNameList & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
operator_concat (const GGS_typeStructuredCastBranchList & inOperand) const {
  GGS_typeStructuredCastBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
dotAssign_operation (const GGS_typeStructuredCastBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeStructuredCastBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCastClassName ;
          GGS_bool p_1 = p->mCheckForKindOfClass ;
          GGS_typeCplusPlusNameList  p_2 = p->mLocalConstantName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1,
                     const GGS_typeCplusPlusNameList & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mCastClassName,
                                ptr->mCheckForKindOfClass,
                                ptr->mLocalConstantName,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastBranchList::
constructor_emptyList (void) {
  GGS_typeStructuredCastBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastBranchList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  GGS_typeStructuredCastBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
internalSubListWithRange (GGS_typeStructuredCastBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCastClassName, ptr->mCheckForKindOfClass, ptr->mLocalConstantName, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredCastBranchList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeStructuredCastBranchList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1,
              GGS_typeCplusPlusNameList & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1,
             GGS_typeCplusPlusNameList & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1,
                 GGS_typeCplusPlusNameList & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1,
                GGS_typeCplusPlusNameList & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredCastBranchList::
reader_mCastClassNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredCastBranchList::
reader_mCheckForKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCheckForKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeStructuredCastBranchList::
reader_mLocalConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocalConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredCastBranchList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMCastClassNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMCheckForKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCheckForKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMLocalConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_typeCplusPlusNameList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocalConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeStructuredCastBranchList::cEnumerator::_mCastClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCastClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeStructuredCastBranchList::cEnumerator::_mCheckForKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCheckForKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusNameList  & GGS_typeStructuredCastBranchList::cEnumerator::_mLocalConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocalConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeStructuredCastBranchList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeStructuredCastInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredCastInstruction::
cPtr_typeStructuredCastInstruction (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeStructuredCastBranchList & argument_3,
                                const GGS_AC_elseOrDefaultForCastInstruction & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCastInstructionLocation (argument_0),
mSourceExpression (argument_1),
mSourceExpressionTypeName (argument_2),
mBranchList (argument_3),
mElseOrDefault (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredCastInstruction * GGS_typeStructuredCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStructuredCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredCastInstruction * ptr = dynamic_cast <const cPtr_typeStructuredCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastInstructionLocation.operator_isEqual (ptr->mCastInstructionLocation).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionTypeName.operator_isEqual (ptr->mSourceExpressionTypeName).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue ()
         && mElseOrDefault.operator_isEqual (ptr->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredCastInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStructuredCastInstruction:"
           << mCastInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseOrDefault.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredCastInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStructuredCastInstruction (& typeid (cPtr_typeStructuredCastInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeStructuredCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeStructuredCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStructuredCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStructuredCastInstruction (mCastInstructionLocation, mSourceExpression, mSourceExpressionTypeName, mBranchList, mElseOrDefault COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeStructuredCastInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction::
GGS_typeStructuredCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction::
GGS_typeStructuredCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStructuredCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeStructuredCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStructuredCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStructuredCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeStructuredCastBranchList & argument_3,
                 const GGS_AC_elseOrDefaultForCastInstruction & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredCastInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStructuredCastInstruction::
reader_mCastInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mCastInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStructuredCastInstruction::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredCastInstruction::
reader_mSourceExpressionTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mSourceExpressionTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastInstruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction  GGS_typeStructuredCastInstruction::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStructuredCastInstruction::actualTypeName (void) const {
  return "typeStructuredCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeStructuredCastInstruction ("typeStructuredCastInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeRoutineCallInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::
cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mRoutineName (argument_0),
mExpressionsList (argument_1),
mFormalParameterList (argument_2),
mIsExternActionCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineCallInstruction * ptr = dynamic_cast <const cPtr_typeRoutineCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mIsExternActionCall.operator_isEqual (ptr->mIsExternActionCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineCallInstruction:"
           << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mFormalParameterList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIsExternActionCall.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineCallInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineCallInstruction (& typeid (cPtr_typeRoutineCallInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeRoutineCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeRoutineCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRoutineCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRoutineCallInstruction (mRoutineName, mExpressionsList, mFormalParameterList, mIsExternActionCall COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRoutineCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_L_EXsignature & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeRoutineCallInstruction::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRoutineCallInstruction::
reader_mExpressionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeRoutineCallInstruction::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineCallInstruction::
reader_mIsExternActionCall (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mIsExternActionCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineCallInstruction::actualTypeName (void) const {
  return "typeRoutineCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRoutineCallInstruction ("typeRoutineCallInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeLogInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogInstruction::
cPtr_typeLogInstruction (const GGS_lstring & argument_0,
                                const GGS_typeCplusPlusName & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mGalgasVariableName (argument_0),
mLoggedVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogInstruction * GGS_typeLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogInstruction * ptr = dynamic_cast <const cPtr_typeLogInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGalgasVariableName.operator_isEqual (ptr->mGalgasVariableName).boolValue ()
         && mLoggedVariable.operator_isEqual (ptr->mLoggedVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLogInstruction:"
           << mGalgasVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLoggedVariable.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLogInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLogInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLogInstruction (& typeid (cPtr_typeLogInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeLogInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeLogInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLogInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLogInstruction (mGalgasVariableName, mLoggedVariable COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeLogInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLogInstruction GGS_typeLogInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLogInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLogInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLogInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLogInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction GGS_typeLogInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeCplusPlusName & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLogInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLogInstruction::
reader_mGalgasVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mGalgasVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeLogInstruction::
reader_mLoggedVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mLoggedVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLogInstruction::actualTypeName (void) const {
  return "typeLogInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeLogInstruction ("typeLogInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeDropInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::
cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDropInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDropInstruction * ptr = dynamic_cast <const cPtr_typeDropInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aVariableConsommee.operator_isEqual (ptr->aVariableConsommee).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDropInstruction:"
           << aVariableConsommee.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDropInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDropInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDropInstruction (& typeid (cPtr_typeDropInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDropInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeDropInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDropInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDropInstruction (aVariableConsommee COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDropInstruction GGS_typeDropInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDropInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeDropInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDropInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDropInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction GGS_typeDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDropInstruction::
reader_aVariableConsommee (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDropInstruction *) mPointer)->aVariableConsommee ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDropInstruction::actualTypeName (void) const {
  return "typeDropInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDropInstruction ("typeDropInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableNomRoutinesDeclarees'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableNomRoutinesDeclarees::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableNomRoutinesDeclarees info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
operator_isEqual (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
operator_isNotEqual (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableNomRoutinesDeclarees::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeEntityToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntityToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntityToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeEntityToGenerate::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeEntityToGenerate:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntityToGenerate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntityToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntityToGenerate (& typeid (cPtr_typeEntityToGenerate), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEntityToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntityToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntityToGenerate GGS_typeEntityToGenerate::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntityToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntityToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntityToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntityToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntityToGenerate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntityToGenerate::actualTypeName (void) const {
  return "typeEntityToGenerate" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * GGS_typeEntityToGenerate::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformation * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformation gClassInfoFor__typeEntityToGenerate ("typeEntityToGenerate") ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeExternTypeToGenerate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::
cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_externTypeConstructorMap & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mConstructorMap (argument_1),
mModifiersMap (argument_2),
mReadersInInstructionMap (argument_3),
mAcceptAddAssignOperatorCall (argument_4),
mAddAssignOperatorCallTypeList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeExternTypeToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeExternTypeToGenerate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeExternTypeToGenerate * ptr = dynamic_cast <const cPtr_typeExternTypeToGenerate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGalgasName.operator_isEqual (ptr->mGalgasName).boolValue ()
         && mConstructorMap.operator_isEqual (ptr->mConstructorMap).boolValue ()
         && mModifiersMap.operator_isEqual (ptr->mModifiersMap).boolValue ()
         && mReadersInInstructionMap.operator_isEqual (ptr->mReadersInInstructionMap).boolValue ()
         && mAcceptAddAssignOperatorCall.operator_isEqual (ptr->mAcceptAddAssignOperatorCall).boolValue ()
         && mAddAssignOperatorCallTypeList.operator_isEqual (ptr->mAddAssignOperatorCallTypeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeExternTypeToGenerate:"
           << mGalgasName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstructorMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mModifiersMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReadersInInstructionMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAcceptAddAssignOperatorCall.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAddAssignOperatorCallTypeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeExternTypeToGenerate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeExternTypeToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeExternTypeToGenerate (& typeid (cPtr_typeExternTypeToGenerate), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeExternTypeToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeExternTypeToGenerate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeExternTypeToGenerate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeExternTypeToGenerate (mGalgasName, mConstructorMap, mModifiersMap, mReadersInInstructionMap, mAcceptAddAssignOperatorCall, mAddAssignOperatorCallTypeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeExternTypeToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeExternTypeToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeExternTypeToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeExternTypeToGenerate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_externTypeConstructorMap & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeExternTypeToGenerate::actualTypeName (void) const {
  return "typeExternTypeToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeExternTypeToGenerate ("typeExternTypeToGenerate", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeRoutineAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::
cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mRoutineName (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineAengendrer * ptr = dynamic_cast <const cPtr_typeRoutineAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineAengendrer:"
           << mRoutineName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineAengendrer (& typeid (cPtr_typeRoutineAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeRoutineAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeRoutineAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRoutineAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRoutineAengendrer (mRoutineName, aListeTypeEtNomsArguments, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRoutineAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineAengendrer::actualTypeName (void) const {
  return "typeRoutineAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRoutineAengendrer ("typeRoutineAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeFonctionAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFonctionAengendrer::
cPtr_typeFonctionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_AC_galgasType & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_typeInstructionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mFunctionName (argument_0),
aListeTypeEtNomsArguments (argument_1),
mReturnedType (argument_2),
mReturnedVar (argument_3),
mInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFonctionAengendrer * GGS_typeFonctionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFonctionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFonctionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFonctionAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFonctionAengendrer * ptr = dynamic_cast <const cPtr_typeFonctionAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue ()
         && mReturnedVar.operator_isEqual (ptr->mReturnedVar).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFonctionAengendrer::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFonctionAengendrer:"
           << mFunctionName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedVar.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFonctionAengendrer (& typeid (cPtr_typeFonctionAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFonctionAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeFonctionAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFonctionAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFonctionAengendrer (mFunctionName, aListeTypeEtNomsArguments, mReturnedType, mReturnedVar, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeFonctionAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer::
GGS_typeFonctionAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer::
GGS_typeFonctionAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFonctionAengendrer GGS_typeFonctionAengendrer::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFonctionAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFonctionAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeFonctionAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFonctionAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFonctionAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer GGS_typeFonctionAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_AC_galgasType & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_typeInstructionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeFonctionAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeFonctionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFonctionAengendrer::actualTypeName (void) const {
  return "typeFonctionAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFonctionAengendrer ("typeFonctionAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_categoryMethodToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryMethodToImplement::
cPtr_categoryMethodToImplement (const GGS_categoryMethodKind& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_location & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mCategoryMethodKind (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryMethodToImplement * GGS_categoryMethodToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryMethodToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_categoryMethodToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryMethodToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryMethodToImplement * ptr = dynamic_cast <const cPtr_categoryMethodToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodKind.operator_isEqual (ptr->mCategoryMethodKind).boolValue ()
         && mBaseClassName.operator_isEqual (ptr->mBaseClassName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryMethodToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@categoryMethodToImplement:"
           << mCategoryMethodKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBaseClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMagicNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryMethodToImplement (& typeid (cPtr_categoryMethodToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_categoryMethodToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__categoryMethodToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryMethodToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryMethodToImplement (mCategoryMethodKind, mBaseClassName, mClassName, mMethodName, aListeTypeEtNomsArguments, mInstructionList, mMagicNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_categoryMethodToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement::
GGS_categoryMethodToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement::
GGS_categoryMethodToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryMethodToImplement GGS_categoryMethodToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryMethodToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryMethodToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryMethodToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryMethodToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement GGS_categoryMethodToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_categoryMethodKind& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_location & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryMethodToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodToImplement::actualTypeName (void) const {
  return "categoryMethodToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__categoryMethodToImplement ("categoryMethodToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_categoryReaderToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryReaderToImplement::
cPtr_categoryReaderToImplement (const GGS_categoryMethodKind& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_location & argument_6,
                                const GGS_AC_galgasType & argument_7,
                                const GGS_typeCplusPlusName & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mCategoryMethodKind (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6),
mReturnedType (argument_7),
mReturnedCppVariableName (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryReaderToImplement * GGS_categoryReaderToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryReaderToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_categoryReaderToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryReaderToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryReaderToImplement * ptr = dynamic_cast <const cPtr_categoryReaderToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodKind.operator_isEqual (ptr->mCategoryMethodKind).boolValue ()
         && mBaseClassName.operator_isEqual (ptr->mBaseClassName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue ()
         && mReturnedCppVariableName.operator_isEqual (ptr->mReturnedCppVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryReaderToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@categoryReaderToImplement:"
           << mCategoryMethodKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBaseClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMagicNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedType.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedCppVariableName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryReaderToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryReaderToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryReaderToImplement (& typeid (cPtr_categoryReaderToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_categoryReaderToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__categoryReaderToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryReaderToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryReaderToImplement (mCategoryMethodKind, mBaseClassName, mClassName, mMethodName, aListeTypeEtNomsArguments, mInstructionList, mMagicNumber, mReturnedType, mReturnedCppVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_categoryReaderToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement::
GGS_categoryReaderToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement::
GGS_categoryReaderToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryReaderToImplement GGS_categoryReaderToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryReaderToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryReaderToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryReaderToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryReaderToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryReaderToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement GGS_categoryReaderToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_categoryMethodKind& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_location & argument_6,
                 const GGS_AC_galgasType & argument_7,
                 const GGS_typeCplusPlusName & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_categoryReaderToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryReaderToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryReaderToImplement::actualTypeName (void) const {
  return "categoryReaderToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__categoryReaderToImplement ("categoryReaderToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_categoryTemplateToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryTemplateToImplement::
cPtr_categoryTemplateToImplement (const GGS_categoryMethodKind& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_templateInstructionList & argument_5,
                                const GGS_location & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mCategoryMethodKind (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryTemplateToImplement * GGS_categoryTemplateToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_categoryTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_categoryTemplateToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryTemplateToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryTemplateToImplement * ptr = dynamic_cast <const cPtr_categoryTemplateToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodKind.operator_isEqual (ptr->mCategoryMethodKind).boolValue ()
         && mBaseClassName.operator_isEqual (ptr->mBaseClassName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryTemplateToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@categoryTemplateToImplement:"
           << mCategoryMethodKind.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBaseClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMagicNumber.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryTemplateToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryTemplateToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryTemplateToImplement (& typeid (cPtr_categoryTemplateToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_categoryTemplateToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__categoryTemplateToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryTemplateToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryTemplateToImplement (mCategoryMethodKind, mBaseClassName, mClassName, mMethodName, aListeTypeEtNomsArguments, mInstructionList, mMagicNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_categoryTemplateToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement::
GGS_categoryTemplateToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement::
GGS_categoryTemplateToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryTemplateToImplement GGS_categoryTemplateToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryTemplateToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryTemplateToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryTemplateToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryTemplateToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryTemplateToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement GGS_categoryTemplateToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_categoryMethodKind& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_templateInstructionList & argument_5,
                 const GGS_location & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_categoryTemplateToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryTemplateToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryTemplateToImplement::actualTypeName (void) const {
  return "categoryTemplateToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__categoryTemplateToImplement ("categoryTemplateToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_listTypeToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::
cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_listTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_listTypeToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_listTypeToImplement * ptr = dynamic_cast <const cPtr_C_listTypeToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomListe.operator_isEqual (ptr->aNomListe).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_listTypeToImplement:"
           << aNomListe.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_listTypeToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_listTypeToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_listTypeToImplement (& typeid (cPtr_C_listTypeToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_listTypeToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_listTypeToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_listTypeToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_listTypeToImplement (aNomListe, mNonExternAttributesList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_listTypeToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_listTypeToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_listTypeToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_listTypeToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_listTypeToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_listTypeToImplement::actualTypeName (void) const {
  return "C_listTypeToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_listTypeToImplement ("C_listTypeToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@EXsortDescriptorList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_EXsortDescriptorList::
elementOf_GGS_EXsortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSortAttribute (argument_0),
mAscendingOrder (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXsortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_EXsortDescriptorList * ptr = dynamic_cast <const elementOf_GGS_EXsortDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortAttribute.operator_isEqual (ptr->mSortAttribute).boolValue ()
         && mAscendingOrder.operator_isEqual (ptr->mAscendingOrder).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXsortDescriptorList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortAttribute.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscendingOrder.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@EXsortDescriptorList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
operator_concat (const GGS_EXsortDescriptorList & inOperand) const {
  GGS_EXsortDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
dotAssign_operation (const GGS_EXsortDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_EXsortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortAttribute ;
          GGS_bool p_1 = p->mAscendingOrder ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSortAttribute,
                                ptr->mAscendingOrder
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_EXsortDescriptorList::
constructor_emptyList (void) {
  GGS_EXsortDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_EXsortDescriptorList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_EXsortDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
internalSubListWithRange (GGS_EXsortDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSortAttribute, ptr->mAscendingOrder) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsortDescriptorList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@EXsortDescriptorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_EXsortDescriptorList::
reader_mSortAttributeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortAttribute ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsortDescriptorList::
reader_mAscendingOrderAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscendingOrder ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_setMSortAttributeAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortAttribute = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_setMAscendingOrderAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscendingOrder = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_EXsortDescriptorList::cEnumerator::_mSortAttribute (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortAttribute ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_EXsortDescriptorList::cEnumerator::_mAscendingOrder (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscendingOrder ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_sortedListTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_sortedListTypeToImplement::
cPtr_C_sortedListTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_EXsortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_sortedListTypeToImplement * GGS_C_sortedListTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_sortedListTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_sortedListTypeToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_sortedListTypeToImplement * ptr = dynamic_cast <const cPtr_C_sortedListTypeToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomListe.operator_isEqual (ptr->aNomListe).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_sortedListTypeToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_sortedListTypeToImplement:"
           << aNomListe.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSortDescriptorList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_sortedListTypeToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_sortedListTypeToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_sortedListTypeToImplement (& typeid (cPtr_C_sortedListTypeToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_sortedListTypeToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_sortedListTypeToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_sortedListTypeToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_sortedListTypeToImplement (aNomListe, mNonExternAttributesList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_sortedListTypeToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_sortedListTypeToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_sortedListTypeToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_sortedListTypeToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_EXsortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_sortedListTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_sortedListTypeToImplement::actualTypeName (void) const {
  return "C_sortedListTypeToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_sortedListTypeToImplement ("C_sortedListTypeToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeDefinitionTableAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::
cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
aNomClasseGenerique (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
aTableMethodesSurcharger (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefinitionTableAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDefinitionTableAimplementer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDefinitionTableAimplementer * ptr = dynamic_cast <const cPtr_typeDefinitionTableAimplementer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomTable.operator_isEqual (ptr->aNomTable).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue ()
         && aNomClasseGenerique.operator_isEqual (ptr->aNomClasseGenerique).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && aTableMethodesSurcharger.operator_isEqual (ptr->aTableMethodesSurcharger).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDefinitionTableAimplementer:"
           << aNomTable.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aNomClasseGenerique.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aTableMethodesSurcharger.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDefinitionTableAimplementer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefinitionTableAimplementer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDefinitionTableAimplementer (& typeid (cPtr_typeDefinitionTableAimplementer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeDefinitionTableAimplementer::galgasRTTI (void) const {
  return & gClassInfoFor__typeDefinitionTableAimplementer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDefinitionTableAimplementer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDefinitionTableAimplementer (aNomTable, mNonExternAttributesList, aNomClasseGenerique, mInsertMethodList, mSearchMethodList, aTableMethodesSurcharger COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (inPointer) != NULL)
      : (typeid (cPtr_typeDefinitionTableAimplementer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDefinitionTableAimplementer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDefinitionTableAimplementer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  macroMyNew (result.mPointer, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDefinitionTableAimplementer::actualTypeName (void) const {
  return "typeDefinitionTableAimplementer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeDefinitionTableAimplementer ("typeDefinitionTableAimplementer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_mapToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::
cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeListeAttributsSemantiques & argument_3,
                                const GGS_typeSemanticAttributesMap & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_insertOrSearchMethodList & argument_6,
                                const GGS_insertOrSearchMethodList & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapTypeName (argument_0),
mEnumTypeName (argument_1),
mCheckFinalStateMethod (argument_2),
mNonExternAttributesList (argument_3),
mAttributeMap (argument_4),
mInsertMethodList (argument_5),
mSearchMethodList (argument_6),
mRemoveMethodList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapToImplement * ptr = dynamic_cast <const cPtr_C_mapToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mCheckFinalStateMethod.operator_isEqual (ptr->mCheckFinalStateMethod).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue ()
         && mAttributeMap.operator_isEqual (ptr->mAttributeMap).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapToImplement:"
           << mMapTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEnumTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mCheckFinalStateMethod.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRemoveMethodList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_mapToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_mapToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_mapToImplement (& typeid (cPtr_C_mapToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_mapToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_mapToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_mapToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_mapToImplement (mMapTypeName, mEnumTypeName, mCheckFinalStateMethod, mNonExternAttributesList, mAttributeMap, mInsertMethodList, mSearchMethodList, mRemoveMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_mapToImplement GGS_C_mapToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_mapToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_mapToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_mapToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_mapToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement GGS_C_mapToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeListeAttributsSemantiques & argument_3,
                 const GGS_typeSemanticAttributesMap & argument_4,
                 const GGS_insertOrSearchMethodList & argument_5,
                 const GGS_insertOrSearchMethodList & argument_6,
                 const GGS_insertOrSearchMethodList & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_mapToImplement::actualTypeName (void) const {
  return "C_mapToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_mapToImplement ("C_mapToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_classToImplement'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_classToImplement::
cPtr_C_classToImplement (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_string& argument_8,
                                const GGS_bool& argument_9,
                                const GGS_L_lazyAttributeList & argument_10,
                                const GGS_typeListeAttributsSemantiques & argument_11,
                                const GGS_typeListeAttributsSemantiques & argument_12
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
mIsAbstract (argument_1),
aListeTousAttributsNonExternes (argument_2),
aTableToutesMethodes (argument_3),
mMethodsMap (argument_4),
aListeAttributsCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7),
mClassMessage (argument_8),
mHasGeneratedInSeparateFileSetting (argument_9),
mLazyAttributeList (argument_10),
mSetterAttributeModifierToImplementList (argument_11),
mGetterAttributeReaderToImplementList (argument_12) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_classToImplement * GGS_C_classToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_classToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_classToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_classToImplement * ptr = dynamic_cast <const cPtr_C_classToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomClasse.operator_isEqual (ptr->aNomClasse).boolValue ()
         && mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && aListeTousAttributsNonExternes.operator_isEqual (ptr->aListeTousAttributsNonExternes).boolValue ()
         && aTableToutesMethodes.operator_isEqual (ptr->aTableToutesMethodes).boolValue ()
         && mMethodsMap.operator_isEqual (ptr->mMethodsMap).boolValue ()
         && aListeAttributsCourants.operator_isEqual (ptr->aListeAttributsCourants).boolValue ()
         && mAncestorClassesMap.operator_isEqual (ptr->mAncestorClassesMap).boolValue ()
         && mMessagesMap.operator_isEqual (ptr->mMessagesMap).boolValue ()
         && mClassMessage.operator_isEqual (ptr->mClassMessage).boolValue ()
         && mHasGeneratedInSeparateFileSetting.operator_isEqual (ptr->mHasGeneratedInSeparateFileSetting).boolValue ()
         && mLazyAttributeList.operator_isEqual (ptr->mLazyAttributeList).boolValue ()
         && mSetterAttributeModifierToImplementList.operator_isEqual (ptr->mSetterAttributeModifierToImplementList).boolValue ()
         && mGetterAttributeReaderToImplementList.operator_isEqual (ptr->mGetterAttributeReaderToImplementList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_classToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_classToImplement:"
           << aNomClasse.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mIsAbstract.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTousAttributsNonExternes.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aTableToutesMethodes.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodsMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeAttributsCourants.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAncestorClassesMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mClassMessage.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mHasGeneratedInSeparateFileSetting.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLazyAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSetterAttributeModifierToImplementList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mGetterAttributeReaderToImplementList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_classToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_classToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_classToImplement (& typeid (cPtr_C_classToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_classToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_classToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_classToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_classToImplement (aNomClasse, mIsAbstract, aListeTousAttributsNonExternes, aTableToutesMethodes, mMethodsMap, aListeAttributsCourants, mAncestorClassesMap, mMessagesMap, mClassMessage, mHasGeneratedInSeparateFileSetting, mLazyAttributeList, mSetterAttributeModifierToImplementList, mGetterAttributeReaderToImplementList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_classToImplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_classToImplement GGS_C_classToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_classToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_classToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_classToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_classToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement GGS_C_classToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_typeTableMethodesAimplementer & argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5,
                 const GGS_typeSuperClassesMap & argument_6,
                 const GGS_typeClassMessagesMap & argument_7,
                 const GGS_string& argument_8,
                 const GGS_bool& argument_9,
                 const GGS_L_lazyAttributeList & argument_10,
                 const GGS_typeListeAttributsSemantiques & argument_11,
                 const GGS_typeListeAttributsSemantiques & argument_12
                                COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_classToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_classToImplement::actualTypeName (void) const {
  return "C_classToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_classToImplement ("C_classToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_mapindexToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapindexToImplement::
cPtr_C_mapindexToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_mapIndexSearchReaderMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapindexTypeName (argument_0),
mMapTypeName (argument_1),
mMapAttributesList (argument_2),
mMapIndexSearchReaderMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapindexToImplement * GGS_C_mapindexToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapindexToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapindexToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapindexToImplement * ptr = dynamic_cast <const cPtr_C_mapindexToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapindexTypeName.operator_isEqual (ptr->mMapindexTypeName).boolValue ()
         && mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mMapAttributesList.operator_isEqual (ptr->mMapAttributesList).boolValue ()
         && mMapIndexSearchReaderMap.operator_isEqual (ptr->mMapIndexSearchReaderMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapindexToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapindexToImplement:"
           << mMapindexTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMapAttributesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMapIndexSearchReaderMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_mapindexToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_mapindexToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_mapindexToImplement (& typeid (cPtr_C_mapindexToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_mapindexToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_mapindexToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_mapindexToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_mapindexToImplement (mMapindexTypeName, mMapTypeName, mMapAttributesList, mMapIndexSearchReaderMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_mapindexToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_mapindexToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_mapindexToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_mapindexToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_mapindexToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_mapIndexSearchReaderMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapindexToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_mapindexToImplement::actualTypeName (void) const {
  return "C_mapindexToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_mapindexToImplement ("C_mapindexToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_domainToImplement'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_domainToImplement::
cPtr_C_domainToImplement (const GGS_lstring & argument_0,
                                const GGS_domainAttributeMap & argument_1,
                                const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mDomainName (argument_0),
mAttributeMap (argument_1),
mRelationMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_domainToImplement * GGS_C_domainToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_domainToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_domainToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_domainToImplement * ptr = dynamic_cast <const cPtr_C_domainToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDomainName.operator_isEqual (ptr->mDomainName).boolValue ()
         && mAttributeMap.operator_isEqual (ptr->mAttributeMap).boolValue ()
         && mRelationMap.operator_isEqual (ptr->mRelationMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_domainToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_domainToImplement:"
           << mDomainName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRelationMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_domainToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_domainToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_domainToImplement (& typeid (cPtr_C_domainToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_domainToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_domainToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_domainToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_domainToImplement (mDomainName, mAttributeMap, mRelationMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_domainToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_domainToImplement GGS_C_domainToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_domainToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_domainToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_domainToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_domainToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement GGS_C_domainToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_domainAttributeMap & argument_1,
                 const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_domainToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_domainToImplement::actualTypeName (void) const {
  return "C_domainToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_domainToImplement ("C_domainToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeEntiteRoutineExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutineExterne::
cPtr_typeEntiteRoutineExterne (const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteRoutineExterne * GGS_typeEntiteRoutineExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutineExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteRoutineExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteRoutineExterne::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteRoutineExterne * ptr = dynamic_cast <const cPtr_typeEntiteRoutineExterne *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aSignature.operator_isEqual (ptr->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutineExterne::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteRoutineExterne:"
           << aSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
static_string_message_messageTypeEntite (void) {
  return "an extern routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
message_messageTypeEntite (void) const {
  return "an extern routine" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
_message (void) const {
  return "an extern routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
_static_message (void) {
  return "an extern routine" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteRoutineExterne (& typeid (cPtr_typeEntiteRoutineExterne), & typeid (cPtr_AC_semanticsEntity), "an extern routine") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEntiteRoutineExterne::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteRoutineExterne ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteRoutineExterne::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteRoutineExterne (aSignature COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeEntiteRoutineExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne::
GGS_typeEntiteRoutineExterne (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne::
GGS_typeEntiteRoutineExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteRoutineExterne GGS_typeEntiteRoutineExterne::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutineExterne result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteRoutineExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteRoutineExterne) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteRoutineExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteRoutineExterne),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne GGS_typeEntiteRoutineExterne::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutineExterne result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteRoutineExterne (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteRoutineExterne::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutineExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteRoutineExterne * p = (cPtr_typeEntiteRoutineExterne *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteRoutineExterne::
reader_aSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutineExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteRoutineExterne *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteRoutineExterne::actualTypeName (void) const {
  return "typeEntiteRoutineExterne" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteRoutineExterne ("typeEntiteRoutineExterne", gClassInfoFor__AC_semanticsEntity) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeEntiteFonctionExterne'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteFonctionExterne::
cPtr_typeEntiteFonctionExterne (const GGS_L_EXsignature & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0),
mReturnedType (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteFonctionExterne * GGS_typeEntiteFonctionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteFonctionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteFonctionExterne::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteFonctionExterne * ptr = dynamic_cast <const cPtr_typeEntiteFonctionExterne *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aSignature.operator_isEqual (ptr->aSignature).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteFonctionExterne::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteFonctionExterne:"
           << aSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedType.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
static_string_message_messageTypeEntite (void) {
  return "an extern function" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
message_messageTypeEntite (void) const {
  return "an extern function" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
_message (void) const {
  return "an extern function" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
_static_message (void) {
  return "an extern function" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteFonctionExterne (& typeid (cPtr_typeEntiteFonctionExterne), & typeid (cPtr_AC_semanticsEntity), "an extern function") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeEntiteFonctionExterne::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteFonctionExterne ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteFonctionExterne::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteFonctionExterne (aSignature, mReturnedType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeEntiteFonctionExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne::
GGS_typeEntiteFonctionExterne (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne::
GGS_typeEntiteFonctionExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteFonctionExterne GGS_typeEntiteFonctionExterne::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonctionExterne result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteFonctionExterne) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteFonctionExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteFonctionExterne),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne GGS_typeEntiteFonctionExterne::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_EXsignature & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonctionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteFonctionExterne (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteFonctionExterne::
reader_messageTypeEntite (C_Compiler & /* inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeEntiteFonctionExterne * p = (cPtr_typeEntiteFonctionExterne *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteFonctionExterne::
reader_aSignature (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteFonctionExterne *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteFonctionExterne::
reader_mReturnedType (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteFonctionExterne *) mPointer)->mReturnedType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteFonctionExterne::actualTypeName (void) const {
  return "typeEntiteFonctionExterne" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeEntiteFonctionExterne ("typeEntiteFonctionExterne", gClassInfoFor__AC_semanticsEntity) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeRoutineExterneAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineExterneAengendrer::
cPtr_typeRoutineExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineExterneAengendrer * GGS_typeRoutineExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineExterneAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineExterneAengendrer * ptr = dynamic_cast <const cPtr_typeRoutineExterneAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomAction.operator_isEqual (ptr->aNomAction).boolValue ()
         && aSignature.operator_isEqual (ptr->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineExterneAengendrer::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineExterneAengendrer:"
           << aNomAction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineExterneAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineExterneAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineExterneAengendrer (& typeid (cPtr_typeRoutineExterneAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeRoutineExterneAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeRoutineExterneAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRoutineExterneAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRoutineExterneAengendrer (aNomAction, aSignature COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeRoutineExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer::
GGS_typeRoutineExterneAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer::
GGS_typeRoutineExterneAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRoutineExterneAengendrer GGS_typeRoutineExterneAengendrer::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineExterneAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineExterneAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineExterneAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRoutineExterneAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineExterneAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer GGS_typeRoutineExterneAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineExterneAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineExterneAengendrer::actualTypeName (void) const {
  return "typeRoutineExterneAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeRoutineExterneAengendrer ("typeRoutineExterneAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeFonctionExterneAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFonctionExterneAengendrer::
cPtr_typeFonctionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1,
                                const GGS_AC_galgasType & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1),
mReturnedType (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFonctionExterneAengendrer * GGS_typeFonctionExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFonctionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFonctionExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFonctionExterneAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFonctionExterneAengendrer * ptr = dynamic_cast <const cPtr_typeFonctionExterneAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomAction.operator_isEqual (ptr->aNomAction).boolValue ()
         && aSignature.operator_isEqual (ptr->aSignature).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFonctionExterneAengendrer::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFonctionExterneAengendrer:"
           << aNomAction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedType.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionExterneAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionExterneAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFonctionExterneAengendrer (& typeid (cPtr_typeFonctionExterneAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeFonctionExterneAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeFonctionExterneAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFonctionExterneAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFonctionExterneAengendrer (aNomAction, aSignature, mReturnedType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFonctionExterneAengendrer'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer::
GGS_typeFonctionExterneAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer::
GGS_typeFonctionExterneAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFonctionExterneAengendrer GGS_typeFonctionExterneAengendrer::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFonctionExterneAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFonctionExterneAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeFonctionExterneAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFonctionExterneAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFonctionExterneAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer GGS_typeFonctionExterneAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1,
                 const GGS_AC_galgasType & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFonctionExterneAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeFonctionExterneAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFonctionExterneAengendrer::actualTypeName (void) const {
  return "typeFonctionExterneAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeFonctionExterneAengendrer ("typeFonctionExterneAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntityToGenerate (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEntitiesToGenerateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeEntitiesToGenerateList * ptr = dynamic_cast <const elementOf_GGS_typeEntitiesToGenerateList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntityToGenerate.operator_isEqual (ptr->mEntityToGenerate).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityToGenerate.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalAppendValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalPrependValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
operator_concat (const GGS_typeEntitiesToGenerateList & inOperand) const {
  GGS_typeEntitiesToGenerateList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
dotAssign_operation (const GGS_typeEntitiesToGenerateList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeEntitiesToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeEntityToGenerate  p_0 = p->mEntityToGenerate ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeEntityToGenerate & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mEntityToGenerate
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_emptyList (void) {
  GGS_typeEntitiesToGenerateList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_listWithValue (const GGS_typeEntityToGenerate & argument_0) {
  GGS_typeEntitiesToGenerateList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalSubListWithRange (GGS_typeEntitiesToGenerateList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntityToGenerate) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeEntitiesToGenerateList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeEntitiesToGenerateList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeEntitiesToGenerateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_first (C_Compiler & inLexique,
              GGS_typeEntityToGenerate & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_last (C_Compiler & inLexique,
             GGS_typeEntityToGenerate & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeEntityToGenerate & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeEntityToGenerate & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate  GGS_typeEntitiesToGenerateList::
reader_mEntityToGenerateAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeEntityToGenerate  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntityToGenerate ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_setMEntityToGenerateAtIndex (C_Compiler & inLexique,
                              const GGS_typeEntityToGenerate  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntityToGenerate = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeEntityToGenerate  & GGS_typeEntitiesToGenerateList::cEnumerator::_mEntityToGenerate (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntityToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeGalgasListmapToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListmapToImplement::
cPtr_typeGalgasListmapToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mListmapTypeName (argument_0),
mListTypename (argument_1),
mAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListmapToImplement * GGS_typeGalgasListmapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeGalgasListmapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeGalgasListmapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListmapToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListmapToImplement * ptr = dynamic_cast <const cPtr_typeGalgasListmapToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mListTypename.operator_isEqual (ptr->mListTypename).boolValue ()
         && mAttributesList.operator_isEqual (ptr->mAttributesList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeGalgasListmapToImplement:"
           << mListmapTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mListTypename.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasListmapToImplement (& typeid (cPtr_typeGalgasListmapToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeGalgasListmapToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasListmapToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasListmapToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasListmapToImplement (mListmapTypeName, mListTypename, mAttributesList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasListmapToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement::
GGS_typeGalgasListmapToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement::
GGS_typeGalgasListmapToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasListmapToImplement GGS_typeGalgasListmapToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasListmapToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasListmapToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasListmapToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasListmapToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement GGS_typeGalgasListmapToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapToImplement result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasListmapToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasListmapToImplement::actualTypeName (void) const {
  return "typeGalgasListmapToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeGalgasListmapToImplement ("typeGalgasListmapToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_typeEnumCstMessageStringMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeEnumCstMessageStringMap::e_typeEnumCstMessageStringMap (void) :
mMessageString () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@typeEnumCstMessageStringMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessageString.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumCstMessageStringMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumCstMessageStringMap * ptr = dynamic_cast <const elementOf_GGS_typeEnumCstMessageStringMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMessageString.operator_isEqual (ptr->mInfo.mMessageString)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeEnumCstMessageStringMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
operator_isEqual (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
operator_isNotEqual (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeEnumCstMessageStringMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeEnumCstMessageStringMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeEnumCstMessageStringMap::cEnumerator::_mMessageString (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessageString ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_enumGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::
cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2,
                                const GGS_enumModifierMap & argument_3,
                                const GGS_enumMethodMap & argument_4,
                                const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2),
mEnumActionMap (argument_3),
mMethodMap (argument_4),
mOperatorMap (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumGalgasType * ptr = dynamic_cast <const cPtr_enumGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mConstantMap.operator_isEqual (ptr->mConstantMap).boolValue ()
         && mEnumMessageMap.operator_isEqual (ptr->mEnumMessageMap).boolValue ()
         && mEnumActionMap.operator_isEqual (ptr->mEnumActionMap).boolValue ()
         && mMethodMap.operator_isEqual (ptr->mMethodMap).boolValue ()
         && mOperatorMap.operator_isEqual (ptr->mOperatorMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumGalgasType:"
           << mEnumTypeName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mConstantMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEnumMessageMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mEnumActionMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mMethodMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mOperatorMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumGalgasType::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumGalgasType (& typeid (cPtr_enumGalgasType), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_enumGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__enumGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumGalgasType (mEnumTypeName, mConstantMap, mEnumMessageMap, mEnumActionMap, mMethodMap, mOperatorMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumGalgasType GGS_enumGalgasType::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_enumGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumGalgasType),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType GGS_enumGalgasType::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2,
                 const GGS_enumModifierMap & argument_3,
                 const GGS_enumMethodMap & argument_4,
                 const GGS_enumOperatorMap & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  macroMyNew (result.mPointer, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumGalgasType::actualTypeName (void) const {
  return "enumGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__enumGalgasType ("enumGalgasType", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@ruleDescriptorForProgramList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ruleDescriptorForProgramList::
elementOf_GGS_ruleDescriptorForProgramList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceExtension (argument_0),
mHelpMessage (argument_1),
mSourceFileName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ruleDescriptorForProgramList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ruleDescriptorForProgramList * ptr = dynamic_cast <const elementOf_GGS_ruleDescriptorForProgramList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceExtension.operator_isEqual (ptr->mSourceExtension).boolValue ()
         && mHelpMessage.operator_isEqual (ptr->mHelpMessage).boolValue ()
         && mSourceFileName.operator_isEqual (ptr->mSourceFileName).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ruleDescriptorForProgramList::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExtension.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHelpMessage.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceFileName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@ruleDescriptorForProgramList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
operator_concat (const GGS_ruleDescriptorForProgramList & inOperand) const {
  GGS_ruleDescriptorForProgramList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
dotAssign_operation (const GGS_ruleDescriptorForProgramList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_ruleDescriptorForProgramList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceExtension ;
          GGS_string p_1 = p->mHelpMessage ;
          GGS_lstring  p_2 = p->mSourceFileName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          _internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSourceExtension,
                                ptr->mHelpMessage,
                                ptr->mSourceFileName,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_emptyList (void) {
  GGS_ruleDescriptorForProgramList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  GGS_ruleDescriptorForProgramList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
internalSubListWithRange (GGS_ruleDescriptorForProgramList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSourceExtension, ptr->mHelpMessage, ptr->mSourceFileName, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ruleDescriptorForProgramList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ruleDescriptorForProgramList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@ruleDescriptorForProgramList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_lstring & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_lstring & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_lstring & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_lstring & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ruleDescriptorForProgramList::
reader_mSourceExtensionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceExtension ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_mHelpMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHelpMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ruleDescriptorForProgramList::
reader_mSourceFileNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceFileName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_ruleDescriptorForProgramList::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMSourceExtensionAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceExtension = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMHelpMessageAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHelpMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMSourceFileNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceFileName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ruleDescriptorForProgramList::cEnumerator::_mSourceExtension (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceExtension ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_ruleDescriptorForProgramList::cEnumerator::_mHelpMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mHelpMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ruleDescriptorForProgramList::cEnumerator::_mSourceFileName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceFileName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_ruleDescriptorForProgramList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@wrapperFileSortedList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperFileSortedList::
elementOf_GGS_wrapperFileSortedList (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3):
mRegularFileName (argument_0),
mAbsoluteFilePath (argument_1),
mWrapperDirectoryIndex (argument_2),
mWrapperFileIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperFileSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_wrapperFileSortedList * ptr = dynamic_cast <const elementOf_GGS_wrapperFileSortedList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegularFileName.operator_isEqual (ptr->mRegularFileName).boolValue ()
         && mAbsoluteFilePath.operator_isEqual (ptr->mAbsoluteFilePath).boolValue ()
         && mWrapperDirectoryIndex.operator_isEqual (ptr->mWrapperDirectoryIndex).boolValue ()
         && mWrapperFileIndex.operator_isEqual (ptr->mWrapperFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_wrapperFileSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_wrapperFileSortedList * operand = (const elementOf_GGS_wrapperFileSortedList *) inOperand ;
  PMSInt32 result = mRegularFileName.compareForSortedList (operand->mRegularFileName) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperFileSortedList::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRegularFileName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbsoluteFilePath.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperDirectoryIndex.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperFileIndex.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@wrapperFileSortedList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList::GGS_wrapperFileSortedList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList::
GGS_wrapperFileSortedList (const GGS_wrapperFileSortedList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileSortedList::
operator_isEqual (const GGS_wrapperFileSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileSortedList::
operator_isNotEqual (const GGS_wrapperFileSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList GGS_wrapperFileSortedList::
operator_concat (const GGS_wrapperFileSortedList & inOperand) const {
  GGS_wrapperFileSortedList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
dotAssign_operation (const GGS_wrapperFileSortedList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_wrapperFileSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mRegularFileName ;
          GGS_string p_1 = p->mAbsoluteFilePath ;
          GGS_uint  p_2 = p->mWrapperDirectoryIndex ;
          GGS_uint  p_3 = p->mWrapperFileIndex ;
          _internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mRegularFileName,
                                ptr->mAbsoluteFilePath,
                                ptr->mWrapperDirectoryIndex,
                                ptr->mWrapperFileIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList  GGS_wrapperFileSortedList::
constructor_emptySortedList (void) {
  GGS_wrapperFileSortedList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedList  GGS_wrapperFileSortedList::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_uint & argument_3) {
  GGS_wrapperFileSortedList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperFileSortedList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@wrapperFileSortedList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
method_smallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
method_greatest (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedList::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperFileSortedList::cEnumerator::_mRegularFileName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRegularFileName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperFileSortedList::cEnumerator::_mAbsoluteFilePath (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbsoluteFilePath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperFileSortedList::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperFileSortedList::cEnumerator::_mWrapperFileIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWrapperFileIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@wrapperDirectorySortedList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperDirectorySortedList::
elementOf_GGS_wrapperDirectorySortedList (const GGS_string& argument_0,
                                const GGS_wrapperFileSortedList & argument_1,
                                const GGS_wrapperDirectorySortedList & argument_2,
                                const GGS_uint & argument_3):
mDirectoryName (argument_0),
mRegularFileSortedList (argument_1),
mDirectorySortedList (argument_2),
mWrapperDirectoryIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperDirectorySortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_wrapperDirectorySortedList * ptr = dynamic_cast <const elementOf_GGS_wrapperDirectorySortedList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDirectoryName.operator_isEqual (ptr->mDirectoryName).boolValue ()
         && mRegularFileSortedList.operator_isEqual (ptr->mRegularFileSortedList).boolValue ()
         && mDirectorySortedList.operator_isEqual (ptr->mDirectorySortedList).boolValue ()
         && mWrapperDirectoryIndex.operator_isEqual (ptr->mWrapperDirectoryIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_wrapperDirectorySortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_wrapperDirectorySortedList * operand = (const elementOf_GGS_wrapperDirectorySortedList *) inOperand ;
  PMSInt32 result = mDirectoryName.compareForSortedList (operand->mDirectoryName) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperDirectorySortedList::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDirectoryName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRegularFileSortedList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDirectorySortedList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperDirectoryIndex.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@wrapperDirectorySortedList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList::GGS_wrapperDirectorySortedList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList::
GGS_wrapperDirectorySortedList (const GGS_wrapperDirectorySortedList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectorySortedList::
operator_isEqual (const GGS_wrapperDirectorySortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectorySortedList::
operator_isNotEqual (const GGS_wrapperDirectorySortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_wrapperFileSortedList & argument_1,
                    const GGS_wrapperDirectorySortedList & argument_2,
                    const GGS_uint & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_wrapperFileSortedList & argument_1,
                                const GGS_wrapperDirectorySortedList & argument_2,
                                const GGS_uint & argument_3) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList GGS_wrapperDirectorySortedList::
operator_concat (const GGS_wrapperDirectorySortedList & inOperand) const {
  GGS_wrapperDirectorySortedList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
dotAssign_operation (const GGS_wrapperDirectorySortedList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_wrapperDirectorySortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDirectoryName ;
          GGS_wrapperFileSortedList  p_1 = p->mRegularFileSortedList ;
          GGS_wrapperDirectorySortedList  p_2 = p->mDirectorySortedList ;
          GGS_uint  p_3 = p->mWrapperDirectoryIndex ;
          _internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mDirectoryName,
                                ptr->mRegularFileSortedList,
                                ptr->mDirectorySortedList,
                                ptr->mWrapperDirectoryIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList  GGS_wrapperDirectorySortedList::
constructor_emptySortedList (void) {
  GGS_wrapperDirectorySortedList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedList  GGS_wrapperDirectorySortedList::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_wrapperFileSortedList & argument_1,
                           const GGS_wrapperDirectorySortedList & argument_2,
                           const GGS_uint & argument_3) {
  GGS_wrapperDirectorySortedList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperDirectorySortedList::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@wrapperDirectorySortedList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
method_smallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_wrapperFileSortedList & _out_1,
                 GGS_wrapperDirectorySortedList & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
method_greatest (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_wrapperFileSortedList & _out_1,
             GGS_wrapperDirectorySortedList & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_wrapperFileSortedList & _out_1,
                 GGS_wrapperDirectorySortedList & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedList::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_wrapperFileSortedList & _out_1,
                GGS_wrapperDirectorySortedList & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperDirectorySortedList::cEnumerator::_mDirectoryName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDirectoryName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperFileSortedList  & GGS_wrapperDirectorySortedList::cEnumerator::_mRegularFileSortedList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRegularFileSortedList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperDirectorySortedList  & GGS_wrapperDirectorySortedList::cEnumerator::_mDirectorySortedList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDirectorySortedList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperDirectorySortedList::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@wrapperExtensionMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperExtensionMap::
elementOf_GGS_wrapperExtensionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_wrapperExtensionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperExtensionMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperExtensionMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_wrapperExtensionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_wrapperExtensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_wrapperExtensionMap * info = (e_wrapperExtensionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_wrapperExtensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_wrapperExtensionMap * info = (e_wrapperExtensionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_wrapperExtensionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMap::
operator_isEqual (const GGS_wrapperExtensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMap::
operator_isNotEqual (const GGS_wrapperExtensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_wrapperExtensionMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperExtensionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_wrapperExtensionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperExtensionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperExtensionMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @wrapperExtensionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_wrapperToImplement'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_wrapperToImplement::
cPtr_C_wrapperToImplement (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_wrapperExtensionMap & argument_2,
                                const GGS_wrapperFileSortedList & argument_3,
                                const GGS_wrapperDirectorySortedList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mWrapperName (argument_0),
mSourceDirectory (argument_1),
mExtensionMap (argument_2),
mRegularFileSortedList (argument_3),
mDirectorySortedList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_wrapperToImplement * GGS_C_wrapperToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_wrapperToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_wrapperToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_wrapperToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_wrapperToImplement * ptr = dynamic_cast <const cPtr_C_wrapperToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWrapperName.operator_isEqual (ptr->mWrapperName).boolValue ()
         && mSourceDirectory.operator_isEqual (ptr->mSourceDirectory).boolValue ()
         && mExtensionMap.operator_isEqual (ptr->mExtensionMap).boolValue ()
         && mRegularFileSortedList.operator_isEqual (ptr->mRegularFileSortedList).boolValue ()
         && mDirectorySortedList.operator_isEqual (ptr->mDirectorySortedList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_wrapperToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_wrapperToImplement:"
           << mWrapperName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mSourceDirectory.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mExtensionMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mRegularFileSortedList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mDirectorySortedList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_wrapperToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_wrapperToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_wrapperToImplement (& typeid (cPtr_C_wrapperToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_wrapperToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_wrapperToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_wrapperToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_wrapperToImplement (mWrapperName, mSourceDirectory, mExtensionMap, mRegularFileSortedList, mDirectorySortedList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_wrapperToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement::
GGS_C_wrapperToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement::
GGS_C_wrapperToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_wrapperToImplement GGS_C_wrapperToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_wrapperToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_wrapperToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_wrapperToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_wrapperToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement GGS_C_wrapperToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_string& argument_1,
                 const GGS_wrapperExtensionMap & argument_2,
                 const GGS_wrapperFileSortedList & argument_3,
                 const GGS_wrapperDirectorySortedList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_wrapperToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_wrapperToImplement::actualTypeName (void) const {
  return "C_wrapperToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_wrapperToImplement ("C_wrapperToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_structToImplement'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_structToImplement::
cPtr_C_structToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mStructName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_structToImplement * GGS_C_structToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_structToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_structToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_structToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_structToImplement * ptr = dynamic_cast <const cPtr_C_structToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructName.operator_isEqual (ptr->mStructName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_structToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_structToImplement:"
           << mStructName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_structToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_structToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_structToImplement (& typeid (cPtr_C_structToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_structToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_structToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_structToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_structToImplement (mStructName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_structToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_structToImplement::
GGS_C_structToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement::
GGS_C_structToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_structToImplement GGS_C_structToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_structToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_structToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_structToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_structToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement GGS_C_structToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_structToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_structToImplement::actualTypeName (void) const {
  return "C_structToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_structToImplement ("C_structToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_C_filewrapperTemplateToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_filewrapperTemplateToImplement::
cPtr_C_filewrapperTemplateToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_2,
                                const GGS_templateInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mFilewrapperName (argument_0),
mTemplateName (argument_1),
mTemplateArgumentList (argument_2),
mTemplateInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_filewrapperTemplateToImplement * GGS_C_filewrapperTemplateToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_filewrapperTemplateToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_filewrapperTemplateToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_filewrapperTemplateToImplement * ptr = dynamic_cast <const cPtr_C_filewrapperTemplateToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mTemplateArgumentList.operator_isEqual (ptr->mTemplateArgumentList).boolValue ()
         && mTemplateInstructionList.operator_isEqual (ptr->mTemplateInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_filewrapperTemplateToImplement::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_filewrapperTemplateToImplement:"
           << mFilewrapperName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateArgumentList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mTemplateInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_filewrapperTemplateToImplement::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_filewrapperTemplateToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_filewrapperTemplateToImplement (& typeid (cPtr_C_filewrapperTemplateToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_filewrapperTemplateToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_filewrapperTemplateToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_filewrapperTemplateToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_filewrapperTemplateToImplement (mFilewrapperName, mTemplateName, mTemplateArgumentList, mTemplateInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_filewrapperTemplateToImplement'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement::
GGS_C_filewrapperTemplateToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement::
GGS_C_filewrapperTemplateToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_filewrapperTemplateToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_filewrapperTemplateToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_filewrapperTemplateToImplement),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_2,
                 const GGS_templateInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_filewrapperTemplateToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_filewrapperTemplateToImplement::actualTypeName (void) const {
  return "C_filewrapperTemplateToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_filewrapperTemplateToImplement ("C_filewrapperTemplateToImplement", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

