//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      april 25th, 2006, at 12h1'57"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantics_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCplusPlusName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName::
cPtr_typeCplusPlusName (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (void) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const GGS_typeCplusPlusName & inOperand) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
~GGS_typeCplusPlusName (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (const GGS_typeCplusPlusName & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (cPtr_typeCplusPlusName * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr_typeCplusPlusName * inSource) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusName
::reader_description (void) const {
  C_String s ;
  s << "<class @typeCplusPlusName" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::cPtr_typeDirectName (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDirectName:" ;
mName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectName * GGS_typeDirectName::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDirectName * ptr_ = (cPtr_typeDirectName *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisName::cPtr_typeCppThisName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeCppThisName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisName * GGS_typeCppThisName::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeCppThisName * ptr_ = (cPtr_typeCppThisName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppThisName (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppInheritedName::cPtr_typeCppInheritedName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCppInheritedName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeCppInheritedName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeCppInheritedName * ptr_ = (cPtr_typeCppInheritedName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppInheritedName (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::cPtr_typeAutomaticName (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAutomaticName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeAutomaticName:" ;
mName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeAutomaticName * ptr_ = (cPtr_typeAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeAutomaticName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::cPtr_typeLocationAutomaticName (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLocationAutomaticName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeLocationAutomaticName:" ;
mLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
    constructor_new (const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLocationAutomaticName * ptr_ = (cPtr_typeLocationAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeLocationAutomaticName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::cPtr_typeOperandName (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0),
mLocationOffset (argument_1),
mFieldKind (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeOperandName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeOperandName:" ;
mName.reader_description () ;
mLocationOffset.reader_description () ;
mFieldKind.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOperandName * GGS_typeOperandName::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeOperandName * ptr_ = (cPtr_typeOperandName *) NULL ;
    macroMyNew (ptr_, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::cPtr_typeKeyName (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocationOffset (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeKeyName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeKeyName:" ;
mLocationOffset.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeKeyName * GGS_typeKeyName::
    constructor_new (const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeKeyName * ptr_ = (cPtr_typeKeyName *) NULL ;
    macroMyNew (ptr_, cPtr_typeKeyName (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNullName::cPtr_typeNullName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNullName::appendForDescription (C_String & ioString) const {
  ioString << "->@typeNullName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNullName * GGS_typeNullName::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeNullName * ptr_ = (cPtr_typeNullName *) NULL ;
    macroMyNew (ptr_, cPtr_typeNullName (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0) {
  mNextItem = (elementOf_GGS_typeCplusPlusNameList *) NULL ;
  mCppName = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mCppName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList
::GGS_typeCplusPlusNameList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeCplusPlusNameList
::GGS_typeCplusPlusNameList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::~GGS_typeCplusPlusNameList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::operator = (const GGS_typeCplusPlusNameList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::reader_description (void) const {
  C_String s ;
  s << "<list @typeCplusPlusNameList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeCplusPlusNameList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExpression::
cPtr_typeExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (void) {
  mPointer = (cPtr_typeExpression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const GGS_typeExpression & inOperand) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
~GGS_typeExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (const GGS_typeExpression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (cPtr_typeExpression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr_typeExpression * inSource) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExpression * GGS_typeExpression
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeExpression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpression
::reader_description (void) const {
  C_String s ;
  s << "<class @typeExpression" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mMessage.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_typeSemanticsTypesList *) NULL ;
  mType = argument_0 ;
  mGalgasVariableName = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mType.reader_description () ;
  ioString << mGalgasVariableName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList
::GGS_typeSemanticsTypesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeSemanticsTypesList
::GGS_typeSemanticsTypesList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::~GGS_typeSemanticsTypesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::operator = (const GGS_typeSemanticsTypesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mGalgasVariableName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::reader_description (void) const {
  C_String s ;
  s << "<list @typeSemanticsTypesList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeSemanticsTypesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUsedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUsedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_L_assignedVariables *) NULL ;
  aNomVariableCible = argument_0 ;
  aNomAttributSource = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << aNomVariableCible.reader_description () ;
  ioString << aNomAttributSource.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables
::GGS_L_assignedVariables (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_L_assignedVariables
::GGS_L_assignedVariables (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::~GGS_L_assignedVariables (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::GGS_L_assignedVariables (const GGS_L_assignedVariables & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::operator = (const GGS_L_assignedVariables & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aNomVariableCible,
                                p->aNomAttributSource) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::reader_description (void) const {
  C_String s ;
  s << "<list @L_assignedVariables" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_assignedVariables
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (void) {
  mPointer = (cPtr_typeCible *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const GGS_typeCible & inOperand) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
~GGS_typeCible (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (const GGS_typeCible & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (cPtr_typeCible * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr_typeCible * inSource) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCible
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCible
::reader_description (void) const {
  C_String s ;
  s << "<class @typeCible" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0) {
  mNextItem = (elementOf_GGS_typeListeCibles *) NULL ;
  aCible = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << aCible.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles
::GGS_typeListeCibles (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeListeCibles
::GGS_typeListeCibles (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListeCibles::~GGS_typeListeCibles (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::GGS_typeListeCibles (const GGS_typeListeCibles & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::operator = (const GGS_typeListeCibles & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalAppendItem (const GGS_typeCible & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
addAssign_operation (const GGS_typeCible & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aCible) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::reader_description (void) const {
  C_String s ;
  s << "<list @typeListeCibles" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListeCibles
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  mNextItem = (elementOf_GGS_typeListeTypesEtNomsArgMethode *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
  mCppName = argument_2 ;
  mModeIn = argument_3 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTypesEtNomsArgMethode::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mType.reader_description () ;
  ioString << mFormalArgumentPassingMode.reader_description () ;
  ioString << mCppName.reader_description () ;
  ioString << mModeIn.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode
::GGS_typeListeTypesEtNomsArgMethode (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeListeTypesEtNomsArgMethode
::GGS_typeListeTypesEtNomsArgMethode (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::~GGS_typeListeTypesEtNomsArgMethode (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::operator = (const GGS_typeListeTypesEtNomsArgMethode & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode,
                                p->mCppName,
                                p->mModeIn) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTypesEtNomsArgMethode::reader_description (void) const {
  C_String s ;
  s << "<list @typeListeTypesEtNomsArgMethode" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListeTypesEtNomsArgMethode
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstruction::
cPtr_typeInstruction (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (void) {
  mPointer = (cPtr_typeInstruction *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const GGS_typeInstruction & inOperand) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
~GGS_typeInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (const GGS_typeInstruction & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (cPtr_typeInstruction * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr_typeInstruction * inSource) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstruction * GGS_typeInstruction
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeInstruction
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstruction
::reader_description (void) const {
  C_String s ;
  s << "<class @typeInstruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionList::
elementOf_GGS_typeInstructionList (const GGS_typeInstruction & argument_0) {
  mNextItem = (elementOf_GGS_typeInstructionList *) NULL ;
  mInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeInstructionList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mInstruction.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionList
::GGS_typeInstructionList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeInstructionList
::GGS_typeInstructionList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeInstructionList::~GGS_typeInstructionList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::GGS_typeInstructionList (const GGS_typeInstructionList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList
::operator = (const GGS_typeInstructionList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
internalAppendItem (const GGS_typeInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionList::reader_description (void) const {
  C_String s ;
  s << "<list @typeInstructionList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeInstructionList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_L_nameWithType *) NULL ;
  mType = argument_0 ;
  mName = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mType.reader_description () ;
  ioString << mName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType
::GGS_L_nameWithType (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_L_nameWithType
::GGS_L_nameWithType (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_nameWithType::~GGS_L_nameWithType (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::GGS_L_nameWithType (const GGS_L_nameWithType & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::operator = (const GGS_L_nameWithType & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::reader_description (void) const {
  C_String s ;
  s << "<list @L_nameWithType" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_nameWithType
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 index = insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertNotAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertNotAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 index = insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0) {
  mNextItem = (elementOf_GGS_typeExpressionList *) NULL ;
  mExpression = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mExpression.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList
::GGS_typeExpressionList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeExpressionList
::GGS_typeExpressionList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeExpressionList::~GGS_typeExpressionList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::GGS_typeExpressionList (const GGS_typeExpressionList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::operator = (const GGS_typeExpressionList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalAppendItem (const GGS_typeExpression & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
addAssign_operation (const GGS_typeExpression & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mExpression) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::reader_description (void) const {
  C_String s ;
  s << "<list @typeExpressionList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeExpressionList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeErrorInstruction:" ;
mErrorLocationExpression.reader_description () ;
mErrorMessageExpression.reader_description () ;
mLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeErrorInstruction * ptr_ = (cPtr_typeErrorInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeWarningInstruction:" ;
mWarningLocationExpression.reader_description () ;
mWarningMessageExpression.reader_description () ;
mLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeWarningInstruction * ptr_ = (cPtr_typeWarningInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeMessageInstruction:" ;
mMessageExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeMessageInstruction * ptr_ = (cPtr_typeMessageInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInstruction::cPtr_typeReaderCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeReaderCallInstruction:" ;
aNomCppVariable.reader_description () ;
aNomMethodeSimple.reader_description () ;
mExpressionsList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInstruction * GGS_typeReaderCallInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeReaderCallInstruction * ptr_ = (cPtr_typeReaderCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeModifierCallInstruction:" ;
aNomCppVariable.reader_description () ;
aNomMethodeSimple.reader_description () ;
mExpressionsList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeModifierCallInstruction * ptr_ = (cPtr_typeModifierCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::appendForDescription (C_String & ioString) const {
  ioString << "->@typeInstructionAppelMethodeListe:" ;
aNomCppAttribut.reader_description () ;
aMethodeDeListe.reader_description () ;
aListeNomsCppArguments.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionAppelMethodeListe * ptr_ = (cPtr_typeInstructionAppelMethodeListe *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::appendForDescription (C_String & ioString) const {
  ioString << "->@typeInstructionDeclarationVarLocale:" ;
aNomCppVariable.reader_description () ;
aTypeVariable.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionDeclarationVarLocale * ptr_ = (cPtr_typeInstructionDeclarationVarLocale *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeMapBlockPrologueInstruction:" ;
aNomVariableTable.reader_description () ;
aNomMethodeBloc.reader_description () ;
mPrologueExpressionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeMapBlockPrologueInstruction * ptr_ = (cPtr_typeMapBlockPrologueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeMapBlockEpilogueInstruction:" ;
aNomVariableTable.reader_description () ;
aNomMethodeBloc.reader_description () ;
mEpilogueExpressionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeMapBlockEpilogueInstruction * ptr_ = (cPtr_typeMapBlockEpilogueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeReaderCallInExpression:" ;
mExpressionValue.reader_description () ;
mReaderName.reader_description () ;
mExpressionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeReaderCallInExpression * ptr_ = (cPtr_typeReaderCallInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::cPtr_typeAndOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeAndOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeAndOperation * ptr_ = (cPtr_typeAndOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeAndOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::cPtr_typeOrOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeOrOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeOrOperation * ptr_ = (cPtr_typeOrOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeOrOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::cPtr_typeConcatOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeConcatOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeConcatOperation * ptr_ = (cPtr_typeConcatOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeConcatOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::appendForDescription (C_String & ioString) const {
  ioString << "->@typeTrueBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeTrueBool * ptr_ = (cPtr_typeTrueBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeTrueBool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFalseBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeFalseBool * ptr_ = (cPtr_typeFalseBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeFalseBool (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::cPtr_typeLiteralStringExpression (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralString (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeLiteralStringExpression:" ;
mLiteralString.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
    constructor_new (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralStringExpression * ptr_ = (cPtr_typeLiteralStringExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeLiteralUIntExpression:" ;
mLiteralInt.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
    constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralUIntExpression * ptr_ = (cPtr_typeLiteralUIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeLiteralSIntExpression:" ;
mLiteralInt.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
    constructor_new (const GGS_lsint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralSIntExpression * ptr_ = (cPtr_typeLiteralSIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeLiteralCharExpression:" ;
mLiteralChar.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
    constructor_new (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeLiteralCharExpression * ptr_ = (cPtr_typeLiteralCharExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeHereExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeHereExpression * ptr_ = (cPtr_typeHereExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeHereExpression (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::cPtr_typeConstructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mClassName (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeConstructorExpression:" ;
mClassName.reader_description () ;
mClassMethodName.reader_description () ;
mExpressionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeConstructorExpression * ptr_ = (cPtr_typeConstructorExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::cPtr_typeTestComplement (const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mTest (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::appendForDescription (C_String & ioString) const {
  ioString << "->@typeTestComplement:" ;
mTest.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
    constructor_new (const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeTestComplement * ptr_ = (cPtr_typeTestComplement *) NULL ;
    macroMyNew (ptr_, cPtr_typeTestComplement (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::cPtr_typeBoolOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeBoolOption::appendForDescription (C_String & ioString) const {
  ioString << "->@typeBoolOption:" ;
mOptionComponentName.reader_description () ;
mOptionName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeBoolOption * GGS_typeBoolOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeBoolOption * ptr_ = (cPtr_typeBoolOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeBoolOption (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::cPtr_typeUIntOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUIntOption::appendForDescription (C_String & ioString) const {
  ioString << "->@typeUIntOption:" ;
mOptionComponentName.reader_description () ;
mOptionName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUIntOption * GGS_typeUIntOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeUIntOption * ptr_ = (cPtr_typeUIntOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeUIntOption (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeStringOption'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStringOption::cPtr_typeStringOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStringOption::appendForDescription (C_String & ioString) const {
  ioString << "->@typeStringOption:" ;
mOptionComponentName.reader_description () ;
mOptionName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStringOption * GGS_typeStringOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeStringOption * ptr_ = (cPtr_typeStringOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeStringOption (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeVarInExpression:" ;
mCppVarName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
    constructor_new (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeVarInExpression * ptr_ = (cPtr_typeVarInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeVarInExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::cPtr_typeJokerInExpression (const GGS_location & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::appendForDescription (C_String & ioString) const {
  ioString << "->@typeJokerInExpression:" ;
mLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
    constructor_new (const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeJokerInExpression * ptr_ = (cPtr_typeJokerInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeJokerInExpression (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAddOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::cPtr_typeAddOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeAddOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeAddOperation * ptr_ = (cPtr_typeAddOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeSubOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::cPtr_typeSubOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeSubOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeSubOperation * ptr_ = (cPtr_typeSubOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMultiplyOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::cPtr_typeMultiplyOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeMultiplyOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeMultiplyOperation * ptr_ = (cPtr_typeMultiplyOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDivideOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::cPtr_typeDivideOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDivideOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeDivideOperation * ptr_ = (cPtr_typeDivideOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeModuloOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::cPtr_typeModuloOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeModuloOperation:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeModuloOperation * ptr_ = (cPtr_typeModuloOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeUnaryMinusOperation'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::cPtr_typeUnaryMinusOperation (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::appendForDescription (C_String & ioString) const {
  ioString << "->@typeUnaryMinusOperation:" ;
mExpression.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeUnaryMinusOperation * ptr_ = (cPtr_typeUnaryMinusOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::cPtr_typeEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeEqualTest:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeEqualTest * ptr_ = (cPtr_typeEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::cPtr_typeNonEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeNonEqualTest:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeNonEqualTest * ptr_ = (cPtr_typeNonEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeNonEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::cPtr_typeStrictInfTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeStrictInfTest:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeStrictInfTest * ptr_ = (cPtr_typeStrictInfTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictInfTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::cPtr_typeInfOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeInfOrEqualTest:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeInfOrEqualTest * ptr_ = (cPtr_typeInfOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::cPtr_typeStrictSupTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeStrictSupTest:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeStrictSupTest * ptr_ = (cPtr_typeStrictSupTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictSupTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::cPtr_typeSupOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeSupOrEqualTest:" ;
mLeftExpression.reader_description () ;
mRightExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeSupOrEqualTest * ptr_ = (cPtr_typeSupOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::appendForDescription (C_String & ioString) const {
  ioString << "->@typeTextTableCall:" ;
mExpression.reader_description () ;
aNomMethodeTest.reader_description () ;
aNomCppClef.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeTextTableCall * ptr_ = (cPtr_typeTextTableCall *) NULL ;
    macroMyNew (ptr_, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@C_assignmentInstruction:" ;
mTargetVarCppName.reader_description () ;
mSourceExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_assignmentInstruction * ptr_ = (cPtr_C_assignmentInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::appendForDescription (C_String & ioString) const {
  ioString << "->@C_declarationInstructionWithAssignment:" ;
mVariableType.reader_description () ;
mTargetVarCppName.reader_description () ;
mSourceExpression.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
    constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_declarationInstructionWithAssignment * ptr_ = (cPtr_C_declarationInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  mNextItem = (elementOf_GGS_L_expression_instructionsList_list *) NULL ;
  mIFexpression = argument_0 ;
  mInstructionList = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mIFexpression.reader_description () ;
  ioString << mInstructionList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list
::GGS_L_expression_instructionsList_list (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_L_expression_instructionsList_list
::GGS_L_expression_instructionsList_list (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::~GGS_L_expression_instructionsList_list (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::operator = (const GGS_L_expression_instructionsList_list & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalAppendItem (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mIFexpression,
                                p->mInstructionList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::reader_description (void) const {
  C_String s ;
  s << "<list @L_expression_instructionsList_list" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_expression_instructionsList_list
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::appendForDescription (C_String & ioString) const {
  ioString << "->@C_if_instruction:" ;
mIFbranchesList.reader_description () ;
mElseInstructionsList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
    constructor_new (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_if_instruction * ptr_ = (cPtr_C_if_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableRoutinesAimplementer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableAttributsSemantiques'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.aNomCppAttribut.reader_description () ;
  ioString << mInfo.mAttributType.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeCplusPlusName &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the attribute '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the attribute '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Lexique & _inLexique,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound COMMA_UNUSED_LOCATION_ARGS) {
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle) != (GGS_localConstantBuildStyleEnum::constructor_listStyle (HERE)) ;
  GGS_bool var_cas_firstOne ;
  var_cas_firstOne = GGS_bool (true, true) ;
  GGS_L_nameWithType::element_type * operand_27926 = var_cas_inLocalDeclarationsList.firstObject () ;
  GGS_typeListeAttributsSemantiques::element_type * operand_28015 = var_cas_inSemanticAttributsList.firstObject () ;
  while ((operand_27926 != NULL)
      && (operand_28015 != NULL)) {
    macroValidPointer (operand_27926) ;
    macroValidPointer (operand_28015) ;
    if (((operand_27926->mName.reader_value ()) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_string var_cas_typeName ;
      if (operand_28015->mAttributType.isBuilt ()) {
        operand_28015->mAttributType (HERE)->methode_getTypeName (_inLexique, var_cas_typeName) ;
      }
      if (((operand_27926->mType.reader_value ()) == (var_cas_typeName)).isBuiltAndTrue ()) {
        GGS_typeCplusPlusName  var_cas_cppName ;
        if (((((var_cas_inLocalConstantStyle) == (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (HERE))) && (var_cas_firstOne))).isBuiltAndTrue ()) {
          var_cas_cppName = GGS_typeKeyName::constructor_new (var_cas_inLocation COMMA_HERE) ;
        }else{
          var_cas_cppName = GGS_typeOperandName::constructor_new (operand_28015->aNomAttribut, var_cas_inLocation, var_cas_mapStyle COMMA_HERE) ;
        }
        var_cas_ioVariablesMap.methode_insertUsedConstInArgument (_inLexique, operand_27926->mName, operand_28015->mAttributType, var_cas_cppName SOURCE_FILE_AT_LINE (683)) ;
      }else{
          operand_27926->mType.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I have found the '@")) + (operand_27926->mType.reader_value ()))) + (GGS_string (true, "' type, I was expected the '@")))) + (var_cas_typeName))) + (GGS_string (true, "' type"))) SOURCE_FILE_AT_LINE (686)) ;
      }
    }
    var_cas_firstOne = GGS_bool (true, false) ;
    operand_27926 = operand_27926->nextObject () ;
    operand_28015 = operand_28015->nextObject () ;
  }
  if (((((var_cas_inLocalDeclarationsList.reader_length ()) < (var_cas_inSemanticAttributsList.reader_length ())) && ((! (var_cas_inEllipsisFound))))).isBuiltAndTrue ()) {
      GGS_location (_inLexique).reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "one or more parameters missing: found ")) + (var_cas_inLocalDeclarationsList.reader_length ().reader_string ()))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length ().reader_string ()))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (695)) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length ()) > (var_cas_inSemanticAttributsList.reader_length ())).isBuiltAndTrue ()) {
      GGS_location (_inLexique).reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "too much parameters: found ")) + (var_cas_inLocalDeclarationsList.reader_length ().reader_string ()))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length ().reader_string ()))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (699)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Lexique & _inLexique,
                                GGS_AC_galgasType   var_cas_targetType,
                                GGS_AC_galgasType   var_cas_sourceType,
                                GGS_location   var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (var_cas_targetType.isBuilt () && var_cas_sourceType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_30044 = var_cas_targetType (HERE) ;
    cPtr_AC_galgasType * ptr_30058 = var_cas_sourceType (HERE) ;
    cPtr_typeGalgas_stringset * operand_30044 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_30044) ;
    cPtr_typeGalgas_stringset * operand_30058 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_30058) ;
    if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_30044 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_30044) ;
      cPtr_typeGalgas_uint * operand_30058 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_30058) ;
      if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_30044 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_30044) ;
        cPtr_typeGalgas_sint * operand_30058 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_30058) ;
        if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
        }else{
          cPtr_typeGalgas_char * operand_30044 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_30044) ;
          cPtr_typeGalgas_char * operand_30058 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_30058) ;
          if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
          }else{
            cPtr_typeGalgas_string * operand_30044 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_30044) ;
            cPtr_typeGalgas_string * operand_30058 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_30058) ;
            if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
            }else{
              cPtr_typeGalgas_bool * operand_30044 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_30044) ;
              cPtr_typeGalgas_bool * operand_30058 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_30058) ;
              if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
              }else{
                cPtr_typeGalgas_double * operand_30044 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_30044) ;
                cPtr_typeGalgas_double * operand_30058 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_30058) ;
                if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                }else{
                  cPtr_typeGalgas_ldouble * operand_30044 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_30044) ;
                  cPtr_typeGalgas_ldouble * operand_30058 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_30058) ;
                  if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                  }else{
                    cPtr_typeGalgas_location * operand_30044 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_30044) ;
                    cPtr_typeGalgas_location * operand_30058 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_30058) ;
                    if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                    }else{
                      cPtr_typeGalgas_lchar * operand_30044 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_30044) ;
                      cPtr_typeGalgas_lchar * operand_30058 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_30058) ;
                      if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                      }else{
                        cPtr_typeGalgas_luint * operand_30044 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_30044) ;
                        cPtr_typeGalgas_luint * operand_30058 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_30058) ;
                        if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                        }else{
                          cPtr_typeGalgas_lsint * operand_30044 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_30044) ;
                          cPtr_typeGalgas_lsint * operand_30058 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_30058) ;
                          if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lstring * operand_30044 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_30044) ;
                            cPtr_typeGalgas_lstring * operand_30058 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_30058) ;
                            if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                            }else{
                              cPtr_typeGalgas_lbool * operand_30044 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_30044) ;
                              cPtr_typeGalgas_lbool * operand_30058 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_30058) ;
                              if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                              }else{
                                cPtr_typeGalgasUndefinedExternType * operand_30044 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_30044) ;
                                cPtr_typeGalgasUndefinedExternType * operand_30058 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_30058) ;
                                if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                                  if (((operand_30044->mGalgasClassName.reader_value ()) != (operand_30058->mGalgasClassName.reader_value ())).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_30044->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_30058->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (740)) ;
                                  }
                                }else{
                                  cPtr_typeGalgasUndefinedListType * operand_30044 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_30044) ;
                                  cPtr_typeGalgasUndefinedListType * operand_30058 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_30058) ;
                                  if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                                    if (((operand_30044->mListTypeName.reader_value ()) != (operand_30058->mListTypeName.reader_value ())).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a '")) + (operand_30044->mListTypeName.reader_value ()))) + (GGS_string (true, "' list type variable, and I got a '")))) + (operand_30058->mListTypeName.reader_value ()))) + (GGS_string (true, "' list type variable"))) SOURCE_FILE_AT_LINE (746)) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasClassType * operand_30044 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_30044) ;
                                    cPtr_typeGalgasClassType * operand_30058 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_30058) ;
                                    if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                                      if (((operand_30044->mClassTypeName.reader_value ()) == (operand_30058->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                      }else if (((! (operand_30058->mAncestorClassesMap.reader_hasKey (operand_30044->mClassTypeName.reader_value ())))).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "The '")) + (operand_30058->mClassTypeName.reader_value ()))) + (GGS_string (true, "' does not inherit from '")))) + (operand_30058->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class"))) SOURCE_FILE_AT_LINE (754)) ;
                                      }
                                    }else{
                                      cPtr_typeGalgasUndefinedClassType * operand_30044 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_30044) ;
                                      cPtr_typeGalgasUndefinedClassType * operand_30058 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_30058) ;
                                      if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                                        if (((operand_30044->mClassTypeName.reader_value ()) != (operand_30058->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a '")) + (operand_30044->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class type variable, and I got a '")))) + (operand_30058->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class type variable"))) SOURCE_FILE_AT_LINE (760)) ;
                                        }
                                      }else{
                                        cPtr_typeGalgasUndefinedMapType * operand_30044 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_30044) ;
                                        cPtr_typeGalgasUndefinedMapType * operand_30058 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_30058) ;
                                        if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                                          if (((operand_30044->mMapTypeName.reader_value ()) != (operand_30058->mMapTypeName.reader_value ())).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting a '")) + (operand_30044->mMapTypeName.reader_value ()))) + (GGS_string (true, "' map type variable, and I got a '")))) + (operand_30058->mMapTypeName.reader_value ()))) + (GGS_string (true, "' map type variable"))) SOURCE_FILE_AT_LINE (767)) ;
                                          }
                                        }else{
                                          cPtr_typeGalgas_enum * operand_30044 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_30044) ;
                                          cPtr_typeGalgas_enum * operand_30058 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_30058) ;
                                          if ((operand_30044 != NULL) && (operand_30058 != NULL)) {
                                            if (((operand_30044->mEnumTypeName.reader_value ()) != (operand_30058->mEnumTypeName.reader_value ())).isBuiltAndTrue ()) {
                                                var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_30044->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_30058->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable"))) SOURCE_FILE_AT_LINE (775)) ;
                                            }
                                          }else{
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((var_cas_targetType.reader_messageGalgasType ()) + (GGS_string (true, " cannot be assigned from ")))) + (var_cas_sourceType.reader_messageGalgasType ())) SOURCE_FILE_AT_LINE (779)) ;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Lexique & _inLexique,
                                GGS_typeSemanticsTypesList   var_cas_t1,
                                GGS_typeListeAttributsSemantiques   var_cas_t2,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_t1.reader_length ()) < (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "one or more identifiers missing") SOURCE_FILE_AT_LINE (796)) ;
  }else if (((var_cas_t1.reader_length ()) > (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "too much identifiers") SOURCE_FILE_AT_LINE (798)) ;
  }else{
    GGS_typeSemanticsTypesList::element_type * operand_34491 = var_cas_t1.firstObject () ;
    GGS_typeListeAttributsSemantiques::element_type * operand_34576 = var_cas_t2.firstObject () ;
    while ((operand_34491 != NULL)
        && (operand_34576 != NULL)) {
      macroValidPointer (operand_34491) ;
      macroValidPointer (operand_34576) ;
      ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_34491->mType,  operand_34576->mAttributType,  operand_34491->mGalgasVariableName.reader_location () SOURCE_FILE_AT_LINE (802)) ;
      operand_34491 = operand_34491->nextObject () ;
      operand_34576 = operand_34576->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique & _inLexique,
                                GGS_L_EXsignature   var_cas_signatureReference,
                                GGS_L_actualParametersSignature   var_cas_inEffectiveArgumentsSignature,
                                const GGS_location  & var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_signatureReference.reader_length ()) > (var_cas_inEffectiveArgumentsSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "one or more arguments missing") SOURCE_FILE_AT_LINE (821)) ;
  }else if (((var_cas_signatureReference.reader_length ()) < (var_cas_inEffectiveArgumentsSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "too much arguments") SOURCE_FILE_AT_LINE (823)) ;
  }else{
    GGS_L_EXsignature::element_type * operand_35810 = var_cas_signatureReference.firstObject () ;
    GGS_L_actualParametersSignature::element_type * operand_35939 = var_cas_inEffectiveArgumentsSignature.firstObject () ;
    while ((operand_35810 != NULL)
        && (operand_35939 != NULL)) {
      macroValidPointer (operand_35810) ;
      macroValidPointer (operand_35939) ;
      if (operand_35810->mFormalArgumentPassingMode.isBuilt () && operand_35939->mFormalArgumentPassingMode.isBuilt ()) {
        if ((operand_35810->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentConstantIn) && (operand_35939->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
          ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_35810->mType,  operand_35939->mType,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (830)) ;
        }else{
          if ((operand_35810->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentIn) && (operand_35939->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
            ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_35810->mType,  operand_35939->mType,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (832)) ;
          }else{
            if ((operand_35810->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentInOut) && (operand_35939->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOutIn)) {
              ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_35810->mType,  operand_35939->mType,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (834)) ;
            }else{
              if ((operand_35810->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentOut) && (operand_35939->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterIn)) {
                if (operand_35939->mType.isBuilt ()) {
                  if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (operand_35939->mType.getPtr ()) != NULL) {
                  }else{ // Else part
                    ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  operand_35810->mType,  operand_35939->mType,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (839)) ;
                  }
                }
              }else{
                  var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((((operand_35939->mFormalArgumentPassingMode.reader_actualArgumentMessage ()) + (GGS_string (true, " is not compatible with ")))) + (operand_35810->mFormalArgumentPassingMode.reader_formalArgumentMessage ())) SOURCE_FILE_AT_LINE (843)) ;
              }
            }
          }
        }
      }
      operand_35810 = operand_35810->nextObject () ;
      operand_35939 = operand_35939->nextObject () ;
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList::constructor_empty (HERE) ;
    GGS_L_EXsignature::element_type * operand_37196 = var_cas_signatureReference.firstObject () ;
    GGS_typeExpressionList::element_type * operand_37264 = var_cas_expressionList.firstObject () ;
    while ((operand_37196 != NULL)
        && (operand_37264 != NULL)) {
      macroValidPointer (operand_37196) ;
      macroValidPointer (operand_37264) ;
      if (operand_37264->mExpression.isBuilt ()) {
        if (dynamic_cast <cPtr_typeJokerInExpression *> (operand_37264->mExpression.getPtr ()) != NULL) {
          cPtr_typeJokerInExpression * operand_37349 = dynamic_cast <cPtr_typeJokerInExpression *> (operand_37264->mExpression.getPtr ()) ;
          macroValidPointer (operand_37349) ; 
          GGS_typeCplusPlusName  var_cas_cppVarName ;
          var_cas_cppVarName = GGS_typeLocationAutomaticName::constructor_new (operand_37349->mLocation COMMA_HERE) ;
          GGS_typeExpression  var_cas_e ;
          var_cas_e = GGS_typeVarInExpression::constructor_new (var_cas_cppVarName COMMA_HERE) ;
          var_cas_ioExpressionList.addAssign_operation (var_cas_e) ;
          GGS_typeInstruction  var_cas_i ;
          var_cas_i = GGS_typeInstructionDeclarationVarLocale::constructor_new (var_cas_cppVarName, operand_37196->mType COMMA_HERE) ;
          var_cas_ioInstructionsList.addAssign_operation (var_cas_i) ;
        }else{ // Else part
          var_cas_ioExpressionList.addAssign_operation (operand_37264->mExpression) ;
        }
      }
      operand_37196 = operand_37196->nextObject () ;
      operand_37264 = operand_37264->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
methode_verifierType (C_Lexique & /* _inLexique */,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList) {
  GGS_typeCplusPlusName  var_cas_nullName ;
  var_cas_nullName = GGS_typeNullName::constructor_new (HERE) ;
  var_cas_outAllVariablesList.addAssign_operation (var_cas_nullName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::appendForDescription (C_String & ioString) const {
  ioString << "->@typeJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeJoker * ptr_ = (cPtr_typeJoker *) NULL ;
    macroMyNew (ptr_, cPtr_typeJoker (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
methode_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList) {
  GGS_location  var_cas_positionErreur ;
  var_cas_positionErreur = aPositionVariableCible ;
  ::routine_verifierCompatibiliteTypesSemantiques (_inLexique,  aTypeVarDest,  var_cas_typeArgumentFormel,  var_cas_positionErreur SOURCE_FILE_AT_LINE (894)) ;
  var_cas_listeAffectations.addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_outAllVariablesList.addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::appendForDescription (C_String & ioString) const {
  ioString << "->@typeEntiteDest:" ;
aTypeVarDest.reader_description () ;
mCppName.reader_description () ;
aPositionVariableCible.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
    constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteDest * ptr_ = (cPtr_typeEntiteDest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mAltParametersMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' non terminal symbol is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' non terminal symbol is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::reader_description (void) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceFileCppName (argument_0),
mGrammarName (argument_1),
mExpressionsList (argument_2),
mAltSymbol (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@C_grammarInstruction:" ;
mSourceFileCppName.reader_description () ;
mGrammarName.reader_description () ;
mExpressionsList.reader_description () ;
mAltSymbol.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_C_grammarInstruction * ptr_ = (cPtr_C_grammarInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeAppendInstruction:" ;
mTargetVarCppName.reader_description () ;
mSourceExpressions.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeAppendInstruction * ptr_ = (cPtr_typeAppendInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeIncrementInstruction:" ;
mTargetVarCppName.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeIncrementInstruction * ptr_ = (cPtr_typeIncrementInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeIncrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDecrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDecrementInstruction:" ;
mTargetVarCppName.reader_description () ;
mInstructionLocation.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeDecrementInstruction * ptr_ = (cPtr_typeDecrementInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeDecrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeAppendInstructionWithAssignment'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstructionWithAssignment::cPtr_typeAppendInstructionWithAssignment (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1),
m_luint_TargetVarCppName (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstructionWithAssignment::appendForDescription (C_String & ioString) const {
  ioString << "->@typeAppendInstructionWithAssignment:" ;
mTargetVarCppName.reader_description () ;
mSourceExpressions.reader_description () ;
m_luint_TargetVarCppName.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeAppendInstructionWithAssignment'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstructionWithAssignment * GGS_typeAppendInstructionWithAssignment::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeAppendInstructionWithAssignment * ptr_ = (cPtr_typeAppendInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelActionExterne::cPtr_typeInstructionAppelActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomAction (argument_0),
mExpressionsList (argument_1),
aListeTypesParametresFormels (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelActionExterne::appendForDescription (C_String & ioString) const {
  ioString << "->@typeInstructionAppelActionExterne:" ;
aNomAction.reader_description () ;
mExpressionsList.reader_description () ;
aListeTypesParametresFormels.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelActionExterne * GGS_typeInstructionAppelActionExterne::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionAppelActionExterne * ptr_ = (cPtr_typeInstructionAppelActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelActionExterne (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  mNextItem = (elementOf_GGS_L_matchInstructionCasesList *) NULL ;
  mCase1_name = argument_0 ;
  mCase2_name = argument_1 ;
  mInstructionList = argument_2 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mCase1_name.reader_description () ;
  ioString << mCase2_name.reader_description () ;
  ioString << mInstructionList.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList
::GGS_L_matchInstructionCasesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_L_matchInstructionCasesList
::GGS_L_matchInstructionCasesList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::~GGS_L_matchInstructionCasesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::operator = (const GGS_L_matchInstructionCasesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCase1_name,
                                p->mCase2_name,
                                p->mInstructionList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::reader_description (void) const {
  C_String s ;
  s << "<list @L_matchInstructionCasesList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_matchInstructionCasesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeMatchInstruction:" ;
aIndicatif1.reader_description () ;
aIndicatif2.reader_description () ;
aNomCppVariable1.reader_description () ;
aNomCppVariable2.reader_description () ;
aNomTypeBase1.reader_description () ;
aNomTypeBase2.reader_description () ;
mOperand1_isEnumeration.reader_description () ;
mOperand2_isEnumeration.reader_description () ;
aListeCas.reader_description () ;
mElseInstructionsList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
    constructor_new (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS) {
    cPtr_typeMatchInstruction * ptr_ = (cPtr_typeMatchInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  mNextItem = (elementOf_GGS_foreachEnumerationList *) NULL ;
  mCppEnumeratedVariableName = argument_0 ;
  mLocationOffset = argument_1 ;
  mCppTypeName = argument_2 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mCppEnumeratedVariableName.reader_description () ;
  ioString << mLocationOffset.reader_description () ;
  ioString << mCppTypeName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList
::GGS_foreachEnumerationList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_foreachEnumerationList
::GGS_foreachEnumerationList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::~GGS_foreachEnumerationList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::GGS_foreachEnumerationList (const GGS_foreachEnumerationList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::operator = (const GGS_foreachEnumerationList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppEnumeratedVariableName,
                                p->mLocationOffset,
                                p->mCppTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::reader_description (void) const {
  C_String s ;
  s << "<list @foreachEnumerationList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_foreachEnumerationList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mWhileExpression (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeForeachInstruction:" ;
mForeachEnumerationList.reader_description () ;
mWhileExpression.reader_description () ;
mInstructionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
    constructor_new (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeForeachInstruction * ptr_ = (cPtr_typeForeachInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeSimpleExtractInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeSimpleExtractInstruction:" ;
aNomVariable.reader_description () ;
aNomClasse.reader_description () ;
aListeAffectationParametresEffectifs.reader_description () ;
mErrorLocationExpression.reader_description () ;
aNomMessage.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_typeSimpleExtractInstruction * ptr_ = (cPtr_typeSimpleExtractInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  mNextItem = (elementOf_GGS_typeStructuredExtractCasesList *) NULL ;
  mClassName = argument_0 ;
  mResultVarID = argument_1 ;
  mInstructionList = argument_2 ;
  mNoUsedParameter = argument_3 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mClassName.reader_description () ;
  ioString << mResultVarID.reader_description () ;
  ioString << mInstructionList.reader_description () ;
  ioString << mNoUsedParameter.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList
::GGS_typeStructuredExtractCasesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeStructuredExtractCasesList
::GGS_typeStructuredExtractCasesList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::~GGS_typeStructuredExtractCasesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::operator = (const GGS_typeStructuredExtractCasesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mClassName,
                                p->mResultVarID,
                                p->mInstructionList,
                                p->mNoUsedParameter) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::reader_description (void) const {
  C_String s ;
  s << "<list @typeStructuredExtractCasesList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeStructuredExtractCasesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::appendForDescription (C_String & ioString) const {
  ioString << "->@typeStructuredExtractInstructionWithElse:" ;
mVariableName.reader_description () ;
mCasesList.reader_description () ;
mElseInstructionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeStructuredExtractInstructionWithElse * ptr_ = (cPtr_typeStructuredExtractInstructionWithElse *) NULL ;
    macroMyNew (ptr_, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomRoutine (argument_0),
mExpressionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeRoutineCallInstruction:" ;
aNomRoutine.reader_description () ;
mExpressionsList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeRoutineCallInstruction * ptr_ = (cPtr_typeRoutineCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDropInstruction:" ;
aVariableConsommee.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDropInstruction * ptr_ = (cPtr_typeDropInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableNomRoutinesDeclarees'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (void) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate & inOperand) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
~GGS_typeEntityToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (const GGS_typeEntityToGenerate & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (cPtr_typeEntityToGenerate * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr_typeEntityToGenerate * inSource) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntityToGenerate
::reader_description (void) const {
  C_String s ;
  s << "<class @typeEntityToGenerate" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mCppClassName (argument_1),
mIncludePath (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::appendForDescription (C_String & ioString) const {
  ioString << "->@typeExternTypeToGenerate:" ;
mGalgasName.reader_description () ;
mCppClassName.reader_description () ;
mIncludePath.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeExternTypeToGenerate * ptr_ = (cPtr_typeExternTypeToGenerate *) NULL ;
    macroMyNew (ptr_, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::appendForDescription (C_String & ioString) const {
  ioString << "->@typeRoutineAengendrer:" ;
aNomRoutine.reader_description () ;
aListeTypeEtNomsArguments.reader_description () ;
mInstructionList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeRoutineAengendrer * ptr_ = (cPtr_typeRoutineAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::appendForDescription (C_String & ioString) const {
  ioString << "->@C_listTypeToImplement:" ;
aNomListe.reader_description () ;
mNonExternAttributesList.reader_description () ;
mExternAttributesList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_C_listTypeToImplement * ptr_ = (cPtr_C_listTypeToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_listTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
aNomClasseGenerique (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
aTableMethodesSurcharger (argument_6) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDefinitionTableAimplementer:" ;
aNomTable.reader_description () ;
mNonExternAttributesList.reader_description () ;
mExternAttributesList.reader_description () ;
aNomClasseGenerique.reader_description () ;
mInsertMethodList.reader_description () ;
mSearchMethodList.reader_description () ;
aTableMethodesSurcharger.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS) {
    cPtr_typeDefinitionTableAimplementer * ptr_ = (cPtr_typeDefinitionTableAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::appendForDescription (C_String & ioString) const {
  ioString << "->@C_mapToImplement:" ;
aNomTable.reader_description () ;
mNonExternAttributesList.reader_description () ;
mExternAttributesList.reader_description () ;
mInsertMethodList.reader_description () ;
mSearchMethodList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_C_mapToImplement * ptr_ = (cPtr_C_mapToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseAbstraiteAimplementer::cPtr_typeDefClasseAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefClasseAbstraiteAimplementer::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDefClasseAbstraiteAimplementer:" ;
aNomClasse.reader_description () ;
aListeTousAttributsNonExternes.reader_description () ;
aTableToutesMethodes.reader_description () ;
mMethodsMap.reader_description () ;
aListeAttributsCourants.reader_description () ;
aListeExternesCourants.reader_description () ;
mAncestorClassesMap.reader_description () ;
mMessagesMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefClasseAbstraiteAimplementer * GGS_typeDefClasseAbstraiteAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
    cPtr_typeDefClasseAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseNonAbstraiteAimplementer::cPtr_typeDefClasseNonAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDefClasseNonAbstraiteAimplementer::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDefClasseNonAbstraiteAimplementer:" ;
aNomClasse.reader_description () ;
aListeTousAttributsNonExternes.reader_description () ;
aTableToutesMethodes.reader_description () ;
mMethodsMap.reader_description () ;
aListeAttributsCourants.reader_description () ;
aListeExternesCourants.reader_description () ;
mAncestorClassesMap.reader_description () ;
mMessagesMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefClasseNonAbstraiteAimplementer * GGS_typeDefClasseNonAbstraiteAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
    cPtr_typeDefClasseNonAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseNonAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseNonAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::cPtr_typeEntiteActionExterne (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}


const char * cPtr_typeEntiteActionExterne::message_messageTypeEntite (void) const {
  return "an external action" ;
}

const char * cPtr_typeEntiteActionExterne::static_string_message_messageTypeEntite (void) {
  return "an external action" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteActionExterne::appendForDescription (C_String & ioString) const {
  ioString << "->@typeEntiteActionExterne:" ;
aSignature.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
    constructor_new (const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeEntiteActionExterne * ptr_ = (cPtr_typeEntiteActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteActionExterne (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeActionExterneAengendrer::appendForDescription (C_String & ioString) const {
  ioString << "->@typeActionExterneAengendrer:" ;
aNomAction.reader_description () ;
aSignature.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeActionExterneAengendrer * ptr_ = (cPtr_typeActionExterneAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0) {
  mNextItem = (elementOf_GGS_typeEntitiesToGenerateList *) NULL ;
  mEntityToGenerate = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mEntityToGenerate.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList
::GGS_typeEntitiesToGenerateList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeEntitiesToGenerateList
::GGS_typeEntitiesToGenerateList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::~GGS_typeEntitiesToGenerateList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::operator = (const GGS_typeEntitiesToGenerateList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalAppendItem (const GGS_typeEntityToGenerate & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mEntityToGenerate) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::reader_description (void) const {
  C_String s ;
  s << "<list @typeEntitiesToGenerateList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeEntitiesToGenerateList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Lexique & _inLexique,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse::constructor_empty (HERE) ;
  GGS_lstring  var_cas_name ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_lstring::constructor_new (HERE) ;
  GGS_AC_semanticsEntity  var_cas_e ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1247)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_lbool::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1252)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_luint::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1257)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_lsint::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1262)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_ldouble::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1267)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_lchar::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1272)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "location"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_location::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1277)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_uint::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1282)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_sint::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1287)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_char::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1292)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_string::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1297)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_bool::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1302)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_double::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1307)) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE) ;
  var_cas_t = GGS_typeGalgas_stringset::constructor_new (HERE) ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t COMMA_HERE) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (_inLexique, var_cas_name, var_cas_e SOURCE_FILE_AT_LINE (1312)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'typeEnumCstMessageStringMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mMessageString.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the message for '%K' constant is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the message for '%K' constant is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::appendForDescription (C_String & ioString) const {
  ioString << "->@enumGalgasType:" ;
mEnumTypeName.reader_description () ;
mConstantMap.reader_description () ;
mEnumMessageMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_enumGalgasType * ptr_ = (cPtr_enumGalgasType *) NULL ;
    macroMyNew (ptr_, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map 'mapAsConstraintPropertyMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapAsConstraintPropertyMap::
elementOf_GGS_mapAsConstraintPropertyMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_mapAsConstraintPropertyMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAsConstraintPropertyMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mMapTypeName.reader_description () ;
  ioString << mInfo.mElementTypeName.reader_description () ;
  ioString << mInfo.mPassIndex.reader_description () ;
  ioString << mInfo.mPassName.reader_description () ;
  ioString << mInfo.mIsShared.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAsConstraintPropertyMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_mapAsConstraintPropertyMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAsConstraintPropertyMap * info = (e_mapAsConstraintPropertyMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_mapAsConstraintPropertyMap GGS_mapAsConstraintPropertyMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_mapAsConstraintPropertyMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               const GGS_lstring &  inParameter1,
               const GGS_uint &  inParameter2,
               const GGS_string&  inParameter3,
               const GGS_bool&  inParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_mapAsConstraintPropertyMap info  ;
    info.mMapTypeName = inParameter0 ;
    info.mElementTypeName = inParameter1 ;
    info.mPassIndex = inParameter2 ;
    info.mPassName = inParameter3 ;
    info.mIsShared = inParameter4 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_string  & outParameter3,
               GGS_bool  & outParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMapTypeName ;
    outParameter1 = node->mInfo.mElementTypeName ;
    outParameter2 = node->mInfo.mPassIndex ;
    outParameter3 = node->mInfo.mPassName ;
    outParameter4 = node->mInfo.mIsShared ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_uint   & outParameter2,
                                GGS_string  & outParameter3,
                                GGS_bool  & outParameter4 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' map property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAsConstraintPropertyMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1,
                                const GGS_uint & inParameter2,
                                const GGS_string& inParameter3,
                                const GGS_bool& inParameter4 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' map property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAsConstraintPropertyMap::reader_description (void) const {
  C_String s ;
  s << "<map @mapAsConstraintPropertyMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'passMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_passMap::
elementOf_GGS_passMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_passMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_passMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_passMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_passMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_passMap * info = (e_passMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_passMap GGS_passMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_passMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_passMap info  ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_passMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_passMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' pass name is not declared",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::methode_searchKeyAndGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' pass name is not declared",
                 inKey,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_passMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' pass name has been already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_passMap::reader_description (void) const {
  C_String s ;
  s << "<map @passMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sharedPropertyList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sharedPropertyList::
elementOf_GGS_sharedPropertyList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_sharedPropertyList *) NULL ;
  mSharedPropertyTypeName = argument_0 ;
  mSharedPropertyName = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sharedPropertyList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mSharedPropertyTypeName.reader_description () ;
  ioString << mSharedPropertyName.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@sharedPropertyList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sharedPropertyList
::GGS_sharedPropertyList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_sharedPropertyList
::GGS_sharedPropertyList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::~GGS_sharedPropertyList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList::GGS_sharedPropertyList (const GGS_sharedPropertyList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList
::operator = (const GGS_sharedPropertyList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sharedPropertyList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mSharedPropertyTypeName,
                                p->mSharedPropertyName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sharedPropertyList  GGS_sharedPropertyList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_sharedPropertyList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sharedPropertyList::reader_description (void) const {
  C_String s ;
  s << "<list @sharedPropertyList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_sharedPropertyList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class map 'callInstructionSharedPropertySignatureMap'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_callInstructionSharedPropertySignatureMap::
elementOf_GGS_callInstructionSharedPropertySignatureMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_callInstructionSharedPropertySignatureMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_callInstructionSharedPropertySignatureMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mSignature.reader_description () ;
  ioString << mInfo.mSignatureLocation.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_callInstructionSharedPropertySignatureMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_callInstructionSharedPropertySignatureMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_callInstructionSharedPropertySignatureMap * info = (e_callInstructionSharedPropertySignatureMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_callInstructionSharedPropertySignatureMap GGS_callInstructionSharedPropertySignatureMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_callInstructionSharedPropertySignatureMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_sharedPropertyList &  inParameter0,
               const GGS_location &  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_callInstructionSharedPropertySignatureMap info  ;
    info.mSignature = inParameter0 ;
    info.mSignatureLocation = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_sharedPropertyList   & outParameter0,
               GGS_location   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mSignature ;
    outParameter1 = node->mInfo.mSignatureLocation ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_sharedPropertyList   & outParameter0,
                                GGS_location   & outParameter1 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "internal error: the '%K' property is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstructionSharedPropertySignatureMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_sharedPropertyList & inParameter0,
                                const GGS_location & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "internal error: the '%K' property has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_callInstructionSharedPropertySignatureMap::reader_description (void) const {
  C_String s ;
  s << "<map @callInstructionSharedPropertySignatureMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'constrainedEntityPassMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constrainedEntityPassMap::
elementOf_GGS_constrainedEntityPassMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constrainedEntityPassMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constrainedEntityPassMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mInstructionList.reader_description () ;
  ioString << mInfo.mSharedPropertyList.reader_description () ;
  ioString << mInfo.mConstraintPropertyDefinitionSet.reader_description () ;
  ioString << mInfo.mCallInstructionSharedPropertySignatureMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constrainedEntityPassMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constrainedEntityPassMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constrainedEntityPassMap * info = (e_constrainedEntityPassMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityPassMap GGS_constrainedEntityPassMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_constrainedEntityPassMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeInstructionList &  inParameter0,
               const GGS_sharedPropertyList &  inParameter1,
               const GGS_stringset &  inParameter2,
               const GGS_callInstructionSharedPropertySignatureMap &  inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_constrainedEntityPassMap info  ;
    info.mInstructionList = inParameter0 ;
    info.mSharedPropertyList = inParameter1 ;
    info.mConstraintPropertyDefinitionSet = inParameter2 ;
    info.mCallInstructionSharedPropertySignatureMap = inParameter3 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeInstructionList   & outParameter0,
               GGS_sharedPropertyList   & outParameter1,
               GGS_stringset   & outParameter2,
               GGS_callInstructionSharedPropertySignatureMap   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mInstructionList ;
    outParameter1 = node->mInfo.mSharedPropertyList ;
    outParameter2 = node->mInfo.mConstraintPropertyDefinitionSet ;
    outParameter3 = node->mInfo.mCallInstructionSharedPropertySignatureMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeInstructionList   & outParameter0,
                                GGS_sharedPropertyList   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_callInstructionSharedPropertySignatureMap   & outParameter3 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' pass name is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityPassMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeInstructionList & inParameter0,
                                const GGS_sharedPropertyList & inParameter1,
                                const GGS_stringset & inParameter2,
                                const GGS_callInstructionSharedPropertySignatureMap & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' pass name has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constrainedEntityPassMap::reader_description (void) const {
  C_String s ;
  s << "<map @constrainedEntityPassMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'constrainedEntityMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_constrainedEntityMap::
elementOf_GGS_constrainedEntityMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_constrainedEntityMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_constrainedEntityMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mPassesDefinedByInheritanceTreeRootEntity.reader_description () ;
  ioString << mInfo.mConstrainedEntityPassMap.reader_description () ;
  ioString << mInfo.mSuperEntityName.reader_description () ;
  ioString << mInfo.mEntityPropertiesMap.reader_description () ;
  ioString << mInfo.mDescendantEntitySet.reader_description () ;
  ioString << mInfo.mEndOfConstraintLocation.reader_description () ;
  ioString << mInfo.mMapAsConstraintPropertyCurrentMap.reader_description () ;
  ioString << mInfo.mAllMapsAsConstraintPropertyMap.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_constrainedEntityMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_constrainedEntityMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_constrainedEntityMap * info = (e_constrainedEntityMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_constrainedEntityMap GGS_constrainedEntityMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_constrainedEntityMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_stringset &  inParameter0,
               const GGS_constrainedEntityPassMap &  inParameter1,
               const GGS_lstring &  inParameter2,
               const GGS_entityPropertyMap &  inParameter3,
               const GGS_stringset &  inParameter4,
               const GGS_location &  inParameter5,
               const GGS_mapAsConstraintPropertyMap &  inParameter6,
               const GGS_mapAsConstraintPropertyMap &  inParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_constrainedEntityMap info  ;
    info.mPassesDefinedByInheritanceTreeRootEntity = inParameter0 ;
    info.mConstrainedEntityPassMap = inParameter1 ;
    info.mSuperEntityName = inParameter2 ;
    info.mEntityPropertiesMap = inParameter3 ;
    info.mDescendantEntitySet = inParameter4 ;
    info.mEndOfConstraintLocation = inParameter5 ;
    info.mMapAsConstraintPropertyCurrentMap = inParameter6 ;
    info.mAllMapsAsConstraintPropertyMap = inParameter7 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringset   & outParameter0,
               GGS_constrainedEntityPassMap   & outParameter1,
               GGS_lstring   & outParameter2,
               GGS_entityPropertyMap   & outParameter3,
               GGS_stringset   & outParameter4,
               GGS_location   & outParameter5,
               GGS_mapAsConstraintPropertyMap   & outParameter6,
               GGS_mapAsConstraintPropertyMap   & outParameter7,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    outParameter6.drop_operation () ;
    outParameter7.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mPassesDefinedByInheritanceTreeRootEntity ;
    outParameter1 = node->mInfo.mConstrainedEntityPassMap ;
    outParameter2 = node->mInfo.mSuperEntityName ;
    outParameter3 = node->mInfo.mEntityPropertiesMap ;
    outParameter4 = node->mInfo.mDescendantEntitySet ;
    outParameter5 = node->mInfo.mEndOfConstraintLocation ;
    outParameter6 = node->mInfo.mMapAsConstraintPropertyCurrentMap ;
    outParameter7 = node->mInfo.mAllMapsAsConstraintPropertyMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset   & outParameter0,
                                GGS_constrainedEntityPassMap   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_entityPropertyMap   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_location   & outParameter5,
                                GGS_mapAsConstraintPropertyMap   & outParameter6,
                                GGS_mapAsConstraintPropertyMap   & outParameter7 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "no constraint has been defined for the '@%K' entity",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 outParameter6,
                 outParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constrainedEntityMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringset & inParameter0,
                                const GGS_constrainedEntityPassMap & inParameter1,
                                const GGS_lstring & inParameter2,
                                const GGS_entityPropertyMap & inParameter3,
                                const GGS_stringset & inParameter4,
                                const GGS_location & inParameter5,
                                const GGS_mapAsConstraintPropertyMap & inParameter6,
                                const GGS_mapAsConstraintPropertyMap & inParameter7 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "constraints for '@%K' entity has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 inParameter7,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constrainedEntityMap::reader_description (void) const {
  C_String s ;
  s << "<map @constrainedEntityMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'callInstruction'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_callInstruction::cPtr_callInstruction (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_metamodelPropertyKind& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_L_lstringList & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCurrentPassName (argument_0),
mCalledPropertyName (argument_1),
mPropertyKind (argument_2),
mPropertyTypeName (argument_3),
mParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_callInstruction::appendForDescription (C_String & ioString) const {
  ioString << "->@callInstruction:" ;
mCurrentPassName.reader_description () ;
mCalledPropertyName.reader_description () ;
mPropertyKind.reader_description () ;
mPropertyTypeName.reader_description () ;
mParameterList.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_callInstruction * GGS_callInstruction::
    constructor_new (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_metamodelPropertyKind& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_L_lstringList & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_callInstruction * ptr_ = (cPtr_callInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_callInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "displayConstraintDefinitionErrors"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayConstraintDefinitionErrors (C_Lexique & _inLexique,
                                GGS_stringset   var_cas_inFirstBranchconstraintDefinitionSet,
                                GGS_stringset   var_cas_inCurrentBranchconstraintDefinitionSet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset  var_cas_missingDefinition ;
  var_cas_missingDefinition = var_cas_inFirstBranchconstraintDefinitionSet.substract_operation (_inLexique, var_cas_inCurrentBranchconstraintDefinitionSet SOURCE_FILE_AT_LINE (1448)) ;
   ;
  GGS_stringset::element_type * operand_61937 = var_cas_missingDefinition.firstObject () ;
  while ((operand_61937 != NULL)) {
    macroValidPointer (operand_61937) ;
      GGS_location (_inLexique).reader_location ().signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_61937->mKey))) + (GGS_string (true, "' property is initialized by first branch, but not by this one"))) SOURCE_FILE_AT_LINE (1450)) ;
    operand_61937 = operand_61937->nextObject () ;
  }
  GGS_stringset  var_cas_unexpectedDefinition ;
  var_cas_unexpectedDefinition = var_cas_inCurrentBranchconstraintDefinitionSet.substract_operation (_inLexique, var_cas_inFirstBranchconstraintDefinitionSet SOURCE_FILE_AT_LINE (1452)) ;
   ;
  GGS_stringset::element_type * operand_62234 = var_cas_unexpectedDefinition.firstObject () ;
  while ((operand_62234 != NULL)) {
    macroValidPointer (operand_62234) ;
      GGS_location (_inLexique).reader_location ().signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_62234->mKey))) + (GGS_string (true, "' property is not initialized by first branch, but by this one"))) SOURCE_FILE_AT_LINE (1454)) ;
    operand_62234 = operand_62234->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Implementation of routine "displayConstraintDefinitionErrorsNoElse"     *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_displayConstraintDefinitionErrorsNoElse (C_Lexique & _inLexique,
                                GGS_stringset   var_cas_inFirstBranchConstraintDefinitionSet,
                                GGS_stringset   var_cas_inInheritedConstraintDefinitionSet COMMA_UNUSED_LOCATION_ARGS) {
  GGS_stringset  var_cas_missingDefinition ;
  var_cas_missingDefinition = var_cas_inFirstBranchConstraintDefinitionSet.substract_operation (_inLexique, var_cas_inInheritedConstraintDefinitionSet SOURCE_FILE_AT_LINE (1464)) ;
   ;
  GGS_stringset::element_type * operand_62770 = var_cas_missingDefinition.firstObject () ;
  while ((operand_62770 != NULL)) {
    macroValidPointer (operand_62770) ;
      GGS_location (_inLexique).reader_location ().signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (operand_62770->mKey))) + (GGS_string (true, "' property is initialized by first branch, but there is no else branch"))) SOURCE_FILE_AT_LINE (1466)) ;
    operand_62770 = operand_62770->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

