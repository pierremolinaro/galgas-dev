//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 25th, 2010, at 11h36'43"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semantics_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeCplusPlusNameList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeCplusPlusNameList * ptr = dynamic_cast <const elementOf_GGS_typeCplusPlusNameList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppName.operator_isEqual (ptr->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCplusPlusNameList ("typeCplusPlusNameList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
operator_concat (const GGS_typeCplusPlusNameList & inOperand) const {
  GGS_typeCplusPlusNameList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
dotAssign_operation (const GGS_typeCplusPlusNameList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeCplusPlusNameList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppName ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCppName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_emptyList (void) {
  GGS_typeCplusPlusNameList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_listWithValue (const GGS_typeCplusPlusName & argument_0) {
  GGS_typeCplusPlusNameList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalSubListWithRange (GGS_typeCplusPlusNameList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCppName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeCplusPlusNameList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_first (C_CompilerEx & inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_last (C_CompilerEx & inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCppName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeCplusPlusNameList::
reader_mCppNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_setMCppNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_typeCplusPlusNameList::cEnumerator::_mCppName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeCplusPlusNameList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCplusPlusNameList * p = NULL ;
    macroMyNew (p, GGS_typeCplusPlusNameList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCplusPlusNameList * p = dynamic_cast <const GGS_typeCplusPlusNameList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCplusPlusNameList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCplusPlusNameList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCplusPlusNameList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_typeClassMessagesMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeClassMessagesMap::e_typeClassMessagesMap (void) :
mMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeClassMessagesMap ("typeClassMessagesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeClassMessagesMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeClassMessagesMap * ptr = dynamic_cast <const elementOf_GGS_typeClassMessagesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMessage.operator_isEqual (ptr->mInfo.mMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeClassMessagesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
operator_isEqual (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
operator_isNotEqual (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeClassMessagesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeClassMessagesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeClassMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeClassMessagesMap::cEnumerator::_mMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeClassMessagesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeClassMessagesMap * p = NULL ;
    macroMyNew (p, GGS_typeClassMessagesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeClassMessagesMap * p = dynamic_cast <const GGS_typeClassMessagesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeClassMessagesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeClassMessagesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeClassMessagesMap ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mType (argument_0),
mGalgasVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticsTypesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeSemanticsTypesList * ptr = dynamic_cast <const elementOf_GGS_typeSemanticsTypesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mGalgasVariableName.operator_isEqual (ptr->mGalgasVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasVariableName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeSemanticsTypesList ("typeSemanticsTypesList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
operator_concat (const GGS_typeSemanticsTypesList & inOperand) const {
  GGS_typeSemanticsTypesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
dotAssign_operation (const GGS_typeSemanticsTypesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeSemanticsTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mGalgasVariableName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mGalgasVariableName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_emptyList (void) {
  GGS_typeSemanticsTypesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_listWithValue (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typeSemanticsTypesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalSubListWithRange (GGS_typeSemanticsTypesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mGalgasVariableName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeSemanticsTypesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeSemanticsTypesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeSemanticsTypesList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_first (C_CompilerEx & inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_last (C_CompilerEx & inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mGalgasVariableName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeSemanticsTypesList::
reader_mTypeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_AC_galgasType  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSemanticsTypesList::
reader_mGalgasVariableNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mGalgasVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_setMTypeAtIndex (C_CompilerEx & inLexique,
                              const GGS_AC_galgasType  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_setMGalgasVariableNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mGalgasVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeSemanticsTypesList::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeSemanticsTypesList::cEnumerator::_mGalgasVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mGalgasVariableName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeSemanticsTypesList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeSemanticsTypesList * p = NULL ;
    macroMyNew (p, GGS_typeSemanticsTypesList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeSemanticsTypesList * p = dynamic_cast <const GGS_typeSemanticsTypesList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeSemanticsTypesList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeSemanticsTypesList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeSemanticsTypesList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

e_typeVariablesMap::e_typeVariablesMap (void) :
mArgumentType (),
mCplusPlusName () {
}

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map '@typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadOnlyAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccessGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForDestructiveReadAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccessGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadWriteAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccessGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForWriteAccess (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccessGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::cElement * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outIndex.drop () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (PMUInt32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUnusedInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUsedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadow (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgumentNoShadow (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadowGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUsedConstInArgumentNoShadow (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUnusedConstInArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariable (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariableGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertWithInstructionLocalVariable (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertWithInstructionLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertWithInstructionLocalVariableGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertWithInstructionLocalVariable (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUsedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgument (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgumentGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const PMSInt32 attributeIndex = insertUnusedInOutArgument (inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
aNomVariableCible (argument_0),
aNomAttributSource (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_assignedVariables::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_assignedVariables * ptr = dynamic_cast <const elementOf_GGS_L_assignedVariables *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariableCible.operator_isEqual (ptr->aNomVariableCible).boolValue ()
         && aNomAttributSource.operator_isEqual (ptr->aNomAttributSource).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomVariableCible.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomAttributSource.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_assignedVariables ("L_assignedVariables", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
operator_concat (const GGS_L_assignedVariables & inOperand) const {
  GGS_L_assignedVariables result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
dotAssign_operation (const GGS_L_assignedVariables inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_assignedVariables * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->aNomVariableCible ;
          GGS_lstring  p_1 = p->aNomAttributSource ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->aNomVariableCible,
                                ptr->aNomAttributSource
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_emptyList (void) {
  GGS_L_assignedVariables result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_listWithValue (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_L_assignedVariables result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalSubListWithRange (GGS_L_assignedVariables & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->aNomVariableCible, ptr->aNomAttributSource) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_assignedVariables result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_assignedVariables result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_assignedVariables", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_first (C_CompilerEx & inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_last (C_CompilerEx & inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aNomVariableCible ;
    _out_1 = ptr->aNomAttributSource ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_L_assignedVariables::
reader_aNomVariableCibleAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aNomVariableCible ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_assignedVariables::
reader_aNomAttributSourceAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aNomAttributSource ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_setANomVariableCibleAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aNomVariableCible = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_setANomAttributSourceAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aNomAttributSource = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_L_assignedVariables::cEnumerator::_aNomVariableCible (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->aNomVariableCible ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_assignedVariables::cEnumerator::_aNomAttributSource (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->aNomAttributSource ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_assignedVariables::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_assignedVariables * p = NULL ;
    macroMyNew (p, GGS_L_assignedVariables (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_assignedVariables * p = dynamic_cast <const GGS_L_assignedVariables *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_assignedVariables, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_assignedVariables::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_assignedVariables ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_typeCible'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCible) ;
    return (cPtr_typeCible *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCible::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeCible:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCible::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCible::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCible (& typeid (cPtr_typeCible), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCible::galgasRTTI (void) const {
  return & gClassInfoFor__typeCible ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCible ("typeCible", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCible GGS_typeCible::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCible result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCible *> (inPointer) != NULL)
      : (typeid (cPtr_typeCible) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCible (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCible),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCible::actualTypeName (void) const {
  return "typeCible" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeCible::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeCible ("typeCible", & kTypeDescriptor_GGS_typeCible) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCible::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCible * p = NULL ;
    macroMyNew (p, GGS_typeCible (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCible GGS_typeCible::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCible result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCible * p = dynamic_cast <const GGS_typeCible *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCible, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCible::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCible ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
aCible (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCibles::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCibles * ptr = dynamic_cast <const elementOf_GGS_typeListeCibles *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aCible.operator_isEqual (ptr->aCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aCible.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeCibles ("typeListeCibles", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalAppendValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalPrependValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
addAssign_operation (const GGS_typeCible & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
operator_concat (const GGS_typeListeCibles & inOperand) const {
  GGS_typeListeCibles result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
dotAssign_operation (const GGS_typeListeCibles inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeCibles * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCible  p_0 = p->aCible ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeCible & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->aCible
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_emptyList (void) {
  GGS_typeListeCibles result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_listWithValue (const GGS_typeCible & argument_0) {
  GGS_typeListeCibles result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalSubListWithRange (GGS_typeListeCibles & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->aCible) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCibles result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCibles result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeCibles", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_first (C_CompilerEx & inLexique,
              GGS_typeCible & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_last (C_CompilerEx & inLexique,
             GGS_typeCible & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeCible & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeCible & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->aCible ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCible  GGS_typeListeCibles::
reader_aCibleAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCible  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->aCible ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_setACibleAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeCible  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->aCible = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCible  & GGS_typeListeCibles::cEnumerator::_aCible (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->aCible ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeCibles::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeCibles * p = NULL ;
    macroMyNew (p, GGS_typeListeCibles (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeCibles * p = dynamic_cast <const GGS_typeListeCibles *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeCibles, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeCibles::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeCibles ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mType (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_nameWithType::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_nameWithType * ptr = dynamic_cast <const elementOf_GGS_L_nameWithType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mName.operator_isEqual (ptr->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_nameWithType ("L_nameWithType", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
operator_concat (const GGS_L_nameWithType & inOperand) const {
  GGS_L_nameWithType result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
dotAssign_operation (const GGS_L_nameWithType inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_nameWithType * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mType,
                                ptr->mName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_emptyList (void) {
  GGS_L_nameWithType result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_L_nameWithType result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalSubListWithRange (GGS_L_nameWithType & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mType, ptr->mName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_nameWithType result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_nameWithType result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_nameWithType", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mType ;
    _out_1 = ptr->mName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_nameWithType::
reader_mTypeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_nameWithType::
reader_mNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_setMTypeAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_setMNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_nameWithType::cEnumerator::_mType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_nameWithType::cEnumerator::_mName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_nameWithType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_nameWithType * p = NULL ;
    macroMyNew (p, GGS_L_nameWithType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_nameWithType * p = dynamic_cast <const GGS_L_nameWithType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_nameWithType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_nameWithType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_nameWithType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

e_typeTableMethodesAimplementer::e_typeTableMethodesAimplementer (void) :
aListeTypesParametres (),
aListeTypeEtNomsArguments (),
mInstructionList () {
}

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableMethodesAimplementer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstract (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstractGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const PMSInt32 attributeIndex = insertAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstract (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstractGetIndex (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const PMSInt32 attributeIndex = insertNotAbstract (inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (PMUInt32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeExpressionList * ptr = dynamic_cast <const elementOf_GGS_typeExpressionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeExpressionList ("typeExpressionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalAppendValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalPrependValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
addAssign_operation (const GGS_typeExpression & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
operator_concat (const GGS_typeExpressionList & inOperand) const {
  GGS_typeExpressionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
dotAssign_operation (const GGS_typeExpressionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mExpression ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeExpression & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_emptyList (void) {
  GGS_typeExpressionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_listWithValue (const GGS_typeExpression & argument_0) {
  GGS_typeExpressionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalSubListWithRange (GGS_typeExpressionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeExpressionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeExpressionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeExpressionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_first (C_CompilerEx & inLexique,
              GGS_typeExpression & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_last (C_CompilerEx & inLexique,
             GGS_typeExpression & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeExpression & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeExpression & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeExpressionList::
reader_mExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_setMExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_typeExpressionList::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeExpressionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeExpressionList * p = NULL ;
    macroMyNew (p, GGS_typeExpressionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeExpressionList * p = dynamic_cast <const GGS_typeExpressionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeExpressionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeExpressionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeExpressionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_varToDropList::
elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mVarToDrop (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_varToDropList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_varToDropList * ptr = dynamic_cast <const elementOf_GGS_varToDropList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarToDrop.operator_isEqual (ptr->mVarToDrop).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_varToDropList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarToDrop.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_varToDropList ("varToDropList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_varToDropList::
internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
operator_concat (const GGS_varToDropList & inOperand) const {
  GGS_varToDropList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
dotAssign_operation (const GGS_varToDropList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_varToDropList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mVarToDrop ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mVarToDrop
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_emptyList (void) {
  GGS_varToDropList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_listWithValue (const GGS_typeCplusPlusName & argument_0) {
  GGS_varToDropList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
internalSubListWithRange (GGS_varToDropList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mVarToDrop) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_varToDropList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_varToDropList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varToDropList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@varToDropList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_first (C_CompilerEx & inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_last (C_CompilerEx & inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVarToDrop ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_varToDropList::
reader_mVarToDropAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusName  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVarToDrop ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_setMVarToDropAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeCplusPlusName  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVarToDrop = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_varToDropList::cEnumerator::_mVarToDrop (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mVarToDrop ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_varToDropList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_varToDropList * p = NULL ;
    macroMyNew (p, GGS_varToDropList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_varToDropList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_varToDropList * p = dynamic_cast <const GGS_varToDropList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_varToDropList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_varToDropList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_varToDropList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeErrorInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::
cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2),
mVarToDropList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeErrorInstruction) ;
    return (cPtr_typeErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeErrorInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeErrorInstruction * ptr = dynamic_cast <const cPtr_typeErrorInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue ()
         && mErrorMessageExpression.operator_isEqual (ptr->mErrorMessageExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mVarToDropList.operator_isEqual (ptr->mVarToDropList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeErrorInstruction:"
           << mErrorLocationExpression.reader_description (inIndentation + 1)
           << mErrorMessageExpression.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mVarToDropList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeErrorInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeErrorInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeErrorInstruction (& typeid (cPtr_typeErrorInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeErrorInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeErrorInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeErrorInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeErrorInstruction (mErrorLocationExpression, mErrorMessageExpression, mLocation, mVarToDropList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeErrorInstruction ("typeErrorInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeErrorInstruction GGS_typeErrorInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeErrorInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeErrorInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeErrorInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeErrorInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction GGS_typeErrorInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2,
                 const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorLocationExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorMessageExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeErrorInstruction::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_typeErrorInstruction::
reader_mVarToDropList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_varToDropList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mVarToDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeErrorInstruction::actualTypeName (void) const {
  return "typeErrorInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeErrorInstruction ("typeErrorInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeErrorInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeErrorInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeErrorInstruction * p = NULL ;
    macroMyNew (p, GGS_typeErrorInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction GGS_typeErrorInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeErrorInstruction * p = dynamic_cast <const GGS_typeErrorInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeErrorInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeErrorInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeErrorInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeSendInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSendInstruction::
cPtr_typeSendInstruction (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSendInstruction * GGS_typeSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeSendInstruction) ;
    return (cPtr_typeSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSendInstruction * ptr = dynamic_cast <const cPtr_typeSendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSendInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeSendInstruction:"
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSendInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSendInstruction (& typeid (cPtr_typeSendInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSendInstruction (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSendInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeSendInstruction ("typeSendInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeSendInstruction::
GGS_typeSendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction::
GGS_typeSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSendInstruction GGS_typeSendInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction GGS_typeSendInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeSendInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSendInstruction::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSendInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSendInstruction::actualTypeName (void) const {
  return "typeSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeSendInstruction ("typeSendInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeSendInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeSendInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeSendInstruction * p = NULL ;
    macroMyNew (p, GGS_typeSendInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSendInstruction GGS_typeSendInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeSendInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeSendInstruction * p = dynamic_cast <const GGS_typeSendInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeSendInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeSendInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeSendInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeWithInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWithInstruction::
cPtr_typeWithInstruction (const GGS_string& argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_string& argument_3,
                                const GGS_typeExpression & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_typeInstructionList & argument_6,
                                const GGS_location & argument_7,
                                const GGS_bool& argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMapTypeName (argument_0),
mAccessedVariableCppName (argument_1),
mStructAttributeList (argument_2),
mErrorMessageName (argument_3),
mKeyExpression (argument_4),
mDoBranchInstructionList (argument_5),
mElseBranchInstructionList (argument_6),
mInstructionLocation (argument_7),
mReadWriteAccess (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWithInstruction * GGS_typeWithInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeWithInstruction) ;
    return (cPtr_typeWithInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeWithInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeWithInstruction * ptr = dynamic_cast <const cPtr_typeWithInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAccessedVariableCppName.operator_isEqual (ptr->mAccessedVariableCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mErrorMessageName.operator_isEqual (ptr->mErrorMessageName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructionList.operator_isEqual (ptr->mDoBranchInstructionList).boolValue ()
         && mElseBranchInstructionList.operator_isEqual (ptr->mElseBranchInstructionList).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReadWriteAccess.operator_isEqual (ptr->mReadWriteAccess).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeWithInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeWithInstruction:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mAccessedVariableCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mErrorMessageName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructionList.reader_description (inIndentation + 1)
           << mElseBranchInstructionList.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReadWriteAccess.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeWithInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeWithInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeWithInstruction (& typeid (cPtr_typeWithInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeWithInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeWithInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeWithInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeWithInstruction (mMapTypeName, mAccessedVariableCppName, mStructAttributeList, mErrorMessageName, mKeyExpression, mDoBranchInstructionList, mElseBranchInstructionList, mInstructionLocation, mReadWriteAccess COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeWithInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeWithInstruction ("typeWithInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeWithInstruction::
GGS_typeWithInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWithInstruction::
GGS_typeWithInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeWithInstruction GGS_typeWithInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeWithInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeWithInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeWithInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeWithInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeWithInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeWithInstruction GGS_typeWithInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_string& argument_3,
                 const GGS_typeExpression & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_typeInstructionList & argument_6,
                 const GGS_location & argument_7,
                 const GGS_bool& argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_typeWithInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeWithInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeWithInstruction::
reader_mMapTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeWithInstruction::
reader_mAccessedVariableCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mAccessedVariableCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeWithInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeWithInstruction::
reader_mErrorMessageName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mErrorMessageName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWithInstruction::
reader_mKeyExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeWithInstruction::
reader_mDoBranchInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mDoBranchInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeWithInstruction::
reader_mElseBranchInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mElseBranchInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeWithInstruction::
reader_mInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeWithInstruction::
reader_mReadWriteAccess (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWithInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWithInstruction *) mPointer)->mReadWriteAccess ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeWithInstruction::actualTypeName (void) const {
  return "typeWithInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeWithInstruction ("typeWithInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeWithInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeWithInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeWithInstruction * p = NULL ;
    macroMyNew (p, GGS_typeWithInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeWithInstruction GGS_typeWithInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeWithInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeWithInstruction * p = dynamic_cast <const GGS_typeWithInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeWithInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeWithInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeWithInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeWarningInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::
cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeWarningInstruction) ;
    return (cPtr_typeWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeWarningInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeWarningInstruction * ptr = dynamic_cast <const cPtr_typeWarningInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWarningLocationExpression.operator_isEqual (ptr->mWarningLocationExpression).boolValue ()
         && mWarningMessageExpression.operator_isEqual (ptr->mWarningMessageExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeWarningInstruction:"
           << mWarningLocationExpression.reader_description (inIndentation + 1)
           << mWarningMessageExpression.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeWarningInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeWarningInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeWarningInstruction (& typeid (cPtr_typeWarningInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeWarningInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeWarningInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeWarningInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeWarningInstruction (mWarningLocationExpression, mWarningMessageExpression, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeWarningInstruction ("typeWarningInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeWarningInstruction GGS_typeWarningInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeWarningInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeWarningInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeWarningInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeWarningInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction GGS_typeWarningInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningLocationExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningMessageExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeWarningInstruction::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeWarningInstruction::actualTypeName (void) const {
  return "typeWarningInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeWarningInstruction ("typeWarningInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeWarningInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeWarningInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeWarningInstruction * p = NULL ;
    macroMyNew (p, GGS_typeWarningInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction GGS_typeWarningInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeWarningInstruction * p = dynamic_cast <const GGS_typeWarningInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeWarningInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeWarningInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeWarningInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeMessageInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::
cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMessageInstruction) ;
    return (cPtr_typeMessageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMessageInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMessageInstruction * ptr = dynamic_cast <const cPtr_typeMessageInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMessageExpression.operator_isEqual (ptr->mMessageExpression).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMessageInstruction:"
           << mMessageExpression.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMessageInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMessageInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMessageInstruction (& typeid (cPtr_typeMessageInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMessageInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMessageInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMessageInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMessageInstruction (mMessageExpression, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMessageInstruction ("typeMessageInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMessageInstruction GGS_typeMessageInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMessageInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMessageInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMessageInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMessageInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction GGS_typeMessageInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMessageInstruction::
reader_mMessageExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMessageInstruction::
reader_mInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMessageInstruction::actualTypeName (void) const {
  return "typeMessageInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMessageInstruction ("typeMessageInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeMessageInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMessageInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMessageInstruction * p = NULL ;
    macroMyNew (p, GGS_typeMessageInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction GGS_typeMessageInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMessageInstruction * p = dynamic_cast <const GGS_typeMessageInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMessageInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMessageInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMessageInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeMethodCallInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodCallInstruction::
cPtr_typeMethodCallInstruction (const GGS_AC_galgasType & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_string& argument_3,
                                const GGS_typeExpressionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mExpressionType (argument_0),
mExpression (argument_1),
mMethodName (argument_2),
mCategoryMethodClassBaseName (argument_3),
mExpressionsList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodCallInstruction * GGS_typeMethodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMethodCallInstruction) ;
    return (cPtr_typeMethodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodCallInstruction * ptr = dynamic_cast <const cPtr_typeMethodCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionType.operator_isEqual (ptr->mExpressionType).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mCategoryMethodClassBaseName.operator_isEqual (ptr->mCategoryMethodClassBaseName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodCallInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMethodCallInstruction:"
           << mExpressionType.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mCategoryMethodClassBaseName.reader_description (inIndentation + 1)
           << mExpressionsList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodCallInstruction (& typeid (cPtr_typeMethodCallInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMethodCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodCallInstruction (mExpressionType, mExpression, mMethodName, mCategoryMethodClassBaseName, mExpressionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMethodCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMethodCallInstruction ("typeMethodCallInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_string& argument_3,
                 const GGS_typeExpressionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeMethodCallInstruction::
reader_mExpressionType (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMethodCallInstruction::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodCallInstruction::
reader_mMethodName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMethodCallInstruction::
reader_mCategoryMethodClassBaseName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mCategoryMethodClassBaseName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMethodCallInstruction::
reader_mExpressionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodCallInstruction::actualTypeName (void) const {
  return "typeMethodCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMethodCallInstruction ("typeMethodCallInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeMethodCallInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMethodCallInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMethodCallInstruction * p = NULL ;
    macroMyNew (p, GGS_typeMethodCallInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMethodCallInstruction * p = dynamic_cast <const GGS_typeMethodCallInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMethodCallInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMethodCallInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMethodCallInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeCallOfTypeMethodInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCallOfTypeMethodInstruction::
cPtr_typeCallOfTypeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTypeName (argument_0),
mTypeMethodName (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCallOfTypeMethodInstruction * GGS_typeCallOfTypeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCallOfTypeMethodInstruction) ;
    return (cPtr_typeCallOfTypeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCallOfTypeMethodInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCallOfTypeMethodInstruction * ptr = dynamic_cast <const cPtr_typeCallOfTypeMethodInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mTypeMethodName.operator_isEqual (ptr->mTypeMethodName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCallOfTypeMethodInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCallOfTypeMethodInstruction:"
           << mTypeName.reader_description (inIndentation + 1)
           << mTypeMethodName.reader_description (inIndentation + 1)
           << mExpressionsList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCallOfTypeMethodInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCallOfTypeMethodInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCallOfTypeMethodInstruction (& typeid (cPtr_typeCallOfTypeMethodInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCallOfTypeMethodInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeCallOfTypeMethodInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCallOfTypeMethodInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCallOfTypeMethodInstruction (mTypeName, mTypeMethodName, mExpressionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeCallOfTypeMethodInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCallOfTypeMethodInstruction ("typeCallOfTypeMethodInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeCallOfTypeMethodInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCallOfTypeMethodInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCallOfTypeMethodInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeCallOfTypeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeMethodName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeCallOfTypeMethodInstruction::
reader_mExpressionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCallOfTypeMethodInstruction::actualTypeName (void) const {
  return "typeCallOfTypeMethodInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCallOfTypeMethodInstruction ("typeCallOfTypeMethodInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeCallOfTypeMethodInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCallOfTypeMethodInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCallOfTypeMethodInstruction * p = NULL ;
    macroMyNew (p, GGS_typeCallOfTypeMethodInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCallOfTypeMethodInstruction * p = dynamic_cast <const GGS_typeCallOfTypeMethodInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCallOfTypeMethodInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCallOfTypeMethodInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCallOfTypeMethodInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeModifierCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::
cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
mStructAttributeList (argument_1),
aNomMethodeSimple (argument_2),
mExpressionsList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeModifierCallInstruction) ;
    return (cPtr_typeModifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModifierCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModifierCallInstruction * ptr = dynamic_cast <const cPtr_typeModifierCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomCppVariable.operator_isEqual (ptr->aNomCppVariable).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && aNomMethodeSimple.operator_isEqual (ptr->aNomMethodeSimple).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeModifierCallInstruction:"
           << aNomCppVariable.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << aNomMethodeSimple.reader_description (inIndentation + 1)
           << mExpressionsList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeModifierCallInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeModifierCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeModifierCallInstruction (& typeid (cPtr_typeModifierCallInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeModifierCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeModifierCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeModifierCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeModifierCallInstruction (aNomCppVariable, mStructAttributeList, aNomMethodeSimple, mExpressionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeModifierCallInstruction ("typeModifierCallInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeModifierCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeModifierCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeModifierCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeModifierCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeModifierCallInstruction::
reader_aNomCppVariable (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeModifierCallInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeModifierCallInstruction::
reader_aNomMethodeSimple (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomMethodeSimple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeModifierCallInstruction::
reader_mExpressionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeModifierCallInstruction::actualTypeName (void) const {
  return "typeModifierCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeModifierCallInstruction ("typeModifierCallInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeModifierCallInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeModifierCallInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeModifierCallInstruction * p = NULL ;
    macroMyNew (p, GGS_typeModifierCallInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeModifierCallInstruction * p = dynamic_cast <const GGS_typeModifierCallInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeModifierCallInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeModifierCallInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeModifierCallInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_typeInstructionAppelMethodeListe'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::
cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionAppelMethodeListe) ;
    return (cPtr_typeInstructionAppelMethodeListe *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelMethodeListe::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelMethodeListe * ptr = dynamic_cast <const cPtr_typeInstructionAppelMethodeListe *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomCppAttribut.operator_isEqual (ptr->aNomCppAttribut).boolValue ()
         && aMethodeDeListe.operator_isEqual (ptr->aMethodeDeListe).boolValue ()
         && aListeNomsCppArguments.operator_isEqual (ptr->aListeNomsCppArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionAppelMethodeListe:"
           << aNomCppAttribut.reader_description (inIndentation + 1)
           << aMethodeDeListe.reader_description (inIndentation + 1)
           << aListeNomsCppArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelMethodeListe::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelMethodeListe::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionAppelMethodeListe (& typeid (cPtr_typeInstructionAppelMethodeListe), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionAppelMethodeListe::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionAppelMethodeListe ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionAppelMethodeListe::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionAppelMethodeListe (aNomCppAttribut, aMethodeDeListe, aListeNomsCppArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionAppelMethodeListe ("typeInstructionAppelMethodeListe", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionAppelMethodeListe) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionAppelMethodeListe (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionAppelMethodeListe),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionAppelMethodeListe::
reader_aNomCppAttribut (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aNomCppAttribut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelMethodeListe::
reader_aMethodeDeListe (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aMethodeDeListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeInstructionAppelMethodeListe::
reader_aListeNomsCppArguments (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aListeNomsCppArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionAppelMethodeListe::actualTypeName (void) const {
  return "typeInstructionAppelMethodeListe" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionAppelMethodeListe ("typeInstructionAppelMethodeListe", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeInstructionAppelMethodeListe) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionAppelMethodeListe::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionAppelMethodeListe * p = NULL ;
    macroMyNew (p, GGS_typeInstructionAppelMethodeListe (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionAppelMethodeListe * p = dynamic_cast <const GGS_typeInstructionAppelMethodeListe *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionAppelMethodeListe, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionAppelMethodeListe::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionAppelMethodeListe ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeInstructionDeclarationVarLocale'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::
cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionDeclarationVarLocale) ;
    return (cPtr_typeInstructionDeclarationVarLocale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionDeclarationVarLocale::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionDeclarationVarLocale * ptr = dynamic_cast <const cPtr_typeInstructionDeclarationVarLocale *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomCppVariable.operator_isEqual (ptr->aNomCppVariable).boolValue ()
         && aTypeVariable.operator_isEqual (ptr->aTypeVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionDeclarationVarLocale:"
           << aNomCppVariable.reader_description (inIndentation + 1)
           << aTypeVariable.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionDeclarationVarLocale::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionDeclarationVarLocale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionDeclarationVarLocale (& typeid (cPtr_typeInstructionDeclarationVarLocale), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionDeclarationVarLocale::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionDeclarationVarLocale ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionDeclarationVarLocale::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionDeclarationVarLocale (aNomCppVariable, aTypeVariable COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionDeclarationVarLocale ("typeInstructionDeclarationVarLocale", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionDeclarationVarLocale) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionDeclarationVarLocale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionDeclarationVarLocale),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionDeclarationVarLocale::
reader_aNomCppVariable (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeInstructionDeclarationVarLocale::
reader_aTypeVariable (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aTypeVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionDeclarationVarLocale::actualTypeName (void) const {
  return "typeInstructionDeclarationVarLocale" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionDeclarationVarLocale ("typeInstructionDeclarationVarLocale", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeInstructionDeclarationVarLocale) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionDeclarationVarLocale::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionDeclarationVarLocale * p = NULL ;
    macroMyNew (p, GGS_typeInstructionDeclarationVarLocale (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionDeclarationVarLocale * p = dynamic_cast <const GGS_typeInstructionDeclarationVarLocale *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionDeclarationVarLocale, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionDeclarationVarLocale::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionDeclarationVarLocale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeMapBlockPrologueInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::
cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMapBlockPrologueInstruction) ;
    return (cPtr_typeMapBlockPrologueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockPrologueInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockPrologueInstruction * ptr = dynamic_cast <const cPtr_typeMapBlockPrologueInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariableTable.operator_isEqual (ptr->aNomVariableTable).boolValue ()
         && aNomMethodeBloc.operator_isEqual (ptr->aNomMethodeBloc).boolValue ()
         && mPrologueExpressionList.operator_isEqual (ptr->mPrologueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMapBlockPrologueInstruction:"
           << aNomVariableTable.reader_description (inIndentation + 1)
           << aNomMethodeBloc.reader_description (inIndentation + 1)
           << mPrologueExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockPrologueInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockPrologueInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMapBlockPrologueInstruction (& typeid (cPtr_typeMapBlockPrologueInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMapBlockPrologueInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMapBlockPrologueInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMapBlockPrologueInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMapBlockPrologueInstruction (aNomVariableTable, aNomMethodeBloc, mPrologueExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMapBlockPrologueInstruction ("typeMapBlockPrologueInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMapBlockPrologueInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMapBlockPrologueInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMapBlockPrologueInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockPrologueInstruction::
reader_aNomVariableTable (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockPrologueInstruction::
reader_aNomMethodeBloc (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockPrologueInstruction::
reader_mPrologueExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->mPrologueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMapBlockPrologueInstruction::actualTypeName (void) const {
  return "typeMapBlockPrologueInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMapBlockPrologueInstruction ("typeMapBlockPrologueInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeMapBlockPrologueInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMapBlockPrologueInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMapBlockPrologueInstruction * p = NULL ;
    macroMyNew (p, GGS_typeMapBlockPrologueInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMapBlockPrologueInstruction * p = dynamic_cast <const GGS_typeMapBlockPrologueInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMapBlockPrologueInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMapBlockPrologueInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMapBlockPrologueInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeMapBlockEpilogueInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::
cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMapBlockEpilogueInstruction) ;
    return (cPtr_typeMapBlockEpilogueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockEpilogueInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockEpilogueInstruction * ptr = dynamic_cast <const cPtr_typeMapBlockEpilogueInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomVariableTable.operator_isEqual (ptr->aNomVariableTable).boolValue ()
         && aNomMethodeBloc.operator_isEqual (ptr->aNomMethodeBloc).boolValue ()
         && mEpilogueExpressionList.operator_isEqual (ptr->mEpilogueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMapBlockEpilogueInstruction:"
           << aNomVariableTable.reader_description (inIndentation + 1)
           << aNomMethodeBloc.reader_description (inIndentation + 1)
           << mEpilogueExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockEpilogueInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMapBlockEpilogueInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMapBlockEpilogueInstruction (& typeid (cPtr_typeMapBlockEpilogueInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMapBlockEpilogueInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMapBlockEpilogueInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMapBlockEpilogueInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMapBlockEpilogueInstruction (aNomVariableTable, aNomMethodeBloc, mEpilogueExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMapBlockEpilogueInstruction ("typeMapBlockEpilogueInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMapBlockEpilogueInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMapBlockEpilogueInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMapBlockEpilogueInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockEpilogueInstruction::
reader_aNomVariableTable (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockEpilogueInstruction::
reader_aNomMethodeBloc (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockEpilogueInstruction::
reader_mEpilogueExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->mEpilogueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMapBlockEpilogueInstruction::actualTypeName (void) const {
  return "typeMapBlockEpilogueInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMapBlockEpilogueInstruction ("typeMapBlockEpilogueInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeMapBlockEpilogueInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMapBlockEpilogueInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMapBlockEpilogueInstruction * p = NULL ;
    macroMyNew (p, GGS_typeMapBlockEpilogueInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMapBlockEpilogueInstruction * p = dynamic_cast <const GGS_typeMapBlockEpilogueInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMapBlockEpilogueInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMapBlockEpilogueInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMapBlockEpilogueInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeReaderCallInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::
cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_string& argument_3,
                                const GGS_string& argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2),
mConversionMethod (argument_3),
mCategoryReaderClassBaseName (argument_4),
mHasLexiqueAndLocationArguments (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeReaderCallInExpression) ;
    return (cPtr_typeReaderCallInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeReaderCallInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeReaderCallInExpression * ptr = dynamic_cast <const cPtr_typeReaderCallInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionValue.operator_isEqual (ptr->mExpressionValue).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue ()
         && mConversionMethod.operator_isEqual (ptr->mConversionMethod).boolValue ()
         && mCategoryReaderClassBaseName.operator_isEqual (ptr->mCategoryReaderClassBaseName).boolValue ()
         && mHasLexiqueAndLocationArguments.operator_isEqual (ptr->mHasLexiqueAndLocationArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeReaderCallInExpression:"
           << mExpressionValue.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1)
           << mConversionMethod.reader_description (inIndentation + 1)
           << mCategoryReaderClassBaseName.reader_description (inIndentation + 1)
           << mHasLexiqueAndLocationArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeReaderCallInExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeReaderCallInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeReaderCallInExpression (& typeid (cPtr_typeReaderCallInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeReaderCallInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeReaderCallInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeReaderCallInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeReaderCallInExpression (mExpressionValue, mReaderName, mExpressionList, mConversionMethod, mCategoryReaderClassBaseName, mHasLexiqueAndLocationArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeReaderCallInExpression ("typeReaderCallInExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeReaderCallInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeReaderCallInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeReaderCallInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeReaderCallInExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_string& argument_3,
                 const GGS_string& argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeReaderCallInExpression::
reader_mExpressionValue (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeReaderCallInExpression::
reader_mReaderName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeReaderCallInExpression::
reader_mExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_mConversionMethod (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mConversionMethod ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_mCategoryReaderClassBaseName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mCategoryReaderClassBaseName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeReaderCallInExpression::
reader_mHasLexiqueAndLocationArguments (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mHasLexiqueAndLocationArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeReaderCallInExpression::actualTypeName (void) const {
  return "typeReaderCallInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeReaderCallInExpression ("typeReaderCallInExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeReaderCallInExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeReaderCallInExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeReaderCallInExpression * p = NULL ;
    macroMyNew (p, GGS_typeReaderCallInExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeReaderCallInExpression * p = dynamic_cast <const GGS_typeReaderCallInExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeReaderCallInExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeReaderCallInExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeReaderCallInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeFileWrapperWithStaticPath'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperWithStaticPath::
cPtr_typeFileWrapperWithStaticPath (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0),
mFileIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperWithStaticPath * GGS_typeFileWrapperWithStaticPath::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFileWrapperWithStaticPath) ;
    return (cPtr_typeFileWrapperWithStaticPath *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperWithStaticPath::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperWithStaticPath * ptr = dynamic_cast <const cPtr_typeFileWrapperWithStaticPath *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue ()
         && mFileIndex.operator_isEqual (ptr->mFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperWithStaticPath::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFileWrapperWithStaticPath:"
           << mFileWrapperName.reader_description (inIndentation + 1)
           << mFileIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperWithStaticPath::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperWithStaticPath::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperWithStaticPath (& typeid (cPtr_typeFileWrapperWithStaticPath), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFileWrapperWithStaticPath::galgasRTTI (void) const {
  return & gClassInfoFor__typeFileWrapperWithStaticPath ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFileWrapperWithStaticPath::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFileWrapperWithStaticPath (mFileWrapperName, mFileIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFileWrapperWithStaticPath'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFileWrapperWithStaticPath ("typeFileWrapperWithStaticPath", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath::
GGS_typeFileWrapperWithStaticPath (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath::
GGS_typeFileWrapperWithStaticPath (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperWithStaticPath) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFileWrapperWithStaticPath (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperWithStaticPath),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperWithStaticPath (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperWithStaticPath::
reader_mFileWrapperName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperWithStaticPath *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeFileWrapperWithStaticPath::
reader_mFileIndex (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperWithStaticPath *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperWithStaticPath *) mPointer)->mFileIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperWithStaticPath::actualTypeName (void) const {
  return "typeFileWrapperWithStaticPath" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFileWrapperWithStaticPath ("typeFileWrapperWithStaticPath", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeFileWrapperWithStaticPath) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFileWrapperWithStaticPath::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFileWrapperWithStaticPath * p = NULL ;
    macroMyNew (p, GGS_typeFileWrapperWithStaticPath (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperWithStaticPath GGS_typeFileWrapperWithStaticPath::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperWithStaticPath result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFileWrapperWithStaticPath * p = dynamic_cast <const GGS_typeFileWrapperWithStaticPath *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFileWrapperWithStaticPath, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFileWrapperWithStaticPath::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFileWrapperWithStaticPath ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeFileWrapperTemplateCall'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperTemplateCall::
cPtr_typeFileWrapperTemplateCall (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0),
mTemplateName (argument_1),
mOutExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperTemplateCall * GGS_typeFileWrapperTemplateCall::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFileWrapperTemplateCall) ;
    return (cPtr_typeFileWrapperTemplateCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperTemplateCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperTemplateCall * ptr = dynamic_cast <const cPtr_typeFileWrapperTemplateCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mOutExpressionList.operator_isEqual (ptr->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperTemplateCall::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFileWrapperTemplateCall:"
           << mFileWrapperName.reader_description (inIndentation + 1)
           << mTemplateName.reader_description (inIndentation + 1)
           << mOutExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperTemplateCall::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperTemplateCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperTemplateCall (& typeid (cPtr_typeFileWrapperTemplateCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFileWrapperTemplateCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeFileWrapperTemplateCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFileWrapperTemplateCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFileWrapperTemplateCall (mFileWrapperName, mTemplateName, mOutExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeFileWrapperTemplateCall'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFileWrapperTemplateCall ("typeFileWrapperTemplateCall", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall::
GGS_typeFileWrapperTemplateCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall::
GGS_typeFileWrapperTemplateCall (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperTemplateCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFileWrapperTemplateCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperTemplateCall),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperTemplateCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperTemplateCall::
reader_mFileWrapperName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperTemplateCall::
reader_mTemplateName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeFileWrapperTemplateCall::
reader_mOutExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperTemplateCall *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperTemplateCall::actualTypeName (void) const {
  return "typeFileWrapperTemplateCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFileWrapperTemplateCall ("typeFileWrapperTemplateCall", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeFileWrapperTemplateCall) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFileWrapperTemplateCall::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFileWrapperTemplateCall * p = NULL ;
    macroMyNew (p, GGS_typeFileWrapperTemplateCall (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperTemplateCall GGS_typeFileWrapperTemplateCall::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperTemplateCall result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFileWrapperTemplateCall * p = dynamic_cast <const GGS_typeFileWrapperTemplateCall *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFileWrapperTemplateCall, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFileWrapperTemplateCall::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFileWrapperTemplateCall ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeCategoryTemplateCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCategoryTemplateCall::
cPtr_typeCategoryTemplateCall (const GGS_typeExpression & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mCategoryTemplateClassBaseName (argument_1),
mTemplateName (argument_2),
mOutExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCategoryTemplateCall * GGS_typeCategoryTemplateCall::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCategoryTemplateCall) ;
    return (cPtr_typeCategoryTemplateCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCategoryTemplateCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCategoryTemplateCall * ptr = dynamic_cast <const cPtr_typeCategoryTemplateCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionValue.operator_isEqual (ptr->mExpressionValue).boolValue ()
         && mCategoryTemplateClassBaseName.operator_isEqual (ptr->mCategoryTemplateClassBaseName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mOutExpressionList.operator_isEqual (ptr->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCategoryTemplateCall::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCategoryTemplateCall:"
           << mExpressionValue.reader_description (inIndentation + 1)
           << mCategoryTemplateClassBaseName.reader_description (inIndentation + 1)
           << mTemplateName.reader_description (inIndentation + 1)
           << mOutExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCategoryTemplateCall::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCategoryTemplateCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCategoryTemplateCall (& typeid (cPtr_typeCategoryTemplateCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCategoryTemplateCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeCategoryTemplateCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCategoryTemplateCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCategoryTemplateCall (mExpressionValue, mCategoryTemplateClassBaseName, mTemplateName, mOutExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeCategoryTemplateCall'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCategoryTemplateCall ("typeCategoryTemplateCall", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall::
GGS_typeCategoryTemplateCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall::
GGS_typeCategoryTemplateCall (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCategoryTemplateCall GGS_typeCategoryTemplateCall::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCategoryTemplateCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCategoryTemplateCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeCategoryTemplateCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCategoryTemplateCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCategoryTemplateCall),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall GGS_typeCategoryTemplateCall::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeCategoryTemplateCall result ;
  macroMyNew (result.mPointer, cPtr_typeCategoryTemplateCall (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCategoryTemplateCall::
reader_mExpressionValue (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCategoryTemplateCall::
reader_mCategoryTemplateClassBaseName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mCategoryTemplateClassBaseName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCategoryTemplateCall::
reader_mTemplateName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeCategoryTemplateCall::
reader_mOutExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCategoryTemplateCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCategoryTemplateCall *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCategoryTemplateCall::actualTypeName (void) const {
  return "typeCategoryTemplateCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCategoryTemplateCall ("typeCategoryTemplateCall", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeCategoryTemplateCall) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCategoryTemplateCall::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCategoryTemplateCall * p = NULL ;
    macroMyNew (p, GGS_typeCategoryTemplateCall (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCategoryTemplateCall GGS_typeCategoryTemplateCall::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCategoryTemplateCall result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCategoryTemplateCall * p = dynamic_cast <const GGS_typeCategoryTemplateCall *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCategoryTemplateCall, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCategoryTemplateCall::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCategoryTemplateCall ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeFileWrapperObjectInstanciation'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFileWrapperObjectInstanciation::
cPtr_typeFileWrapperObjectInstanciation (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFileWrapperName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFileWrapperObjectInstanciation * GGS_typeFileWrapperObjectInstanciation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFileWrapperObjectInstanciation) ;
    return (cPtr_typeFileWrapperObjectInstanciation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFileWrapperObjectInstanciation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFileWrapperObjectInstanciation * ptr = dynamic_cast <const cPtr_typeFileWrapperObjectInstanciation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFileWrapperObjectInstanciation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFileWrapperObjectInstanciation:"
           << mFileWrapperName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperObjectInstanciation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFileWrapperObjectInstanciation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFileWrapperObjectInstanciation (& typeid (cPtr_typeFileWrapperObjectInstanciation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFileWrapperObjectInstanciation::galgasRTTI (void) const {
  return & gClassInfoFor__typeFileWrapperObjectInstanciation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFileWrapperObjectInstanciation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFileWrapperObjectInstanciation (mFileWrapperName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeFileWrapperObjectInstanciation'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFileWrapperObjectInstanciation ("typeFileWrapperObjectInstanciation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation::
GGS_typeFileWrapperObjectInstanciation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation::
GGS_typeFileWrapperObjectInstanciation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (inPointer) != NULL)
      : (typeid (cPtr_typeFileWrapperObjectInstanciation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFileWrapperObjectInstanciation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFileWrapperObjectInstanciation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation result ;
  macroMyNew (result.mPointer, cPtr_typeFileWrapperObjectInstanciation (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFileWrapperObjectInstanciation::
reader_mFileWrapperName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFileWrapperObjectInstanciation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFileWrapperObjectInstanciation *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFileWrapperObjectInstanciation::actualTypeName (void) const {
  return "typeFileWrapperObjectInstanciation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFileWrapperObjectInstanciation ("typeFileWrapperObjectInstanciation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeFileWrapperObjectInstanciation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFileWrapperObjectInstanciation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFileWrapperObjectInstanciation * p = NULL ;
    macroMyNew (p, GGS_typeFileWrapperObjectInstanciation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFileWrapperObjectInstanciation GGS_typeFileWrapperObjectInstanciation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFileWrapperObjectInstanciation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFileWrapperObjectInstanciation * p = dynamic_cast <const GGS_typeFileWrapperObjectInstanciation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFileWrapperObjectInstanciation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFileWrapperObjectInstanciation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFileWrapperObjectInstanciation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeCastInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCastInExpression::
cPtr_typeCastInExpression (const GGS_typeExpression & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpression & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCastedExpression (argument_0),
mCheckForKindOfClass (argument_1),
mCastTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCastInExpression * GGS_typeCastInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCastInExpression) ;
    return (cPtr_typeCastInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCastInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCastInExpression * ptr = dynamic_cast <const cPtr_typeCastInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastedExpression.operator_isEqual (ptr->mCastedExpression).boolValue ()
         && mCheckForKindOfClass.operator_isEqual (ptr->mCheckForKindOfClass).boolValue ()
         && mCastTypeName.operator_isEqual (ptr->mCastTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCastInExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCastInExpression:"
           << mCastedExpression.reader_description (inIndentation + 1)
           << mCheckForKindOfClass.reader_description (inIndentation + 1)
           << mCastTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCastInExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCastInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCastInExpression (& typeid (cPtr_typeCastInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCastInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeCastInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCastInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCastInExpression (mCastedExpression, mCheckForKindOfClass, mCastTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCastInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCastInExpression ("typeCastInExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeCastInExpression::
GGS_typeCastInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression::
GGS_typeCastInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCastInExpression GGS_typeCastInExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCastInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeCastInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCastInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCastInExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression GGS_typeCastInExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeCastInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCastInExpression::
reader_mCastedExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCastedExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCastInExpression::
reader_mCheckForKindOfClass (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCheckForKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCastInExpression::
reader_mCastTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mCastTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeCastInExpression::
reader_mErrorLocationExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCastInExpression *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCastInExpression::actualTypeName (void) const {
  return "typeCastInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCastInExpression ("typeCastInExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeCastInExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCastInExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCastInExpression * p = NULL ;
    macroMyNew (p, GGS_typeCastInExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCastInExpression GGS_typeCastInExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCastInExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCastInExpression * p = dynamic_cast <const GGS_typeCastInExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCastInExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCastInExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCastInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_objectCastInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_objectCastInExpression::
cPtr_objectCastInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCastedExpression (argument_0),
mCastTypeName (argument_1),
mErrorLocationExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_objectCastInExpression * GGS_objectCastInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_objectCastInExpression) ;
    return (cPtr_objectCastInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_objectCastInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_objectCastInExpression * ptr = dynamic_cast <const cPtr_objectCastInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastedExpression.operator_isEqual (ptr->mCastedExpression).boolValue ()
         && mCastTypeName.operator_isEqual (ptr->mCastTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_objectCastInExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@objectCastInExpression:"
           << mCastedExpression.reader_description (inIndentation + 1)
           << mCastTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_objectCastInExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_objectCastInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_objectCastInExpression (& typeid (cPtr_objectCastInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_objectCastInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__objectCastInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_objectCastInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_objectCastInExpression (mCastedExpression, mCastTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_objectCastInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_objectCastInExpression ("objectCastInExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_objectCastInExpression::
GGS_objectCastInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_objectCastInExpression::
GGS_objectCastInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_objectCastInExpression GGS_objectCastInExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_objectCastInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_objectCastInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_objectCastInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_objectCastInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_objectCastInExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectCastInExpression GGS_objectCastInExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_objectCastInExpression result ;
  macroMyNew (result.mPointer, cPtr_objectCastInExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_objectCastInExpression::
reader_mCastedExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_objectCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_objectCastInExpression *) mPointer)->mCastedExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_objectCastInExpression::
reader_mCastTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_objectCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_objectCastInExpression *) mPointer)->mCastTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_objectCastInExpression::
reader_mErrorLocationExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_objectCastInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_objectCastInExpression *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_objectCastInExpression::actualTypeName (void) const {
  return "objectCastInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__objectCastInExpression ("objectCastInExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_objectCastInExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_objectCastInExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_objectCastInExpression * p = NULL ;
    macroMyNew (p, GGS_objectCastInExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectCastInExpression GGS_objectCastInExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_objectCastInExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_objectCastInExpression * p = dynamic_cast <const GGS_objectCastInExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_objectCastInExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_objectCastInExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_objectCastInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAndOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::
cPtr_typeAndOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeAndOperation) ;
    return (cPtr_typeAndOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAndOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAndOperation * ptr = dynamic_cast <const cPtr_typeAndOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeAndOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAndOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAndOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAndOperation (& typeid (cPtr_typeAndOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeAndOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeAndOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAndOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAndOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeAndOperation ("typeAndOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAndOperation GGS_typeAndOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAndOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeAndOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAndOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAndOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation GGS_typeAndOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAndOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAndOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAndOperation::actualTypeName (void) const {
  return "typeAndOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeAndOperation ("typeAndOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeAndOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeAndOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeAndOperation * p = NULL ;
    macroMyNew (p, GGS_typeAndOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation GGS_typeAndOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeAndOperation * p = dynamic_cast <const GGS_typeAndOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeAndOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeAndOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeAndOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeOrOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::
cPtr_typeOrOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeOrOperation) ;
    return (cPtr_typeOrOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOrOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOrOperation * ptr = dynamic_cast <const cPtr_typeOrOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeOrOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOrOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOrOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOrOperation (& typeid (cPtr_typeOrOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeOrOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeOrOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeOrOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeOrOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeOrOperation ("typeOrOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeOrOperation GGS_typeOrOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOrOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeOrOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeOrOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOrOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation GGS_typeOrOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  macroMyNew (result.mPointer, cPtr_typeOrOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeOrOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOrOperation::actualTypeName (void) const {
  return "typeOrOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeOrOperation ("typeOrOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeOrOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeOrOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeOrOperation * p = NULL ;
    macroMyNew (p, GGS_typeOrOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation GGS_typeOrOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeOrOperation * p = dynamic_cast <const GGS_typeOrOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeOrOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeOrOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeOrOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeXorOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeXorOperation::
cPtr_typeXorOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeXorOperation * GGS_typeXorOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeXorOperation) ;
    return (cPtr_typeXorOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeXorOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeXorOperation * ptr = dynamic_cast <const cPtr_typeXorOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeXorOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeXorOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeXorOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeXorOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeXorOperation (& typeid (cPtr_typeXorOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeXorOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeXorOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeXorOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeXorOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeXorOperation ("typeXorOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeXorOperation GGS_typeXorOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeXorOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeXorOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeXorOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeXorOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation GGS_typeXorOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  macroMyNew (result.mPointer, cPtr_typeXorOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeXorOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeXorOperation::actualTypeName (void) const {
  return "typeXorOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeXorOperation ("typeXorOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeXorOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeXorOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeXorOperation * p = NULL ;
    macroMyNew (p, GGS_typeXorOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation GGS_typeXorOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeXorOperation * p = dynamic_cast <const GGS_typeXorOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeXorOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeXorOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeXorOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeConcatOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::
cPtr_typeConcatOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConcatOperation) ;
    return (cPtr_typeConcatOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConcatOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConcatOperation * ptr = dynamic_cast <const cPtr_typeConcatOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeConcatOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConcatOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConcatOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConcatOperation (& typeid (cPtr_typeConcatOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConcatOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeConcatOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConcatOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConcatOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConcatOperation ("typeConcatOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConcatOperation GGS_typeConcatOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConcatOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeConcatOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConcatOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConcatOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation GGS_typeConcatOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  macroMyNew (result.mPointer, cPtr_typeConcatOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeConcatOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConcatOperation::actualTypeName (void) const {
  return "typeConcatOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeConcatOperation ("typeConcatOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeConcatOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConcatOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConcatOperation * p = NULL ;
    macroMyNew (p, GGS_typeConcatOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation GGS_typeConcatOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConcatOperation * p = dynamic_cast <const GGS_typeConcatOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConcatOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConcatOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConcatOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeTrueBool'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::
cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeTrueBool) ;
    return (cPtr_typeTrueBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTrueBool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeTrueBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTrueBool::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTrueBool::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTrueBool (& typeid (cPtr_typeTrueBool), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeTrueBool::galgasRTTI (void) const {
  return & gClassInfoFor__typeTrueBool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTrueBool ("typeTrueBool", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeTrueBool GGS_typeTrueBool::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTrueBool *> (inPointer) != NULL)
      : (typeid (cPtr_typeTrueBool) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeTrueBool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTrueBool),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeTrueBool * gSingleton_typeTrueBool = NULL ;

//---------------------------------------------------------------------------*

GGS_typeTrueBool GGS_typeTrueBool::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  if (NULL == gSingleton_typeTrueBool) {
    macroMyNew (gSingleton_typeTrueBool, cPtr_typeTrueBool (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeTrueBool) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTrueBool::actualTypeName (void) const {
  return "typeTrueBool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeTrueBool ("typeTrueBool", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeTrueBool) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeTrueBool::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTrueBool * p = NULL ;
    macroMyNew (p, GGS_typeTrueBool (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool GGS_typeTrueBool::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTrueBool * p = dynamic_cast <const GGS_typeTrueBool *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTrueBool, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTrueBool::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTrueBool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeFalseBool'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::
cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFalseBool) ;
    return (cPtr_typeFalseBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFalseBool::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeFalseBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFalseBool::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFalseBool::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFalseBool (& typeid (cPtr_typeFalseBool), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFalseBool::galgasRTTI (void) const {
  return & gClassInfoFor__typeFalseBool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFalseBool ("typeFalseBool", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFalseBool GGS_typeFalseBool::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFalseBool *> (inPointer) != NULL)
      : (typeid (cPtr_typeFalseBool) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFalseBool (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFalseBool),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeFalseBool * gSingleton_typeFalseBool = NULL ;

//---------------------------------------------------------------------------*

GGS_typeFalseBool GGS_typeFalseBool::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  if (NULL == gSingleton_typeFalseBool) {
    macroMyNew (gSingleton_typeFalseBool, cPtr_typeFalseBool (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeFalseBool) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFalseBool::actualTypeName (void) const {
  return "typeFalseBool" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFalseBool ("typeFalseBool", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeFalseBool) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFalseBool::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFalseBool * p = NULL ;
    macroMyNew (p, GGS_typeFalseBool (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool GGS_typeFalseBool::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFalseBool * p = dynamic_cast <const GGS_typeFalseBool *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFalseBool, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFalseBool::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFalseBool ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralStringExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::
cPtr_typeLiteralStringExpression (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralStringList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralStringExpression) ;
    return (cPtr_typeLiteralStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralStringExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralStringExpression * ptr = dynamic_cast <const cPtr_typeLiteralStringExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralStringList.operator_isEqual (ptr->mLiteralStringList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralStringExpression:"
           << mLiteralStringList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralStringExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralStringExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralStringExpression (& typeid (cPtr_typeLiteralStringExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralStringExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralStringExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralStringExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralStringExpression (mLiteralStringList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralStringExpression ("typeLiteralStringExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralStringExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralStringExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralStringExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralStringExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_typeLiteralStringExpression::
reader_mLiteralStringList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralStringExpression *) mPointer)->mLiteralStringList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralStringExpression::actualTypeName (void) const {
  return "typeLiteralStringExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralStringExpression ("typeLiteralStringExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralStringExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralStringExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralStringExpression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralStringExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralStringExpression * p = dynamic_cast <const GGS_typeLiteralStringExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralStringExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralStringExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralStringExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLiteralUIntExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::
cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralUIntExpression) ;
    return (cPtr_typeLiteralUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUIntExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUIntExpression * ptr = dynamic_cast <const cPtr_typeLiteralUIntExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralUIntExpression:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUIntExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUIntExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralUIntExpression (& typeid (cPtr_typeLiteralUIntExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralUIntExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralUIntExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralUIntExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralUIntExpression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralUIntExpression ("typeLiteralUIntExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralUIntExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralUIntExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralUIntExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralUIntExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeLiteralUIntExpression::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralUIntExpression::actualTypeName (void) const {
  return "typeLiteralUIntExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralUIntExpression ("typeLiteralUIntExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralUIntExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralUIntExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralUIntExpression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralUIntExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralUIntExpression * p = dynamic_cast <const GGS_typeLiteralUIntExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralUIntExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralUIntExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralUIntExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLiteralSIntExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::
cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralSIntExpression) ;
    return (cPtr_typeLiteralSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSIntExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSIntExpression * ptr = dynamic_cast <const cPtr_typeLiteralSIntExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralSIntExpression:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSIntExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSIntExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralSIntExpression (& typeid (cPtr_typeLiteralSIntExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralSIntExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralSIntExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralSIntExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralSIntExpression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralSIntExpression ("typeLiteralSIntExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralSIntExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralSIntExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralSIntExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralSIntExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_typeLiteralSIntExpression::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralSIntExpression::actualTypeName (void) const {
  return "typeLiteralSIntExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralSIntExpression ("typeLiteralSIntExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralSIntExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralSIntExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralSIntExpression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralSIntExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralSIntExpression * p = dynamic_cast <const GGS_typeLiteralSIntExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralSIntExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralSIntExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralSIntExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralUInt64Expression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUInt64Expression::
cPtr_typeLiteralUInt64Expression (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUInt64Expression * GGS_typeLiteralUInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralUInt64Expression) ;
    return (cPtr_typeLiteralUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUInt64Expression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUInt64Expression * ptr = dynamic_cast <const cPtr_typeLiteralUInt64Expression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUInt64Expression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralUInt64Expression:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUInt64Expression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralUInt64Expression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralUInt64Expression (& typeid (cPtr_typeLiteralUInt64Expression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralUInt64Expression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralUInt64Expression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralUInt64Expression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralUInt64Expression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralUInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralUInt64Expression ("typeLiteralUInt64Expression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralUInt64Expression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralUInt64Expression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralUInt64Expression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_typeLiteralUInt64Expression::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralUInt64Expression::actualTypeName (void) const {
  return "typeLiteralUInt64Expression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralUInt64Expression ("typeLiteralUInt64Expression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralUInt64Expression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralUInt64Expression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralUInt64Expression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralUInt64Expression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralUInt64Expression * p = dynamic_cast <const GGS_typeLiteralUInt64Expression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralUInt64Expression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralUInt64Expression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralUInt64Expression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralSInt64Expression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSInt64Expression::
cPtr_typeLiteralSInt64Expression (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSInt64Expression * GGS_typeLiteralSInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralSInt64Expression) ;
    return (cPtr_typeLiteralSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSInt64Expression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSInt64Expression * ptr = dynamic_cast <const cPtr_typeLiteralSInt64Expression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSInt64Expression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralSInt64Expression:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSInt64Expression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralSInt64Expression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralSInt64Expression (& typeid (cPtr_typeLiteralSInt64Expression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralSInt64Expression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralSInt64Expression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralSInt64Expression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralSInt64Expression (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralSInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralSInt64Expression ("typeLiteralSInt64Expression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralSInt64Expression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralSInt64Expression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralSInt64Expression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_typeLiteralSInt64Expression::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralSInt64Expression::actualTypeName (void) const {
  return "typeLiteralSInt64Expression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralSInt64Expression ("typeLiteralSInt64Expression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralSInt64Expression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralSInt64Expression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralSInt64Expression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralSInt64Expression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralSInt64Expression * p = dynamic_cast <const GGS_typeLiteralSInt64Expression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralSInt64Expression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralSInt64Expression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralSInt64Expression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLiteralCharExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::
cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralCharExpression) ;
    return (cPtr_typeLiteralCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralCharExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralCharExpression * ptr = dynamic_cast <const cPtr_typeLiteralCharExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralChar.operator_isEqual (ptr->mLiteralChar).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralCharExpression:"
           << mLiteralChar.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralCharExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralCharExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralCharExpression (& typeid (cPtr_typeLiteralCharExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralCharExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralCharExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralCharExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralCharExpression (mLiteralChar COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralCharExpression ("typeLiteralCharExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralCharExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralCharExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralCharExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralCharExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeLiteralCharExpression::
reader_mLiteralChar (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralCharExpression *) mPointer)->mLiteralChar ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralCharExpression::actualTypeName (void) const {
  return "typeLiteralCharExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralCharExpression ("typeLiteralCharExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralCharExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralCharExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralCharExpression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralCharExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralCharExpression * p = dynamic_cast <const GGS_typeLiteralCharExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralCharExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralCharExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralCharExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLiteralDoubleExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralDoubleExpression::
cPtr_typeLiteralDoubleExpression (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralDouble (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralDoubleExpression * GGS_typeLiteralDoubleExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLiteralDoubleExpression) ;
    return (cPtr_typeLiteralDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralDoubleExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralDoubleExpression * ptr = dynamic_cast <const cPtr_typeLiteralDoubleExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralDouble.operator_isEqual (ptr->mLiteralDouble).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralDoubleExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLiteralDoubleExpression:"
           << mLiteralDouble.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralDoubleExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLiteralDoubleExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLiteralDoubleExpression (& typeid (cPtr_typeLiteralDoubleExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLiteralDoubleExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeLiteralDoubleExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLiteralDoubleExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLiteralDoubleExpression (mLiteralDouble COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralDoubleExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLiteralDoubleExpression ("typeLiteralDoubleExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeLiteralDoubleExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLiteralDoubleExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLiteralDoubleExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralDoubleExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_typeLiteralDoubleExpression::
reader_mLiteralDouble (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralDoubleExpression *) mPointer)->mLiteralDouble ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLiteralDoubleExpression::actualTypeName (void) const {
  return "typeLiteralDoubleExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLiteralDoubleExpression ("typeLiteralDoubleExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLiteralDoubleExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLiteralDoubleExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLiteralDoubleExpression * p = NULL ;
    macroMyNew (p, GGS_typeLiteralDoubleExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLiteralDoubleExpression * p = dynamic_cast <const GGS_typeLiteralDoubleExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLiteralDoubleExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLiteralDoubleExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLiteralDoubleExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeHereExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::
cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeHereExpression) ;
    return (cPtr_typeHereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeHereExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeHereExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeHereExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeHereExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeHereExpression (& typeid (cPtr_typeHereExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeHereExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeHereExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeHereExpression ("typeHereExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeHereExpression GGS_typeHereExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeHereExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeHereExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeHereExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeHereExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeHereExpression * gSingleton_typeHereExpression = NULL ;

//---------------------------------------------------------------------------*

GGS_typeHereExpression GGS_typeHereExpression::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  if (NULL == gSingleton_typeHereExpression) {
    macroMyNew (gSingleton_typeHereExpression, cPtr_typeHereExpression (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeHereExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeHereExpression::actualTypeName (void) const {
  return "typeHereExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeHereExpression ("typeHereExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeHereExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeHereExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeHereExpression * p = NULL ;
    macroMyNew (p, GGS_typeHereExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression GGS_typeHereExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeHereExpression * p = dynamic_cast <const GGS_typeHereExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeHereExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeHereExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeHereExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeConstructorExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::
cPtr_typeConstructorExpression (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mType (argument_0),
mConstructorName (argument_1),
mHasLexiqueAndLocationArguments (argument_2),
mExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConstructorExpression) ;
    return (cPtr_typeConstructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConstructorExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConstructorExpression * ptr = dynamic_cast <const cPtr_typeConstructorExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mType.operator_isEqual (ptr->mType).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mHasLexiqueAndLocationArguments.operator_isEqual (ptr->mHasLexiqueAndLocationArguments).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeConstructorExpression:"
           << mType.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mHasLexiqueAndLocationArguments.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConstructorExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConstructorExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConstructorExpression (& typeid (cPtr_typeConstructorExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConstructorExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeConstructorExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConstructorExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConstructorExpression (mType, mConstructorName, mHasLexiqueAndLocationArguments, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConstructorExpression ("typeConstructorExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConstructorExpression GGS_typeConstructorExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConstructorExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeConstructorExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConstructorExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConstructorExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression GGS_typeConstructorExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  macroMyNew (result.mPointer, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeConstructorExpression::
reader_mType (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeConstructorExpression::
reader_mConstructorName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConstructorExpression::
reader_mHasLexiqueAndLocationArguments (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mHasLexiqueAndLocationArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeConstructorExpression::
reader_mExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConstructorExpression::actualTypeName (void) const {
  return "typeConstructorExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeConstructorExpression ("typeConstructorExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeConstructorExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConstructorExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConstructorExpression * p = NULL ;
    macroMyNew (p, GGS_typeConstructorExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression GGS_typeConstructorExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConstructorExpression * p = dynamic_cast <const GGS_typeConstructorExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConstructorExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConstructorExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConstructorExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeIfThenElseExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIfThenElseExpression::
cPtr_typeIfThenElseExpression (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mIfExpression (argument_0),
mThenExpression (argument_1),
mElseExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIfThenElseExpression * GGS_typeIfThenElseExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeIfThenElseExpression) ;
    return (cPtr_typeIfThenElseExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeIfThenElseExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeIfThenElseExpression * ptr = dynamic_cast <const cPtr_typeIfThenElseExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeIfThenElseExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeIfThenElseExpression:"
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeIfThenElseExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeIfThenElseExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeIfThenElseExpression (& typeid (cPtr_typeIfThenElseExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeIfThenElseExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeIfThenElseExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeIfThenElseExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeIfThenElseExpression (mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIfThenElseExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeIfThenElseExpression ("typeIfThenElseExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression::
GGS_typeIfThenElseExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression::
GGS_typeIfThenElseExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeIfThenElseExpression GGS_typeIfThenElseExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeIfThenElseExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeIfThenElseExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeIfThenElseExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeIfThenElseExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeIfThenElseExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression GGS_typeIfThenElseExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeIfThenElseExpression result ;
  macroMyNew (result.mPointer, cPtr_typeIfThenElseExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeIfThenElseExpression::
reader_mIfExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIfThenElseExpression *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeIfThenElseExpression::
reader_mThenExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIfThenElseExpression *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeIfThenElseExpression::
reader_mElseExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIfThenElseExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIfThenElseExpression *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeIfThenElseExpression::actualTypeName (void) const {
  return "typeIfThenElseExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeIfThenElseExpression ("typeIfThenElseExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeIfThenElseExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeIfThenElseExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeIfThenElseExpression * p = NULL ;
    macroMyNew (p, GGS_typeIfThenElseExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeIfThenElseExpression GGS_typeIfThenElseExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeIfThenElseExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeIfThenElseExpression * p = dynamic_cast <const GGS_typeIfThenElseExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeIfThenElseExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeIfThenElseExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeIfThenElseExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeTestComplement'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::
cPtr_typeTestComplement (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeTestComplement) ;
    return (cPtr_typeTestComplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTestComplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTestComplement * ptr = dynamic_cast <const cPtr_typeTestComplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeTestComplement:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTestComplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTestComplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTestComplement (& typeid (cPtr_typeTestComplement), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeTestComplement::galgasRTTI (void) const {
  return & gClassInfoFor__typeTestComplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeTestComplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeTestComplement (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTestComplement ("typeTestComplement", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeTestComplement GGS_typeTestComplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTestComplement *> (inPointer) != NULL)
      : (typeid (cPtr_typeTestComplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeTestComplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTestComplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement GGS_typeTestComplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  macroMyNew (result.mPointer, cPtr_typeTestComplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeTestComplement::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTestComplement::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTestComplement::actualTypeName (void) const {
  return "typeTestComplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeTestComplement ("typeTestComplement", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeTestComplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeTestComplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTestComplement * p = NULL ;
    macroMyNew (p, GGS_typeTestComplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement GGS_typeTestComplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTestComplement * p = dynamic_cast <const GGS_typeTestComplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTestComplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTestComplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTestComplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeLogicalNegate'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogicalNegate::
cPtr_typeLogicalNegate (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogicalNegate * GGS_typeLogicalNegate::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLogicalNegate) ;
    return (cPtr_typeLogicalNegate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogicalNegate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogicalNegate * ptr = dynamic_cast <const cPtr_typeLogicalNegate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogicalNegate::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLogicalNegate:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLogicalNegate::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLogicalNegate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLogicalNegate (& typeid (cPtr_typeLogicalNegate), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLogicalNegate::galgasRTTI (void) const {
  return & gClassInfoFor__typeLogicalNegate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLogicalNegate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLogicalNegate (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeLogicalNegate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLogicalNegate ("typeLogicalNegate", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLogicalNegate GGS_typeLogicalNegate::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLogicalNegate *> (inPointer) != NULL)
      : (typeid (cPtr_typeLogicalNegate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLogicalNegate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLogicalNegate),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate GGS_typeLogicalNegate::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  macroMyNew (result.mPointer, cPtr_typeLogicalNegate (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLogicalNegate::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLogicalNegate::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLogicalNegate::actualTypeName (void) const {
  return "typeLogicalNegate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLogicalNegate ("typeLogicalNegate", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLogicalNegate) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLogicalNegate::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLogicalNegate * p = NULL ;
    macroMyNew (p, GGS_typeLogicalNegate (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate GGS_typeLogicalNegate::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLogicalNegate * p = dynamic_cast <const GGS_typeLogicalNegate *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLogicalNegate, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLogicalNegate::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLogicalNegate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeOptionAccess'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOptionAccess::
cPtr_typeOptionAccess (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1),
mAccessorName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOptionAccess * GGS_typeOptionAccess::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeOptionAccess) ;
    return (cPtr_typeOptionAccess *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOptionAccess::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOptionAccess * ptr = dynamic_cast <const cPtr_typeOptionAccess *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionName.operator_isEqual (ptr->mOptionName).boolValue ()
         && mAccessorName.operator_isEqual (ptr->mAccessorName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOptionAccess::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeOptionAccess:"
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionName.reader_description (inIndentation + 1)
           << mAccessorName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOptionAccess::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOptionAccess::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOptionAccess (& typeid (cPtr_typeOptionAccess), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeOptionAccess::galgasRTTI (void) const {
  return & gClassInfoFor__typeOptionAccess ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeOptionAccess::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeOptionAccess (mOptionComponentName, mOptionName, mAccessorName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeOptionAccess'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeOptionAccess ("typeOptionAccess", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeOptionAccess::
GGS_typeOptionAccess (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOptionAccess::
GGS_typeOptionAccess (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeOptionAccess GGS_typeOptionAccess::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOptionAccess result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOptionAccess *> (inPointer) != NULL)
      : (typeid (cPtr_typeOptionAccess) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeOptionAccess (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOptionAccess),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOptionAccess GGS_typeOptionAccess::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeOptionAccess result ;
  macroMyNew (result.mPointer, cPtr_typeOptionAccess (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeOptionAccess::
reader_mOptionComponentName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOptionAccess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOptionAccess *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeOptionAccess::
reader_mOptionName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOptionAccess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOptionAccess *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeOptionAccess::
reader_mAccessorName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOptionAccess *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOptionAccess *) mPointer)->mAccessorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOptionAccess::actualTypeName (void) const {
  return "typeOptionAccess" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeOptionAccess ("typeOptionAccess", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeOptionAccess) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeOptionAccess::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeOptionAccess * p = NULL ;
    macroMyNew (p, GGS_typeOptionAccess (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOptionAccess GGS_typeOptionAccess::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeOptionAccess result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeOptionAccess * p = dynamic_cast <const GGS_typeOptionAccess *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeOptionAccess, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeOptionAccess::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeOptionAccess ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeFunctionCall'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFunctionCall::
cPtr_typeFunctionCall (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mFunctionName (argument_0),
mExpressionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFunctionCall * GGS_typeFunctionCall::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFunctionCall) ;
    return (cPtr_typeFunctionCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFunctionCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFunctionCall * ptr = dynamic_cast <const cPtr_typeFunctionCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFunctionCall::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFunctionCall:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFunctionCall::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFunctionCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFunctionCall (& typeid (cPtr_typeFunctionCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFunctionCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeFunctionCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFunctionCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFunctionCall (mFunctionName, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFunctionCall'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFunctionCall ("typeFunctionCall", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeFunctionCall::
GGS_typeFunctionCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFunctionCall::
GGS_typeFunctionCall (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFunctionCall GGS_typeFunctionCall::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFunctionCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFunctionCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeFunctionCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFunctionCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFunctionCall),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFunctionCall GGS_typeFunctionCall::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFunctionCall result ;
  macroMyNew (result.mPointer, cPtr_typeFunctionCall (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFunctionCall::
reader_mFunctionName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFunctionCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFunctionCall *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeFunctionCall::
reader_mExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFunctionCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFunctionCall *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFunctionCall::actualTypeName (void) const {
  return "typeFunctionCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFunctionCall ("typeFunctionCall", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeFunctionCall) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFunctionCall::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFunctionCall * p = NULL ;
    macroMyNew (p, GGS_typeFunctionCall (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFunctionCall GGS_typeFunctionCall::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFunctionCall result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFunctionCall * p = dynamic_cast <const GGS_typeFunctionCall *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFunctionCall, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFunctionCall::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFunctionCall ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeVarInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::
cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeVarInExpression) ;
    return (cPtr_typeVarInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeVarInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeVarInExpression * ptr = dynamic_cast <const cPtr_typeVarInExpression *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCppVarName.operator_isEqual (ptr->mCppVarName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeVarInExpression:"
           << mCppVarName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeVarInExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVarInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeVarInExpression (& typeid (cPtr_typeVarInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeVarInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeVarInExpression ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeVarInExpression::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeVarInExpression (mCppVarName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeVarInExpression ("typeVarInExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeVarInExpression GGS_typeVarInExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeVarInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeVarInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeVarInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeVarInExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression GGS_typeVarInExpression::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeVarInExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeVarInExpression::
reader_mCppVarName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeVarInExpression *) mPointer)->mCppVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeVarInExpression::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeVarInExpression *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeVarInExpression::actualTypeName (void) const {
  return "typeVarInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeVarInExpression ("typeVarInExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeVarInExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeVarInExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeVarInExpression * p = NULL ;
    macroMyNew (p, GGS_typeVarInExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression GGS_typeVarInExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeVarInExpression * p = dynamic_cast <const GGS_typeVarInExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeVarInExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeVarInExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeVarInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeJokerInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::
cPtr_typeJokerInExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeJokerInExpression) ;
    return (cPtr_typeJokerInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJokerInExpression::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeJokerInExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeJokerInExpression::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeJokerInExpression::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeJokerInExpression (& typeid (cPtr_typeJokerInExpression), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeJokerInExpression::galgasRTTI (void) const {
  return & gClassInfoFor__typeJokerInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeJokerInExpression ("typeJokerInExpression", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeJokerInExpression GGS_typeJokerInExpression::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeJokerInExpression *> (inPointer) != NULL)
      : (typeid (cPtr_typeJokerInExpression) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeJokerInExpression (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeJokerInExpression),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeJokerInExpression * gSingleton_typeJokerInExpression = NULL ;

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression GGS_typeJokerInExpression::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  if (NULL == gSingleton_typeJokerInExpression) {
    macroMyNew (gSingleton_typeJokerInExpression, cPtr_typeJokerInExpression (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeJokerInExpression) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeJokerInExpression::actualTypeName (void) const {
  return "typeJokerInExpression" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeJokerInExpression ("typeJokerInExpression", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeJokerInExpression) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeJokerInExpression::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeJokerInExpression * p = NULL ;
    macroMyNew (p, GGS_typeJokerInExpression (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression GGS_typeJokerInExpression::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeJokerInExpression * p = dynamic_cast <const GGS_typeJokerInExpression *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeJokerInExpression, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeJokerInExpression::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeJokerInExpression ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAddOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::
cPtr_typeAddOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeAddOperation) ;
    return (cPtr_typeAddOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAddOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAddOperation * ptr = dynamic_cast <const cPtr_typeAddOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeAddOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAddOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAddOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAddOperation (& typeid (cPtr_typeAddOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeAddOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeAddOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAddOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAddOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeAddOperation ("typeAddOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAddOperation GGS_typeAddOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAddOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeAddOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAddOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAddOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation GGS_typeAddOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAddOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAddOperation::actualTypeName (void) const {
  return "typeAddOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeAddOperation ("typeAddOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeAddOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeAddOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeAddOperation * p = NULL ;
    macroMyNew (p, GGS_typeAddOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation GGS_typeAddOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeAddOperation * p = dynamic_cast <const GGS_typeAddOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeAddOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeAddOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeAddOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeSubOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::
cPtr_typeSubOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeSubOperation) ;
    return (cPtr_typeSubOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSubOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSubOperation * ptr = dynamic_cast <const cPtr_typeSubOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeSubOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSubOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSubOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSubOperation (& typeid (cPtr_typeSubOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeSubOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeSubOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSubOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSubOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeSubOperation ("typeSubOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSubOperation GGS_typeSubOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSubOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeSubOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSubOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSubOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation GGS_typeSubOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  macroMyNew (result.mPointer, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSubOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSubOperation::actualTypeName (void) const {
  return "typeSubOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeSubOperation ("typeSubOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeSubOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeSubOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeSubOperation * p = NULL ;
    macroMyNew (p, GGS_typeSubOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation GGS_typeSubOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeSubOperation * p = dynamic_cast <const GGS_typeSubOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeSubOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeSubOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeSubOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeMultiplyOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::
cPtr_typeMultiplyOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMultiplyOperation) ;
    return (cPtr_typeMultiplyOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMultiplyOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMultiplyOperation * ptr = dynamic_cast <const cPtr_typeMultiplyOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMultiplyOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMultiplyOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMultiplyOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMultiplyOperation (& typeid (cPtr_typeMultiplyOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMultiplyOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeMultiplyOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMultiplyOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMultiplyOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMultiplyOperation ("typeMultiplyOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMultiplyOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeMultiplyOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMultiplyOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMultiplyOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  macroMyNew (result.mPointer, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMultiplyOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMultiplyOperation::actualTypeName (void) const {
  return "typeMultiplyOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMultiplyOperation ("typeMultiplyOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeMultiplyOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMultiplyOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMultiplyOperation * p = NULL ;
    macroMyNew (p, GGS_typeMultiplyOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation GGS_typeMultiplyOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMultiplyOperation * p = dynamic_cast <const GGS_typeMultiplyOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMultiplyOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMultiplyOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMultiplyOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeDivideOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::
cPtr_typeDivideOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDivideOperation) ;
    return (cPtr_typeDivideOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDivideOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDivideOperation * ptr = dynamic_cast <const cPtr_typeDivideOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDivideOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDivideOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDivideOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDivideOperation (& typeid (cPtr_typeDivideOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDivideOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeDivideOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDivideOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDivideOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDivideOperation ("typeDivideOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDivideOperation GGS_typeDivideOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDivideOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeDivideOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDivideOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDivideOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation GGS_typeDivideOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  macroMyNew (result.mPointer, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDivideOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDivideOperation::actualTypeName (void) const {
  return "typeDivideOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDivideOperation ("typeDivideOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeDivideOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDivideOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDivideOperation * p = NULL ;
    macroMyNew (p, GGS_typeDivideOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation GGS_typeDivideOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDivideOperation * p = dynamic_cast <const GGS_typeDivideOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDivideOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDivideOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDivideOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeModuloOperation'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::
cPtr_typeModuloOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeModuloOperation) ;
    return (cPtr_typeModuloOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModuloOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModuloOperation * ptr = dynamic_cast <const cPtr_typeModuloOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeModuloOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeModuloOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeModuloOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeModuloOperation (& typeid (cPtr_typeModuloOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeModuloOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeModuloOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeModuloOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeModuloOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeModuloOperation ("typeModuloOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeModuloOperation GGS_typeModuloOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeModuloOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeModuloOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeModuloOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeModuloOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation GGS_typeModuloOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  macroMyNew (result.mPointer, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeModuloOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeModuloOperation::actualTypeName (void) const {
  return "typeModuloOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeModuloOperation ("typeModuloOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeModuloOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeModuloOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeModuloOperation * p = NULL ;
    macroMyNew (p, GGS_typeModuloOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation GGS_typeModuloOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeModuloOperation * p = dynamic_cast <const GGS_typeModuloOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeModuloOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeModuloOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeModuloOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeUnaryMinusOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::
cPtr_typeUnaryMinusOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeUnaryMinusOperation) ;
    return (cPtr_typeUnaryMinusOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUnaryMinusOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUnaryMinusOperation * ptr = dynamic_cast <const cPtr_typeUnaryMinusOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeUnaryMinusOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUnaryMinusOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUnaryMinusOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUnaryMinusOperation (& typeid (cPtr_typeUnaryMinusOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUnaryMinusOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeUnaryMinusOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeUnaryMinusOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeUnaryMinusOperation (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUnaryMinusOperation ("typeUnaryMinusOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUnaryMinusOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeUnaryMinusOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUnaryMinusOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUnaryMinusOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  macroMyNew (result.mPointer, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeUnaryMinusOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeUnaryMinusOperation::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUnaryMinusOperation::actualTypeName (void) const {
  return "typeUnaryMinusOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUnaryMinusOperation ("typeUnaryMinusOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeUnaryMinusOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUnaryMinusOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUnaryMinusOperation * p = NULL ;
    macroMyNew (p, GGS_typeUnaryMinusOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUnaryMinusOperation * p = dynamic_cast <const GGS_typeUnaryMinusOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUnaryMinusOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUnaryMinusOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUnaryMinusOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::
cPtr_typeEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEqualTest) ;
    return (cPtr_typeEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEqualTest * ptr = dynamic_cast <const cPtr_typeEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEqualTest:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEqualTest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEqualTest (& typeid (cPtr_typeEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEqualTest ("typeEqualTest", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEqualTest GGS_typeEqualTest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEqualTest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest GGS_typeEqualTest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEqualTest::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEqualTest::actualTypeName (void) const {
  return "typeEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEqualTest ("typeEqualTest", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeEqualTest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEqualTest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEqualTest * p = NULL ;
    macroMyNew (p, GGS_typeEqualTest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest GGS_typeEqualTest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEqualTest * p = dynamic_cast <const GGS_typeEqualTest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEqualTest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEqualTest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEqualTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeNonEqualTest'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::
cPtr_typeNonEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeNonEqualTest) ;
    return (cPtr_typeNonEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonEqualTest * ptr = dynamic_cast <const cPtr_typeNonEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeNonEqualTest:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNonEqualTest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNonEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNonEqualTest (& typeid (cPtr_typeNonEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeNonEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeNonEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeNonEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeNonEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeNonEqualTest ("typeNonEqualTest", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeNonEqualTest GGS_typeNonEqualTest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNonEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeNonEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeNonEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNonEqualTest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest GGS_typeNonEqualTest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeNonEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeNonEqualTest::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNonEqualTest::actualTypeName (void) const {
  return "typeNonEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeNonEqualTest ("typeNonEqualTest", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeNonEqualTest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeNonEqualTest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeNonEqualTest * p = NULL ;
    macroMyNew (p, GGS_typeNonEqualTest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest GGS_typeNonEqualTest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeNonEqualTest * p = dynamic_cast <const GGS_typeNonEqualTest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeNonEqualTest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeNonEqualTest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeNonEqualTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeStrictInfTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::
cPtr_typeStrictInfTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeStrictInfTest) ;
    return (cPtr_typeStrictInfTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictInfTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictInfTest * ptr = dynamic_cast <const cPtr_typeStrictInfTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeStrictInfTest:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStrictInfTest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStrictInfTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStrictInfTest (& typeid (cPtr_typeStrictInfTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeStrictInfTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeStrictInfTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStrictInfTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStrictInfTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeStrictInfTest ("typeStrictInfTest", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStrictInfTest GGS_typeStrictInfTest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStrictInfTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeStrictInfTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStrictInfTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStrictInfTest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest GGS_typeStrictInfTest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictInfTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStrictInfTest::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStrictInfTest::actualTypeName (void) const {
  return "typeStrictInfTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeStrictInfTest ("typeStrictInfTest", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeStrictInfTest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeStrictInfTest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeStrictInfTest * p = NULL ;
    macroMyNew (p, GGS_typeStrictInfTest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest GGS_typeStrictInfTest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeStrictInfTest * p = dynamic_cast <const GGS_typeStrictInfTest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeStrictInfTest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeStrictInfTest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeStrictInfTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeInfOrEqualTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::
cPtr_typeInfOrEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInfOrEqualTest) ;
    return (cPtr_typeInfOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInfOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInfOrEqualTest * ptr = dynamic_cast <const cPtr_typeInfOrEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInfOrEqualTest:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInfOrEqualTest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInfOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInfOrEqualTest (& typeid (cPtr_typeInfOrEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInfOrEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeInfOrEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInfOrEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInfOrEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInfOrEqualTest ("typeInfOrEqualTest", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInfOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeInfOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInfOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInfOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeInfOrEqualTest::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInfOrEqualTest::actualTypeName (void) const {
  return "typeInfOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInfOrEqualTest ("typeInfOrEqualTest", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeInfOrEqualTest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInfOrEqualTest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInfOrEqualTest * p = NULL ;
    macroMyNew (p, GGS_typeInfOrEqualTest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInfOrEqualTest * p = dynamic_cast <const GGS_typeInfOrEqualTest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInfOrEqualTest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInfOrEqualTest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInfOrEqualTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeStrictSupTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::
cPtr_typeStrictSupTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeStrictSupTest) ;
    return (cPtr_typeStrictSupTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictSupTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictSupTest * ptr = dynamic_cast <const cPtr_typeStrictSupTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeStrictSupTest:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStrictSupTest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStrictSupTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStrictSupTest (& typeid (cPtr_typeStrictSupTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeStrictSupTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeStrictSupTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStrictSupTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStrictSupTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeStrictSupTest ("typeStrictSupTest", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStrictSupTest GGS_typeStrictSupTest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStrictSupTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeStrictSupTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStrictSupTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStrictSupTest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest GGS_typeStrictSupTest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictSupTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStrictSupTest::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStrictSupTest::actualTypeName (void) const {
  return "typeStrictSupTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeStrictSupTest ("typeStrictSupTest", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeStrictSupTest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeStrictSupTest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeStrictSupTest * p = NULL ;
    macroMyNew (p, GGS_typeStrictSupTest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest GGS_typeStrictSupTest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeStrictSupTest * p = dynamic_cast <const GGS_typeStrictSupTest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeStrictSupTest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeStrictSupTest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeStrictSupTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeSupOrEqualTest'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::
cPtr_typeSupOrEqualTest (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeSupOrEqualTest) ;
    return (cPtr_typeSupOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSupOrEqualTest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSupOrEqualTest * ptr = dynamic_cast <const cPtr_typeSupOrEqualTest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeSupOrEqualTest:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeSupOrEqualTest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeSupOrEqualTest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeSupOrEqualTest (& typeid (cPtr_typeSupOrEqualTest), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeSupOrEqualTest::galgasRTTI (void) const {
  return & gClassInfoFor__typeSupOrEqualTest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeSupOrEqualTest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeSupOrEqualTest (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeSupOrEqualTest ("typeSupOrEqualTest", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeSupOrEqualTest *> (inPointer) != NULL)
      : (typeid (cPtr_typeSupOrEqualTest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeSupOrEqualTest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeSupOrEqualTest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSupOrEqualTest::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeSupOrEqualTest::actualTypeName (void) const {
  return "typeSupOrEqualTest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeSupOrEqualTest ("typeSupOrEqualTest", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeSupOrEqualTest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeSupOrEqualTest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeSupOrEqualTest * p = NULL ;
    macroMyNew (p, GGS_typeSupOrEqualTest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeSupOrEqualTest * p = dynamic_cast <const GGS_typeSupOrEqualTest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeSupOrEqualTest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeSupOrEqualTest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeSupOrEqualTest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeLeftShiftOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLeftShiftOperation::
cPtr_typeLeftShiftOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLeftShiftOperation * GGS_typeLeftShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLeftShiftOperation) ;
    return (cPtr_typeLeftShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLeftShiftOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLeftShiftOperation * ptr = dynamic_cast <const cPtr_typeLeftShiftOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLeftShiftOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLeftShiftOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLeftShiftOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLeftShiftOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLeftShiftOperation (& typeid (cPtr_typeLeftShiftOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLeftShiftOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeLeftShiftOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLeftShiftOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLeftShiftOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeLeftShiftOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLeftShiftOperation ("typeLeftShiftOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLeftShiftOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeLeftShiftOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLeftShiftOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLeftShiftOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeLeftShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLeftShiftOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLeftShiftOperation::actualTypeName (void) const {
  return "typeLeftShiftOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLeftShiftOperation ("typeLeftShiftOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeLeftShiftOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLeftShiftOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLeftShiftOperation * p = NULL ;
    macroMyNew (p, GGS_typeLeftShiftOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLeftShiftOperation * p = dynamic_cast <const GGS_typeLeftShiftOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLeftShiftOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLeftShiftOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLeftShiftOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeRightShiftOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRightShiftOperation::
cPtr_typeRightShiftOperation (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRightShiftOperation * GGS_typeRightShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeRightShiftOperation) ;
    return (cPtr_typeRightShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRightShiftOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRightShiftOperation * ptr = dynamic_cast <const cPtr_typeRightShiftOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRightShiftOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeRightShiftOperation:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRightShiftOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRightShiftOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRightShiftOperation (& typeid (cPtr_typeRightShiftOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeRightShiftOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeRightShiftOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRightShiftOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRightShiftOperation (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeRightShiftOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeRightShiftOperation ("typeRightShiftOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRightShiftOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeRightShiftOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRightShiftOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRightShiftOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeRightShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeRightShiftOperation::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRightShiftOperation::actualTypeName (void) const {
  return "typeRightShiftOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeRightShiftOperation ("typeRightShiftOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeRightShiftOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeRightShiftOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeRightShiftOperation * p = NULL ;
    macroMyNew (p, GGS_typeRightShiftOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation GGS_typeRightShiftOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeRightShiftOperation * p = dynamic_cast <const GGS_typeRightShiftOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeRightShiftOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeRightShiftOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeRightShiftOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeClassToTypeOperand'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeClassToTypeOperand::
cPtr_typeClassToTypeOperand (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeClassToTypeOperand * GGS_typeClassToTypeOperand::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeClassToTypeOperand) ;
    return (cPtr_typeClassToTypeOperand *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeClassToTypeOperand::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeClassToTypeOperand * ptr = dynamic_cast <const cPtr_typeClassToTypeOperand *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeClassToTypeOperand::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeClassToTypeOperand:"
           << mTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeClassToTypeOperand::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeClassToTypeOperand::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeClassToTypeOperand (& typeid (cPtr_typeClassToTypeOperand), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeClassToTypeOperand::galgasRTTI (void) const {
  return & gClassInfoFor__typeClassToTypeOperand ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeClassToTypeOperand::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeClassToTypeOperand (mTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeClassToTypeOperand'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeClassToTypeOperand ("typeClassToTypeOperand", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeClassToTypeOperand::
GGS_typeClassToTypeOperand (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassToTypeOperand::
GGS_typeClassToTypeOperand (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeClassToTypeOperand GGS_typeClassToTypeOperand::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeClassToTypeOperand result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeClassToTypeOperand *> (inPointer) != NULL)
      : (typeid (cPtr_typeClassToTypeOperand) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeClassToTypeOperand (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeClassToTypeOperand),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassToTypeOperand GGS_typeClassToTypeOperand::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeClassToTypeOperand result ;
  macroMyNew (result.mPointer, cPtr_typeClassToTypeOperand (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeClassToTypeOperand::
reader_mTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeClassToTypeOperand *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeClassToTypeOperand *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeClassToTypeOperand::actualTypeName (void) const {
  return "typeClassToTypeOperand" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeClassToTypeOperand ("typeClassToTypeOperand", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeClassToTypeOperand) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeClassToTypeOperand::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeClassToTypeOperand * p = NULL ;
    macroMyNew (p, GGS_typeClassToTypeOperand (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassToTypeOperand GGS_typeClassToTypeOperand::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeClassToTypeOperand result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeClassToTypeOperand * p = dynamic_cast <const GGS_typeClassToTypeOperand *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeClassToTypeOperand, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeClassToTypeOperand::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeClassToTypeOperand ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeFieldAccessOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFieldAccessOperation::
cPtr_typeFieldAccessOperation (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
mFieldName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFieldAccessOperation * GGS_typeFieldAccessOperation::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFieldAccessOperation) ;
    return (cPtr_typeFieldAccessOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFieldAccessOperation::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFieldAccessOperation * ptr = dynamic_cast <const cPtr_typeFieldAccessOperation *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mFieldName.operator_isEqual (ptr->mFieldName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFieldAccessOperation::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFieldAccessOperation:"
           << mExpression.reader_description (inIndentation + 1)
           << mFieldName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFieldAccessOperation::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFieldAccessOperation::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFieldAccessOperation (& typeid (cPtr_typeFieldAccessOperation), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFieldAccessOperation::galgasRTTI (void) const {
  return & gClassInfoFor__typeFieldAccessOperation ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFieldAccessOperation::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFieldAccessOperation (mExpression, mFieldName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeFieldAccessOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFieldAccessOperation ("typeFieldAccessOperation", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeFieldAccessOperation::
GGS_typeFieldAccessOperation (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFieldAccessOperation::
GGS_typeFieldAccessOperation (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFieldAccessOperation GGS_typeFieldAccessOperation::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFieldAccessOperation result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFieldAccessOperation *> (inPointer) != NULL)
      : (typeid (cPtr_typeFieldAccessOperation) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFieldAccessOperation (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFieldAccessOperation),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFieldAccessOperation GGS_typeFieldAccessOperation::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFieldAccessOperation result ;
  macroMyNew (result.mPointer, cPtr_typeFieldAccessOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeFieldAccessOperation::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFieldAccessOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFieldAccessOperation *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeFieldAccessOperation::
reader_mFieldName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFieldAccessOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFieldAccessOperation *) mPointer)->mFieldName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFieldAccessOperation::actualTypeName (void) const {
  return "typeFieldAccessOperation" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFieldAccessOperation ("typeFieldAccessOperation", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeFieldAccessOperation) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFieldAccessOperation::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFieldAccessOperation * p = NULL ;
    macroMyNew (p, GGS_typeFieldAccessOperation (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFieldAccessOperation GGS_typeFieldAccessOperation::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFieldAccessOperation result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFieldAccessOperation * p = dynamic_cast <const GGS_typeFieldAccessOperation *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFieldAccessOperation, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFieldAccessOperation::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFieldAccessOperation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeTextTableCall'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::
cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeTextTableCall) ;
    return (cPtr_typeTextTableCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTextTableCall::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTextTableCall * ptr = dynamic_cast <const cPtr_typeTextTableCall *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && aNomMethodeTest.operator_isEqual (ptr->aNomMethodeTest).boolValue ()
         && aNomCppClef.operator_isEqual (ptr->aNomCppClef).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeTextTableCall:"
           << mExpression.reader_description (inIndentation + 1)
           << aNomMethodeTest.reader_description (inIndentation + 1)
           << aNomCppClef.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeTextTableCall::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeTextTableCall::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeTextTableCall (& typeid (cPtr_typeTextTableCall), & typeid (cPtr_typeExpression), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeTextTableCall::galgasRTTI (void) const {
  return & gClassInfoFor__typeTextTableCall ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeTextTableCall::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeTextTableCall (mExpression, aNomMethodeTest, aNomCppClef COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTextTableCall ("typeTextTableCall", true, & kTypeDescriptor_GGS_typeExpression) ;

//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeTextTableCall GGS_typeTextTableCall::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeTextTableCall *> (inPointer) != NULL)
      : (typeid (cPtr_typeTextTableCall) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeTextTableCall (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeTextTableCall),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall GGS_typeTextTableCall::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  macroMyNew (result.mPointer, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTextTableCall::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeTextTableCall::
reader_aNomMethodeTest (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomMethodeTest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeTextTableCall::
reader_aNomCppClef (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomCppClef ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeTextTableCall::actualTypeName (void) const {
  return "typeTextTableCall" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeTextTableCall ("typeTextTableCall", gClassInfoFor__typeExpression, & kTypeDescriptor_GGS_typeTextTableCall) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeTextTableCall::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTextTableCall * p = NULL ;
    macroMyNew (p, GGS_typeTextTableCall (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall GGS_typeTextTableCall::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTextTableCall * p = dynamic_cast <const GGS_typeTextTableCall *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTextTableCall, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTextTableCall::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTextTableCall ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_C_assignmentInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::
cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_assignmentInstruction) ;
    return (cPtr_C_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_assignmentInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_assignmentInstruction * ptr = dynamic_cast <const cPtr_C_assignmentInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_assignmentInstruction:"
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_assignmentInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_assignmentInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_assignmentInstruction (& typeid (cPtr_C_assignmentInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_assignmentInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_assignmentInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_assignmentInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_assignmentInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_assignmentInstruction ("C_assignmentInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_assignmentInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_assignmentInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_assignmentInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_assignmentInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_assignmentInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_assignmentInstruction::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_C_assignmentInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_assignmentInstruction::
reader_mSourceExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_assignmentInstruction::actualTypeName (void) const {
  return "C_assignmentInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_assignmentInstruction ("C_assignmentInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_assignmentInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_assignmentInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_assignmentInstruction * p = NULL ;
    macroMyNew (p, GGS_C_assignmentInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction GGS_C_assignmentInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_assignmentInstruction * p = dynamic_cast <const GGS_C_assignmentInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_assignmentInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_assignmentInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_assignmentInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_C_constantDeclarationInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_constantDeclarationInstruction::
cPtr_C_constantDeclarationInstruction (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_constantDeclarationInstruction * GGS_C_constantDeclarationInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_constantDeclarationInstruction) ;
    return (cPtr_C_constantDeclarationInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_constantDeclarationInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_constantDeclarationInstruction * ptr = dynamic_cast <const cPtr_C_constantDeclarationInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetType.operator_isEqual (ptr->mTargetType).boolValue ()
         && mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_constantDeclarationInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_constantDeclarationInstruction:"
           << mTargetType.reader_description (inIndentation + 1)
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_constantDeclarationInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_constantDeclarationInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_constantDeclarationInstruction (& typeid (cPtr_C_constantDeclarationInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_constantDeclarationInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_constantDeclarationInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_constantDeclarationInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_constantDeclarationInstruction (mTargetType, mTargetVarCppName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_constantDeclarationInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_constantDeclarationInstruction ("C_constantDeclarationInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction::
GGS_C_constantDeclarationInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction::
GGS_C_constantDeclarationInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_constantDeclarationInstruction GGS_C_constantDeclarationInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_constantDeclarationInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_constantDeclarationInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_constantDeclarationInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_constantDeclarationInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction GGS_C_constantDeclarationInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_constantDeclarationInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_constantDeclarationInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_C_constantDeclarationInstruction::
reader_mTargetType (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_constantDeclarationInstruction *) mPointer)->mTargetType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_constantDeclarationInstruction::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_constantDeclarationInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_constantDeclarationInstruction::
reader_mSourceExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_constantDeclarationInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_constantDeclarationInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_constantDeclarationInstruction::actualTypeName (void) const {
  return "C_constantDeclarationInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_constantDeclarationInstruction ("C_constantDeclarationInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_constantDeclarationInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_constantDeclarationInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_constantDeclarationInstruction * p = NULL ;
    macroMyNew (p, GGS_C_constantDeclarationInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_constantDeclarationInstruction GGS_C_constantDeclarationInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_constantDeclarationInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_constantDeclarationInstruction * p = dynamic_cast <const GGS_C_constantDeclarationInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_constantDeclarationInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_constantDeclarationInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_constantDeclarationInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_dotEqualInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_dotEqualInstruction::
cPtr_C_dotEqualInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_string& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpression (argument_2),
mSourceExpressionConverter (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_dotEqualInstruction * GGS_C_dotEqualInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_dotEqualInstruction) ;
    return (cPtr_C_dotEqualInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_dotEqualInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_dotEqualInstruction * ptr = dynamic_cast <const cPtr_C_dotEqualInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionConverter.operator_isEqual (ptr->mSourceExpressionConverter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_dotEqualInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_dotEqualInstruction:"
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mSourceExpressionConverter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_dotEqualInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_dotEqualInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_dotEqualInstruction (& typeid (cPtr_C_dotEqualInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_dotEqualInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_dotEqualInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_dotEqualInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_dotEqualInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpression, mSourceExpressionConverter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_dotEqualInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_dotEqualInstruction ("C_dotEqualInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_dotEqualInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_dotEqualInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_dotEqualInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_dotEqualInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_string& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_dotEqualInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_dotEqualInstruction::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_C_dotEqualInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_dotEqualInstruction::
reader_mSourceExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_dotEqualInstruction::
reader_mSourceExpressionConverter (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpressionConverter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_dotEqualInstruction::actualTypeName (void) const {
  return "C_dotEqualInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_dotEqualInstruction ("C_dotEqualInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_dotEqualInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_dotEqualInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_dotEqualInstruction * p = NULL ;
    macroMyNew (p, GGS_C_dotEqualInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_dotEqualInstruction * p = dynamic_cast <const GGS_C_dotEqualInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_dotEqualInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_dotEqualInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_dotEqualInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_C_declarationInstructionWithAssignment'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::
cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_declarationInstructionWithAssignment) ;
    return (cPtr_C_declarationInstructionWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_declarationInstructionWithAssignment::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_declarationInstructionWithAssignment * ptr = dynamic_cast <const cPtr_C_declarationInstructionWithAssignment *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableType.operator_isEqual (ptr->mVariableType).boolValue ()
         && mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_declarationInstructionWithAssignment:"
           << mVariableType.reader_description (inIndentation + 1)
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_declarationInstructionWithAssignment::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_declarationInstructionWithAssignment::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_declarationInstructionWithAssignment (& typeid (cPtr_C_declarationInstructionWithAssignment), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_declarationInstructionWithAssignment::galgasRTTI (void) const {
  return & gClassInfoFor__C_declarationInstructionWithAssignment ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_declarationInstructionWithAssignment::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_declarationInstructionWithAssignment (mVariableType, mTargetVarCppName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_declarationInstructionWithAssignment ("C_declarationInstructionWithAssignment", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (inPointer) != NULL)
      : (typeid (cPtr_C_declarationInstructionWithAssignment) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_declarationInstructionWithAssignment (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_declarationInstructionWithAssignment),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_C_declarationInstructionWithAssignment::
reader_mVariableType (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mVariableType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_declarationInstructionWithAssignment::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_declarationInstructionWithAssignment::
reader_mSourceExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_declarationInstructionWithAssignment::actualTypeName (void) const {
  return "C_declarationInstructionWithAssignment" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_declarationInstructionWithAssignment ("C_declarationInstructionWithAssignment", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_declarationInstructionWithAssignment) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_declarationInstructionWithAssignment::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_declarationInstructionWithAssignment * p = NULL ;
    macroMyNew (p, GGS_C_declarationInstructionWithAssignment (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_declarationInstructionWithAssignment * p = dynamic_cast <const GGS_C_declarationInstructionWithAssignment *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_declarationInstructionWithAssignment, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_declarationInstructionWithAssignment::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_declarationInstructionWithAssignment ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_while_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_while_instruction::
cPtr_C_while_instruction (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariantExpression (argument_0),
mInstructionList1 (argument_1),
mWhileExpression (argument_2),
mInstructionList2 (argument_3),
mLocation (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_while_instruction * GGS_C_while_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_while_instruction) ;
    return (cPtr_C_while_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_while_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_while_instruction * ptr = dynamic_cast <const cPtr_C_while_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mInstructionList1.operator_isEqual (ptr->mInstructionList1).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mInstructionList2.operator_isEqual (ptr->mInstructionList2).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_while_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_while_instruction:"
           << mVariantExpression.reader_description (inIndentation + 1)
           << mInstructionList1.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mInstructionList2.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_while_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_while_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_while_instruction (& typeid (cPtr_C_while_instruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_while_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_while_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_while_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_while_instruction (mVariantExpression, mInstructionList1, mWhileExpression, mInstructionList2, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_while_instruction ("C_while_instruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_while_instruction GGS_C_while_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_while_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_while_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_while_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_while_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction GGS_C_while_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeInstructionList & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_while_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mVariantExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList1 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mWhileExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList2 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_while_instruction::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_while_instruction::actualTypeName (void) const {
  return "C_while_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_while_instruction ("C_while_instruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_while_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_while_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_while_instruction * p = NULL ;
    macroMyNew (p, GGS_C_while_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction GGS_C_while_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_while_instruction * p = dynamic_cast <const GGS_C_while_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_while_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_while_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_while_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIFexpression (argument_0),
mInstructionList (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_expression_instructionsList_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_expression_instructionsList_list * ptr = dynamic_cast <const elementOf_GGS_L_expression_instructionsList_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_expression_instructionsList_list ("L_expression_instructionsList_list", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_location & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
operator_concat (const GGS_L_expression_instructionsList_list & inOperand) const {
  GGS_L_expression_instructionsList_list result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
dotAssign_operation (const GGS_L_expression_instructionsList_list inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_expression_instructionsList_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mIFexpression ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          GGS_location  p_2 = p->mLocation ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_typeInstructionList & argument_1,
                     const GGS_location & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIFexpression,
                                ptr->mInstructionList,
                                ptr->mLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_emptyList (void) {
  GGS_L_expression_instructionsList_list result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_listWithValue (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_location & argument_2) {
  GGS_L_expression_instructionsList_list result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalSubListWithRange (GGS_L_expression_instructionsList_list & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIFexpression, ptr->mInstructionList, ptr->mLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_expression_instructionsList_list", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_first (C_CompilerEx & inLexique,
              GGS_typeExpression & _out_0,
              GGS_typeInstructionList & _out_1,
              GGS_location & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_last (C_CompilerEx & inLexique,
             GGS_typeExpression & _out_0,
             GGS_typeInstructionList & _out_1,
             GGS_location & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_typeInstructionList & _out_1,
                 GGS_location & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeExpression & _out_0,
                GGS_typeInstructionList & _out_1,
                GGS_location & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mInstructionList ;
    _out_2 = ptr->mLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_L_expression_instructionsList_list::
reader_mIFexpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_expression_instructionsList_list::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_expression_instructionsList_list::
reader_mLocationAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMIFexpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_setMLocationAtIndex (C_CompilerEx & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_L_expression_instructionsList_list::cEnumerator::_mIFexpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFexpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_expression_instructionsList_list::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_expression_instructionsList_list::cEnumerator::_mLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_expression_instructionsList_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_expression_instructionsList_list * p = NULL ;
    macroMyNew (p, GGS_L_expression_instructionsList_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_expression_instructionsList_list * p = dynamic_cast <const GGS_L_expression_instructionsList_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_expression_instructionsList_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_expression_instructionsList_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_expression_instructionsList_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_if_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::
cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_if_instruction) ;
    return (cPtr_C_if_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_if_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_if_instruction * ptr = dynamic_cast <const cPtr_C_if_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFbranchesList.operator_isEqual (ptr->mIFbranchesList).boolValue ()
         && mElseInstructionsList.operator_isEqual (ptr->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_if_instruction:"
           << mIFbranchesList.reader_description (inIndentation + 1)
           << mElseInstructionsList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_if_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_if_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_if_instruction (& typeid (cPtr_C_if_instruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_if_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_if_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_if_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_if_instruction (mIFbranchesList, mElseInstructionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_if_instruction ("C_if_instruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_if_instruction GGS_C_if_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_if_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_if_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_if_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_if_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction GGS_C_if_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_if_instruction::
reader_mIFbranchesList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_if_instruction::
reader_mElseInstructionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_if_instruction::actualTypeName (void) const {
  return "C_if_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_if_instruction ("C_if_instruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_if_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_if_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_if_instruction * p = NULL ;
    macroMyNew (p, GGS_C_if_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction GGS_C_if_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_if_instruction * p = dynamic_cast <const GGS_C_if_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_if_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_if_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_if_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_switchBranchlist'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_switchBranchlist::
elementOf_GGS_L_switchBranchlist (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mConstantSet (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_switchBranchlist::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_switchBranchlist * ptr = dynamic_cast <const elementOf_GGS_L_switchBranchlist *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantSet.operator_isEqual (ptr->mConstantSet).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_switchBranchlist::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantSet.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_switchBranchlist'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_switchBranchlist ("L_switchBranchlist", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
internalAppendValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
internalPrependValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
addAssign_operation (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
operator_concat (const GGS_L_switchBranchlist & inOperand) const {
  GGS_L_switchBranchlist result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
dotAssign_operation (const GGS_L_switchBranchlist inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_switchBranchlist * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_stringset  p_0 = p->mConstantSet ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_stringset & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantSet,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_emptyList (void) {
  GGS_L_switchBranchlist result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_listWithValue (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  GGS_L_switchBranchlist result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
internalSubListWithRange (GGS_L_switchBranchlist & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantSet, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_switchBranchlist result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_switchBranchlist result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_switchBranchlist::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_switchBranchlist", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_first (C_CompilerEx & inLexique,
              GGS_stringset & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_last (C_CompilerEx & inLexique,
             GGS_stringset & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_stringset & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_stringset & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantSet ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_stringset  GGS_L_switchBranchlist::
reader_mConstantSetAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_stringset  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantSet ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_switchBranchlist::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_setMConstantSetAtIndex (C_CompilerEx & inLexique,
                              const GGS_stringset  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantSet = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_stringset  & GGS_L_switchBranchlist::cEnumerator::_mConstantSet (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantSet ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_switchBranchlist::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_switchBranchlist::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_switchBranchlist * p = NULL ;
    macroMyNew (p, GGS_L_switchBranchlist (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_switchBranchlist * p = dynamic_cast <const GGS_L_switchBranchlist *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_switchBranchlist, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_switchBranchlist::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_switchBranchlist ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_switch_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_switch_instruction::
cPtr_C_switch_instruction (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSwitchExpression (argument_0),
mEnumTypeName (argument_1),
mBranchList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_switch_instruction * GGS_C_switch_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_switch_instruction) ;
    return (cPtr_C_switch_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_switch_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_switch_instruction * ptr = dynamic_cast <const cPtr_C_switch_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_switch_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_switch_instruction:"
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mBranchList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_switch_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_switch_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_switch_instruction (& typeid (cPtr_C_switch_instruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_switch_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_switch_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_switch_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_switch_instruction (mSwitchExpression, mEnumTypeName, mBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_switch_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_switch_instruction ("C_switch_instruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_switch_instruction GGS_C_switch_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_switch_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_switch_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_switch_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_switch_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction GGS_C_switch_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_switch_instruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_switch_instruction::
reader_mSwitchExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_switch_instruction::
reader_mEnumTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_C_switch_instruction::
reader_mBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_switchBranchlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_switch_instruction::actualTypeName (void) const {
  return "C_switch_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_switch_instruction ("C_switch_instruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_switch_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_switch_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_switch_instruction * p = NULL ;
    macroMyNew (p, GGS_C_switch_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction GGS_C_switch_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_switch_instruction * p = dynamic_cast <const GGS_C_switch_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_switch_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_switch_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_switch_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableRoutinesAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableRoutinesAimplementer ("typeTableRoutinesAimplementer", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableRoutinesAimplementer::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableRoutinesAimplementer info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
operator_isEqual (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
operator_isNotEqual (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeTableRoutinesAimplementer info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableRoutinesAimplementer::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableRoutinesAimplementer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableRoutinesAimplementer * p = NULL ;
    macroMyNew (p, GGS_typeTableRoutinesAimplementer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableRoutinesAimplementer * p = dynamic_cast <const GGS_typeTableRoutinesAimplementer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableRoutinesAimplementer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableRoutinesAimplementer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableRoutinesAimplementer ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'e_typeTableAttributsSemantiques'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableAttributsSemantiques::e_typeTableAttributsSemantiques (void) :
aNomCppAttribut (),
mAttributType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableAttributsSemantiques'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableAttributsSemantiques ("typeTableAttributsSemantiques", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aNomCppAttribut.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableAttributsSemantiques::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableAttributsSemantiques * ptr = dynamic_cast <const elementOf_GGS_typeTableAttributsSemantiques *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aNomCppAttribut.operator_isEqual (ptr->mInfo.aNomCppAttribut)).boolValue ()
           && (mInfo.mAttributType.operator_isEqual (ptr->mInfo.mAttributType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableAttributsSemantiques info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
operator_isEqual (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
operator_isNotEqual (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeCplusPlusName & inParameter0,
               const GGS_AC_galgasType & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableAttributsSemantiques::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableAttributsSemantiques::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeTableAttributsSemantiques & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_typeTableAttributsSemantiques::cEnumerator::_aNomCppAttribut (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aNomCppAttribut ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeTableAttributsSemantiques::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableAttributsSemantiques::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableAttributsSemantiques * p = NULL ;
    macroMyNew (p, GGS_typeTableAttributsSemantiques (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableAttributsSemantiques * p = dynamic_cast <const GGS_typeTableAttributsSemantiques *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableAttributsSemantiques, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableAttributsSemantiques::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableAttributsSemantiques ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_typeCplusPlusName & inValue0,
                                             const GGS_AC_galgasType & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_CompilerEx & inLexique,
                                GGS_bool  var_cas_inEnumeratorNewStyle,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildMapWithLocalConstants at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mapStyle = (var_cas_inLocalConstantStyle).operator_isNotEqual (GGS_localConstantBuildStyleEnum::constructor_listStyle (inLexique COMMA_SOURCE_FILE_AT_LINE (823))) ;
  GGS_bool var_cas_firstOne = GGS_bool (true) ;
  {
    GGS_L_nameWithType::cEnumerator enumerator_34048 (var_cas_inLocalDeclarationsList, true) ;
    const GGS_L_nameWithType::cElement * operand_34048 = NULL ;
    GGS_typeListeAttributsSemantiques::cEnumerator enumerator_34083 (var_cas_inSemanticAttributsList, true) ;
    const GGS_typeListeAttributsSemantiques::cElement * operand_34083 = NULL ;
    while (((operand_34048 = enumerator_34048.nextObject ()))
        && ((operand_34083 = enumerator_34083.nextObject ()))) {
      macroValidPointer (operand_34048) ;
      macroValidPointer (operand_34083) ;
      const GGS_bool cond_34847 = (operand_34048->mType.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (827))).operator_isNotEqual (GGS_string ("")) ;
      if (cond_34847.isBuiltAndTrue ()) {
        GGS_string var_cas_typeName ;
        if (operand_34083->mAttributType.isBuilt ()) {
          operand_34083->mAttributType (HERE)->method_getTypeName (inLexique, var_cas_typeName COMMA_SOURCE_FILE_AT_LINE (829)) ;
        }
        const GGS_bool cond_34695 = (operand_34048->mType.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (830))).operator_isEqual (var_cas_typeName) ;
        if (cond_34695.isBuiltAndTrue ()) {
          GGS_typeCplusPlusName  var_cas_cppName ;
          const GGS_bool cond_34466 = ((var_cas_inLocalConstantStyle).operator_isEqual (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (inLexique COMMA_SOURCE_FILE_AT_LINE (832)))).operator_and (var_cas_firstOne) ;
          if (cond_34466.isBuiltAndTrue ()) {
            var_cas_cppName = GGS_typeKeyName ::constructor_new (inLexique, var_cas_inLocation, var_cas_inEnumeratorNewStyle COMMA_SOURCE_FILE_AT_LINE (833)) ;
          }else if (cond_34466.isBuiltAndFalse ()) {
            var_cas_cppName = GGS_typeOperandName ::constructor_new (inLexique, var_cas_inLocation, operand_34083->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (835)), var_cas_mapStyle, var_cas_inEnumeratorNewStyle COMMA_SOURCE_FILE_AT_LINE (835)) ;
          }
          var_cas_ioVariablesMap.modifier_insertUsedConstInArgument (inLexique, operand_34048->mName, operand_34083->mAttributType, var_cas_cppName COMMA_SOURCE_FILE_AT_LINE (837)) ;
        }else if (cond_34695.isBuiltAndFalse ()) {
          operand_34048->mType.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("I have found the '@")).operator_concat (operand_34048->mType.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (839)))).operator_concat (GGS_string ("' type, I was expected the '@"))).operator_concat (var_cas_typeName)).operator_concat (GGS_string ("' type")) COMMA_SOURCE_FILE_AT_LINE (841)) ;
        }
      }
      var_cas_firstOne = GGS_bool (false) ;
    }
  }
  const GGS_bool cond_35252 = ((var_cas_inLocalDeclarationsList.reader_length ()).operator_strictInf (var_cas_inSemanticAttributsList.reader_length ())).operator_and ((var_cas_inEllipsisFound).operator_not ()) ;
  if (cond_35252.isBuiltAndTrue ()) {
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("one or more parameters missing: found ")).operator_concat (var_cas_inLocalDeclarationsList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (848)))).operator_concat (GGS_string (" effective parameters, while "))).operator_concat (var_cas_inSemanticAttributsList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (849)))).operator_concat (GGS_string (" are needed")) COMMA_SOURCE_FILE_AT_LINE (850)) ;
  }else if (cond_35252.isBuiltAndFalse ()) {
    const GGS_bool cond_35526 = (var_cas_inLocalDeclarationsList.reader_length ()).operator_strictSup (var_cas_inSemanticAttributsList.reader_length ()) ;
    if (cond_35526.isBuiltAndTrue ()) {
      GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("too much parameters: found ")).operator_concat (var_cas_inLocalDeclarationsList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (852)))).operator_concat (GGS_string (" effective parameters, while "))).operator_concat (var_cas_inSemanticAttributsList.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (853)))).operator_concat (GGS_string (" are needed")) COMMA_SOURCE_FILE_AT_LINE (854)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildMapWithLocalConstants\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_CompilerEx & inLexique,
                                const GGS_typeSemanticsTypesList   var_cas_t1,
                                const GGS_typeListeAttributsSemantiques   var_cas_t2,
                                const GGS_location   var_cas_inErrorLocation
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_36259 = (var_cas_t1.reader_length ()).operator_strictInf (var_cas_t2.reader_length ()) ;
  if (cond_36259.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more identifiers missing") COMMA_SOURCE_FILE_AT_LINE (871)) ;
  }else if (cond_36259.isBuiltAndFalse ()) {
    const GGS_bool cond_36350 = (var_cas_t1.reader_length ()).operator_strictSup (var_cas_t2.reader_length ()) ;
    if (cond_36350.isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("too much identifiers") COMMA_SOURCE_FILE_AT_LINE (873)) ;
    }else if (cond_36350.isBuiltAndFalse ()) {
      {
        GGS_typeSemanticsTypesList::cEnumerator enumerator_36365 (var_cas_t1, true) ;
        const GGS_typeSemanticsTypesList::cElement * operand_36365 = NULL ;
        GGS_typeListeAttributsSemantiques::cEnumerator enumerator_36369 (var_cas_t2, true) ;
        const GGS_typeListeAttributsSemantiques::cElement * operand_36369 = NULL ;
        while (((operand_36365 = enumerator_36365.nextObject ()))
            && ((operand_36369 = enumerator_36369.nextObject ()))) {
          macroValidPointer (operand_36365) ;
          macroValidPointer (operand_36369) ;
          ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_36365->mType,  operand_36369->mAttributType,  operand_36365->mGalgasVariableName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (878)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (875)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_CompilerEx & inLexique,
                                const GGS_L_EXsignature   var_cas_signatureReference,
                                const GGS_L_actualParametersSignature   var_cas_inEffectiveArgumentsSignature,
                                const GGS_location   var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteArgEffectifsSignature at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_37366 = (var_cas_signatureReference.reader_length ()).operator_strictSup (var_cas_inEffectiveArgumentsSignature.reader_length ()) ;
  if (cond_37366.isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more arguments missing") COMMA_SOURCE_FILE_AT_LINE (900)) ;
  }else if (cond_37366.isBuiltAndFalse ()) {
    const GGS_bool cond_37498 = (var_cas_signatureReference.reader_length ()).operator_strictInf (var_cas_inEffectiveArgumentsSignature.reader_length ()) ;
    if (cond_37498.isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("too much arguments") COMMA_SOURCE_FILE_AT_LINE (902)) ;
    }else if (cond_37498.isBuiltAndFalse ()) {
      {
        GGS_L_EXsignature::cEnumerator enumerator_37553 (var_cas_signatureReference, true) ;
        const GGS_L_EXsignature::cElement * operand_37553 = NULL ;
        GGS_L_actualParametersSignature::cEnumerator enumerator_37596 (var_cas_inEffectiveArgumentsSignature, true) ;
        const GGS_L_actualParametersSignature::cElement * operand_37596 = NULL ;
        while (((operand_37553 = enumerator_37553.nextObject ()))
            && ((operand_37596 = enumerator_37596.nextObject ()))) {
          macroValidPointer (operand_37553) ;
          macroValidPointer (operand_37596) ;
          if (operand_37553->mFormalArgumentPassingMode.isBuilt () && operand_37596->mFormalArgumentPassingMode.isBuilt ()) {
            if ((operand_37553->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingModeAST::enum_argumentConstantIn) && (operand_37596->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOut)) {
              ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37553->mType,  operand_37596->mType,  var_cas_inErrorLocation,  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (908)) ;
            }else{
              if ((operand_37553->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingModeAST::enum_argumentIn) && (operand_37596->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOut)) {
                ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37553->mType,  operand_37596->mType,  var_cas_inErrorLocation,  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (910)) ;
              }else{
                if ((operand_37553->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingModeAST::enum_argumentInOut) && (operand_37596->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterOutIn)) {
                  ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37553->mType,  operand_37596->mType,  var_cas_inErrorLocation,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (912)) ;
                }else{
                  if ((operand_37553->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingModeAST::enum_argumentOut) && (operand_37596->mFormalArgumentPassingMode.enumValue () == GGS_EXactualParametersPassingMode::enum_parameterIn)) {
                    { const GGS_AC_galgasType _var_38321 = operand_37596->mType ; // CAST instruction
                      if (_var_38321.getPtr () != NULL) {
                        macroValidPointer (_var_38321.getPtr ()) ;
                        if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (_var_38321.getPtr ()) != NULL) {
                        }else{
                          ::routine_checkAssignmentTypesCompatibility (inLexique,  operand_37553->mType,  operand_37596->mType,  var_cas_inErrorLocation,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (917)) ;
                        }
                      }
                    }
                  }else{
                    var_cas_inErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((operand_37596->mFormalArgumentPassingMode.reader_actualArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (920))).operator_concat (GGS_string (" is not compatible with "))).operator_concat (operand_37553->mFormalArgumentPassingMode.reader_formalArgumentMessage (inLexique COMMA_SOURCE_FILE_AT_LINE (921))) COMMA_SOURCE_FILE_AT_LINE (922)) ;
                  }
                }
              }
            }
          }
        }
      }
      GGS_typeExpressionList  var_cas_expressionList = var_cas_ioExpressionList ;
      var_cas_ioExpressionList = GGS_typeExpressionList ::constructor_emptyList () ;
      GGS_uint  var_cas_sequenceNumber = GGS_uint (0U) ;
      {
        GGS_L_EXsignature::cEnumerator enumerator_38791 (var_cas_signatureReference, true) ;
        const GGS_L_EXsignature::cElement * operand_38791 = NULL ;
        GGS_typeExpressionList::cEnumerator enumerator_38807 (var_cas_expressionList, true) ;
        const GGS_typeExpressionList::cElement * operand_38807 = NULL ;
        while (((operand_38791 = enumerator_38791.nextObject ()))
            && ((operand_38807 = enumerator_38807.nextObject ()))) {
          macroValidPointer (operand_38791) ;
          macroValidPointer (operand_38807) ;
          { const GGS_typeExpression _var_39323 = operand_38807->mExpression ; // CAST instruction
            if (_var_39323.getPtr () != NULL) {
              macroValidPointer (_var_39323.getPtr ()) ;
              if (dynamic_cast <cPtr_typeJokerInExpression *> (_var_39323.getPtr ()) != NULL) {
                GGS_typeCplusPlusName  var_cas_cppVarName = GGS_typeLocationAutomaticName ::constructor_new (inLexique, GGS_location (inLexique), var_cas_sequenceNumber COMMA_SOURCE_FILE_AT_LINE (931)) ;
                var_cas_sequenceNumber.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (932)) ;
                GGS_typeExpression  var_cas_e = GGS_typeVarInExpression ::constructor_new (inLexique, var_cas_cppVarName, GGS_lstringlist ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (933)) ;
                var_cas_ioExpressionList.addAssign_operation (var_cas_e) ;
                GGS_typeInstruction  var_cas_i = GGS_typeInstructionDeclarationVarLocale ::constructor_new (inLexique, var_cas_cppVarName, operand_38791->mType COMMA_SOURCE_FILE_AT_LINE (935)) ;
                var_cas_ioInstructionsList.addAssign_operation (var_cas_i) ;
              }else{
                var_cas_ioExpressionList.addAssign_operation (operand_38807->mExpression) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteArgEffectifsSignature\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'cPtr_typeJoker'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::
cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeJoker) ;
    return (cPtr_typeJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJoker::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
method_verifierType (C_CompilerEx & inLexique,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList COMMA_UNUSED_LOCATION_ARGS) const {
  var_cas_outAllVariablesList.addAssign_operation (GGS_typeNullName ::constructor_new (inLexique, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (958))) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeJoker::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeJoker::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeJoker (& typeid (cPtr_typeJoker), & typeid (cPtr_typeCible), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeJoker::galgasRTTI (void) const {
  return & gClassInfoFor__typeJoker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeJoker ("typeJoker", true, & kTypeDescriptor_GGS_typeCible) ;

//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeJoker GGS_typeJoker::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeJoker *> (inPointer) != NULL)
      : (typeid (cPtr_typeJoker) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeJoker (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeJoker),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeJoker * gSingleton_typeJoker = NULL ;

//---------------------------------------------------------------------------*

GGS_typeJoker GGS_typeJoker::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  if (NULL == gSingleton_typeJoker) {
    macroMyNew (gSingleton_typeJoker, cPtr_typeJoker (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeJoker) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeJoker::actualTypeName (void) const {
  return "typeJoker" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeJoker ("typeJoker", gClassInfoFor__typeCible, & kTypeDescriptor_GGS_typeJoker) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeJoker::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeJoker * p = NULL ;
    macroMyNew (p, GGS_typeJoker (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker GGS_typeJoker::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeJoker * p = dynamic_cast <const GGS_typeJoker *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeJoker, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeJoker::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeJoker ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeEntiteDest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::
cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEntiteDest) ;
    return (cPtr_typeEntiteDest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteDest::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteDest * ptr = dynamic_cast <const cPtr_typeEntiteDest *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aTypeVarDest.operator_isEqual (ptr->aTypeVarDest).boolValue ()
         && mCppName.operator_isEqual (ptr->mCppName).boolValue ()
         && aPositionVariableCible.operator_isEqual (ptr->aPositionVariableCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
method_verifierType (C_CompilerEx & inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_ioAllVariablesList COMMA_UNUSED_LOCATION_ARGS) const {
  ::routine_checkAssignmentTypesCompatibility (inLexique,  aTypeVarDest,  var_cas_typeArgumentFormel,  aPositionVariableCible,  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (975)) ;
  var_cas_listeAffectations.addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_ioAllVariablesList.addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEntiteDest:"
           << aTypeVarDest.reader_description (inIndentation + 1)
           << mCppName.reader_description (inIndentation + 1)
           << aPositionVariableCible.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteDest::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteDest::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteDest (& typeid (cPtr_typeEntiteDest), & typeid (cPtr_typeCible), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntiteDest::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteDest ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteDest::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteDest (aTypeVarDest, mCppName, aPositionVariableCible COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntiteDest ("typeEntiteDest", true, & kTypeDescriptor_GGS_typeCible) ;

//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteDest GGS_typeEntiteDest::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteDest *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteDest) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteDest (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteDest),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest GGS_typeEntiteDest::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteDest::
reader_aTypeVarDest (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aTypeVarDest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeEntiteDest::
reader_mCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->mCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEntiteDest::
reader_aPositionVariableCible (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aPositionVariableCible ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteDest::actualTypeName (void) const {
  return "typeEntiteDest" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEntiteDest ("typeEntiteDest", gClassInfoFor__typeCible, & kTypeDescriptor_GGS_typeEntiteDest) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntiteDest::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntiteDest * p = NULL ;
    macroMyNew (p, GGS_typeEntiteDest (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest GGS_typeEntiteDest::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntiteDest * p = dynamic_cast <const GGS_typeEntiteDest *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntiteDest, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntiteDest::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntiteDest ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_M_nonTerminalSymbolForSyntax'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_nonTerminalSymbolForSyntax::e_M_nonTerminalSymbolForSyntax (void) :
mAltParametersMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_nonTerminalSymbolForSyntax ("M_nonTerminalSymbolForSyntax", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAltParametersMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonTerminalSymbolForSyntax::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonTerminalSymbolForSyntax * ptr = dynamic_cast <const elementOf_GGS_M_nonTerminalSymbolForSyntax *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAltParametersMap.operator_isEqual (ptr->mInfo.mAltParametersMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonTerminalSymbolForSyntax info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
operator_isEqual (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
operator_isNotEqual (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_M_nonterminalSymbolAlts & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_nonTerminalSymbolForSyntax::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_nonTerminalSymbolForSyntax::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_M_nonterminalSymbolAlts  & GGS_M_nonTerminalSymbolForSyntax::cEnumerator::_mAltParametersMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAltParametersMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_nonTerminalSymbolForSyntax::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_nonTerminalSymbolForSyntax * p = NULL ;
    macroMyNew (p, GGS_M_nonTerminalSymbolForSyntax (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_nonTerminalSymbolForSyntax * p = dynamic_cast <const GGS_M_nonTerminalSymbolForSyntax *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_nonTerminalSymbolForSyntax, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_nonTerminalSymbolForSyntax::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_nonTerminalSymbolForSyntax ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_M_nonterminalSymbolAlts & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_grammarInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::
cPtr_C_grammarInstruction (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeExpressionList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_typeCplusPlusName & argument_6,
                                const GGS_typeExpression & argument_7,
                                const GGS_typeExpression & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceIsFile (argument_0),
mSourceExpression (argument_1),
mGrammarName (argument_2),
mExpressionsList (argument_3),
mAltSymbol (argument_4),
mLexiqueClassName (argument_5),
mSentStringName (argument_6),
mDependencyFileExtension (argument_7),
mDependancyFilePath (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_grammarInstruction) ;
    return (cPtr_C_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarInstruction * ptr = dynamic_cast <const cPtr_C_grammarInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceIsFile.operator_isEqual (ptr->mSourceIsFile).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mGrammarName.operator_isEqual (ptr->mGrammarName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue ()
         && mAltSymbol.operator_isEqual (ptr->mAltSymbol).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue ()
         && mSentStringName.operator_isEqual (ptr->mSentStringName).boolValue ()
         && mDependencyFileExtension.operator_isEqual (ptr->mDependencyFileExtension).boolValue ()
         && mDependancyFilePath.operator_isEqual (ptr->mDependancyFilePath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_grammarInstruction:"
           << mSourceIsFile.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mGrammarName.reader_description (inIndentation + 1)
           << mExpressionsList.reader_description (inIndentation + 1)
           << mAltSymbol.reader_description (inIndentation + 1)
           << mLexiqueClassName.reader_description (inIndentation + 1)
           << mSentStringName.reader_description (inIndentation + 1)
           << mDependencyFileExtension.reader_description (inIndentation + 1)
           << mDependancyFilePath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_grammarInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_grammarInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_grammarInstruction (& typeid (cPtr_C_grammarInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_grammarInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_grammarInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_grammarInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_grammarInstruction (mSourceIsFile, mSourceExpression, mGrammarName, mExpressionsList, mAltSymbol, mLexiqueClassName, mSentStringName, mDependencyFileExtension, mDependancyFilePath COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_grammarInstruction ("C_grammarInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_grammarInstruction GGS_C_grammarInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_grammarInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_grammarInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_grammarInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_grammarInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction GGS_C_grammarInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeExpressionList & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_typeCplusPlusName & argument_6,
                 const GGS_typeExpression & argument_7,
                 const GGS_typeExpression & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarInstruction::
reader_mSourceIsFile (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mSourceExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mGrammarName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mGrammarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_C_grammarInstruction::
reader_mExpressionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mAltSymbol (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mAltSymbol ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mLexiqueClassName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_grammarInstruction::
reader_mSentStringName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSentStringName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mDependencyFileExtension (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mDependencyFileExtension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_grammarInstruction::
reader_mDependancyFilePath (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mDependancyFilePath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_grammarInstruction::actualTypeName (void) const {
  return "C_grammarInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_grammarInstruction ("C_grammarInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_C_grammarInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_grammarInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_grammarInstruction * p = NULL ;
    macroMyNew (p, GGS_C_grammarInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction GGS_C_grammarInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_grammarInstruction * p = dynamic_cast <const GGS_C_grammarInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_grammarInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_grammarInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_grammarInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeAppendInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::
cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mSourceExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeAppendInstruction) ;
    return (cPtr_typeAppendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAppendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAppendInstruction * ptr = dynamic_cast <const cPtr_typeAppendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpressions.operator_isEqual (ptr->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeAppendInstruction:"
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAppendInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAppendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAppendInstruction (& typeid (cPtr_typeAppendInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeAppendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeAppendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeAppendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeAppendInstruction (mTargetVarCppName, mStructAttributeList, mSourceExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeAppendInstruction ("typeAppendInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAppendInstruction GGS_typeAppendInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAppendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeAppendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAppendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAppendInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction GGS_typeAppendInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeAppendInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeAppendInstruction::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeAppendInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeAppendInstruction::
reader_mSourceExpressions (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAppendInstruction::actualTypeName (void) const {
  return "typeAppendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeAppendInstruction ("typeAppendInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeAppendInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeAppendInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeAppendInstruction * p = NULL ;
    macroMyNew (p, GGS_typeAppendInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction GGS_typeAppendInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeAppendInstruction * p = dynamic_cast <const GGS_typeAppendInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeAppendInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeAppendInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeAppendInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeIncrementInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::
cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeIncrementInstruction) ;
    return (cPtr_typeIncrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeIncrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeIncrementInstruction * ptr = dynamic_cast <const cPtr_typeIncrementInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeIncrementInstruction:"
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeIncrementInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeIncrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeIncrementInstruction (& typeid (cPtr_typeIncrementInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeIncrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeIncrementInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeIncrementInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeIncrementInstruction (mTargetVarCppName, mStructAttributeList, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeIncrementInstruction ("typeIncrementInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeIncrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeIncrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeIncrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeIncrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeIncrementInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeIncrementInstruction::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeIncrementInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeIncrementInstruction::
reader_mInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeIncrementInstruction::actualTypeName (void) const {
  return "typeIncrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeIncrementInstruction ("typeIncrementInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeIncrementInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeIncrementInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeIncrementInstruction * p = NULL ;
    macroMyNew (p, GGS_typeIncrementInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction GGS_typeIncrementInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeIncrementInstruction * p = dynamic_cast <const GGS_typeIncrementInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeIncrementInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeIncrementInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeIncrementInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeDecrementInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::
cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mStructAttributeList (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDecrementInstruction) ;
    return (cPtr_typeDecrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDecrementInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDecrementInstruction * ptr = dynamic_cast <const cPtr_typeDecrementInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTargetVarCppName.operator_isEqual (ptr->mTargetVarCppName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDecrementInstruction:"
           << mTargetVarCppName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDecrementInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDecrementInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDecrementInstruction (& typeid (cPtr_typeDecrementInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDecrementInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeDecrementInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDecrementInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDecrementInstruction (mTargetVarCppName, mStructAttributeList, mInstructionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDecrementInstruction ("typeDecrementInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDecrementInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeDecrementInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDecrementInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDecrementInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDecrementInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDecrementInstruction::
reader_mTargetVarCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeDecrementInstruction::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDecrementInstruction::
reader_mInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDecrementInstruction::actualTypeName (void) const {
  return "typeDecrementInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDecrementInstruction ("typeDecrementInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeDecrementInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDecrementInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDecrementInstruction * p = NULL ;
    macroMyNew (p, GGS_typeDecrementInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction GGS_typeDecrementInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDecrementInstruction * p = dynamic_cast <const GGS_typeDecrementInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDecrementInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDecrementInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDecrementInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCase1_name (argument_0),
mCase2_name (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_matchInstructionCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_matchInstructionCasesList * ptr = dynamic_cast <const elementOf_GGS_L_matchInstructionCasesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCase1_name.operator_isEqual (ptr->mCase1_name).boolValue ()
         && mCase2_name.operator_isEqual (ptr->mCase2_name).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase1_name.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase2_name.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_matchInstructionCasesList ("L_matchInstructionCasesList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
operator_concat (const GGS_L_matchInstructionCasesList & inOperand) const {
  GGS_L_matchInstructionCasesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
dotAssign_operation (const GGS_L_matchInstructionCasesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_matchInstructionCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCase1_name ;
          GGS_lstring  p_1 = p->mCase2_name ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCase1_name,
                                ptr->mCase2_name,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_emptyList (void) {
  GGS_L_matchInstructionCasesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  GGS_L_matchInstructionCasesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalSubListWithRange (GGS_L_matchInstructionCasesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCase1_name, ptr->mCase2_name, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_matchInstructionCasesList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCase1_name ;
    _out_1 = ptr->mCase2_name ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_matchInstructionCasesList::
reader_mCase1_nameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCase1_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_L_matchInstructionCasesList::
reader_mCase2_nameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCase2_name ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_L_matchInstructionCasesList::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMCase1_nameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCase1_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMCase2_nameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCase2_name = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_matchInstructionCasesList::cEnumerator::_mCase1_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCase1_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_L_matchInstructionCasesList::cEnumerator::_mCase2_name (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCase2_name ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_L_matchInstructionCasesList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_matchInstructionCasesList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_matchInstructionCasesList * p = NULL ;
    macroMyNew (p, GGS_L_matchInstructionCasesList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_matchInstructionCasesList * p = dynamic_cast <const GGS_L_matchInstructionCasesList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_matchInstructionCasesList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_matchInstructionCasesList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_matchInstructionCasesList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeMatchInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::
cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMatchInstruction) ;
    return (cPtr_typeMatchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMatchInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMatchInstruction * ptr = dynamic_cast <const cPtr_typeMatchInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aIndicatif1.operator_isEqual (ptr->aIndicatif1).boolValue ()
         && aIndicatif2.operator_isEqual (ptr->aIndicatif2).boolValue ()
         && aNomCppVariable1.operator_isEqual (ptr->aNomCppVariable1).boolValue ()
         && aNomCppVariable2.operator_isEqual (ptr->aNomCppVariable2).boolValue ()
         && aNomTypeBase1.operator_isEqual (ptr->aNomTypeBase1).boolValue ()
         && aNomTypeBase2.operator_isEqual (ptr->aNomTypeBase2).boolValue ()
         && mOperand1_isEnumeration.operator_isEqual (ptr->mOperand1_isEnumeration).boolValue ()
         && mOperand2_isEnumeration.operator_isEqual (ptr->mOperand2_isEnumeration).boolValue ()
         && aListeCas.operator_isEqual (ptr->aListeCas).boolValue ()
         && mElseInstructionsList.operator_isEqual (ptr->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMatchInstruction:"
           << aIndicatif1.reader_description (inIndentation + 1)
           << aIndicatif2.reader_description (inIndentation + 1)
           << aNomCppVariable1.reader_description (inIndentation + 1)
           << aNomCppVariable2.reader_description (inIndentation + 1)
           << aNomTypeBase1.reader_description (inIndentation + 1)
           << aNomTypeBase2.reader_description (inIndentation + 1)
           << mOperand1_isEnumeration.reader_description (inIndentation + 1)
           << mOperand2_isEnumeration.reader_description (inIndentation + 1)
           << aListeCas.reader_description (inIndentation + 1)
           << mElseInstructionsList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMatchInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMatchInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMatchInstruction (& typeid (cPtr_typeMatchInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMatchInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeMatchInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMatchInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMatchInstruction (aIndicatif1, aIndicatif2, aNomCppVariable1, aNomCppVariable2, aNomTypeBase1, aNomTypeBase2, mOperand1_isEnumeration, mOperand2_isEnumeration, aListeCas, mElseInstructionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMatchInstruction ("typeMatchInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMatchInstruction GGS_typeMatchInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMatchInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeMatchInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMatchInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMatchInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction GGS_typeMatchInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_location & argument_1,
                 const GGS_typeCplusPlusName & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_bool& argument_7,
                 const GGS_L_matchInstructionCasesList & argument_8,
                 const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif1 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif2 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable1 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable2 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase1 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase2 (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand1_isEnumeration (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand1_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand2_isEnumeration (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand2_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_typeMatchInstruction::
reader_aListeCas (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aListeCas ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeMatchInstruction::
reader_mElseInstructionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMatchInstruction::actualTypeName (void) const {
  return "typeMatchInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMatchInstruction ("typeMatchInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeMatchInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMatchInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMatchInstruction * p = NULL ;
    macroMyNew (p, GGS_typeMatchInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction GGS_typeMatchInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMatchInstruction * p = dynamic_cast <const GGS_typeMatchInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMatchInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMatchInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMatchInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mNewStyle (argument_0),
mSourceExpression (argument_1),
mLocationOffset (argument_2),
mCppTypeName (argument_3),
mAscending (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachEnumerationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachEnumerationList * ptr = dynamic_cast <const elementOf_GGS_foreachEnumerationList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNewStyle.operator_isEqual (ptr->mNewStyle).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mLocationOffset.operator_isEqual (ptr->mLocationOffset).boolValue ()
         && mCppTypeName.operator_isEqual (ptr->mCppTypeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNewStyle.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationOffset.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachEnumerationList ("foreachEnumerationList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_typeExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_string& argument_3,
                    const GGS_bool& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_typeExpression & argument_1,
                    const GGS_location & argument_2,
                    const GGS_string& argument_3,
                    const GGS_bool& argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
operator_concat (const GGS_foreachEnumerationList & inOperand) const {
  GGS_foreachEnumerationList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
dotAssign_operation (const GGS_foreachEnumerationList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachEnumerationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mNewStyle ;
          GGS_typeExpression  p_1 = p->mSourceExpression ;
          GGS_location  p_2 = p->mLocationOffset ;
          GGS_string p_3 = p->mCppTypeName ;
          GGS_bool p_4 = p->mAscending ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_typeExpression & argument_1,
                     const GGS_location & argument_2,
                     const GGS_string& argument_3,
                     const GGS_bool& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mNewStyle,
                                ptr->mSourceExpression,
                                ptr->mLocationOffset,
                                ptr->mCppTypeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_emptyList (void) {
  GGS_foreachEnumerationList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4) {
  GGS_foreachEnumerationList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalSubListWithRange (GGS_foreachEnumerationList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mNewStyle, ptr->mSourceExpression, ptr->mLocationOffset, ptr->mCppTypeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachEnumerationList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachEnumerationList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachEnumerationList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_first (C_CompilerEx & inLexique,
              GGS_bool& _out_0,
              GGS_typeExpression & _out_1,
              GGS_location & _out_2,
              GGS_string& _out_3,
              GGS_bool& _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_last (C_CompilerEx & inLexique,
             GGS_bool& _out_0,
             GGS_typeExpression & _out_1,
             GGS_location & _out_2,
             GGS_string& _out_3,
             GGS_bool& _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_bool& _out_0,
                 GGS_typeExpression & _out_1,
                 GGS_location & _out_2,
                 GGS_string& _out_3,
                 GGS_bool& _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_bool& _out_0,
                GGS_typeExpression & _out_1,
                GGS_location & _out_2,
                GGS_string& _out_3,
                GGS_bool& _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mNewStyle ;
    _out_1 = ptr->mSourceExpression ;
    _out_2 = ptr->mLocationOffset ;
    _out_3 = ptr->mCppTypeName ;
    _out_4 = ptr->mAscending ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
reader_mNewStyleAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNewStyle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_foreachEnumerationList::
reader_mSourceExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeExpression  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachEnumerationList::
reader_mLocationOffsetAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationOffset ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_mCppTypeNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCppTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
reader_mAscendingAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMNewStyleAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNewStyle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMSourceExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeExpression  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMLocationOffsetAtIndex (C_CompilerEx & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationOffset = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMCppTypeNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCppTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_setMAscendingAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachEnumerationList::cEnumerator::_mNewStyle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNewStyle ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeExpression  & GGS_foreachEnumerationList::cEnumerator::_mSourceExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_foreachEnumerationList::cEnumerator::_mLocationOffset (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocationOffset ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_foreachEnumerationList::cEnumerator::_mCppTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCppTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachEnumerationList::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachEnumerationList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachEnumerationList * p = NULL ;
    macroMyNew (p, GGS_foreachEnumerationList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachEnumerationList * p = dynamic_cast <const GGS_foreachEnumerationList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachEnumerationList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachEnumerationList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachEnumerationList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeForeachInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::
cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_typeInstructionList & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mIndexVariable (argument_1),
mWhileExpression (argument_2),
mBeforeInstructionList (argument_3),
mDoInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mAfterInstructionList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeForeachInstruction) ;
    return (cPtr_typeForeachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeForeachInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeForeachInstruction * ptr = dynamic_cast <const cPtr_typeForeachInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mForeachEnumerationList.operator_isEqual (ptr->mForeachEnumerationList).boolValue ()
         && mIndexVariable.operator_isEqual (ptr->mIndexVariable).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeForeachInstruction:"
           << mForeachEnumerationList.reader_description (inIndentation + 1)
           << mIndexVariable.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeForeachInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeForeachInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeForeachInstruction (& typeid (cPtr_typeForeachInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeForeachInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeForeachInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeForeachInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeForeachInstruction (mForeachEnumerationList, mIndexVariable, mWhileExpression, mBeforeInstructionList, mDoInstructionList, mBetweenInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeForeachInstruction ("typeForeachInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeForeachInstruction GGS_typeForeachInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeForeachInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeForeachInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeForeachInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeForeachInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction GGS_typeForeachInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_foreachEnumerationList & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_typeInstructionList & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_typeInstructionList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_typeForeachInstruction::
reader_mForeachEnumerationList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachEnumerationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mForeachEnumerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeForeachInstruction::
reader_mIndexVariable (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mIndexVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeForeachInstruction::
reader_mWhileExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mBeforeInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mDoInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mBetweenInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mAfterInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeForeachInstruction::actualTypeName (void) const {
  return "typeForeachInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeForeachInstruction ("typeForeachInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeForeachInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeForeachInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeForeachInstruction * p = NULL ;
    macroMyNew (p, GGS_typeForeachInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction GGS_typeForeachInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeForeachInstruction * p = dynamic_cast <const GGS_typeForeachInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeForeachInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeForeachInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeForeachInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mClassName (argument_0),
mResultVarID (argument_1),
mInstructionList (argument_2),
mNoUsedParameter (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredExtractCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredExtractCasesList * ptr = dynamic_cast <const elementOf_GGS_typeStructuredExtractCasesList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mResultVarID.operator_isEqual (ptr->mResultVarID).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mNoUsedParameter.operator_isEqual (ptr->mNoUsedParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mResultVarID.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNoUsedParameter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeStructuredExtractCasesList ("typeStructuredExtractCasesList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
operator_concat (const GGS_typeStructuredExtractCasesList & inOperand) const {
  GGS_typeStructuredExtractCasesList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
dotAssign_operation (const GGS_typeStructuredExtractCasesList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeStructuredExtractCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mClassName ;
          GGS_location  p_1 = p->mResultVarID ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          GGS_bool p_3 = p->mNoUsedParameter ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_location & argument_1,
                     const GGS_typeInstructionList & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mClassName,
                                ptr->mResultVarID,
                                ptr->mInstructionList,
                                ptr->mNoUsedParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_emptyList (void) {
  GGS_typeStructuredExtractCasesList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  GGS_typeStructuredExtractCasesList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalSubListWithRange (GGS_typeStructuredExtractCasesList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mClassName, ptr->mResultVarID, ptr->mInstructionList, ptr->mNoUsedParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeStructuredExtractCasesList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_location & _out_1,
              GGS_typeInstructionList & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_location & _out_1,
             GGS_typeInstructionList & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_location & _out_1,
                 GGS_typeInstructionList & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_location & _out_1,
                GGS_typeInstructionList & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mClassName ;
    _out_1 = ptr->mResultVarID ;
    _out_2 = ptr->mInstructionList ;
    _out_3 = ptr->mNoUsedParameter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredExtractCasesList::
reader_mClassNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStructuredExtractCasesList::
reader_mResultVarIDAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mResultVarID ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractCasesList::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractCasesList::
reader_mNoUsedParameterAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mNoUsedParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMClassNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMResultVarIDAtIndex (C_CompilerEx & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mResultVarID = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_setMNoUsedParameterAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mNoUsedParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeStructuredExtractCasesList::cEnumerator::_mClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeStructuredExtractCasesList::cEnumerator::_mResultVarID (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mResultVarID ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeStructuredExtractCasesList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeStructuredExtractCasesList::cEnumerator::_mNoUsedParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mNoUsedParameter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeStructuredExtractCasesList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeStructuredExtractCasesList * p = NULL ;
    macroMyNew (p, GGS_typeStructuredExtractCasesList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeStructuredExtractCasesList * p = dynamic_cast <const GGS_typeStructuredExtractCasesList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeStructuredExtractCasesList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeStructuredExtractCasesList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeStructuredExtractCasesList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_typeStructuredExtractInstructionWithElse'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::
cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeStructuredExtractInstructionWithElse) ;
    return (cPtr_typeStructuredExtractInstructionWithElse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredExtractInstructionWithElse::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredExtractInstructionWithElse * ptr = dynamic_cast <const cPtr_typeStructuredExtractInstructionWithElse *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mCasesList.operator_isEqual (ptr->mCasesList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeStructuredExtractInstructionWithElse:"
           << mVariableName.reader_description (inIndentation + 1)
           << mCasesList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredExtractInstructionWithElse::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredExtractInstructionWithElse::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStructuredExtractInstructionWithElse (& typeid (cPtr_typeStructuredExtractInstructionWithElse), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeStructuredExtractInstructionWithElse::galgasRTTI (void) const {
  return & gClassInfoFor__typeStructuredExtractInstructionWithElse ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStructuredExtractInstructionWithElse::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStructuredExtractInstructionWithElse (mVariableName, mCasesList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeStructuredExtractInstructionWithElse ("typeStructuredExtractInstructionWithElse", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (inPointer) != NULL)
      : (typeid (cPtr_typeStructuredExtractInstructionWithElse) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStructuredExtractInstructionWithElse (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStructuredExtractInstructionWithElse),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeStructuredExtractCasesList & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeStructuredExtractInstructionWithElse::
reader_mVariableName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractInstructionWithElse::
reader_mCasesList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mCasesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractInstructionWithElse::
reader_mElseInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStructuredExtractInstructionWithElse::actualTypeName (void) const {
  return "typeStructuredExtractInstructionWithElse" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeStructuredExtractInstructionWithElse ("typeStructuredExtractInstructionWithElse", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeStructuredExtractInstructionWithElse) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeStructuredExtractInstructionWithElse::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeStructuredExtractInstructionWithElse * p = NULL ;
    macroMyNew (p, GGS_typeStructuredExtractInstructionWithElse (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeStructuredExtractInstructionWithElse * p = dynamic_cast <const GGS_typeStructuredExtractInstructionWithElse *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeStructuredExtractInstructionWithElse, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeStructuredExtractInstructionWithElse::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeStructuredExtractInstructionWithElse ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_AC_elseOrDefaultForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_AC_elseOrDefaultForCastInstruction::
cPtr_AC_elseOrDefaultForCastInstruction (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_AC_elseOrDefaultForCastInstruction * GGS_AC_elseOrDefaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_AC_elseOrDefaultForCastInstruction) ;
    return (cPtr_AC_elseOrDefaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_AC_elseOrDefaultForCastInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@AC_elseOrDefaultForCastInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_AC_elseOrDefaultForCastInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_AC_elseOrDefaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_AC_elseOrDefaultForCastInstruction (& typeid (cPtr_AC_elseOrDefaultForCastInstruction), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_AC_elseOrDefaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__AC_elseOrDefaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_AC_elseOrDefaultForCastInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_AC_elseOrDefaultForCastInstruction ("AC_elseOrDefaultForCastInstruction", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction::
GGS_AC_elseOrDefaultForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction::
GGS_AC_elseOrDefaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_AC_elseOrDefaultForCastInstruction GGS_AC_elseOrDefaultForCastInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_AC_elseOrDefaultForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_AC_elseOrDefaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_AC_elseOrDefaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_AC_elseOrDefaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_AC_elseOrDefaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_AC_elseOrDefaultForCastInstruction::actualTypeName (void) const {
  return "AC_elseOrDefaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_AC_elseOrDefaultForCastInstruction::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__AC_elseOrDefaultForCastInstruction ("AC_elseOrDefaultForCastInstruction", & kTypeDescriptor_GGS_AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_AC_elseOrDefaultForCastInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_AC_elseOrDefaultForCastInstruction * p = NULL ;
    macroMyNew (p, GGS_AC_elseOrDefaultForCastInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction GGS_AC_elseOrDefaultForCastInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_AC_elseOrDefaultForCastInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_AC_elseOrDefaultForCastInstruction * p = dynamic_cast <const GGS_AC_elseOrDefaultForCastInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_AC_elseOrDefaultForCastInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_AC_elseOrDefaultForCastInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_AC_elseOrDefaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_elseForCastInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_elseForCastInstruction::
cPtr_C_elseForCastInstruction (const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_elseOrDefaultForCastInstruction (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_elseForCastInstruction * GGS_C_elseForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_elseForCastInstruction) ;
    return (cPtr_C_elseForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_elseForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_elseForCastInstruction * ptr = dynamic_cast <const cPtr_C_elseForCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_elseForCastInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_elseForCastInstruction:"
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_elseForCastInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_elseForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_elseForCastInstruction (& typeid (cPtr_C_elseForCastInstruction), & typeid (cPtr_AC_elseOrDefaultForCastInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_elseForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_elseForCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_elseForCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_elseForCastInstruction (mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_elseForCastInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_elseForCastInstruction ("C_elseForCastInstruction", true, & kTypeDescriptor_GGS_AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction::
GGS_C_elseForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction::
GGS_C_elseForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_elseForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_elseForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_elseForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_elseForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_elseForCastInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_elseForCastInstruction::
reader_mElseInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_elseForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_elseForCastInstruction *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_elseForCastInstruction::actualTypeName (void) const {
  return "C_elseForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_elseForCastInstruction ("C_elseForCastInstruction", gClassInfoFor__AC_elseOrDefaultForCastInstruction, & kTypeDescriptor_GGS_C_elseForCastInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_elseForCastInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_elseForCastInstruction * p = NULL ;
    macroMyNew (p, GGS_C_elseForCastInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_elseForCastInstruction GGS_C_elseForCastInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_elseForCastInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_elseForCastInstruction * p = dynamic_cast <const GGS_C_elseForCastInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_elseForCastInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_elseForCastInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_elseForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_defaultForCastInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_defaultForCastInstruction::
cPtr_C_defaultForCastInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_elseOrDefaultForCastInstruction (THERE),
mErrorLocationExpression (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_defaultForCastInstruction * GGS_C_defaultForCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_defaultForCastInstruction) ;
    return (cPtr_C_defaultForCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_defaultForCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_defaultForCastInstruction * ptr = dynamic_cast <const cPtr_C_defaultForCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_defaultForCastInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_defaultForCastInstruction:"
           << mErrorLocationExpression.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_defaultForCastInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_defaultForCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_defaultForCastInstruction (& typeid (cPtr_C_defaultForCastInstruction), & typeid (cPtr_AC_elseOrDefaultForCastInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_defaultForCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_defaultForCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_defaultForCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_defaultForCastInstruction (mErrorLocationExpression, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_defaultForCastInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_defaultForCastInstruction ("C_defaultForCastInstruction", true, & kTypeDescriptor_GGS_AC_elseOrDefaultForCastInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction::
GGS_C_defaultForCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction::
GGS_C_defaultForCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_defaultForCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_defaultForCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_defaultForCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_defaultForCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_defaultForCastInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_defaultForCastInstruction::
reader_mErrorLocationExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_defaultForCastInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_defaultForCastInstruction::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_defaultForCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_defaultForCastInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_defaultForCastInstruction::actualTypeName (void) const {
  return "C_defaultForCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_defaultForCastInstruction ("C_defaultForCastInstruction", gClassInfoFor__AC_elseOrDefaultForCastInstruction, & kTypeDescriptor_GGS_C_defaultForCastInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_defaultForCastInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_defaultForCastInstruction * p = NULL ;
    macroMyNew (p, GGS_C_defaultForCastInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_defaultForCastInstruction GGS_C_defaultForCastInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_defaultForCastInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_defaultForCastInstruction * p = dynamic_cast <const GGS_C_defaultForCastInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_defaultForCastInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_defaultForCastInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_defaultForCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeStructuredCastBranchList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredCastBranchList::
elementOf_GGS_typeStructuredCastBranchList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCastClassName (argument_0),
mCheckForKindOfClass (argument_1),
mLocalConstantName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredCastBranchList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredCastBranchList * ptr = dynamic_cast <const elementOf_GGS_typeStructuredCastBranchList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastClassName.operator_isEqual (ptr->mCastClassName).boolValue ()
         && mCheckForKindOfClass.operator_isEqual (ptr->mCheckForKindOfClass).boolValue ()
         && mLocalConstantName.operator_isEqual (ptr->mLocalConstantName).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredCastBranchList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastClassName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCheckForKindOfClass.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocalConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeStructuredCastBranchList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeStructuredCastBranchList ("typeStructuredCastBranchList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_typeCplusPlusNameList & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_typeCplusPlusNameList & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
operator_concat (const GGS_typeStructuredCastBranchList & inOperand) const {
  GGS_typeStructuredCastBranchList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
dotAssign_operation (const GGS_typeStructuredCastBranchList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeStructuredCastBranchList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCastClassName ;
          GGS_bool p_1 = p->mCheckForKindOfClass ;
          GGS_typeCplusPlusNameList  p_2 = p->mLocalConstantName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1,
                     const GGS_typeCplusPlusNameList & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCastClassName,
                                ptr->mCheckForKindOfClass,
                                ptr->mLocalConstantName,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastBranchList::
constructor_emptyList (void) {
  GGS_typeStructuredCastBranchList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastBranchList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeCplusPlusNameList & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  GGS_typeStructuredCastBranchList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
internalSubListWithRange (GGS_typeStructuredCastBranchList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCastClassName, ptr->mCheckForKindOfClass, ptr->mLocalConstantName, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredCastBranchList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeStructuredCastBranchList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1,
              GGS_typeCplusPlusNameList & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1,
             GGS_typeCplusPlusNameList & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1,
                 GGS_typeCplusPlusNameList & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1,
                GGS_typeCplusPlusNameList & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCastClassName ;
    _out_1 = ptr->mCheckForKindOfClass ;
    _out_2 = ptr->mLocalConstantName ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredCastBranchList::
reader_mCastClassNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastClassName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredCastBranchList::
reader_mCheckForKindOfClassAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCheckForKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeStructuredCastBranchList::
reader_mLocalConstantNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocalConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredCastBranchList::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMCastClassNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastClassName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMCheckForKindOfClassAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCheckForKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMLocalConstantNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeCplusPlusNameList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocalConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredCastBranchList::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeStructuredCastBranchList::cEnumerator::_mCastClassName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCastClassName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeStructuredCastBranchList::cEnumerator::_mCheckForKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCheckForKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusNameList  & GGS_typeStructuredCastBranchList::cEnumerator::_mLocalConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocalConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeStructuredCastBranchList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeStructuredCastBranchList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeStructuredCastBranchList * p = NULL ;
    macroMyNew (p, GGS_typeStructuredCastBranchList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList GGS_typeStructuredCastBranchList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastBranchList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeStructuredCastBranchList * p = dynamic_cast <const GGS_typeStructuredCastBranchList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeStructuredCastBranchList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeStructuredCastBranchList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeStructuredCastBranchList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeStructuredCastInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredCastInstruction::
cPtr_typeStructuredCastInstruction (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeStructuredCastBranchList & argument_3,
                                const GGS_AC_elseOrDefaultForCastInstruction & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCastInstructionLocation (argument_0),
mSourceExpression (argument_1),
mSourceExpressionTypeName (argument_2),
mBranchList (argument_3),
mElseOrDefault (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredCastInstruction * GGS_typeStructuredCastInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeStructuredCastInstruction) ;
    return (cPtr_typeStructuredCastInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredCastInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredCastInstruction * ptr = dynamic_cast <const cPtr_typeStructuredCastInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCastInstructionLocation.operator_isEqual (ptr->mCastInstructionLocation).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionTypeName.operator_isEqual (ptr->mSourceExpressionTypeName).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue ()
         && mElseOrDefault.operator_isEqual (ptr->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredCastInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeStructuredCastInstruction:"
           << mCastInstructionLocation.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mSourceExpressionTypeName.reader_description (inIndentation + 1)
           << mBranchList.reader_description (inIndentation + 1)
           << mElseOrDefault.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredCastInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeStructuredCastInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeStructuredCastInstruction (& typeid (cPtr_typeStructuredCastInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeStructuredCastInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeStructuredCastInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeStructuredCastInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeStructuredCastInstruction (mCastInstructionLocation, mSourceExpression, mSourceExpressionTypeName, mBranchList, mElseOrDefault COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeStructuredCastInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeStructuredCastInstruction ("typeStructuredCastInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction::
GGS_typeStructuredCastInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction::
GGS_typeStructuredCastInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeStructuredCastInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeStructuredCastInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeStructuredCastInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeStructuredCastInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeStructuredCastBranchList & argument_3,
                 const GGS_AC_elseOrDefaultForCastInstruction & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredCastInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeStructuredCastInstruction::
reader_mCastInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mCastInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStructuredCastInstruction::
reader_mSourceExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStructuredCastInstruction::
reader_mSourceExpressionTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mSourceExpressionTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastBranchList  GGS_typeStructuredCastInstruction::
reader_mBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredCastBranchList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_elseOrDefaultForCastInstruction  GGS_typeStructuredCastInstruction::
reader_mElseOrDefault (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_elseOrDefaultForCastInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredCastInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredCastInstruction *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeStructuredCastInstruction::actualTypeName (void) const {
  return "typeStructuredCastInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeStructuredCastInstruction ("typeStructuredCastInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeStructuredCastInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeStructuredCastInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeStructuredCastInstruction * p = NULL ;
    macroMyNew (p, GGS_typeStructuredCastInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredCastInstruction GGS_typeStructuredCastInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeStructuredCastInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeStructuredCastInstruction * p = dynamic_cast <const GGS_typeStructuredCastInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeStructuredCastInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeStructuredCastInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeStructuredCastInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeRoutineCallInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::
cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mRoutineName (argument_0),
mExpressionsList (argument_1),
mFormalParameterList (argument_2),
mIsExternActionCall (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeRoutineCallInstruction) ;
    return (cPtr_typeRoutineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineCallInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineCallInstruction * ptr = dynamic_cast <const cPtr_typeRoutineCallInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mExpressionsList.operator_isEqual (ptr->mExpressionsList).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mIsExternActionCall.operator_isEqual (ptr->mIsExternActionCall).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeRoutineCallInstruction:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mExpressionsList.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mIsExternActionCall.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineCallInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineCallInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineCallInstruction (& typeid (cPtr_typeRoutineCallInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeRoutineCallInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeRoutineCallInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRoutineCallInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRoutineCallInstruction (mRoutineName, mExpressionsList, mFormalParameterList, mIsExternActionCall COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeRoutineCallInstruction ("typeRoutineCallInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineCallInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineCallInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRoutineCallInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineCallInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_L_EXsignature & argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeRoutineCallInstruction::
reader_mRoutineName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRoutineCallInstruction::
reader_mExpressionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeRoutineCallInstruction::
reader_mFormalParameterList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineCallInstruction::
reader_mIsExternActionCall (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mIsExternActionCall ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineCallInstruction::actualTypeName (void) const {
  return "typeRoutineCallInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeRoutineCallInstruction ("typeRoutineCallInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeRoutineCallInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeRoutineCallInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeRoutineCallInstruction * p = NULL ;
    macroMyNew (p, GGS_typeRoutineCallInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeRoutineCallInstruction * p = dynamic_cast <const GGS_typeRoutineCallInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeRoutineCallInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeRoutineCallInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeRoutineCallInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeLogInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogInstruction::
cPtr_typeLogInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mLogMessage (argument_0),
mLogExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogInstruction * GGS_typeLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLogInstruction) ;
    return (cPtr_typeLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogInstruction * ptr = dynamic_cast <const cPtr_typeLogInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLogMessage.operator_isEqual (ptr->mLogMessage).boolValue ()
         && mLogExpression.operator_isEqual (ptr->mLogExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLogInstruction:"
           << mLogMessage.reader_description (inIndentation + 1)
           << mLogExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLogInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLogInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLogInstruction (& typeid (cPtr_typeLogInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLogInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeLogInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLogInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLogInstruction (mLogMessage, mLogExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeLogInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLogInstruction ("typeLogInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLogInstruction GGS_typeLogInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLogInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLogInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLogInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLogInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction GGS_typeLogInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLogInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLogInstruction::
reader_mLogMessage (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mLogMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLogInstruction::
reader_mLogExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mLogExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLogInstruction::actualTypeName (void) const {
  return "typeLogInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLogInstruction ("typeLogInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeLogInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLogInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLogInstruction * p = NULL ;
    macroMyNew (p, GGS_typeLogInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction GGS_typeLogInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLogInstruction * p = dynamic_cast <const GGS_typeLogInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLogInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLogInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLogInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeDropInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::
cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDropInstruction) ;
    return (cPtr_typeDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDropInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDropInstruction * ptr = dynamic_cast <const cPtr_typeDropInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aVariableConsommee.operator_isEqual (ptr->aVariableConsommee).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDropInstruction:"
           << aVariableConsommee.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDropInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDropInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDropInstruction (& typeid (cPtr_typeDropInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDropInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeDropInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDropInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDropInstruction (aVariableConsommee COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDropInstruction ("typeDropInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDropInstruction GGS_typeDropInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDropInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeDropInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDropInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDropInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction GGS_typeDropInstruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDropInstruction::
reader_aVariableConsommee (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDropInstruction *) mPointer)->aVariableConsommee ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDropInstruction::actualTypeName (void) const {
  return "typeDropInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDropInstruction ("typeDropInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeDropInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDropInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDropInstruction * p = NULL ;
    macroMyNew (p, GGS_typeDropInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction GGS_typeDropInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDropInstruction * p = dynamic_cast <const GGS_typeDropInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDropInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDropInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDropInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableNomRoutinesDeclarees'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableNomRoutinesDeclarees ("typeTableNomRoutinesDeclarees", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableNomRoutinesDeclarees::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableNomRoutinesDeclarees info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
operator_isEqual (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
operator_isNotEqual (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeTableNomRoutinesDeclarees info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableNomRoutinesDeclarees::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableNomRoutinesDeclarees::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableNomRoutinesDeclarees * p = NULL ;
    macroMyNew (p, GGS_typeTableNomRoutinesDeclarees (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableNomRoutinesDeclarees * p = dynamic_cast <const GGS_typeTableNomRoutinesDeclarees *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableNomRoutinesDeclarees, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableNomRoutinesDeclarees::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableNomRoutinesDeclarees ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeEntityToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEntityToGenerate) ;
    return (cPtr_typeEntityToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeEntityToGenerate::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeEntityToGenerate:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntityToGenerate::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntityToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntityToGenerate (& typeid (cPtr_typeEntityToGenerate), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntityToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntityToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntityToGenerate ("typeEntityToGenerate", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntityToGenerate GGS_typeEntityToGenerate::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntityToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntityToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntityToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntityToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntityToGenerate),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntityToGenerate::actualTypeName (void) const {
  return "typeEntityToGenerate" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeEntityToGenerate::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeEntityToGenerate ("typeEntityToGenerate", & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntityToGenerate::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntityToGenerate * p = NULL ;
    macroMyNew (p, GGS_typeEntityToGenerate (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate GGS_typeEntityToGenerate::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntityToGenerate result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntityToGenerate * p = dynamic_cast <const GGS_typeEntityToGenerate *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntityToGenerate, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntityToGenerate::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntityToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeExternTypeToGenerate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::
cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_externTypeConstructorMap & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mConstructorMap (argument_1),
mModifiersMap (argument_2),
mReadersInInstructionMap (argument_3),
mAcceptAddAssignOperatorCall (argument_4),
mAddAssignOperatorCallTypeList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeExternTypeToGenerate) ;
    return (cPtr_typeExternTypeToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeExternTypeToGenerate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeExternTypeToGenerate * ptr = dynamic_cast <const cPtr_typeExternTypeToGenerate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mGalgasName.operator_isEqual (ptr->mGalgasName).boolValue ()
         && mConstructorMap.operator_isEqual (ptr->mConstructorMap).boolValue ()
         && mModifiersMap.operator_isEqual (ptr->mModifiersMap).boolValue ()
         && mReadersInInstructionMap.operator_isEqual (ptr->mReadersInInstructionMap).boolValue ()
         && mAcceptAddAssignOperatorCall.operator_isEqual (ptr->mAcceptAddAssignOperatorCall).boolValue ()
         && mAddAssignOperatorCallTypeList.operator_isEqual (ptr->mAddAssignOperatorCallTypeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeExternTypeToGenerate:"
           << mGalgasName.reader_description (inIndentation + 1)
           << mConstructorMap.reader_description (inIndentation + 1)
           << mModifiersMap.reader_description (inIndentation + 1)
           << mReadersInInstructionMap.reader_description (inIndentation + 1)
           << mAcceptAddAssignOperatorCall.reader_description (inIndentation + 1)
           << mAddAssignOperatorCallTypeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeExternTypeToGenerate::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeExternTypeToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeExternTypeToGenerate (& typeid (cPtr_typeExternTypeToGenerate), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeExternTypeToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeExternTypeToGenerate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeExternTypeToGenerate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeExternTypeToGenerate (mGalgasName, mConstructorMap, mModifiersMap, mReadersInInstructionMap, mAcceptAddAssignOperatorCall, mAddAssignOperatorCallTypeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeExternTypeToGenerate ("typeExternTypeToGenerate", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeExternTypeToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeExternTypeToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeExternTypeToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeExternTypeToGenerate),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_externTypeConstructorMap & argument_1,
                 const GGS_typeTableMethodes & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeExternTypeToGenerate::actualTypeName (void) const {
  return "typeExternTypeToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeExternTypeToGenerate ("typeExternTypeToGenerate", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeExternTypeToGenerate) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeExternTypeToGenerate::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeExternTypeToGenerate * p = NULL ;
    macroMyNew (p, GGS_typeExternTypeToGenerate (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeExternTypeToGenerate * p = dynamic_cast <const GGS_typeExternTypeToGenerate *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeExternTypeToGenerate, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeExternTypeToGenerate::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeExternTypeToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeRoutineAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::
cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mRoutineName (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeRoutineAengendrer) ;
    return (cPtr_typeRoutineAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineAengendrer * ptr = dynamic_cast <const cPtr_typeRoutineAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeRoutineAengendrer:"
           << mRoutineName.reader_description (inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineAengendrer::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineAengendrer (& typeid (cPtr_typeRoutineAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeRoutineAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeRoutineAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRoutineAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRoutineAengendrer (mRoutineName, aListeTypeEtNomsArguments, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeRoutineAengendrer ("typeRoutineAengendrer", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRoutineAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineAengendrer),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineAengendrer::actualTypeName (void) const {
  return "typeRoutineAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeRoutineAengendrer ("typeRoutineAengendrer", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeRoutineAengendrer) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeRoutineAengendrer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeRoutineAengendrer * p = NULL ;
    macroMyNew (p, GGS_typeRoutineAengendrer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeRoutineAengendrer * p = dynamic_cast <const GGS_typeRoutineAengendrer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeRoutineAengendrer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeRoutineAengendrer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeRoutineAengendrer ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeFonctionAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFonctionAengendrer::
cPtr_typeFonctionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_AC_galgasType & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_typeInstructionList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mFunctionName (argument_0),
aListeTypeEtNomsArguments (argument_1),
mReturnedType (argument_2),
mReturnedVar (argument_3),
mInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFonctionAengendrer * GGS_typeFonctionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFonctionAengendrer) ;
    return (cPtr_typeFonctionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFonctionAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFonctionAengendrer * ptr = dynamic_cast <const cPtr_typeFonctionAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue ()
         && mReturnedVar.operator_isEqual (ptr->mReturnedVar).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFonctionAengendrer::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFonctionAengendrer:"
           << mFunctionName.reader_description (inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description (inIndentation + 1)
           << mReturnedType.reader_description (inIndentation + 1)
           << mReturnedVar.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionAengendrer::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFonctionAengendrer (& typeid (cPtr_typeFonctionAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFonctionAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeFonctionAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFonctionAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFonctionAengendrer (mFunctionName, aListeTypeEtNomsArguments, mReturnedType, mReturnedVar, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeFonctionAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFonctionAengendrer ("typeFonctionAengendrer", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer::
GGS_typeFonctionAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer::
GGS_typeFonctionAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFonctionAengendrer GGS_typeFonctionAengendrer::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFonctionAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFonctionAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeFonctionAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFonctionAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFonctionAengendrer),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer GGS_typeFonctionAengendrer::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_AC_galgasType & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_typeInstructionList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeFonctionAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeFonctionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFonctionAengendrer::actualTypeName (void) const {
  return "typeFonctionAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFonctionAengendrer ("typeFonctionAengendrer", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeFonctionAengendrer) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFonctionAengendrer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFonctionAengendrer * p = NULL ;
    macroMyNew (p, GGS_typeFonctionAengendrer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionAengendrer GGS_typeFonctionAengendrer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFonctionAengendrer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFonctionAengendrer * p = dynamic_cast <const GGS_typeFonctionAengendrer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFonctionAengendrer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFonctionAengendrer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFonctionAengendrer ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeOnceFunctionToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOnceFunctionToGenerate::
cPtr_typeOnceFunctionToGenerate (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mFunctionName (argument_0),
mReturnedType (argument_1),
mReturnedVar (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOnceFunctionToGenerate * GGS_typeOnceFunctionToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeOnceFunctionToGenerate) ;
    return (cPtr_typeOnceFunctionToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOnceFunctionToGenerate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOnceFunctionToGenerate * ptr = dynamic_cast <const cPtr_typeOnceFunctionToGenerate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue ()
         && mReturnedVar.operator_isEqual (ptr->mReturnedVar).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOnceFunctionToGenerate::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeOnceFunctionToGenerate:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mReturnedType.reader_description (inIndentation + 1)
           << mReturnedVar.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeOnceFunctionToGenerate::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeOnceFunctionToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeOnceFunctionToGenerate (& typeid (cPtr_typeOnceFunctionToGenerate), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeOnceFunctionToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeOnceFunctionToGenerate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeOnceFunctionToGenerate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeOnceFunctionToGenerate (mFunctionName, mReturnedType, mReturnedVar, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeOnceFunctionToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeOnceFunctionToGenerate ("typeOnceFunctionToGenerate", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeOnceFunctionToGenerate::
GGS_typeOnceFunctionToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOnceFunctionToGenerate::
GGS_typeOnceFunctionToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeOnceFunctionToGenerate GGS_typeOnceFunctionToGenerate::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeOnceFunctionToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeOnceFunctionToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeOnceFunctionToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeOnceFunctionToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeOnceFunctionToGenerate),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOnceFunctionToGenerate GGS_typeOnceFunctionToGenerate::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_AC_galgasType & argument_1,
                 const GGS_typeCplusPlusName & argument_2,
                 const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeOnceFunctionToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeOnceFunctionToGenerate (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeOnceFunctionToGenerate::actualTypeName (void) const {
  return "typeOnceFunctionToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeOnceFunctionToGenerate ("typeOnceFunctionToGenerate", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeOnceFunctionToGenerate) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeOnceFunctionToGenerate::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeOnceFunctionToGenerate * p = NULL ;
    macroMyNew (p, GGS_typeOnceFunctionToGenerate (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeOnceFunctionToGenerate GGS_typeOnceFunctionToGenerate::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeOnceFunctionToGenerate result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeOnceFunctionToGenerate * p = dynamic_cast <const GGS_typeOnceFunctionToGenerate *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeOnceFunctionToGenerate, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeOnceFunctionToGenerate::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeOnceFunctionToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_categoryMethodToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryMethodToImplement::
cPtr_categoryMethodToImplement (const GGS_categoryMethodKind& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_location & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mCategoryMethodKind (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryMethodToImplement * GGS_categoryMethodToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_categoryMethodToImplement) ;
    return (cPtr_categoryMethodToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryMethodToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryMethodToImplement * ptr = dynamic_cast <const cPtr_categoryMethodToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodKind.operator_isEqual (ptr->mCategoryMethodKind).boolValue ()
         && mBaseClassName.operator_isEqual (ptr->mBaseClassName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryMethodToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@categoryMethodToImplement:"
           << mCategoryMethodKind.reader_description (inIndentation + 1)
           << mBaseClassName.reader_description (inIndentation + 1)
           << mClassName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1)
           << mMagicNumber.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryMethodToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryMethodToImplement (& typeid (cPtr_categoryMethodToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_categoryMethodToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__categoryMethodToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryMethodToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryMethodToImplement (mCategoryMethodKind, mBaseClassName, mClassName, mMethodName, aListeTypeEtNomsArguments, mInstructionList, mMagicNumber COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_categoryMethodToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryMethodToImplement ("categoryMethodToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement::
GGS_categoryMethodToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement::
GGS_categoryMethodToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryMethodToImplement GGS_categoryMethodToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryMethodToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryMethodToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryMethodToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryMethodToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement GGS_categoryMethodToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_categoryMethodKind& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_location & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryMethodToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryMethodToImplement::actualTypeName (void) const {
  return "categoryMethodToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__categoryMethodToImplement ("categoryMethodToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_categoryMethodToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_categoryMethodToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryMethodToImplement * p = NULL ;
    macroMyNew (p, GGS_categoryMethodToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodToImplement GGS_categoryMethodToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryMethodToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryMethodToImplement * p = dynamic_cast <const GGS_categoryMethodToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryMethodToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryMethodToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryMethodToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_categoryReaderToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryReaderToImplement::
cPtr_categoryReaderToImplement (const GGS_categoryMethodKind& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_typeInstructionList & argument_5,
                                const GGS_location & argument_6,
                                const GGS_AC_galgasType & argument_7,
                                const GGS_typeCplusPlusName & argument_8
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mCategoryMethodKind (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6),
mReturnedType (argument_7),
mReturnedCppVariableName (argument_8) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryReaderToImplement * GGS_categoryReaderToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_categoryReaderToImplement) ;
    return (cPtr_categoryReaderToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryReaderToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryReaderToImplement * ptr = dynamic_cast <const cPtr_categoryReaderToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodKind.operator_isEqual (ptr->mCategoryMethodKind).boolValue ()
         && mBaseClassName.operator_isEqual (ptr->mBaseClassName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue ()
         && mReturnedCppVariableName.operator_isEqual (ptr->mReturnedCppVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryReaderToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@categoryReaderToImplement:"
           << mCategoryMethodKind.reader_description (inIndentation + 1)
           << mBaseClassName.reader_description (inIndentation + 1)
           << mClassName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1)
           << mMagicNumber.reader_description (inIndentation + 1)
           << mReturnedType.reader_description (inIndentation + 1)
           << mReturnedCppVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryReaderToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryReaderToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryReaderToImplement (& typeid (cPtr_categoryReaderToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_categoryReaderToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__categoryReaderToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryReaderToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryReaderToImplement (mCategoryMethodKind, mBaseClassName, mClassName, mMethodName, aListeTypeEtNomsArguments, mInstructionList, mMagicNumber, mReturnedType, mReturnedCppVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_categoryReaderToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryReaderToImplement ("categoryReaderToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement::
GGS_categoryReaderToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement::
GGS_categoryReaderToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryReaderToImplement GGS_categoryReaderToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryReaderToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryReaderToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryReaderToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryReaderToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryReaderToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement GGS_categoryReaderToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_categoryMethodKind& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_typeInstructionList & argument_5,
                 const GGS_location & argument_6,
                 const GGS_AC_galgasType & argument_7,
                 const GGS_typeCplusPlusName & argument_8
                                COMMA_LOCATION_ARGS) {
  GGS_categoryReaderToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryReaderToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryReaderToImplement::actualTypeName (void) const {
  return "categoryReaderToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__categoryReaderToImplement ("categoryReaderToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_categoryReaderToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_categoryReaderToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryReaderToImplement * p = NULL ;
    macroMyNew (p, GGS_categoryReaderToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderToImplement GGS_categoryReaderToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryReaderToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryReaderToImplement * p = dynamic_cast <const GGS_categoryReaderToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryReaderToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryReaderToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryReaderToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_categoryTemplateToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_categoryTemplateToImplement::
cPtr_categoryTemplateToImplement (const GGS_categoryMethodKind& argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                                const GGS_templateInstructionList & argument_5,
                                const GGS_location & argument_6,
                                const GGS_bool& argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mCategoryMethodKind (argument_0),
mBaseClassName (argument_1),
mClassName (argument_2),
mMethodName (argument_3),
aListeTypeEtNomsArguments (argument_4),
mInstructionList (argument_5),
mMagicNumber (argument_6),
mUsesColumnMarker (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_categoryTemplateToImplement * GGS_categoryTemplateToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_categoryTemplateToImplement) ;
    return (cPtr_categoryTemplateToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_categoryTemplateToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_categoryTemplateToImplement * ptr = dynamic_cast <const cPtr_categoryTemplateToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodKind.operator_isEqual (ptr->mCategoryMethodKind).boolValue ()
         && mBaseClassName.operator_isEqual (ptr->mBaseClassName).boolValue ()
         && mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && aListeTypeEtNomsArguments.operator_isEqual (ptr->aListeTypeEtNomsArguments).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mMagicNumber.operator_isEqual (ptr->mMagicNumber).boolValue ()
         && mUsesColumnMarker.operator_isEqual (ptr->mUsesColumnMarker).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_categoryTemplateToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@categoryTemplateToImplement:"
           << mCategoryMethodKind.reader_description (inIndentation + 1)
           << mBaseClassName.reader_description (inIndentation + 1)
           << mClassName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1)
           << mMagicNumber.reader_description (inIndentation + 1)
           << mUsesColumnMarker.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_categoryTemplateToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_categoryTemplateToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_categoryTemplateToImplement (& typeid (cPtr_categoryTemplateToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_categoryTemplateToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__categoryTemplateToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_categoryTemplateToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_categoryTemplateToImplement (mCategoryMethodKind, mBaseClassName, mClassName, mMethodName, aListeTypeEtNomsArguments, mInstructionList, mMagicNumber, mUsesColumnMarker COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_categoryTemplateToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryTemplateToImplement ("categoryTemplateToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement::
GGS_categoryTemplateToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement::
GGS_categoryTemplateToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_categoryTemplateToImplement GGS_categoryTemplateToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_categoryTemplateToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_categoryTemplateToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_categoryTemplateToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_categoryTemplateToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_categoryTemplateToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement GGS_categoryTemplateToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_categoryMethodKind& argument_0,
                 const GGS_string& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_4,
                 const GGS_templateInstructionList & argument_5,
                 const GGS_location & argument_6,
                 const GGS_bool& argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_categoryTemplateToImplement result ;
  macroMyNew (result.mPointer, cPtr_categoryTemplateToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_categoryTemplateToImplement::actualTypeName (void) const {
  return "categoryTemplateToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__categoryTemplateToImplement ("categoryTemplateToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_categoryTemplateToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_categoryTemplateToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryTemplateToImplement * p = NULL ;
    macroMyNew (p, GGS_categoryTemplateToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryTemplateToImplement GGS_categoryTemplateToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryTemplateToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryTemplateToImplement * p = dynamic_cast <const GGS_categoryTemplateToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryTemplateToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryTemplateToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryTemplateToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_listTypeToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::
cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_listTypeToImplement) ;
    return (cPtr_C_listTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_listTypeToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_listTypeToImplement * ptr = dynamic_cast <const cPtr_C_listTypeToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomListe.operator_isEqual (ptr->aNomListe).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_listTypeToImplement:"
           << aNomListe.reader_description (inIndentation + 1)
           << mNonExternAttributesList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_listTypeToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_listTypeToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_listTypeToImplement (& typeid (cPtr_C_listTypeToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_listTypeToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_listTypeToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_listTypeToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_listTypeToImplement (aNomListe, mNonExternAttributesList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_listTypeToImplement ("C_listTypeToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_listTypeToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_listTypeToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_listTypeToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_listTypeToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_listTypeToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_listTypeToImplement::actualTypeName (void) const {
  return "C_listTypeToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_listTypeToImplement ("C_listTypeToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_listTypeToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_listTypeToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_listTypeToImplement * p = NULL ;
    macroMyNew (p, GGS_C_listTypeToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement GGS_C_listTypeToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_listTypeToImplement * p = dynamic_cast <const GGS_C_listTypeToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_listTypeToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_listTypeToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_listTypeToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@EXsortDescriptorList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_EXsortDescriptorList::
elementOf_GGS_EXsortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSortAttribute (argument_0),
mAscendingOrder (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXsortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_EXsortDescriptorList * ptr = dynamic_cast <const elementOf_GGS_EXsortDescriptorList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortAttribute.operator_isEqual (ptr->mSortAttribute).boolValue ()
         && mAscendingOrder.operator_isEqual (ptr->mAscendingOrder).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXsortDescriptorList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortAttribute.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscendingOrder.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@EXsortDescriptorList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXsortDescriptorList ("EXsortDescriptorList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
operator_concat (const GGS_EXsortDescriptorList & inOperand) const {
  GGS_EXsortDescriptorList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
dotAssign_operation (const GGS_EXsortDescriptorList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_EXsortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortAttribute ;
          GGS_bool p_1 = p->mAscendingOrder ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSortAttribute,
                                ptr->mAscendingOrder
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_EXsortDescriptorList::
constructor_emptyList (void) {
  GGS_EXsortDescriptorList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList  GGS_EXsortDescriptorList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_EXsortDescriptorList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
internalSubListWithRange (GGS_EXsortDescriptorList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSortAttribute, ptr->mAscendingOrder) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_EXsortDescriptorList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXsortDescriptorList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@EXsortDescriptorList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortAttribute ;
    _out_1 = ptr->mAscendingOrder ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_EXsortDescriptorList::
reader_mSortAttributeAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortAttribute ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXsortDescriptorList::
reader_mAscendingOrderAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscendingOrder ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_setMSortAttributeAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortAttribute = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_EXsortDescriptorList::
modifier_setMAscendingOrderAtIndex (C_CompilerEx & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscendingOrder = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_EXsortDescriptorList::cEnumerator::_mSortAttribute (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortAttribute ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_EXsortDescriptorList::cEnumerator::_mAscendingOrder (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscendingOrder ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXsortDescriptorList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXsortDescriptorList * p = NULL ;
    macroMyNew (p, GGS_EXsortDescriptorList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXsortDescriptorList GGS_EXsortDescriptorList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXsortDescriptorList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXsortDescriptorList * p = dynamic_cast <const GGS_EXsortDescriptorList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXsortDescriptorList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXsortDescriptorList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXsortDescriptorList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_sortedListTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_sortedListTypeToImplement::
cPtr_C_sortedListTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_EXsortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_sortedListTypeToImplement * GGS_C_sortedListTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_sortedListTypeToImplement) ;
    return (cPtr_C_sortedListTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_sortedListTypeToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_sortedListTypeToImplement * ptr = dynamic_cast <const cPtr_C_sortedListTypeToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomListe.operator_isEqual (ptr->aNomListe).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_sortedListTypeToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_sortedListTypeToImplement:"
           << aNomListe.reader_description (inIndentation + 1)
           << mNonExternAttributesList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_sortedListTypeToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_sortedListTypeToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_sortedListTypeToImplement (& typeid (cPtr_C_sortedListTypeToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_sortedListTypeToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_sortedListTypeToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_sortedListTypeToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_sortedListTypeToImplement (aNomListe, mNonExternAttributesList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_sortedListTypeToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_sortedListTypeToImplement ("C_sortedListTypeToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_sortedListTypeToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_sortedListTypeToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_sortedListTypeToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_EXsortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_sortedListTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_sortedListTypeToImplement::actualTypeName (void) const {
  return "C_sortedListTypeToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_sortedListTypeToImplement ("C_sortedListTypeToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_sortedListTypeToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_sortedListTypeToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_sortedListTypeToImplement * p = NULL ;
    macroMyNew (p, GGS_C_sortedListTypeToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_sortedListTypeToImplement * p = dynamic_cast <const GGS_C_sortedListTypeToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_sortedListTypeToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_sortedListTypeToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_sortedListTypeToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeDefinitionTableAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::
cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
aNomClasseGenerique (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
aTableMethodesSurcharger (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDefinitionTableAimplementer) ;
    return (cPtr_typeDefinitionTableAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDefinitionTableAimplementer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDefinitionTableAimplementer * ptr = dynamic_cast <const cPtr_typeDefinitionTableAimplementer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomTable.operator_isEqual (ptr->aNomTable).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue ()
         && aNomClasseGenerique.operator_isEqual (ptr->aNomClasseGenerique).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && aTableMethodesSurcharger.operator_isEqual (ptr->aTableMethodesSurcharger).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDefinitionTableAimplementer:"
           << aNomTable.reader_description (inIndentation + 1)
           << mNonExternAttributesList.reader_description (inIndentation + 1)
           << aNomClasseGenerique.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << aTableMethodesSurcharger.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDefinitionTableAimplementer::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDefinitionTableAimplementer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDefinitionTableAimplementer (& typeid (cPtr_typeDefinitionTableAimplementer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDefinitionTableAimplementer::galgasRTTI (void) const {
  return & gClassInfoFor__typeDefinitionTableAimplementer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDefinitionTableAimplementer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDefinitionTableAimplementer (aNomTable, mNonExternAttributesList, aNomClasseGenerique, mInsertMethodList, mSearchMethodList, aTableMethodesSurcharger COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDefinitionTableAimplementer ("typeDefinitionTableAimplementer", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (inPointer) != NULL)
      : (typeid (cPtr_typeDefinitionTableAimplementer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDefinitionTableAimplementer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDefinitionTableAimplementer),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  macroMyNew (result.mPointer, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDefinitionTableAimplementer::actualTypeName (void) const {
  return "typeDefinitionTableAimplementer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDefinitionTableAimplementer ("typeDefinitionTableAimplementer", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeDefinitionTableAimplementer) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDefinitionTableAimplementer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDefinitionTableAimplementer * p = NULL ;
    macroMyNew (p, GGS_typeDefinitionTableAimplementer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDefinitionTableAimplementer * p = dynamic_cast <const GGS_typeDefinitionTableAimplementer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDefinitionTableAimplementer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDefinitionTableAimplementer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDefinitionTableAimplementer ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_mapAutomatonStateMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapAutomatonStateMap::e_mapAutomatonStateMap (void) :
mStateIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@mapAutomatonStateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapAutomatonStateMap ("mapAutomatonStateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapAutomatonStateMap::
elementOf_GGS_mapAutomatonStateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapAutomatonStateMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAutomatonStateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStateIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapAutomatonStateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapAutomatonStateMap * ptr = dynamic_cast <const elementOf_GGS_mapAutomatonStateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mStateIndex.operator_isEqual (ptr->mInfo.mStateIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAutomatonStateMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_mapAutomatonStateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAutomatonStateMap * info = (e_mapAutomatonStateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapAutomatonStateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapAutomatonStateMap * info = (e_mapAutomatonStateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapAutomatonStateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonStateMap::
operator_isEqual (const GGS_mapAutomatonStateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonStateMap::
operator_isNotEqual (const GGS_mapAutomatonStateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_mapAutomatonStateMap info  ;
    info.mStateIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mStateIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonStateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonStateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonStateMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_mapAutomatonStateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAutomatonStateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAutomatonStateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapAutomatonStateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapAutomatonStateMap::cEnumerator::_mStateIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStateIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapAutomatonStateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapAutomatonStateMap * p = NULL ;
    macroMyNew (p, GGS_mapAutomatonStateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapAutomatonStateMap * p = dynamic_cast <const GGS_mapAutomatonStateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapAutomatonStateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapAutomatonStateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapAutomatonStateMap ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonStateMap GGS_mapAutomatonStateMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonStateMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_mapAutomatonActionMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_mapAutomatonActionMap::e_mapAutomatonActionMap (void) :
mActionIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@mapAutomatonActionMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapAutomatonActionMap ("mapAutomatonActionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_mapAutomatonActionMap::
elementOf_GGS_mapAutomatonActionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_mapAutomatonActionMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapAutomatonActionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mActionIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapAutomatonActionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_mapAutomatonActionMap * ptr = dynamic_cast <const elementOf_GGS_mapAutomatonActionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mActionIndex.operator_isEqual (ptr->mInfo.mActionIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_mapAutomatonActionMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_mapAutomatonActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_mapAutomatonActionMap * info = (e_mapAutomatonActionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_mapAutomatonActionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_mapAutomatonActionMap * info = (e_mapAutomatonActionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_mapAutomatonActionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonActionMap::
operator_isEqual (const GGS_mapAutomatonActionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonActionMap::
operator_isNotEqual (const GGS_mapAutomatonActionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_mapAutomatonActionMap info  ;
    info.mActionIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mActionIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonActionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_mapAutomatonActionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_mapAutomatonActionMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_mapAutomatonActionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapAutomatonActionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAutomatonActionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @mapAutomatonActionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapAutomatonActionMap::cEnumerator::_mActionIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mActionIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapAutomatonActionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapAutomatonActionMap * p = NULL ;
    macroMyNew (p, GGS_mapAutomatonActionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapAutomatonActionMap * p = dynamic_cast <const GGS_mapAutomatonActionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapAutomatonActionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapAutomatonActionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapAutomatonActionMap ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonActionMap GGS_mapAutomatonActionMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonActionMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@mapStateTransitionSortedList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapStateTransitionSortedList::
elementOf_GGS_mapStateTransitionSortedList (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapAutomatonMessageKind& argument_4,
                                const GGS_string& argument_5):
mActionIndex (argument_0),
mActionName (argument_1),
mTargetStateIndex (argument_2),
mTargetStateName (argument_3),
mTransitionMessageKind (argument_4),
mTransitionMessage (argument_5) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapStateTransitionSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapStateTransitionSortedList * ptr = dynamic_cast <const elementOf_GGS_mapStateTransitionSortedList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActionIndex.operator_isEqual (ptr->mActionIndex).boolValue ()
         && mActionName.operator_isEqual (ptr->mActionName).boolValue ()
         && mTargetStateIndex.operator_isEqual (ptr->mTargetStateIndex).boolValue ()
         && mTargetStateName.operator_isEqual (ptr->mTargetStateName).boolValue ()
         && mTransitionMessageKind.operator_isEqual (ptr->mTransitionMessageKind).boolValue ()
         && mTransitionMessage.operator_isEqual (ptr->mTransitionMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_mapStateTransitionSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_mapStateTransitionSortedList * operand = (const elementOf_GGS_mapStateTransitionSortedList *) inOperand ;
  PMSInt32 result = mActionIndex.genericObjectCompare (operand->mActionIndex) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapStateTransitionSortedList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Sorted list '@mapStateTransitionSortedList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapStateTransitionSortedList ("mapStateTransitionSortedList", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList::GGS_mapStateTransitionSortedList (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList::
GGS_mapStateTransitionSortedList (const GGS_mapStateTransitionSortedList & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateTransitionSortedList::
operator_isEqual (const GGS_mapStateTransitionSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateTransitionSortedList::
operator_isNotEqual (const GGS_mapStateTransitionSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_string& argument_3,
                    const GGS_mapAutomatonMessageKind& argument_4,
                    const GGS_string& argument_5) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapAutomatonMessageKind& argument_4,
                                const GGS_string& argument_5) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList GGS_mapStateTransitionSortedList::
operator_concat (const GGS_mapStateTransitionSortedList & inOperand) const {
  GGS_mapStateTransitionSortedList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
dotAssign_operation (const GGS_mapStateTransitionSortedList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapStateTransitionSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mActionIndex ;
          GGS_string p_1 = p->mActionName ;
          GGS_uint  p_2 = p->mTargetStateIndex ;
          GGS_string p_3 = p->mTargetStateName ;
          GGS_mapAutomatonMessageKind p_4 = p->mTransitionMessageKind ;
          GGS_string p_5 = p->mTransitionMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActionIndex,
                                ptr->mActionName,
                                ptr->mTargetStateIndex,
                                ptr->mTargetStateName,
                                ptr->mTransitionMessageKind,
                                ptr->mTransitionMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList  GGS_mapStateTransitionSortedList::
constructor_emptySortedList (void) {
  GGS_mapStateTransitionSortedList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList  GGS_mapStateTransitionSortedList::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_string& argument_3,
                           const GGS_mapAutomatonMessageKind& argument_4,
                           const GGS_string& argument_5) {
  GGS_mapStateTransitionSortedList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapStateTransitionSortedList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapStateTransitionSortedList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
method_smallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_mapAutomatonMessageKind& _out_4,
                 GGS_string& _out_5
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
method_greatest (C_CompilerEx & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_string& _out_3,
             GGS_mapAutomatonMessageKind& _out_4,
             GGS_string& _out_5
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_mapAutomatonMessageKind& _out_4,
                 GGS_string& _out_5
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionSortedList::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_string& _out_3,
                GGS_mapAutomatonMessageKind& _out_4,
                GGS_string& _out_5
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionIndex ;
    _out_1 = ptr->mActionName ;
    _out_2 = ptr->mTargetStateIndex ;
    _out_3 = ptr->mTargetStateName ;
    _out_4 = ptr->mTransitionMessageKind ;
    _out_5 = ptr->mTransitionMessage ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapStateTransitionSortedList::cEnumerator::_mActionIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateTransitionSortedList::cEnumerator::_mActionName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapStateTransitionSortedList::cEnumerator::_mTargetStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateTransitionSortedList::cEnumerator::_mTargetStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_mapStateTransitionSortedList::cEnumerator::_mTransitionMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateTransitionSortedList::cEnumerator::_mTransitionMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapStateTransitionSortedList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapStateTransitionSortedList * p = NULL ;
    macroMyNew (p, GGS_mapStateTransitionSortedList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionSortedList GGS_mapStateTransitionSortedList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapStateTransitionSortedList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapStateTransitionSortedList * p = dynamic_cast <const GGS_mapStateTransitionSortedList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapStateTransitionSortedList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapStateTransitionSortedList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapStateTransitionSortedList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@mapStateSortedList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapStateSortedList::
elementOf_GGS_mapStateSortedList (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapStateTransitionSortedList & argument_4):
mStateIndex (argument_0),
mStateName (argument_1),
mStateMessageKind (argument_2),
mStateMessage (argument_3),
mTransitionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapStateSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapStateSortedList * ptr = dynamic_cast <const elementOf_GGS_mapStateSortedList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStateIndex.operator_isEqual (ptr->mStateIndex).boolValue ()
         && mStateName.operator_isEqual (ptr->mStateName).boolValue ()
         && mStateMessageKind.operator_isEqual (ptr->mStateMessageKind).boolValue ()
         && mStateMessage.operator_isEqual (ptr->mStateMessage).boolValue ()
         && mTransitionList.operator_isEqual (ptr->mTransitionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_mapStateSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_mapStateSortedList * operand = (const elementOf_GGS_mapStateSortedList *) inOperand ;
  PMSInt32 result = mStateIndex.genericObjectCompare (operand->mStateIndex) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapStateSortedList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Sorted list '@mapStateSortedList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapStateSortedList ("mapStateSortedList", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_mapStateSortedList::GGS_mapStateSortedList (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList::
GGS_mapStateSortedList (const GGS_mapStateSortedList & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateSortedList::
operator_isEqual (const GGS_mapStateSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapStateSortedList::
operator_isNotEqual (const GGS_mapStateSortedList & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_mapAutomatonMessageKind& argument_2,
                    const GGS_string& argument_3,
                    const GGS_mapStateTransitionSortedList & argument_4) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_string& argument_3,
                                const GGS_mapStateTransitionSortedList & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList GGS_mapStateSortedList::
operator_concat (const GGS_mapStateSortedList & inOperand) const {
  GGS_mapStateSortedList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
dotAssign_operation (const GGS_mapStateSortedList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapStateSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mStateIndex ;
          GGS_string p_1 = p->mStateName ;
          GGS_mapAutomatonMessageKind p_2 = p->mStateMessageKind ;
          GGS_string p_3 = p->mStateMessage ;
          GGS_mapStateTransitionSortedList  p_4 = p->mTransitionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStateIndex,
                                ptr->mStateName,
                                ptr->mStateMessageKind,
                                ptr->mStateMessage,
                                ptr->mTransitionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList  GGS_mapStateSortedList::
constructor_emptySortedList (void) {
  GGS_mapStateSortedList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList  GGS_mapStateSortedList::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_mapAutomatonMessageKind& argument_2,
                           const GGS_string& argument_3,
                           const GGS_mapStateTransitionSortedList & argument_4) {
  GGS_mapStateSortedList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapStateSortedList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapStateSortedList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
method_smallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_mapAutomatonMessageKind& _out_2,
                 GGS_string& _out_3,
                 GGS_mapStateTransitionSortedList & _out_4
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
method_greatest (C_CompilerEx & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_mapAutomatonMessageKind& _out_2,
             GGS_string& _out_3,
             GGS_mapStateTransitionSortedList & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_mapAutomatonMessageKind& _out_2,
                 GGS_string& _out_3,
                 GGS_mapStateTransitionSortedList & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateSortedList::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_mapAutomatonMessageKind& _out_2,
                GGS_string& _out_3,
                GGS_mapStateTransitionSortedList & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateIndex ;
    _out_1 = ptr->mStateName ;
    _out_2 = ptr->mStateMessageKind ;
    _out_3 = ptr->mStateMessage ;
    _out_4 = ptr->mTransitionList ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_mapStateSortedList::cEnumerator::_mStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateSortedList::cEnumerator::_mStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_mapStateSortedList::cEnumerator::_mStateMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_mapStateSortedList::cEnumerator::_mStateMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapStateTransitionSortedList  & GGS_mapStateSortedList::cEnumerator::_mTransitionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapStateSortedList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapStateSortedList * p = NULL ;
    macroMyNew (p, GGS_mapStateSortedList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList GGS_mapStateSortedList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapStateSortedList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapStateSortedList * p = dynamic_cast <const GGS_mapStateSortedList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapStateSortedList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapStateSortedList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapStateSortedList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@branchBehaviourSortedListForMapOverride'         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_branchBehaviourSortedListForMapOverride::
elementOf_GGS_branchBehaviourSortedListForMapOverride (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_uint & argument_4,
                                const GGS_string& argument_5,
                                const GGS_mapAutomatonMessageKind& argument_6,
                                const GGS_string& argument_7):
mStartStateIndex (argument_0),
mStartStateName (argument_1),
mCurrentStateIndex (argument_2),
mCurrentStateName (argument_3),
mFinalStateIndex (argument_4),
mFinalStateName (argument_5),
mStateMessageKind (argument_6),
mBehaviourMessage (argument_7) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_branchBehaviourSortedListForMapOverride::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_branchBehaviourSortedListForMapOverride * ptr = dynamic_cast <const elementOf_GGS_branchBehaviourSortedListForMapOverride *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartStateIndex.operator_isEqual (ptr->mStartStateIndex).boolValue ()
         && mStartStateName.operator_isEqual (ptr->mStartStateName).boolValue ()
         && mCurrentStateIndex.operator_isEqual (ptr->mCurrentStateIndex).boolValue ()
         && mCurrentStateName.operator_isEqual (ptr->mCurrentStateName).boolValue ()
         && mFinalStateIndex.operator_isEqual (ptr->mFinalStateIndex).boolValue ()
         && mFinalStateName.operator_isEqual (ptr->mFinalStateName).boolValue ()
         && mStateMessageKind.operator_isEqual (ptr->mStateMessageKind).boolValue ()
         && mBehaviourMessage.operator_isEqual (ptr->mBehaviourMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_branchBehaviourSortedListForMapOverride::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_branchBehaviourSortedListForMapOverride * operand = (const elementOf_GGS_branchBehaviourSortedListForMapOverride *) inOperand ;
  PMSInt32 result = mStartStateIndex.genericObjectCompare (operand->mStartStateIndex) ;
  if (result == 0) {
    result = mCurrentStateIndex.genericObjectCompare (operand->mCurrentStateIndex) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_branchBehaviourSortedListForMapOverride::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCurrentStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCurrentStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFinalStateIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFinalStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBehaviourMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Sorted list '@branchBehaviourSortedListForMapOverride'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_branchBehaviourSortedListForMapOverride ("branchBehaviourSortedListForMapOverride", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride::GGS_branchBehaviourSortedListForMapOverride (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride::
GGS_branchBehaviourSortedListForMapOverride (const GGS_branchBehaviourSortedListForMapOverride & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_branchBehaviourSortedListForMapOverride::
operator_isEqual (const GGS_branchBehaviourSortedListForMapOverride & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_branchBehaviourSortedListForMapOverride::
operator_isNotEqual (const GGS_branchBehaviourSortedListForMapOverride & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
internalAppendValues (const GGS_uint & argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_string& argument_3,
                    const GGS_uint & argument_4,
                    const GGS_string& argument_5,
                    const GGS_mapAutomatonMessageKind& argument_6,
                    const GGS_string& argument_7) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
addAssign_operation (const GGS_uint & argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_string& argument_3,
                                const GGS_uint & argument_4,
                                const GGS_string& argument_5,
                                const GGS_mapAutomatonMessageKind& argument_6,
                                const GGS_string& argument_7) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7) ;
  }
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride GGS_branchBehaviourSortedListForMapOverride::
operator_concat (const GGS_branchBehaviourSortedListForMapOverride & inOperand) const {
  GGS_branchBehaviourSortedListForMapOverride result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
dotAssign_operation (const GGS_branchBehaviourSortedListForMapOverride inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_branchBehaviourSortedListForMapOverride * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mStartStateIndex ;
          GGS_string p_1 = p->mStartStateName ;
          GGS_uint  p_2 = p->mCurrentStateIndex ;
          GGS_string p_3 = p->mCurrentStateName ;
          GGS_uint  p_4 = p->mFinalStateIndex ;
          GGS_string p_5 = p->mFinalStateName ;
          GGS_mapAutomatonMessageKind p_6 = p->mStateMessageKind ;
          GGS_string p_7 = p->mBehaviourMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStartStateIndex,
                                ptr->mStartStateName,
                                ptr->mCurrentStateIndex,
                                ptr->mCurrentStateName,
                                ptr->mFinalStateIndex,
                                ptr->mFinalStateName,
                                ptr->mStateMessageKind,
                                ptr->mBehaviourMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_branchBehaviourSortedListForMapOverride::
constructor_emptySortedList (void) {
  GGS_branchBehaviourSortedListForMapOverride result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_branchBehaviourSortedListForMapOverride::
constructor_sortedListWithValue (const GGS_uint & argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_string& argument_3,
                           const GGS_uint & argument_4,
                           const GGS_string& argument_5,
                           const GGS_mapAutomatonMessageKind& argument_6,
                           const GGS_string& argument_7) {
  GGS_branchBehaviourSortedListForMapOverride result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_branchBehaviourSortedListForMapOverride::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@branchBehaviourSortedListForMapOverride", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
method_smallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_uint & _out_4,
                 GGS_string& _out_5,
                 GGS_mapAutomatonMessageKind& _out_6,
                 GGS_string& _out_7
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
method_greatest (C_CompilerEx & inLexique,
             GGS_uint & _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_string& _out_3,
             GGS_uint & _out_4,
             GGS_string& _out_5,
             GGS_mapAutomatonMessageKind& _out_6,
             GGS_string& _out_7
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_uint & _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_string& _out_3,
                 GGS_uint & _out_4,
                 GGS_string& _out_5,
                 GGS_mapAutomatonMessageKind& _out_6,
                 GGS_string& _out_7
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_branchBehaviourSortedListForMapOverride::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_uint & _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_string& _out_3,
                GGS_uint & _out_4,
                GGS_string& _out_5,
                GGS_mapAutomatonMessageKind& _out_6,
                GGS_string& _out_7
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStartStateIndex ;
    _out_1 = ptr->mStartStateName ;
    _out_2 = ptr->mCurrentStateIndex ;
    _out_3 = ptr->mCurrentStateName ;
    _out_4 = ptr->mFinalStateIndex ;
    _out_5 = ptr->mFinalStateName ;
    _out_6 = ptr->mStateMessageKind ;
    _out_7 = ptr->mBehaviourMessage ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
    _out_7.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mStartStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStartStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mStartStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStartStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mCurrentStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCurrentStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mCurrentStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCurrentStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mFinalStateIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFinalStateIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mFinalStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFinalStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mStateMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_branchBehaviourSortedListForMapOverride::cEnumerator::_mBehaviourMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBehaviourMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_branchBehaviourSortedListForMapOverride::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_branchBehaviourSortedListForMapOverride * p = NULL ;
    macroMyNew (p, GGS_branchBehaviourSortedListForMapOverride (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride GGS_branchBehaviourSortedListForMapOverride::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_branchBehaviourSortedListForMapOverride result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_branchBehaviourSortedListForMapOverride * p = dynamic_cast <const GGS_branchBehaviourSortedListForMapOverride *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_branchBehaviourSortedListForMapOverride, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_branchBehaviourSortedListForMapOverride::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_branchBehaviourSortedListForMapOverride ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@mapOverrideList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapOverrideList::
elementOf_GGS_mapOverrideList (const GGS_lstring & argument_0,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mOverrideName (argument_0),
mBranchBehaviourSortedListForMapOverride (argument_1),
mBranchCombinationSortedListForMapOverride (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapOverrideList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapOverrideList * ptr = dynamic_cast <const elementOf_GGS_mapOverrideList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverrideName.operator_isEqual (ptr->mOverrideName).boolValue ()
         && mBranchBehaviourSortedListForMapOverride.operator_isEqual (ptr->mBranchBehaviourSortedListForMapOverride).boolValue ()
         && mBranchCombinationSortedListForMapOverride.operator_isEqual (ptr->mBranchCombinationSortedListForMapOverride).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapOverrideList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverrideName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBranchBehaviourSortedListForMapOverride.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBranchCombinationSortedListForMapOverride.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@mapOverrideList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapOverrideList ("mapOverrideList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                    const GGS_branchBehaviourSortedListForMapOverride & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::
operator_concat (const GGS_mapOverrideList & inOperand) const {
  GGS_mapOverrideList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
dotAssign_operation (const GGS_mapOverrideList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapOverrideList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverrideName ;
          GGS_branchBehaviourSortedListForMapOverride  p_1 = p->mBranchBehaviourSortedListForMapOverride ;
          GGS_branchBehaviourSortedListForMapOverride  p_2 = p->mBranchCombinationSortedListForMapOverride ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                     const GGS_branchBehaviourSortedListForMapOverride & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverrideName,
                                ptr->mBranchBehaviourSortedListForMapOverride,
                                ptr->mBranchCombinationSortedListForMapOverride
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList  GGS_mapOverrideList::
constructor_emptyList (void) {
  GGS_mapOverrideList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList  GGS_mapOverrideList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_1,
                                const GGS_branchBehaviourSortedListForMapOverride & argument_2) {
  GGS_mapOverrideList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
internalSubListWithRange (GGS_mapOverrideList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverrideName, ptr->mBranchBehaviourSortedListForMapOverride, ptr->mBranchCombinationSortedListForMapOverride) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapOverrideList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapOverrideList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapOverrideList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapOverrideList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_branchBehaviourSortedListForMapOverride & _out_1,
              GGS_branchBehaviourSortedListForMapOverride & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_branchBehaviourSortedListForMapOverride & _out_1,
             GGS_branchBehaviourSortedListForMapOverride & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_branchBehaviourSortedListForMapOverride & _out_1,
                 GGS_branchBehaviourSortedListForMapOverride & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_branchBehaviourSortedListForMapOverride & _out_1,
                GGS_branchBehaviourSortedListForMapOverride & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverrideName ;
    _out_1 = ptr->mBranchBehaviourSortedListForMapOverride ;
    _out_2 = ptr->mBranchCombinationSortedListForMapOverride ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapOverrideList::
reader_mOverrideNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverrideName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_mapOverrideList::
reader_mBranchBehaviourSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_branchBehaviourSortedListForMapOverride  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBranchBehaviourSortedListForMapOverride ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_branchBehaviourSortedListForMapOverride  GGS_mapOverrideList::
reader_mBranchCombinationSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_branchBehaviourSortedListForMapOverride  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mBranchCombinationSortedListForMapOverride ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_setMOverrideNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverrideName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_setMBranchBehaviourSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique,
                              const GGS_branchBehaviourSortedListForMapOverride  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBranchBehaviourSortedListForMapOverride = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapOverrideList::
modifier_setMBranchCombinationSortedListForMapOverrideAtIndex (C_CompilerEx & inLexique,
                              const GGS_branchBehaviourSortedListForMapOverride  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mBranchCombinationSortedListForMapOverride = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapOverrideList::cEnumerator::_mOverrideName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverrideName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_branchBehaviourSortedListForMapOverride  & GGS_mapOverrideList::cEnumerator::_mBranchBehaviourSortedListForMapOverride (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBranchBehaviourSortedListForMapOverride ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_branchBehaviourSortedListForMapOverride  & GGS_mapOverrideList::cEnumerator::_mBranchCombinationSortedListForMapOverride (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mBranchCombinationSortedListForMapOverride ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapOverrideList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapOverrideList * p = NULL ;
    macroMyNew (p, GGS_mapOverrideList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList GGS_mapOverrideList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapOverrideList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapOverrideList * p = dynamic_cast <const GGS_mapOverrideList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapOverrideList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapOverrideList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapOverrideList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_C_mapToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::
cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeSemanticAttributesMap & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_mapStateSortedList & argument_7,
                                const GGS_uint & argument_8,
                                const GGS_mapOverrideList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapTypeName (argument_0),
mNonExternAttributesList (argument_1),
mAttributeMap (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
mRemoveMethodList (argument_5),
mHasInsertOrReplaceModifier (argument_6),
mMapStateSortedList (argument_7),
mActionCount (argument_8),
mMapOverrideList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_mapToImplement) ;
    return (cPtr_C_mapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapToImplement * ptr = dynamic_cast <const cPtr_C_mapToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mNonExternAttributesList.operator_isEqual (ptr->mNonExternAttributesList).boolValue ()
         && mAttributeMap.operator_isEqual (ptr->mAttributeMap).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue ()
         && mHasInsertOrReplaceModifier.operator_isEqual (ptr->mHasInsertOrReplaceModifier).boolValue ()
         && mMapStateSortedList.operator_isEqual (ptr->mMapStateSortedList).boolValue ()
         && mActionCount.operator_isEqual (ptr->mActionCount).boolValue ()
         && mMapOverrideList.operator_isEqual (ptr->mMapOverrideList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_mapToImplement:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mNonExternAttributesList.reader_description (inIndentation + 1)
           << mAttributeMap.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << mRemoveMethodList.reader_description (inIndentation + 1)
           << mHasInsertOrReplaceModifier.reader_description (inIndentation + 1)
           << mMapStateSortedList.reader_description (inIndentation + 1)
           << mActionCount.reader_description (inIndentation + 1)
           << mMapOverrideList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_mapToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_mapToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_mapToImplement (& typeid (cPtr_C_mapToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_mapToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_mapToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_mapToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_mapToImplement (mMapTypeName, mNonExternAttributesList, mAttributeMap, mInsertMethodList, mSearchMethodList, mRemoveMethodList, mHasInsertOrReplaceModifier, mMapStateSortedList, mActionCount, mMapOverrideList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_mapToImplement ("C_mapToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_mapToImplement GGS_C_mapToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_mapToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_mapToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_mapToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_mapToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement GGS_C_mapToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_typeSemanticAttributesMap & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_insertOrSearchMethodList & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_mapStateSortedList & argument_7,
                 const GGS_uint & argument_8,
                 const GGS_mapOverrideList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_mapToImplement::
reader_mHasInsertOrReplaceModifier (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mHasInsertOrReplaceModifier ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateSortedList  GGS_C_mapToImplement::
reader_mMapStateSortedList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapStateSortedList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mMapStateSortedList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_mapToImplement::
reader_mActionCount (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mActionCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapOverrideList  GGS_C_mapToImplement::
reader_mMapOverrideList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapOverrideList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mMapOverrideList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_mapToImplement::actualTypeName (void) const {
  return "C_mapToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_mapToImplement ("C_mapToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_mapToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_mapToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_mapToImplement * p = NULL ;
    macroMyNew (p, GGS_C_mapToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement GGS_C_mapToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_mapToImplement * p = dynamic_cast <const GGS_C_mapToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_mapToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_mapToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_mapToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_classToImplement'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_classToImplement::
cPtr_C_classToImplement (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_string& argument_8,
                                const GGS_bool& argument_9,
                                const GGS_L_lazyAttributeList & argument_10,
                                const GGS_typeListeAttributsSemantiques & argument_11,
                                const GGS_typeListeAttributsSemantiques & argument_12
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
mIsAbstract (argument_1),
aListeTousAttributsNonExternes (argument_2),
aTableToutesMethodes (argument_3),
mMethodsMap (argument_4),
aListeAttributsCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7),
mClassMessage (argument_8),
mHasGeneratedInSeparateFileSetting (argument_9),
mLazyAttributeList (argument_10),
mSetterAttributeModifierToImplementList (argument_11),
mGetterAttributeReaderToImplementList (argument_12) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_classToImplement * GGS_C_classToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_classToImplement) ;
    return (cPtr_C_classToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_classToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_classToImplement * ptr = dynamic_cast <const cPtr_C_classToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomClasse.operator_isEqual (ptr->aNomClasse).boolValue ()
         && mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && aListeTousAttributsNonExternes.operator_isEqual (ptr->aListeTousAttributsNonExternes).boolValue ()
         && aTableToutesMethodes.operator_isEqual (ptr->aTableToutesMethodes).boolValue ()
         && mMethodsMap.operator_isEqual (ptr->mMethodsMap).boolValue ()
         && aListeAttributsCourants.operator_isEqual (ptr->aListeAttributsCourants).boolValue ()
         && mAncestorClassesMap.operator_isEqual (ptr->mAncestorClassesMap).boolValue ()
         && mMessagesMap.operator_isEqual (ptr->mMessagesMap).boolValue ()
         && mClassMessage.operator_isEqual (ptr->mClassMessage).boolValue ()
         && mHasGeneratedInSeparateFileSetting.operator_isEqual (ptr->mHasGeneratedInSeparateFileSetting).boolValue ()
         && mLazyAttributeList.operator_isEqual (ptr->mLazyAttributeList).boolValue ()
         && mSetterAttributeModifierToImplementList.operator_isEqual (ptr->mSetterAttributeModifierToImplementList).boolValue ()
         && mGetterAttributeReaderToImplementList.operator_isEqual (ptr->mGetterAttributeReaderToImplementList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_classToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_classToImplement:"
           << aNomClasse.reader_description (inIndentation + 1)
           << mIsAbstract.reader_description (inIndentation + 1)
           << aListeTousAttributsNonExternes.reader_description (inIndentation + 1)
           << aTableToutesMethodes.reader_description (inIndentation + 1)
           << mMethodsMap.reader_description (inIndentation + 1)
           << aListeAttributsCourants.reader_description (inIndentation + 1)
           << mAncestorClassesMap.reader_description (inIndentation + 1)
           << mMessagesMap.reader_description (inIndentation + 1)
           << mClassMessage.reader_description (inIndentation + 1)
           << mHasGeneratedInSeparateFileSetting.reader_description (inIndentation + 1)
           << mLazyAttributeList.reader_description (inIndentation + 1)
           << mSetterAttributeModifierToImplementList.reader_description (inIndentation + 1)
           << mGetterAttributeReaderToImplementList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_classToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_classToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_classToImplement (& typeid (cPtr_C_classToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_classToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_classToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_classToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_classToImplement (aNomClasse, mIsAbstract, aListeTousAttributsNonExternes, aTableToutesMethodes, mMethodsMap, aListeAttributsCourants, mAncestorClassesMap, mMessagesMap, mClassMessage, mHasGeneratedInSeparateFileSetting, mLazyAttributeList, mSetterAttributeModifierToImplementList, mGetterAttributeReaderToImplementList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_classToImplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_classToImplement ("C_classToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_classToImplement GGS_C_classToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_classToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_classToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_classToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_classToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement GGS_C_classToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_typeTableMethodesAimplementer & argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5,
                 const GGS_typeSuperClassesMap & argument_6,
                 const GGS_typeClassMessagesMap & argument_7,
                 const GGS_string& argument_8,
                 const GGS_bool& argument_9,
                 const GGS_L_lazyAttributeList & argument_10,
                 const GGS_typeListeAttributsSemantiques & argument_11,
                 const GGS_typeListeAttributsSemantiques & argument_12
                                COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_classToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_classToImplement::actualTypeName (void) const {
  return "C_classToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_classToImplement ("C_classToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_classToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_classToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_classToImplement * p = NULL ;
    macroMyNew (p, GGS_C_classToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement GGS_C_classToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_classToImplement * p = dynamic_cast <const GGS_C_classToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_classToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_classToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_classToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_mapindexToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapindexToImplement::
cPtr_C_mapindexToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_EXmapMethodMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapindexTypeName (argument_0),
mMapTypeName (argument_1),
mMapAttributesList (argument_2),
mMapReaderMethodMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapindexToImplement * GGS_C_mapindexToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_mapindexToImplement) ;
    return (cPtr_C_mapindexToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapindexToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapindexToImplement * ptr = dynamic_cast <const cPtr_C_mapindexToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapindexTypeName.operator_isEqual (ptr->mMapindexTypeName).boolValue ()
         && mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mMapAttributesList.operator_isEqual (ptr->mMapAttributesList).boolValue ()
         && mMapReaderMethodMap.operator_isEqual (ptr->mMapReaderMethodMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapindexToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_mapindexToImplement:"
           << mMapindexTypeName.reader_description (inIndentation + 1)
           << mMapTypeName.reader_description (inIndentation + 1)
           << mMapAttributesList.reader_description (inIndentation + 1)
           << mMapReaderMethodMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_mapindexToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_mapindexToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_mapindexToImplement (& typeid (cPtr_C_mapindexToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_mapindexToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_mapindexToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_mapindexToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_mapindexToImplement (mMapindexTypeName, mMapTypeName, mMapAttributesList, mMapReaderMethodMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_mapindexToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_mapindexToImplement ("C_mapindexToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_mapindexToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_mapindexToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_mapindexToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_mapindexToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_EXmapMethodMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapindexToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_mapindexToImplement::actualTypeName (void) const {
  return "C_mapindexToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_mapindexToImplement ("C_mapindexToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_mapindexToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_mapindexToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_mapindexToImplement * p = NULL ;
    macroMyNew (p, GGS_C_mapindexToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement GGS_C_mapindexToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_mapindexToImplement * p = dynamic_cast <const GGS_C_mapindexToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_mapindexToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_mapindexToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_mapindexToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_domainToImplement'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_domainToImplement::
cPtr_C_domainToImplement (const GGS_lstring & argument_0,
                                const GGS_domainAttributeMap & argument_1,
                                const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mDomainName (argument_0),
mAttributeMap (argument_1),
mRelationMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_domainToImplement * GGS_C_domainToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_domainToImplement) ;
    return (cPtr_C_domainToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_domainToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_domainToImplement * ptr = dynamic_cast <const cPtr_C_domainToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDomainName.operator_isEqual (ptr->mDomainName).boolValue ()
         && mAttributeMap.operator_isEqual (ptr->mAttributeMap).boolValue ()
         && mRelationMap.operator_isEqual (ptr->mRelationMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_domainToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_domainToImplement:"
           << mDomainName.reader_description (inIndentation + 1)
           << mAttributeMap.reader_description (inIndentation + 1)
           << mRelationMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_domainToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_domainToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_domainToImplement (& typeid (cPtr_C_domainToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_domainToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_domainToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_domainToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_domainToImplement (mDomainName, mAttributeMap, mRelationMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_domainToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_domainToImplement ("C_domainToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_domainToImplement GGS_C_domainToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_domainToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_domainToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_domainToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_domainToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement GGS_C_domainToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_domainAttributeMap & argument_1,
                 const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_domainToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_domainToImplement::actualTypeName (void) const {
  return "C_domainToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_domainToImplement ("C_domainToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_domainToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_domainToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_domainToImplement * p = NULL ;
    macroMyNew (p, GGS_C_domainToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement GGS_C_domainToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_domainToImplement * p = dynamic_cast <const GGS_C_domainToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_domainToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_domainToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_domainToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeEntiteRoutineExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteRoutineExterne::
cPtr_typeEntiteRoutineExterne (const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteRoutineExterne * GGS_typeEntiteRoutineExterne::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEntiteRoutineExterne) ;
    return (cPtr_typeEntiteRoutineExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteRoutineExterne::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteRoutineExterne * ptr = dynamic_cast <const cPtr_typeEntiteRoutineExterne *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aSignature.operator_isEqual (ptr->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteRoutineExterne::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEntiteRoutineExterne:"
           << aSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
static_string_message_messageTypeEntite (void) {
  return "an extern routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
message_messageTypeEntite (void) const {
  return "an extern routine" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
instanceMessage (void) const {
  return "an extern routine" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteRoutineExterne::
_static_message (void) {
  return "an extern routine" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteRoutineExterne (& typeid (cPtr_typeEntiteRoutineExterne), & typeid (cPtr_AC_semanticsEntity), "an extern routine") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntiteRoutineExterne::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteRoutineExterne ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteRoutineExterne::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteRoutineExterne (aSignature COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeEntiteRoutineExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntiteRoutineExterne ("typeEntiteRoutineExterne", true, & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne::
GGS_typeEntiteRoutineExterne (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne::
GGS_typeEntiteRoutineExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteRoutineExterne GGS_typeEntiteRoutineExterne::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutineExterne result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteRoutineExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteRoutineExterne) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteRoutineExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteRoutineExterne),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne GGS_typeEntiteRoutineExterne::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutineExterne result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteRoutineExterne (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteRoutineExterne::
reader_messageTypeEntite (C_CompilerEx & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeEntiteRoutineExterne) ;
    cPtr_typeEntiteRoutineExterne * p = (cPtr_typeEntiteRoutineExterne *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteRoutineExterne::
reader_aSignature (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteRoutineExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteRoutineExterne *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteRoutineExterne::actualTypeName (void) const {
  return "typeEntiteRoutineExterne" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEntiteRoutineExterne ("typeEntiteRoutineExterne", gClassInfoFor__AC_semanticsEntity, & kTypeDescriptor_GGS_typeEntiteRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntiteRoutineExterne::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntiteRoutineExterne * p = NULL ;
    macroMyNew (p, GGS_typeEntiteRoutineExterne (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteRoutineExterne GGS_typeEntiteRoutineExterne::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntiteRoutineExterne result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntiteRoutineExterne * p = dynamic_cast <const GGS_typeEntiteRoutineExterne *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntiteRoutineExterne, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntiteRoutineExterne::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntiteRoutineExterne ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeEntiteFonctionExterne'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteFonctionExterne::
cPtr_typeEntiteFonctionExterne (const GGS_L_EXsignature & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0),
mReturnedType (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteFonctionExterne * GGS_typeEntiteFonctionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEntiteFonctionExterne) ;
    return (cPtr_typeEntiteFonctionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteFonctionExterne::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteFonctionExterne * ptr = dynamic_cast <const cPtr_typeEntiteFonctionExterne *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aSignature.operator_isEqual (ptr->aSignature).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteFonctionExterne::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEntiteFonctionExterne:"
           << aSignature.reader_description (inIndentation + 1)
           << mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
static_string_message_messageTypeEntite (void) {
  return "an extern function" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
message_messageTypeEntite (void) const {
  return "an extern function" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
instanceMessage (void) const {
  return "an extern function" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteFonctionExterne::
_static_message (void) {
  return "an extern function" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEntiteFonctionExterne (& typeid (cPtr_typeEntiteFonctionExterne), & typeid (cPtr_AC_semanticsEntity), "an extern function") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEntiteFonctionExterne::galgasRTTI (void) const {
  return & gClassInfoFor__typeEntiteFonctionExterne ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEntiteFonctionExterne::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEntiteFonctionExterne (aSignature, mReturnedType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeEntiteFonctionExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntiteFonctionExterne ("typeEntiteFonctionExterne", true, & kTypeDescriptor_GGS_AC_semanticsEntity) ;

//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne::
GGS_typeEntiteFonctionExterne (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne::
GGS_typeEntiteFonctionExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEntiteFonctionExterne GGS_typeEntiteFonctionExterne::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonctionExterne result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeEntiteFonctionExterne) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEntiteFonctionExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEntiteFonctionExterne),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne GGS_typeEntiteFonctionExterne::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_L_EXsignature & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonctionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteFonctionExterne (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteFonctionExterne::
reader_messageTypeEntite (C_CompilerEx & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeEntiteFonctionExterne) ;
    cPtr_typeEntiteFonctionExterne * p = (cPtr_typeEntiteFonctionExterne *) mPointer ;
    result = GGS_string (true, p->message_messageTypeEntite ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteFonctionExterne::
reader_aSignature (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteFonctionExterne *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteFonctionExterne::
reader_mReturnedType (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteFonctionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteFonctionExterne *) mPointer)->mReturnedType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEntiteFonctionExterne::actualTypeName (void) const {
  return "typeEntiteFonctionExterne" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEntiteFonctionExterne ("typeEntiteFonctionExterne", gClassInfoFor__AC_semanticsEntity, & kTypeDescriptor_GGS_typeEntiteFonctionExterne) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntiteFonctionExterne::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntiteFonctionExterne * p = NULL ;
    macroMyNew (p, GGS_typeEntiteFonctionExterne (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteFonctionExterne GGS_typeEntiteFonctionExterne::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntiteFonctionExterne result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntiteFonctionExterne * p = dynamic_cast <const GGS_typeEntiteFonctionExterne *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntiteFonctionExterne, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntiteFonctionExterne::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntiteFonctionExterne ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeRoutineExterneAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineExterneAengendrer::
cPtr_typeRoutineExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineExterneAengendrer * GGS_typeRoutineExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeRoutineExterneAengendrer) ;
    return (cPtr_typeRoutineExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineExterneAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineExterneAengendrer * ptr = dynamic_cast <const cPtr_typeRoutineExterneAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomAction.operator_isEqual (ptr->aNomAction).boolValue ()
         && aSignature.operator_isEqual (ptr->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineExterneAengendrer::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeRoutineExterneAengendrer:"
           << aNomAction.reader_description (inIndentation + 1)
           << aSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineExterneAengendrer::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRoutineExterneAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRoutineExterneAengendrer (& typeid (cPtr_typeRoutineExterneAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeRoutineExterneAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeRoutineExterneAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRoutineExterneAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRoutineExterneAengendrer (aNomAction, aSignature COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeRoutineExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeRoutineExterneAengendrer ("typeRoutineExterneAengendrer", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer::
GGS_typeRoutineExterneAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer::
GGS_typeRoutineExterneAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRoutineExterneAengendrer GGS_typeRoutineExterneAengendrer::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRoutineExterneAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRoutineExterneAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeRoutineExterneAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRoutineExterneAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRoutineExterneAengendrer),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer GGS_typeRoutineExterneAengendrer::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineExterneAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRoutineExterneAengendrer::actualTypeName (void) const {
  return "typeRoutineExterneAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeRoutineExterneAengendrer ("typeRoutineExterneAengendrer", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeRoutineExterneAengendrer) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeRoutineExterneAengendrer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeRoutineExterneAengendrer * p = NULL ;
    macroMyNew (p, GGS_typeRoutineExterneAengendrer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineExterneAengendrer GGS_typeRoutineExterneAengendrer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeRoutineExterneAengendrer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeRoutineExterneAengendrer * p = dynamic_cast <const GGS_typeRoutineExterneAengendrer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeRoutineExterneAengendrer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeRoutineExterneAengendrer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeRoutineExterneAengendrer ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeFonctionExterneAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFonctionExterneAengendrer::
cPtr_typeFonctionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1,
                                const GGS_AC_galgasType & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1),
mReturnedType (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFonctionExterneAengendrer * GGS_typeFonctionExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFonctionExterneAengendrer) ;
    return (cPtr_typeFonctionExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFonctionExterneAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFonctionExterneAengendrer * ptr = dynamic_cast <const cPtr_typeFonctionExterneAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomAction.operator_isEqual (ptr->aNomAction).boolValue ()
         && aSignature.operator_isEqual (ptr->aSignature).boolValue ()
         && mReturnedType.operator_isEqual (ptr->mReturnedType).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFonctionExterneAengendrer::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFonctionExterneAengendrer:"
           << aNomAction.reader_description (inIndentation + 1)
           << aSignature.reader_description (inIndentation + 1)
           << mReturnedType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionExterneAengendrer::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFonctionExterneAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFonctionExterneAengendrer (& typeid (cPtr_typeFonctionExterneAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFonctionExterneAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeFonctionExterneAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFonctionExterneAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFonctionExterneAengendrer (aNomAction, aSignature, mReturnedType COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFonctionExterneAengendrer'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFonctionExterneAengendrer ("typeFonctionExterneAengendrer", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer::
GGS_typeFonctionExterneAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer::
GGS_typeFonctionExterneAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFonctionExterneAengendrer GGS_typeFonctionExterneAengendrer::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFonctionExterneAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFonctionExterneAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeFonctionExterneAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFonctionExterneAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFonctionExterneAengendrer),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer GGS_typeFonctionExterneAengendrer::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1,
                 const GGS_AC_galgasType & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFonctionExterneAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeFonctionExterneAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFonctionExterneAengendrer::actualTypeName (void) const {
  return "typeFonctionExterneAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFonctionExterneAengendrer ("typeFonctionExterneAengendrer", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeFonctionExterneAengendrer) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFonctionExterneAengendrer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFonctionExterneAengendrer * p = NULL ;
    macroMyNew (p, GGS_typeFonctionExterneAengendrer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFonctionExterneAengendrer GGS_typeFonctionExterneAengendrer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFonctionExterneAengendrer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFonctionExterneAengendrer * p = dynamic_cast <const GGS_typeFonctionExterneAengendrer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFonctionExterneAengendrer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFonctionExterneAengendrer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFonctionExterneAengendrer ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEntityToGenerate (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEntitiesToGenerateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeEntitiesToGenerateList * ptr = dynamic_cast <const elementOf_GGS_typeEntitiesToGenerateList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntityToGenerate.operator_isEqual (ptr->mEntityToGenerate).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityToGenerate.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEntitiesToGenerateList ("typeEntitiesToGenerateList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalAppendValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalPrependValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
operator_concat (const GGS_typeEntitiesToGenerateList & inOperand) const {
  GGS_typeEntitiesToGenerateList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
dotAssign_operation (const GGS_typeEntitiesToGenerateList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeEntitiesToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeEntityToGenerate  p_0 = p->mEntityToGenerate ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeEntityToGenerate & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEntityToGenerate
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_emptyList (void) {
  GGS_typeEntitiesToGenerateList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_listWithValue (const GGS_typeEntityToGenerate & argument_0) {
  GGS_typeEntitiesToGenerateList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalSubListWithRange (GGS_typeEntitiesToGenerateList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntityToGenerate) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeEntitiesToGenerateList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeEntitiesToGenerateList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeEntitiesToGenerateList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_first (C_CompilerEx & inLexique,
              GGS_typeEntityToGenerate & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_last (C_CompilerEx & inLexique,
             GGS_typeEntityToGenerate & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeEntityToGenerate & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeEntityToGenerate & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntityToGenerate ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate  GGS_typeEntitiesToGenerateList::
reader_mEntityToGenerateAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeEntityToGenerate  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntityToGenerate ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_setMEntityToGenerateAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeEntityToGenerate  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntityToGenerate = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeEntityToGenerate  & GGS_typeEntitiesToGenerateList::cEnumerator::_mEntityToGenerate (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntityToGenerate ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeEntitiesToGenerateList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEntitiesToGenerateList * p = NULL ;
    macroMyNew (p, GGS_typeEntitiesToGenerateList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEntitiesToGenerateList * p = dynamic_cast <const GGS_typeEntitiesToGenerateList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEntitiesToGenerateList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEntitiesToGenerateList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEntitiesToGenerateList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeGalgasListmapToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeGalgasListmapToImplement::
cPtr_typeGalgasListmapToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mListmapTypeName (argument_0),
mListTypename (argument_1),
mAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeGalgasListmapToImplement * GGS_typeGalgasListmapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeGalgasListmapToImplement) ;
    return (cPtr_typeGalgasListmapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeGalgasListmapToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeGalgasListmapToImplement * ptr = dynamic_cast <const cPtr_typeGalgasListmapToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mListTypename.operator_isEqual (ptr->mListTypename).boolValue ()
         && mAttributesList.operator_isEqual (ptr->mAttributesList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeGalgasListmapToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeGalgasListmapToImplement:"
           << mListmapTypeName.reader_description (inIndentation + 1)
           << mListTypename.reader_description (inIndentation + 1)
           << mAttributesList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeGalgasListmapToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeGalgasListmapToImplement (& typeid (cPtr_typeGalgasListmapToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeGalgasListmapToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__typeGalgasListmapToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeGalgasListmapToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeGalgasListmapToImplement (mListmapTypeName, mListTypename, mAttributesList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeGalgasListmapToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeGalgasListmapToImplement ("typeGalgasListmapToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement::
GGS_typeGalgasListmapToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement::
GGS_typeGalgasListmapToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeGalgasListmapToImplement GGS_typeGalgasListmapToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeGalgasListmapToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_typeGalgasListmapToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeGalgasListmapToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeGalgasListmapToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement GGS_typeGalgasListmapToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapToImplement result ;
  macroMyNew (result.mPointer, cPtr_typeGalgasListmapToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeGalgasListmapToImplement::actualTypeName (void) const {
  return "typeGalgasListmapToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeGalgasListmapToImplement ("typeGalgasListmapToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeGalgasListmapToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeGalgasListmapToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeGalgasListmapToImplement * p = NULL ;
    macroMyNew (p, GGS_typeGalgasListmapToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeGalgasListmapToImplement GGS_typeGalgasListmapToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeGalgasListmapToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeGalgasListmapToImplement * p = dynamic_cast <const GGS_typeGalgasListmapToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeGalgasListmapToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeGalgasListmapToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeGalgasListmapToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_typeEnumCstMessageStringMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeEnumCstMessageStringMap::e_typeEnumCstMessageStringMap (void) :
mMessageString () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@typeEnumCstMessageStringMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEnumCstMessageStringMap ("typeEnumCstMessageStringMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMessageString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumCstMessageStringMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumCstMessageStringMap * ptr = dynamic_cast <const elementOf_GGS_typeEnumCstMessageStringMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMessageString.operator_isEqual (ptr->mInfo.mMessageString)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeEnumCstMessageStringMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
operator_isEqual (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
operator_isNotEqual (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeEnumCstMessageStringMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeEnumCstMessageStringMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeEnumCstMessageStringMap::cEnumerator::_mMessageString (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMessageString ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeEnumCstMessageStringMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEnumCstMessageStringMap * p = NULL ;
    macroMyNew (p, GGS_typeEnumCstMessageStringMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEnumCstMessageStringMap * p = dynamic_cast <const GGS_typeEnumCstMessageStringMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEnumCstMessageStringMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEnumCstMessageStringMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEnumCstMessageStringMap ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_enumGalgasType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::
cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumGalgasType) ;
    return (cPtr_enumGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumGalgasType::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumGalgasType * ptr = dynamic_cast <const cPtr_enumGalgasType *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mConstantMap.operator_isEqual (ptr->mConstantMap).boolValue ()
         && mEnumMessageMap.operator_isEqual (ptr->mEnumMessageMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumGalgasType:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mConstantMap.reader_description (inIndentation + 1)
           << mEnumMessageMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumGalgasType::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumGalgasType::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumGalgasType (& typeid (cPtr_enumGalgasType), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumGalgasType::galgasRTTI (void) const {
  return & gClassInfoFor__enumGalgasType ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumGalgasType::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumGalgasType (mEnumTypeName, mConstantMap, mEnumMessageMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumGalgasType ("enumGalgasType", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumGalgasType GGS_enumGalgasType::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumGalgasType *> (inPointer) != NULL)
      : (typeid (cPtr_enumGalgasType) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumGalgasType (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumGalgasType),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType GGS_enumGalgasType::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  macroMyNew (result.mPointer, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumGalgasType::actualTypeName (void) const {
  return "enumGalgasType" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumGalgasType ("enumGalgasType", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_enumGalgasType) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumGalgasType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumGalgasType * p = NULL ;
    macroMyNew (p, GGS_enumGalgasType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType GGS_enumGalgasType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumGalgasType * p = dynamic_cast <const GGS_enumGalgasType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumGalgasType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumGalgasType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumGalgasType ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@ruleDescriptorForProgramList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ruleDescriptorForProgramList::
elementOf_GGS_ruleDescriptorForProgramList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSourceExtension (argument_0),
mHelpMessage (argument_1),
mSourceFileName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ruleDescriptorForProgramList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ruleDescriptorForProgramList * ptr = dynamic_cast <const elementOf_GGS_ruleDescriptorForProgramList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSourceExtension.operator_isEqual (ptr->mSourceExtension).boolValue ()
         && mHelpMessage.operator_isEqual (ptr->mHelpMessage).boolValue ()
         && mSourceFileName.operator_isEqual (ptr->mSourceFileName).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ruleDescriptorForProgramList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExtension.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHelpMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceFileName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@ruleDescriptorForProgramList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ruleDescriptorForProgramList ("ruleDescriptorForProgramList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
operator_concat (const GGS_ruleDescriptorForProgramList & inOperand) const {
  GGS_ruleDescriptorForProgramList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
dotAssign_operation (const GGS_ruleDescriptorForProgramList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_ruleDescriptorForProgramList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceExtension ;
          GGS_string p_1 = p->mHelpMessage ;
          GGS_lstring  p_2 = p->mSourceFileName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSourceExtension,
                                ptr->mHelpMessage,
                                ptr->mSourceFileName,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_emptyList (void) {
  GGS_ruleDescriptorForProgramList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  GGS_ruleDescriptorForProgramList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
internalSubListWithRange (GGS_ruleDescriptorForProgramList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSourceExtension, ptr->mHelpMessage, ptr->mSourceFileName, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ruleDescriptorForProgramList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ruleDescriptorForProgramList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@ruleDescriptorForProgramList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_first (C_CompilerEx & inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_lstring & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_last (C_CompilerEx & inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_lstring & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_lstring & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_lstring & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSourceExtension ;
    _out_1 = ptr->mHelpMessage ;
    _out_2 = ptr->mSourceFileName ;
    _out_3 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ruleDescriptorForProgramList::
reader_mSourceExtensionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceExtension ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_mHelpMessageAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHelpMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_ruleDescriptorForProgramList::
reader_mSourceFileNameAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSourceFileName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_ruleDescriptorForProgramList::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMSourceExtensionAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceExtension = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMHelpMessageAtIndex (C_CompilerEx & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHelpMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMSourceFileNameAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSourceFileName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ruleDescriptorForProgramList::cEnumerator::_mSourceExtension (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceExtension ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_ruleDescriptorForProgramList::cEnumerator::_mHelpMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mHelpMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_ruleDescriptorForProgramList::cEnumerator::_mSourceFileName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSourceFileName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_ruleDescriptorForProgramList::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ruleDescriptorForProgramList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ruleDescriptorForProgramList * p = NULL ;
    macroMyNew (p, GGS_ruleDescriptorForProgramList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ruleDescriptorForProgramList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ruleDescriptorForProgramList * p = dynamic_cast <const GGS_ruleDescriptorForProgramList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ruleDescriptorForProgramList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ruleDescriptorForProgramList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ruleDescriptorForProgramList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@wrapperFileSortedListEX'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperFileSortedListEX::
elementOf_GGS_wrapperFileSortedListEX (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3):
mRegularFileName (argument_0),
mAbsoluteFilePath (argument_1),
mWrapperDirectoryIndex (argument_2),
mWrapperFileIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperFileSortedListEX::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_wrapperFileSortedListEX * ptr = dynamic_cast <const elementOf_GGS_wrapperFileSortedListEX *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRegularFileName.operator_isEqual (ptr->mRegularFileName).boolValue ()
         && mAbsoluteFilePath.operator_isEqual (ptr->mAbsoluteFilePath).boolValue ()
         && mWrapperDirectoryIndex.operator_isEqual (ptr->mWrapperDirectoryIndex).boolValue ()
         && mWrapperFileIndex.operator_isEqual (ptr->mWrapperFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_wrapperFileSortedListEX::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_wrapperFileSortedListEX * operand = (const elementOf_GGS_wrapperFileSortedListEX *) inOperand ;
  PMSInt32 result = mRegularFileName.genericObjectCompare (operand->mRegularFileName) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperFileSortedListEX::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRegularFileName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbsoluteFilePath.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperDirectoryIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperFileIndex.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Sorted list '@wrapperFileSortedListEX'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_wrapperFileSortedListEX ("wrapperFileSortedListEX", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedListEX::GGS_wrapperFileSortedListEX (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedListEX::
GGS_wrapperFileSortedListEX (const GGS_wrapperFileSortedListEX & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileSortedListEX::
operator_isEqual (const GGS_wrapperFileSortedListEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileSortedListEX::
operator_isNotEqual (const GGS_wrapperFileSortedListEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedListEX GGS_wrapperFileSortedListEX::
operator_concat (const GGS_wrapperFileSortedListEX & inOperand) const {
  GGS_wrapperFileSortedListEX result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
dotAssign_operation (const GGS_wrapperFileSortedListEX inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_wrapperFileSortedListEX * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mRegularFileName ;
          GGS_string p_1 = p->mAbsoluteFilePath ;
          GGS_uint  p_2 = p->mWrapperDirectoryIndex ;
          GGS_uint  p_3 = p->mWrapperFileIndex ;
          internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mRegularFileName,
                                ptr->mAbsoluteFilePath,
                                ptr->mWrapperDirectoryIndex,
                                ptr->mWrapperFileIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedListEX  GGS_wrapperFileSortedListEX::
constructor_emptySortedList (void) {
  GGS_wrapperFileSortedListEX result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedListEX  GGS_wrapperFileSortedListEX::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_uint & argument_2,
                           const GGS_uint & argument_3) {
  GGS_wrapperFileSortedListEX result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperFileSortedListEX::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@wrapperFileSortedListEX", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
method_smallest (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
method_greatest (C_CompilerEx & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_uint & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileSortedListEX::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_uint & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mRegularFileName ;
    _out_1 = ptr->mAbsoluteFilePath ;
    _out_2 = ptr->mWrapperDirectoryIndex ;
    _out_3 = ptr->mWrapperFileIndex ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperFileSortedListEX::cEnumerator::_mRegularFileName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRegularFileName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperFileSortedListEX::cEnumerator::_mAbsoluteFilePath (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbsoluteFilePath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperFileSortedListEX::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperFileSortedListEX::cEnumerator::_mWrapperFileIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWrapperFileIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_wrapperFileSortedListEX::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_wrapperFileSortedListEX * p = NULL ;
    macroMyNew (p, GGS_wrapperFileSortedListEX (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileSortedListEX GGS_wrapperFileSortedListEX::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_wrapperFileSortedListEX result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_wrapperFileSortedListEX * p = dynamic_cast <const GGS_wrapperFileSortedListEX *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_wrapperFileSortedListEX, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_wrapperFileSortedListEX::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_wrapperFileSortedListEX ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@wrapperDirectorySortedListEX'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_wrapperDirectorySortedListEX::
elementOf_GGS_wrapperDirectorySortedListEX (const GGS_string& argument_0,
                                const GGS_wrapperFileSortedListEX & argument_1,
                                const GGS_wrapperDirectorySortedListEX & argument_2,
                                const GGS_uint & argument_3):
mDirectoryName (argument_0),
mRegularFileSortedList (argument_1),
mDirectorySortedList (argument_2),
mWrapperDirectoryIndex (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperDirectorySortedListEX::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_wrapperDirectorySortedListEX * ptr = dynamic_cast <const elementOf_GGS_wrapperDirectorySortedListEX *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDirectoryName.operator_isEqual (ptr->mDirectoryName).boolValue ()
         && mRegularFileSortedList.operator_isEqual (ptr->mRegularFileSortedList).boolValue ()
         && mDirectorySortedList.operator_isEqual (ptr->mDirectorySortedList).boolValue ()
         && mWrapperDirectoryIndex.operator_isEqual (ptr->mWrapperDirectoryIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_wrapperDirectorySortedListEX::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_wrapperDirectorySortedListEX * operand = (const elementOf_GGS_wrapperDirectorySortedListEX *) inOperand ;
  PMSInt32 result = mDirectoryName.genericObjectCompare (operand->mDirectoryName) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperDirectorySortedListEX::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDirectoryName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRegularFileSortedList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDirectorySortedList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mWrapperDirectoryIndex.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Sorted list '@wrapperDirectorySortedListEX'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_wrapperDirectorySortedListEX ("wrapperDirectorySortedListEX", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedListEX::GGS_wrapperDirectorySortedListEX (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedListEX::
GGS_wrapperDirectorySortedListEX (const GGS_wrapperDirectorySortedListEX & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectorySortedListEX::
operator_isEqual (const GGS_wrapperDirectorySortedListEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectorySortedListEX::
operator_isNotEqual (const GGS_wrapperDirectorySortedListEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_wrapperFileSortedListEX & argument_1,
                    const GGS_wrapperDirectorySortedListEX & argument_2,
                    const GGS_uint & argument_3) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_wrapperFileSortedListEX & argument_1,
                                const GGS_wrapperDirectorySortedListEX & argument_2,
                                const GGS_uint & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedListEX GGS_wrapperDirectorySortedListEX::
operator_concat (const GGS_wrapperDirectorySortedListEX & inOperand) const {
  GGS_wrapperDirectorySortedListEX result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
dotAssign_operation (const GGS_wrapperDirectorySortedListEX inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_wrapperDirectorySortedListEX * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDirectoryName ;
          GGS_wrapperFileSortedListEX  p_1 = p->mRegularFileSortedList ;
          GGS_wrapperDirectorySortedListEX  p_2 = p->mDirectorySortedList ;
          GGS_uint  p_3 = p->mWrapperDirectoryIndex ;
          internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDirectoryName,
                                ptr->mRegularFileSortedList,
                                ptr->mDirectorySortedList,
                                ptr->mWrapperDirectoryIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedListEX  GGS_wrapperDirectorySortedListEX::
constructor_emptySortedList (void) {
  GGS_wrapperDirectorySortedListEX result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedListEX  GGS_wrapperDirectorySortedListEX::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_wrapperFileSortedListEX & argument_1,
                           const GGS_wrapperDirectorySortedListEX & argument_2,
                           const GGS_uint & argument_3) {
  GGS_wrapperDirectorySortedListEX result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperDirectorySortedListEX::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@wrapperDirectorySortedListEX", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
method_smallest (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_wrapperFileSortedListEX & _out_1,
                 GGS_wrapperDirectorySortedListEX & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
method_greatest (C_CompilerEx & inLexique,
             GGS_string& _out_0,
             GGS_wrapperFileSortedListEX & _out_1,
             GGS_wrapperDirectorySortedListEX & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_wrapperFileSortedListEX & _out_1,
                 GGS_wrapperDirectorySortedListEX & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectorySortedListEX::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_string& _out_0,
                GGS_wrapperFileSortedListEX & _out_1,
                GGS_wrapperDirectorySortedListEX & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDirectoryName ;
    _out_1 = ptr->mRegularFileSortedList ;
    _out_2 = ptr->mDirectorySortedList ;
    _out_3 = ptr->mWrapperDirectoryIndex ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperDirectorySortedListEX::cEnumerator::_mDirectoryName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDirectoryName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperFileSortedListEX  & GGS_wrapperDirectorySortedListEX::cEnumerator::_mRegularFileSortedList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRegularFileSortedList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperDirectorySortedListEX  & GGS_wrapperDirectorySortedListEX::cEnumerator::_mDirectorySortedList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDirectorySortedList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperDirectorySortedListEX::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_wrapperDirectorySortedListEX::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_wrapperDirectorySortedListEX * p = NULL ;
    macroMyNew (p, GGS_wrapperDirectorySortedListEX (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectorySortedListEX GGS_wrapperDirectorySortedListEX::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_wrapperDirectorySortedListEX result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_wrapperDirectorySortedListEX * p = dynamic_cast <const GGS_wrapperDirectorySortedListEX *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_wrapperDirectorySortedListEX, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_wrapperDirectorySortedListEX::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_wrapperDirectorySortedListEX ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@wrapperExtensionMapEX'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_wrapperExtensionMapEX ("wrapperExtensionMapEX", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_wrapperExtensionMapEX::
elementOf_GGS_wrapperExtensionMapEX (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_wrapperExtensionMapEX & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperExtensionMapEX::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperExtensionMapEX::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_wrapperExtensionMapEX::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_wrapperExtensionMapEX *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_wrapperExtensionMapEX * info = (e_wrapperExtensionMapEX *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMapEX::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_wrapperExtensionMapEX *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_wrapperExtensionMapEX * info = (e_wrapperExtensionMapEX *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMapEX GGS_wrapperExtensionMapEX::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMapEX result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMapEX::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_wrapperExtensionMapEX info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMapEX::
operator_isEqual (const GGS_wrapperExtensionMapEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMapEX::
operator_isNotEqual (const GGS_wrapperExtensionMapEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMapEX::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMapEX::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_wrapperExtensionMapEX info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMapEX::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperExtensionMapEX::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMapEX::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMapEX GGS_wrapperExtensionMapEX::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_wrapperExtensionMapEX & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMapEX result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMapEX GGS_wrapperExtensionMapEX::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperExtensionMapEX result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperExtensionMapEX::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @wrapperExtensionMapEX " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_wrapperExtensionMapEX::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_wrapperExtensionMapEX * p = NULL ;
    macroMyNew (p, GGS_wrapperExtensionMapEX (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMapEX GGS_wrapperExtensionMapEX::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_wrapperExtensionMapEX result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_wrapperExtensionMapEX * p = dynamic_cast <const GGS_wrapperExtensionMapEX *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_wrapperExtensionMapEX, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_wrapperExtensionMapEX::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_wrapperExtensionMapEX ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMapEX GGS_wrapperExtensionMapEX::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_wrapperExtensionMapEX result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_wrapperToImplement'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_wrapperToImplement::
cPtr_C_wrapperToImplement (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_wrapperExtensionMapEX & argument_2,
                                const GGS_wrapperFileSortedListEX & argument_3,
                                const GGS_wrapperDirectorySortedListEX & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mWrapperName (argument_0),
mSourceDirectory (argument_1),
mExtensionMap (argument_2),
mRegularFileSortedList (argument_3),
mDirectorySortedList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_wrapperToImplement * GGS_C_wrapperToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_wrapperToImplement) ;
    return (cPtr_C_wrapperToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_wrapperToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_wrapperToImplement * ptr = dynamic_cast <const cPtr_C_wrapperToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mWrapperName.operator_isEqual (ptr->mWrapperName).boolValue ()
         && mSourceDirectory.operator_isEqual (ptr->mSourceDirectory).boolValue ()
         && mExtensionMap.operator_isEqual (ptr->mExtensionMap).boolValue ()
         && mRegularFileSortedList.operator_isEqual (ptr->mRegularFileSortedList).boolValue ()
         && mDirectorySortedList.operator_isEqual (ptr->mDirectorySortedList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_wrapperToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_wrapperToImplement:"
           << mWrapperName.reader_description (inIndentation + 1)
           << mSourceDirectory.reader_description (inIndentation + 1)
           << mExtensionMap.reader_description (inIndentation + 1)
           << mRegularFileSortedList.reader_description (inIndentation + 1)
           << mDirectorySortedList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_wrapperToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_wrapperToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_wrapperToImplement (& typeid (cPtr_C_wrapperToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_wrapperToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_wrapperToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_wrapperToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_wrapperToImplement (mWrapperName, mSourceDirectory, mExtensionMap, mRegularFileSortedList, mDirectorySortedList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_wrapperToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_wrapperToImplement ("C_wrapperToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement::
GGS_C_wrapperToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement::
GGS_C_wrapperToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_wrapperToImplement GGS_C_wrapperToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_wrapperToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_wrapperToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_wrapperToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_wrapperToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement GGS_C_wrapperToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_string& argument_1,
                 const GGS_wrapperExtensionMapEX & argument_2,
                 const GGS_wrapperFileSortedListEX & argument_3,
                 const GGS_wrapperDirectorySortedListEX & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_wrapperToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_wrapperToImplement::actualTypeName (void) const {
  return "C_wrapperToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_wrapperToImplement ("C_wrapperToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_wrapperToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_wrapperToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_wrapperToImplement * p = NULL ;
    macroMyNew (p, GGS_C_wrapperToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_wrapperToImplement GGS_C_wrapperToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_wrapperToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_wrapperToImplement * p = dynamic_cast <const GGS_C_wrapperToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_wrapperToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_wrapperToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_wrapperToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_C_structToImplement'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_structToImplement::
cPtr_C_structToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mStructName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_structToImplement * GGS_C_structToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_structToImplement) ;
    return (cPtr_C_structToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_structToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_structToImplement * ptr = dynamic_cast <const cPtr_C_structToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructName.operator_isEqual (ptr->mStructName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_structToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_structToImplement:"
           << mStructName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_structToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_structToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_structToImplement (& typeid (cPtr_C_structToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_structToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_structToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_structToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_structToImplement (mStructName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_structToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_structToImplement ("C_structToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_structToImplement::
GGS_C_structToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement::
GGS_C_structToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_structToImplement GGS_C_structToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_structToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_structToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_structToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_structToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement GGS_C_structToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_structToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_structToImplement::actualTypeName (void) const {
  return "C_structToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_structToImplement ("C_structToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_structToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_structToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_structToImplement * p = NULL ;
    macroMyNew (p, GGS_C_structToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_structToImplement GGS_C_structToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_structToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_structToImplement * p = dynamic_cast <const GGS_C_structToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_structToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_structToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_structToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_C_filewrapperTemplateToImplement'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_filewrapperTemplateToImplement::
cPtr_C_filewrapperTemplateToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_2,
                                const GGS_templateInstructionList & argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mFilewrapperName (argument_0),
mTemplateName (argument_1),
mTemplateArgumentList (argument_2),
mTemplateInstructionList (argument_3),
mUsesColumnMarker (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_filewrapperTemplateToImplement * GGS_C_filewrapperTemplateToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_filewrapperTemplateToImplement) ;
    return (cPtr_C_filewrapperTemplateToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_filewrapperTemplateToImplement::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_filewrapperTemplateToImplement * ptr = dynamic_cast <const cPtr_C_filewrapperTemplateToImplement *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mTemplateArgumentList.operator_isEqual (ptr->mTemplateArgumentList).boolValue ()
         && mTemplateInstructionList.operator_isEqual (ptr->mTemplateInstructionList).boolValue ()
         && mUsesColumnMarker.operator_isEqual (ptr->mUsesColumnMarker).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_filewrapperTemplateToImplement::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_filewrapperTemplateToImplement:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mTemplateName.reader_description (inIndentation + 1)
           << mTemplateArgumentList.reader_description (inIndentation + 1)
           << mTemplateInstructionList.reader_description (inIndentation + 1)
           << mUsesColumnMarker.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_filewrapperTemplateToImplement::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_filewrapperTemplateToImplement::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_filewrapperTemplateToImplement (& typeid (cPtr_C_filewrapperTemplateToImplement), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_filewrapperTemplateToImplement::galgasRTTI (void) const {
  return & gClassInfoFor__C_filewrapperTemplateToImplement ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_filewrapperTemplateToImplement::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_filewrapperTemplateToImplement (mFilewrapperName, mTemplateName, mTemplateArgumentList, mTemplateInstructionList, mUsesColumnMarker COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_C_filewrapperTemplateToImplement'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_filewrapperTemplateToImplement ("C_filewrapperTemplateToImplement", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement::
GGS_C_filewrapperTemplateToImplement (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement::
GGS_C_filewrapperTemplateToImplement (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_filewrapperTemplateToImplement *> (inPointer) != NULL)
      : (typeid (cPtr_C_filewrapperTemplateToImplement) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_filewrapperTemplateToImplement (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_filewrapperTemplateToImplement),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_2,
                 const GGS_templateInstructionList & argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_filewrapperTemplateToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_filewrapperTemplateToImplement::actualTypeName (void) const {
  return "C_filewrapperTemplateToImplement" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_filewrapperTemplateToImplement ("C_filewrapperTemplateToImplement", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_C_filewrapperTemplateToImplement) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_filewrapperTemplateToImplement::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_filewrapperTemplateToImplement * p = NULL ;
    macroMyNew (p, GGS_C_filewrapperTemplateToImplement (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_filewrapperTemplateToImplement GGS_C_filewrapperTemplateToImplement::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_filewrapperTemplateToImplement result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_filewrapperTemplateToImplement * p = dynamic_cast <const GGS_C_filewrapperTemplateToImplement *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_filewrapperTemplateToImplement, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_filewrapperTemplateToImplement::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_filewrapperTemplateToImplement ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_templateVariableMapEX'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_templateVariableMapEX::e_templateVariableMapEX (void) :
mArgumentType (),
mCplusPlusName () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@templateVariableMapEX'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateVariableMapEX ("templateVariableMapEX", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_templateVariableMapEX::
elementOf_GGS_templateVariableMapEX (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_templateVariableMapEX & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateVariableMapEX::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mArgumentType.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCplusPlusName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateVariableMapEX::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_templateVariableMapEX * ptr = dynamic_cast <const elementOf_GGS_templateVariableMapEX *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mArgumentType.operator_isEqual (ptr->mInfo.mArgumentType)).boolValue ()
           && (mInfo.mCplusPlusName.operator_isEqual (ptr->mInfo.mCplusPlusName)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_templateVariableMapEX::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_templateVariableMapEX *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_templateVariableMapEX * info = (e_templateVariableMapEX *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_templateVariableMapEX *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_templateVariableMapEX * info = (e_templateVariableMapEX *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_templateVariableMapEX GGS_templateVariableMapEX::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_templateVariableMapEX result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_templateVariableMapEX info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateVariableMapEX::
operator_isEqual (const GGS_templateVariableMapEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateVariableMapEX::
operator_isNotEqual (const GGS_templateVariableMapEX & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType & inParameter0,
               const GGS_typeCplusPlusName & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_templateVariableMapEX info  ;
    info.mArgumentType = inParameter0 ;
    info.mCplusPlusName = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_typeCplusPlusName   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mArgumentType ;
    outParameter1 = node->mInfo.mCplusPlusName ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_templateVariableMapEX::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_templateVariableMapEX::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_templateVariableMapEX::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0,
                                const GGS_typeCplusPlusName & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_templateVariableMapEX GGS_templateVariableMapEX::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_templateVariableMapEX & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_templateVariableMapEX result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateVariableMapEX GGS_templateVariableMapEX::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateVariableMapEX result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateVariableMapEX::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @templateVariableMapEX " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_templateVariableMapEX::cEnumerator::_mArgumentType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mArgumentType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCplusPlusName  & GGS_templateVariableMapEX::cEnumerator::_mCplusPlusName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCplusPlusName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateVariableMapEX::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateVariableMapEX * p = NULL ;
    macroMyNew (p, GGS_templateVariableMapEX (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateVariableMapEX GGS_templateVariableMapEX::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateVariableMapEX result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateVariableMapEX * p = dynamic_cast <const GGS_templateVariableMapEX *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateVariableMapEX, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateVariableMapEX::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateVariableMapEX ;
}

//---------------------------------------------------------------------------*

GGS_templateVariableMapEX GGS_templateVariableMapEX::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_AC_galgasType & inValue0,
                                             const GGS_typeCplusPlusName & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_templateVariableMapEX result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semantics_semantics (void) {
  macroReleaseObject (gSingleton_typeTrueBool) ;
  macroReleaseObject (gSingleton_typeFalseBool) ;
  macroReleaseObject (gSingleton_typeHereExpression) ;
  macroReleaseObject (gSingleton_typeJokerInExpression) ;
  macroReleaseObject (gSingleton_typeJoker) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semantics_semantics (NULL, epilogueRoutineFor_semantics_semantics) ;

//---------------------------------------------------------------------------*

