//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      january 3rd, 2006, at 21h6'44"                       *
//                                                                           *
// This file is free software; you can redistribute it and/or modify it      *
// under the terms of the GNU Lesser General Public License as published     *
// by the Free Software Foundation; either version 2 of the License, or      *
// (at your option) any later version.                                       *
//                                                                           *
// This file is distributed in the hope it will be useful, but WITHOUT       *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public       *
// License for more details.                                                 *
//                                                                           *
// You should have received a copy of the GNU General Public License along   *
// with this program; if not, write to the Free Software Foundation          *
// Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               Include directives generated by extern types                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"
#include "cTableMethodesAimplementer.hh"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCplusPlusName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (void) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const GGS_typeCplusPlusName & inOperand) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
~GGS_typeCplusPlusName (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (const GGS_typeCplusPlusName & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (cPtr_typeCplusPlusName * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (cPtr_typeCplusPlusName * inSource) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::cPtr_typeDirectName (const GGS_lstring & argument_0)
:mName (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDirectName * GGS_typeDirectName::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeDirectName * ptr_ = (cPtr_typeDirectName *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCppThisName * GGS_typeCppThisName::
    constructor_new () {
    cPtr_typeCppThisName * ptr_ = (cPtr_typeCppThisName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppThisName ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
    constructor_new () {
    cPtr_typeCppInheritedName * ptr_ = (cPtr_typeCppInheritedName *) NULL ;
    macroMyNew (ptr_, cPtr_typeCppInheritedName ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::cPtr_typeAutomaticName (const GGS_lstring & argument_0)
:mName (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeAutomaticName * ptr_ = (cPtr_typeAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeAutomaticName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::cPtr_typeLocationAutomaticName (const GGS_location & argument_0)
:mLocation (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
    constructor_new (const GGS_location & argument_0) {
    cPtr_typeLocationAutomaticName * ptr_ = (cPtr_typeLocationAutomaticName *) NULL ;
    macroMyNew (ptr_, cPtr_typeLocationAutomaticName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::cPtr_typeOperandName (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2)
:mName (argument_0),
mLocationOffset (argument_1),
mFieldKind (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeOperandName * GGS_typeOperandName::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2) {
    cPtr_typeOperandName * ptr_ = (cPtr_typeOperandName *) NULL ;
    macroMyNew (ptr_, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::cPtr_typeKeyName (const GGS_location & argument_0)
:mLocationOffset (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeKeyName * GGS_typeKeyName::
    constructor_new (const GGS_location & argument_0) {
    cPtr_typeKeyName * ptr_ = (cPtr_typeKeyName *) NULL ;
    macroMyNew (ptr_, cPtr_typeKeyName (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeNullName * GGS_typeNullName::
    constructor_new () {
    cPtr_typeNullName * ptr_ = (cPtr_typeNullName *) NULL ;
    macroMyNew (ptr_, cPtr_typeNullName ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0) {
  mNextItem = (elementOf_GGS_typeCplusPlusNameList *) NULL ;
  mCppName = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList
::GGS_typeCplusPlusNameList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::~GGS_typeCplusPlusNameList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::operator = (const GGS_typeCplusPlusNameList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_empty (void) {
  GGS_typeCplusPlusNameList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (void) {
  mPointer = (cPtr_typeExpression *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const GGS_typeExpression & inOperand) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
~GGS_typeExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (const GGS_typeExpression & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (cPtr_typeExpression * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (cPtr_typeExpression * inSource) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeExpression * GGS_typeExpression
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeExpression
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map 'typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::constructor_empty (void) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0) {
  searchElement (inLexique,
                 "the message '%K' is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0) {
  insertElement (lexique_var_,
                 "the message '%K' is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_typeSemanticsTypesList *) NULL ;
  mType = argument_0 ;
  mGalgasVariableName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList
::GGS_typeSemanticsTypesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::~GGS_typeSemanticsTypesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::operator = (const GGS_typeSemanticsTypesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mGalgasVariableName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_empty (void) {
  GGS_typeSemanticsTypesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::constructor_empty (void) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertConstInArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertConstInArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertConstInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUsedConstInArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUsedConstInArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUsedConstInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedConstInArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedConstInArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedConstInArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertLocalVariable (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertLocalVariableGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertLocalVariable (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertOutArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertOutArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertOutArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInOutArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertInOutArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertInOutArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedInOutArgument (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::methode_insertUnusedInOutArgumentGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 index = insertUnusedInOutArgument (lexique_var_, info, inKey, inKey, "the variable '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_L_assignedVariables *) NULL ;
  aNomVariableCible = argument_0 ;
  aNomAttributSource = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables
::GGS_L_assignedVariables (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::~GGS_L_assignedVariables (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::GGS_L_assignedVariables (const GGS_L_assignedVariables & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::operator = (const GGS_L_assignedVariables & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aNomVariableCible,
                                p->aNomAttributSource) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_empty (void) {
  GGS_L_assignedVariables result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (void) {
  mPointer = (cPtr_typeCible *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const GGS_typeCible & inOperand) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
~GGS_typeCible (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (const GGS_typeCible & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (cPtr_typeCible * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (cPtr_typeCible * inSource) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCible * GGS_typeCible
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCible
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0) {
  mNextItem = (elementOf_GGS_typeListeCibles *) NULL ;
  aCible = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles
::GGS_typeListeCibles (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::~GGS_typeListeCibles (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::GGS_typeListeCibles (const GGS_typeListeCibles & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::operator = (const GGS_typeListeCibles & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
internalAppendItem (const GGS_typeCible & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
addAssign_operation (const GGS_typeCible & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aCible) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_empty (void) {
  GGS_typeListeCibles result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  mNextItem = (elementOf_GGS_typeListeTypesEtNomsArgMethode *) NULL ;
  mType = argument_0 ;
  mFormalArgumentPassingMode = argument_1 ;
  mCppName = argument_2 ;
  aModeIn = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode
::GGS_typeListeTypesEtNomsArgMethode (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::~GGS_typeListeTypesEtNomsArgMethode (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::operator = (const GGS_typeListeTypesEtNomsArgMethode & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mFormalArgumentPassingMode,
                                p->mCppName,
                                p->aModeIn) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_empty (void) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (void) {
  mPointer = (cPtr_typeInstruction *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const GGS_typeInstruction & inOperand) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
~GGS_typeInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (const GGS_typeInstruction & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (cPtr_typeInstruction * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (cPtr_typeInstruction * inSource) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstruction * GGS_typeInstruction
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeInstruction
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeInstructionsList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionsList::
elementOf_GGS_typeInstructionsList (const GGS_typeInstruction & argument_0) {
  mNextItem = (elementOf_GGS_typeInstructionsList *) NULL ;
  aInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionsList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionsList
::GGS_typeInstructionsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionsList::~GGS_typeInstructionsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionsList::GGS_typeInstructionsList (const GGS_typeInstructionsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::operator = (const GGS_typeInstructionsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList::
internalAppendItem (const GGS_typeInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList::
addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionsList  GGS_typeInstructionsList::
constructor_empty (void) {
  GGS_typeInstructionsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (elementOf_GGS_L_nameWithType *) NULL ;
  mType = argument_0 ;
  mName = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType
::GGS_L_nameWithType (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::~GGS_L_nameWithType (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::GGS_L_nameWithType (const GGS_L_nameWithType & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::operator = (const GGS_L_nameWithType & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mType,
                                p->mName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_empty (void) {
  GGS_L_nameWithType result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::constructor_empty (void) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertAbstract (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionsList = inParameter2 ;
  insertAbstract (lexique_var_, info, inKey, inKey, "the method '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertAbstractGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionsList = inParameter2 ;
  const sint32 index = insertAbstract (lexique_var_, info, inKey, inKey, "the method '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertNotAbstract (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionsList = inParameter2 ;
  insertNotAbstract (lexique_var_, info, inKey, inKey, "the method '%' is already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::methode_insertNotAbstractGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionsList = inParameter2 ;
  const sint32 index = insertNotAbstract (lexique_var_, info, inKey, inKey, "the method '%' is already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0) {
  mNextItem = (elementOf_GGS_typeExpressionList *) NULL ;
  mExpression = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList
::GGS_typeExpressionList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::~GGS_typeExpressionList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::GGS_typeExpressionList (const GGS_typeExpressionList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::operator = (const GGS_typeExpressionList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
internalAppendItem (const GGS_typeExpression & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
addAssign_operation (const GGS_typeExpression & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mExpression) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_empty (void) {
  GGS_typeExpressionList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeErrorInstruction * ptr_ = (cPtr_typeErrorInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeErrorInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeWarningInstruction * ptr_ = (cPtr_typeWarningInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeWarningInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0)
:mMessageExpression (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
    constructor_new (const GGS_typeExpression & argument_0) {
    cPtr_typeMessageInstruction * ptr_ = (cPtr_typeMessageInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMessageInstruction (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInstruction::cPtr_typeReaderCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeReaderCallInstruction * GGS_typeReaderCallInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeReaderCallInstruction * ptr_ = (cPtr_typeReaderCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeModifierCallInstruction * ptr_ = (cPtr_typeModifierCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2)
:aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2) {
    cPtr_typeInstructionAppelMethodeListe * ptr_ = (cPtr_typeInstructionAppelMethodeListe *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1)
:aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1) {
    cPtr_typeInstructionDeclarationVarLocale * ptr_ = (cPtr_typeInstructionDeclarationVarLocale *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeMapBlockPrologueInstruction * ptr_ = (cPtr_typeMapBlockPrologueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeMapBlockEpilogueInstruction * ptr_ = (cPtr_typeMapBlockEpilogueInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeReaderCallInExpression * ptr_ = (cPtr_typeReaderCallInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::cPtr_typeAndOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAndOperation * GGS_typeAndOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeAndOperation * ptr_ = (cPtr_typeAndOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeAndOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::cPtr_typeOrOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeOrOperation * GGS_typeOrOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeOrOperation * ptr_ = (cPtr_typeOrOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeOrOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeMinusOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMinusOperation::cPtr_typeMinusOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeMinusOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMinusOperation * GGS_typeMinusOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeMinusOperation * ptr_ = (cPtr_typeMinusOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeMinusOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::cPtr_typeConcatOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeConcatOperation * ptr_ = (cPtr_typeConcatOperation *) NULL ;
    macroMyNew (ptr_, cPtr_typeConcatOperation (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeTrueBool * GGS_typeTrueBool::
    constructor_new () {
    cPtr_typeTrueBool * ptr_ = (cPtr_typeTrueBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeTrueBool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFalseBool * GGS_typeFalseBool::
    constructor_new () {
    cPtr_typeFalseBool * ptr_ = (cPtr_typeFalseBool *) NULL ;
    macroMyNew (ptr_, cPtr_typeFalseBool ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::cPtr_typeLiteralStringExpression (const GGS_lstring & argument_0)
:mLiteralString (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeLiteralStringExpression * ptr_ = (cPtr_typeLiteralStringExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralStringExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0)
:mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeLiteralUIntExpression * ptr_ = (cPtr_typeLiteralUIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralUIntExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0)
:mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
    constructor_new (const GGS_lsint & argument_0) {
    cPtr_typeLiteralSIntExpression * ptr_ = (cPtr_typeLiteralSIntExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralSIntExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0)
:mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
    constructor_new (const GGS_lchar & argument_0) {
    cPtr_typeLiteralCharExpression * ptr_ = (cPtr_typeLiteralCharExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeLiteralCharExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeHereExpression * GGS_typeHereExpression::
    constructor_new () {
    cPtr_typeHereExpression * ptr_ = (cPtr_typeHereExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeHereExpression ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::cPtr_typeConstructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2)
:mClassName (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
    cPtr_typeConstructorExpression * ptr_ = (cPtr_typeConstructorExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::cPtr_typeTestComplement (const GGS_typeExpression & argument_0)
:mTest (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeTestComplement * GGS_typeTestComplement::
    constructor_new (const GGS_typeExpression & argument_0) {
    cPtr_typeTestComplement * ptr_ = (cPtr_typeTestComplement *) NULL ;
    macroMyNew (ptr_, cPtr_typeTestComplement (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::cPtr_typeBoolOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeBoolOption * GGS_typeBoolOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeBoolOption * ptr_ = (cPtr_typeBoolOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeBoolOption (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::cPtr_typeUIntOption (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUIntOption * GGS_typeUIntOption::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeUIntOption * ptr_ = (cPtr_typeUIntOption *) NULL ;
    macroMyNew (ptr_, cPtr_typeUIntOption (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0)
:mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
    constructor_new (const GGS_typeCplusPlusName & argument_0) {
    cPtr_typeVarInExpression * ptr_ = (cPtr_typeVarInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeVarInExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::cPtr_typeJokerInExpression (const GGS_location & argument_0)
:mLocation (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
    constructor_new (const GGS_location & argument_0) {
    cPtr_typeJokerInExpression * ptr_ = (cPtr_typeJokerInExpression *) NULL ;
    macroMyNew (ptr_, cPtr_typeJokerInExpression (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::cPtr_typeEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEqualTest * GGS_typeEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeEqualTest * ptr_ = (cPtr_typeEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::cPtr_typeNonEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeNonEqualTest * ptr_ = (cPtr_typeNonEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeNonEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::cPtr_typeStrictInfTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeStrictInfTest * ptr_ = (cPtr_typeStrictInfTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictInfTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::cPtr_typeInfOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeInfOrEqualTest * ptr_ = (cPtr_typeInfOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::cPtr_typeStrictSupTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeStrictSupTest * ptr_ = (cPtr_typeStrictSupTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeStrictSupTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::cPtr_typeSupOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1)
:mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_typeSupOrEqualTest * ptr_ = (cPtr_typeSupOrEqualTest *) NULL ;
    macroMyNew (ptr_, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2)
:mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
    constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2) {
    cPtr_typeTextTableCall * ptr_ = (cPtr_typeTextTableCall *) NULL ;
    macroMyNew (ptr_, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1)
:mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1) {
    cPtr_C_assignmentInstruction * ptr_ = (cPtr_C_assignmentInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_assignmentInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2)
:mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
    constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2) {
    cPtr_C_declarationInstructionWithAssignment * ptr_ = (cPtr_C_declarationInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
  mNextItem = (elementOf_GGS_L_expression_instructionsList_list *) NULL ;
  mIFexpression = argument_0 ;
  mInstructionsList = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list
::GGS_L_expression_instructionsList_list (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::~GGS_L_expression_instructionsList_list (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::operator = (const GGS_L_expression_instructionsList_list & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
internalAppendItem (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mIFexpression,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_empty (void) {
  GGS_L_expression_instructionsList_list result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionsList & argument_1)
:mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_if_instruction * GGS_C_if_instruction::
    constructor_new (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
    cPtr_C_if_instruction * ptr_ = (cPtr_C_if_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_if_instruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableRoutinesAimplementer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::constructor_empty (void) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the routine '%K' is already declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableAttributsSemantiques'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::constructor_empty (void) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeCplusPlusName &  inParameter0,
               const GGS_AC_galgasType &  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1) {
  searchElement (inLexique,
                 "the attribute '%K' is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1) {
  insertElement (lexique_var_,
                 "the attribute '%K' is already declared",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Lexique & lexique_var_,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound) {
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle) != (GGS_localConstantBuildStyleEnum::constructor_listStyle ()) ;
  GGS_bool var_cas_first ;
  var_cas_first = GGS_bool (true, true) ;
  GGS_L_nameWithType::element_type * operand_25603 = var_cas_inLocalDeclarationsList.firstObject () ;
  GGS_typeListeAttributsSemantiques::element_type * operand_25692 = var_cas_inSemanticAttributsList.firstObject () ;
  while ((operand_25603 != NULL)
      && (operand_25692 != NULL)) {
    macroValidPointer (operand_25603) ;
    macroValidPointer (operand_25692) ;
    if (((operand_25603->mName.reader_value ()) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_string var_cas_typeName ;
      if (operand_25692->mAttributType.isBuilt ()) {
        operand_25692->mAttributType (HERE)->methode_getTypeName (lexique_var_, var_cas_typeName) ;
      }
      if (((operand_25603->mType.reader_value ()) == (var_cas_typeName)).isBuiltAndTrue ()) {
        GGS_typeCplusPlusName  var_cas_cppName ;
        if (((((var_cas_inLocalConstantStyle) == (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle ())) && (var_cas_first))).isBuiltAndTrue ()) {
          var_cas_cppName = GGS_typeKeyName::constructor_new (var_cas_inLocation) ;
        }else{
          var_cas_cppName = GGS_typeOperandName::constructor_new (operand_25692->aNomAttribut, var_cas_inLocation, var_cas_mapStyle) ;
        }
        var_cas_ioVariablesMap.methode_insertUsedConstInArgument (lexique_var_, operand_25603->mName, operand_25692->mAttributType, var_cas_cppName) ;
      }else{
          operand_25603->mType.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I have found the '@")) + (operand_25603->mType.reader_value ()))) + (GGS_string (true, "' type, I was expected the '@")))) + (var_cas_typeName))) + (GGS_string (true, "' type")))) ;
      }
    }
    var_cas_first = GGS_bool (true, false) ;
    operand_25603 = operand_25603->nextObject () ;
    operand_25692 = operand_25692->nextObject () ;
  }
  if (((((var_cas_inLocalDeclarationsList.reader_length ()) < (var_cas_inSemanticAttributsList.reader_length ())) && ((! var_cas_inEllipsisFound)))).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "one or more parameters missing: found ")) + (var_cas_inLocalDeclarationsList.reader_length ().reader_string ()))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length ().reader_string ()))) + (GGS_string (true, " are needed")))) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length ()) > (var_cas_inSemanticAttributsList.reader_length ())).isBuiltAndTrue ()) {
      GGS_location (lexique_var_).reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "too much parameters: found ")) + (var_cas_inLocalDeclarationsList.reader_length ().reader_string ()))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length ().reader_string ()))) + (GGS_string (true, " are needed")))) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "checkAssignmentTypesCompatibility"        *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_checkAssignmentTypesCompatibility (C_Lexique & lexique_var_,
                                GGS_AC_galgasType   var_cas_targetType,
                                GGS_AC_galgasType   var_cas_sourceType,
                                GGS_location   var_cas_inErrorLocation) {
  if (var_cas_targetType.isBuilt () && var_cas_sourceType.isBuilt ()) {
    cPtr_AC_galgasType * ptr_27715 = var_cas_targetType (HERE) ;
    cPtr_AC_galgasType * ptr_27729 = var_cas_sourceType (HERE) ;
    cPtr_typeGalgas_stringset * operand_27715 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_27715) ;
    cPtr_typeGalgas_stringset * operand_27729 = dynamic_cast <cPtr_typeGalgas_stringset *> (ptr_27729) ;
    if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
    }else{
      cPtr_typeGalgas_uint * operand_27715 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_27715) ;
      cPtr_typeGalgas_uint * operand_27729 = dynamic_cast <cPtr_typeGalgas_uint *> (ptr_27729) ;
      if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
      }else{
        cPtr_typeGalgas_sint * operand_27715 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_27715) ;
        cPtr_typeGalgas_sint * operand_27729 = dynamic_cast <cPtr_typeGalgas_sint *> (ptr_27729) ;
        if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
        }else{
          cPtr_typeGalgas_char * operand_27715 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_27715) ;
          cPtr_typeGalgas_char * operand_27729 = dynamic_cast <cPtr_typeGalgas_char *> (ptr_27729) ;
          if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
          }else{
            cPtr_typeGalgas_string * operand_27715 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_27715) ;
            cPtr_typeGalgas_string * operand_27729 = dynamic_cast <cPtr_typeGalgas_string *> (ptr_27729) ;
            if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
            }else{
              cPtr_typeGalgas_bool * operand_27715 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_27715) ;
              cPtr_typeGalgas_bool * operand_27729 = dynamic_cast <cPtr_typeGalgas_bool *> (ptr_27729) ;
              if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
              }else{
                cPtr_typeGalgas_double * operand_27715 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_27715) ;
                cPtr_typeGalgas_double * operand_27729 = dynamic_cast <cPtr_typeGalgas_double *> (ptr_27729) ;
                if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                }else{
                  cPtr_typeGalgas_ldouble * operand_27715 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_27715) ;
                  cPtr_typeGalgas_ldouble * operand_27729 = dynamic_cast <cPtr_typeGalgas_ldouble *> (ptr_27729) ;
                  if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                  }else{
                    cPtr_typeGalgas_location * operand_27715 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_27715) ;
                    cPtr_typeGalgas_location * operand_27729 = dynamic_cast <cPtr_typeGalgas_location *> (ptr_27729) ;
                    if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                    }else{
                      cPtr_typeGalgas_lchar * operand_27715 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_27715) ;
                      cPtr_typeGalgas_lchar * operand_27729 = dynamic_cast <cPtr_typeGalgas_lchar *> (ptr_27729) ;
                      if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                      }else{
                        cPtr_typeGalgas_luint * operand_27715 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_27715) ;
                        cPtr_typeGalgas_luint * operand_27729 = dynamic_cast <cPtr_typeGalgas_luint *> (ptr_27729) ;
                        if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                        }else{
                          cPtr_typeGalgas_lsint * operand_27715 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_27715) ;
                          cPtr_typeGalgas_lsint * operand_27729 = dynamic_cast <cPtr_typeGalgas_lsint *> (ptr_27729) ;
                          if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                          }else{
                            cPtr_typeGalgas_lstring * operand_27715 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_27715) ;
                            cPtr_typeGalgas_lstring * operand_27729 = dynamic_cast <cPtr_typeGalgas_lstring *> (ptr_27729) ;
                            if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                            }else{
                              cPtr_typeGalgas_lbool * operand_27715 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_27715) ;
                              cPtr_typeGalgas_lbool * operand_27729 = dynamic_cast <cPtr_typeGalgas_lbool *> (ptr_27729) ;
                              if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                              }else{
                                cPtr_typeGalgasUndefinedExternType * operand_27715 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_27715) ;
                                cPtr_typeGalgasUndefinedExternType * operand_27729 = dynamic_cast <cPtr_typeGalgasUndefinedExternType *> (ptr_27729) ;
                                if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                                  if (((operand_27715->mGalgasClassName.reader_value ()) != (operand_27729->mGalgasClassName.reader_value ())).isBuiltAndTrue ()) {
                                      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an extern variable of extern '")) + (operand_27715->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an extern '")))) + (operand_27729->mGalgasClassName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                  }
                                }else{
                                  cPtr_typeGalgasUndefinedListType * operand_27715 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_27715) ;
                                  cPtr_typeGalgasUndefinedListType * operand_27729 = dynamic_cast <cPtr_typeGalgasUndefinedListType *> (ptr_27729) ;
                                  if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                                    if (((operand_27715->mListTypeName.reader_value ()) != (operand_27729->mListTypeName.reader_value ())).isBuiltAndTrue ()) {
                                        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting a '")) + (operand_27715->mListTypeName.reader_value ()))) + (GGS_string (true, "' list type variable, and I got a '")))) + (operand_27729->mListTypeName.reader_value ()))) + (GGS_string (true, "' list type variable")))) ;
                                    }
                                  }else{
                                    cPtr_typeGalgasClassType * operand_27715 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_27715) ;
                                    cPtr_typeGalgasClassType * operand_27729 = dynamic_cast <cPtr_typeGalgasClassType *> (ptr_27729) ;
                                    if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                                      if (((operand_27715->mClassTypeName.reader_value ()) == (operand_27729->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                      }else if (((! operand_27729->mAncestorClassesMap.reader_hasKey (operand_27715->mClassTypeName.reader_value ()))).isBuiltAndTrue ()) {
                                          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "The '")) + (operand_27729->mClassTypeName.reader_value ()))) + (GGS_string (true, "' does not inherit from '")))) + (operand_27729->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class")))) ;
                                      }
                                    }else{
                                      cPtr_typeGalgasUndefinedClassType * operand_27715 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_27715) ;
                                      cPtr_typeGalgasUndefinedClassType * operand_27729 = dynamic_cast <cPtr_typeGalgasUndefinedClassType *> (ptr_27729) ;
                                      if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                                        if (((operand_27715->mClassTypeName.reader_value ()) != (operand_27729->mClassTypeName.reader_value ())).isBuiltAndTrue ()) {
                                            var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting a '")) + (operand_27715->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class type variable, and I got a '")))) + (operand_27729->mClassTypeName.reader_value ()))) + (GGS_string (true, "' class type variable")))) ;
                                        }
                                      }else{
                                        cPtr_typeGalgasUndefinedMapType * operand_27715 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_27715) ;
                                        cPtr_typeGalgasUndefinedMapType * operand_27729 = dynamic_cast <cPtr_typeGalgasUndefinedMapType *> (ptr_27729) ;
                                        if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                                          if (((operand_27715->mMapTypeName.reader_value ()) != (operand_27729->mMapTypeName.reader_value ())).isBuiltAndTrue ()) {
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting a '")) + (operand_27715->mMapTypeName.reader_value ()))) + (GGS_string (true, "' map type variable, and I got a '")))) + (operand_27729->mMapTypeName.reader_value ()))) + (GGS_string (true, "' map type variable")))) ;
                                          }
                                        }else{
                                          cPtr_typeGalgas_enum * operand_27715 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_27715) ;
                                          cPtr_typeGalgas_enum * operand_27729 = dynamic_cast <cPtr_typeGalgas_enum *> (ptr_27729) ;
                                          if ((operand_27715 != NULL) && (operand_27729 != NULL)) {
                                            if (((operand_27715->mEnumTypeName.reader_value ()) != (operand_27729->mEnumTypeName.reader_value ())).isBuiltAndTrue ()) {
                                                var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((((((GGS_string (true, "I was expecting an enum variable of  '")) + (operand_27715->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable, and I got an enum '")))) + (operand_27729->mEnumTypeName.reader_value ()))) + (GGS_string (true, "' type variable")))) ;
                                            }
                                          }else{
                                              var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((var_cas_targetType.reader_messageGalgasType ()) + (GGS_string (true, " cannot be assigned from ")))) + (var_cas_sourceType.reader_messageGalgasType ()))) ;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Lexique & lexique_var_,
                                GGS_typeSemanticsTypesList   var_cas_t1,
                                GGS_typeListeAttributsSemantiques   var_cas_t2,
                                const GGS_location  & var_cas_inErrorLocation) {
  if (((var_cas_t1.reader_length ()) < (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more identifiers missing")) ;
  }else if (((var_cas_t1.reader_length ()) > (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much identifiers")) ;
  }else{
    GGS_typeSemanticsTypesList::element_type * operand_32162 = var_cas_t1.firstObject () ;
    GGS_typeListeAttributsSemantiques::element_type * operand_32247 = var_cas_t2.firstObject () ;
    while ((operand_32162 != NULL)
        && (operand_32247 != NULL)) {
      macroValidPointer (operand_32162) ;
      macroValidPointer (operand_32247) ;
      ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_32162->mType,  operand_32247->mAttributType,  operand_32162->mGalgasVariableName.reader_location ()) ;
      operand_32162 = operand_32162->nextObject () ;
      operand_32247 = operand_32247->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique & lexique_var_,
                                GGS_L_signature   var_cas_signatureReference,
                                GGS_L_actualParametersSignature   var_cas_inEffectiveArgumentsSignature,
                                const GGS_location  & var_cas_inErrorLocation,
                                GGS_typeInstructionsList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList) {
  if (((var_cas_signatureReference.reader_length ()) > (var_cas_inEffectiveArgumentsSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more arguments missing")) ;
  }else if (((var_cas_signatureReference.reader_length ()) < (var_cas_inEffectiveArgumentsSignature.reader_length ())).isBuiltAndTrue ()) {
      var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much arguments")) ;
  }else{
    GGS_L_signature::element_type * operand_33480 = var_cas_signatureReference.firstObject () ;
    GGS_L_actualParametersSignature::element_type * operand_33609 = var_cas_inEffectiveArgumentsSignature.firstObject () ;
    while ((operand_33480 != NULL)
        && (operand_33609 != NULL)) {
      macroValidPointer (operand_33480) ;
      macroValidPointer (operand_33609) ;
      if (operand_33480->mFormalArgumentPassingMode.isBuilt () && operand_33609->mFormalArgumentPassingMode.isBuilt ()) {
        if ((operand_33480->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentConstantIn) && (operand_33609->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
          ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_33480->mType,  operand_33609->mType,  var_cas_inErrorLocation) ;
        }else{
          if ((operand_33480->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentIn) && (operand_33609->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
            ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_33480->mType,  operand_33609->mType,  var_cas_inErrorLocation) ;
          }else{
            if ((operand_33480->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentInOut) && (operand_33609->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOutIn)) {
              ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_33480->mType,  operand_33609->mType,  var_cas_inErrorLocation) ;
            }else{
              if ((operand_33480->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentOut) && (operand_33609->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterIn)) {
                if (operand_33609->mType.isBuilt ()) {
                  if (dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (operand_33609->mType.getPtr ()) != NULL) {
                  }else{ // Else part
                    ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  operand_33480->mType,  operand_33609->mType,  var_cas_inErrorLocation) ;
                  }
                }
              }else{
                  var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, ((((operand_33609->mFormalArgumentPassingMode.reader_actualArgumentMessage ()) + (GGS_string (true, " is not compatible with ")))) + (operand_33480->mFormalArgumentPassingMode.reader_formalArgumentMessage ()))) ;
              }
            }
          }
        }
      }
      operand_33480 = operand_33480->nextObject () ;
      operand_33609 = operand_33609->nextObject () ;
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList::constructor_empty () ;
    GGS_L_signature::element_type * operand_34866 = var_cas_signatureReference.firstObject () ;
    GGS_typeExpressionList::element_type * operand_34934 = var_cas_expressionList.firstObject () ;
    while ((operand_34866 != NULL)
        && (operand_34934 != NULL)) {
      macroValidPointer (operand_34866) ;
      macroValidPointer (operand_34934) ;
      if (operand_34934->mExpression.isBuilt ()) {
        if (dynamic_cast <cPtr_typeJokerInExpression *> (operand_34934->mExpression.getPtr ()) != NULL) {
          cPtr_typeJokerInExpression * operand_35019 = dynamic_cast <cPtr_typeJokerInExpression *> (operand_34934->mExpression.getPtr ()) ;
          macroValidPointer (operand_35019) ; 
          GGS_typeCplusPlusName  var_cas_cppVarName ;
          var_cas_cppVarName = GGS_typeLocationAutomaticName::constructor_new (operand_35019->mLocation) ;
          GGS_typeExpression  var_cas_e ;
          var_cas_e = GGS_typeVarInExpression::constructor_new (var_cas_cppVarName) ;
          var_cas_ioExpressionList.addAssign_operation (var_cas_e) ;
          GGS_typeInstruction  var_cas_i ;
          var_cas_i = GGS_typeInstructionDeclarationVarLocale::constructor_new (var_cas_cppVarName, operand_34866->mType) ;
          var_cas_ioInstructionsList.addAssign_operation (var_cas_i) ;
        }else{ // Else part
          var_cas_ioExpressionList.addAssign_operation (operand_34934->mExpression) ;
        }
      }
      operand_34866 = operand_34866->nextObject () ;
      operand_34934 = operand_34934->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
methode_verifierType (C_Lexique & /* lexique_var_ */,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList) {
  GGS_typeCplusPlusName  var_cas_nullName ;
  var_cas_nullName = GGS_typeNullName::constructor_new () ;
  var_cas_outAllVariablesList.addAssign_operation (var_cas_nullName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeJoker * GGS_typeJoker::
    constructor_new () {
    cPtr_typeJoker * ptr_ = (cPtr_typeJoker *) NULL ;
    macroMyNew (ptr_, cPtr_typeJoker ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2)
:aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
methode_verifierType (C_Lexique & lexique_var_,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList) {
  GGS_location  var_cas_positionErreur ;
  var_cas_positionErreur = aPositionVariableCible ;
  ::routine_verifierCompatibiliteTypesSemantiques (lexique_var_,  aTypeVarDest,  var_cas_typeArgumentFormel,  var_cas_positionErreur) ;
  var_cas_listeAffectations.addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_outAllVariablesList.addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
    constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2) {
    cPtr_typeEntiteDest * ptr_ = (cPtr_typeEntiteDest *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeEntiteNonTerminal'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteNonTerminal::cPtr_typeEntiteNonTerminal (const GGS_M_nonterminalSymbolAlts & argument_0)
:mAltParametersMap (argument_0) {
}


const char * cPtr_typeEntiteNonTerminal::message_messageTypeEntite (void) const {
  return "a nonterminal symbol" ;
}

const char * cPtr_typeEntiteNonTerminal::static_string_message_messageTypeEntite (void) {
  return "a nonterminal symbol" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntiteNonTerminal'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteNonTerminal * GGS_typeEntiteNonTerminal::
    constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) {
    cPtr_typeEntiteNonTerminal * ptr_ = (cPtr_typeEntiteNonTerminal *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteNonTerminal (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3)
:mSourceFileCppName (argument_0),
mGrammarName (argument_1),
mExpressionsList (argument_2),
mAltSymbol (argument_3) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3) {
    cPtr_C_grammarInstruction * ptr_ = (cPtr_C_grammarInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1)
:mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1) {
    cPtr_typeAppendInstruction * ptr_ = (cPtr_typeAppendInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0)
:mTargetVarCppName (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0) {
    cPtr_typeIncrementInstruction * ptr_ = (cPtr_typeIncrementInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeIncrementInstruction (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeAppendInstructionWithAssignment'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstructionWithAssignment::cPtr_typeAppendInstructionWithAssignment (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2)
:mTargetVarCppName (argument_0),
mSourceExpressions (argument_1),
m_luint_TargetVarCppName (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeAppendInstructionWithAssignment'           *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAppendInstructionWithAssignment * GGS_typeAppendInstructionWithAssignment::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2) {
    cPtr_typeAppendInstructionWithAssignment * ptr_ = (cPtr_typeAppendInstructionWithAssignment *) NULL ;
    macroMyNew (ptr_, cPtr_typeAppendInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelActionExterne::cPtr_typeInstructionAppelActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_signature & argument_2)
:aNomAction (argument_0),
mExpressionsList (argument_1),
aListeTypesParametresFormels (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionAppelActionExterne * GGS_typeInstructionAppelActionExterne::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_signature & argument_2) {
    cPtr_typeInstructionAppelActionExterne * ptr_ = (cPtr_typeInstructionAppelActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelActionExterne (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
  mNextItem = (elementOf_GGS_L_matchInstructionCasesList *) NULL ;
  mCase1_name = argument_0 ;
  mCase2_name = argument_1 ;
  mInstructionsList = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList
::GGS_L_matchInstructionCasesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::~GGS_L_matchInstructionCasesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::operator = (const GGS_L_matchInstructionCasesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCase1_name,
                                p->mCase2_name,
                                p->mInstructionsList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_empty (void) {
  GGS_L_matchInstructionCasesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionsList & argument_9)
:aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
    constructor_new (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionsList & argument_9) {
    cPtr_typeMatchInstruction * ptr_ = (cPtr_typeMatchInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  mNextItem = (elementOf_GGS_foreachEnumerationList *) NULL ;
  mCppEnumeratedVariableName = argument_0 ;
  mLocationOffset = argument_1 ;
  mCppTypeName = argument_2 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList
::GGS_foreachEnumerationList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::~GGS_foreachEnumerationList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::GGS_foreachEnumerationList (const GGS_foreachEnumerationList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::operator = (const GGS_foreachEnumerationList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCppEnumeratedVariableName,
                                p->mLocationOffset,
                                p->mCppTypeName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_empty (void) {
  GGS_foreachEnumerationList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionsList & argument_2)
:mForeachEnumerationList (argument_0),
mWhileExpression (argument_1),
mInstructionsList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
    constructor_new (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
    cPtr_typeForeachInstruction * ptr_ = (cPtr_typeForeachInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4)
:aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4) {
    cPtr_typeSimpleExtractInstruction * ptr_ = (cPtr_typeSimpleExtractInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) {
  mNextItem = (elementOf_GGS_typeStructuredExtractCasesList *) NULL ;
  mClassName = argument_0 ;
  mResultVarID = argument_1 ;
  mInstructionsList = argument_2 ;
  mNoUsedParameter = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList
::GGS_typeStructuredExtractCasesList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::~GGS_typeStructuredExtractCasesList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::operator = (const GGS_typeStructuredExtractCasesList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mClassName,
                                p->mResultVarID,
                                p->mInstructionsList,
                                p->mNoUsedParameter) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_empty (void) {
  GGS_typeStructuredExtractCasesList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionsList & argument_2)
:mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
    constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
    cPtr_typeStructuredExtractInstructionWithElse * ptr_ = (cPtr_typeStructuredExtractInstructionWithElse *) NULL ;
    macroMyNew (ptr_, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1)
:aNomRoutine (argument_0),
mExpressionsList (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1) {
    cPtr_typeRoutineCallInstruction * ptr_ = (cPtr_typeRoutineCallInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0)
:aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
    constructor_new (const GGS_typeCplusPlusName & argument_0) {
    cPtr_typeDropInstruction * ptr_ = (cPtr_typeDropInstruction *) NULL ;
    macroMyNew (ptr_, cPtr_typeDropInstruction (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableNomRoutinesDeclarees'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::constructor_empty (void) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the routine '%K' is already declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (void) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate & inOperand) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
~GGS_typeEntityToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (const GGS_typeEntityToGenerate & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (cPtr_typeEntityToGenerate * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (cPtr_typeEntityToGenerate * inSource) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1)
:mName (argument_0),
mCppClassName (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
    cPtr_typeExternTypeToGenerate * ptr_ = (cPtr_typeExternTypeToGenerate *) NULL ;
    macroMyNew (ptr_, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionsList & argument_2)
:aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionsList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
    cPtr_typeRoutineAengendrer * ptr_ = (cPtr_typeRoutineAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2)
:aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2) {
    cPtr_C_listTypeToImplement * ptr_ = (cPtr_C_listTypeToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_listTypeToImplement (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6)
:aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mExternAttributesList (argument_2),
aNomClasseGenerique (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
aTableMethodesSurcharger (argument_6) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6) {
    cPtr_typeDefinitionTableAimplementer * ptr_ = (cPtr_typeDefinitionTableAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'stateMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_stateMap::
elementOf_GGS_stateMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_stateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_stateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_stateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_stateMap * info = (e_stateMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_stateMap GGS_stateMap::constructor_empty (void) {
  GGS_stateMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_stateMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_stateMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_stateMap info  ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_stateMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_stateMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) {
  searchElement (inLexique,
                 "the '%K' state is not declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_stateMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey) {
  insertElement (lexique_var_,
                 "the '%K' state is already declared",
                 inKey,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::cPtr_C_mapToImplement (const GGS_stateMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_L_nameWithType & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5)
:mStateMap (argument_0),
aNomTable (argument_1),
mNonExternAttributesList (argument_2),
mExternAttributesList (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
    constructor_new (const GGS_stateMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_L_nameWithType & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5) {
    cPtr_C_mapToImplement * ptr_ = (cPtr_C_mapToImplement *) NULL ;
    macroMyNew (ptr_, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseAbstraiteAimplementer::cPtr_typeDefClasseAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7)
:aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefClasseAbstraiteAimplementer * GGS_typeDefClasseAbstraiteAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7) {
    cPtr_typeDefClasseAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefClasseNonAbstraiteAimplementer::cPtr_typeDefClasseNonAbstraiteAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7)
:aNomClasse (argument_0),
aListeTousAttributsNonExternes (argument_1),
aTableToutesMethodes (argument_2),
mMethodsMap (argument_3),
aListeAttributsCourants (argument_4),
aListeExternesCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDefClasseNonAbstraiteAimplementer * GGS_typeDefClasseNonAbstraiteAimplementer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7) {
    cPtr_typeDefClasseNonAbstraiteAimplementer * ptr_ = (cPtr_typeDefClasseNonAbstraiteAimplementer *) NULL ;
    macroMyNew (ptr_, cPtr_typeDefClasseNonAbstraiteAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::cPtr_typeEntiteActionExterne (const GGS_L_signature & argument_0)
:aSignature (argument_0) {
}


const char * cPtr_typeEntiteActionExterne::message_messageTypeEntite (void) const {
  return "an external action" ;
}

const char * cPtr_typeEntiteActionExterne::static_string_message_messageTypeEntite (void) {
  return "an external action" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
    constructor_new (const GGS_L_signature & argument_0) {
    cPtr_typeEntiteActionExterne * ptr_ = (cPtr_typeEntiteActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeEntiteActionExterne (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_signature & argument_1)
:aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_L_signature & argument_1) {
    cPtr_typeActionExterneAengendrer * ptr_ = (cPtr_typeActionExterneAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0) {
  mNextItem = (elementOf_GGS_typeEntitiesToGenerateList *) NULL ;
  mEntityToGenerate = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList
::GGS_typeEntitiesToGenerateList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::~GGS_typeEntitiesToGenerateList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::operator = (const GGS_typeEntitiesToGenerateList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
internalAppendItem (const GGS_typeEntityToGenerate & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mEntityToGenerate) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_empty (void) {
  GGS_typeEntitiesToGenerateList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of routine "enterBuiltinTypes"                *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterBuiltinTypes (C_Lexique & lexique_var_,
                                GGS_M_semanticsEntitiesForUse  & var_cas_ioComponentSemanticsEntitiesMap) {
  var_cas_ioComponentSemanticsEntitiesMap = GGS_M_semanticsEntitiesForUse::constructor_empty () ;
  GGS_lstring  var_cas_name ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lstring"), GGS_location (lexique_var_)) ;
  GGS_AC_galgasType  var_cas_t ;
  var_cas_t = GGS_typeGalgas_lstring::constructor_new () ;
  GGS_AC_semanticsEntity  var_cas_e ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lbool"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_lbool::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "luint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_luint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lsint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_lsint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "ldouble"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_ldouble::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "lchar"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_lchar::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "location"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_location::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "uint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_uint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "sint"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_sint::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "char"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_char::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "string"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_string::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "bool"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_bool::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "double"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_double::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
  var_cas_name = GGS_lstring::constructor_new (GGS_string (true, "stringset"), GGS_location (lexique_var_)) ;
  var_cas_t = GGS_typeGalgas_stringset::constructor_new () ;
  var_cas_e = GGS_typeEntiteType::constructor_new (var_cas_t) ;
  var_cas_ioComponentSemanticsEntitiesMap.methode_insertKey (lexique_var_, var_cas_name, var_cas_e) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'typeEnumCstMessageStringMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::constructor_empty (void) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0) {
  searchElement (inLexique,
                 "the message for '%K' constant is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0) {
  insertElement (lexique_var_,
                 "the message for '%K' constant is already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2)
:mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_enumGalgasType * GGS_enumGalgasType::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) {
    cPtr_enumGalgasType * ptr_ = (cPtr_enumGalgasType *) NULL ;
    macroMyNew (ptr_, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*

