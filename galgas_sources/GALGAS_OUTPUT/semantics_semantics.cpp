//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'semantics_semantics.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       march 7th, 2007, at 14h3'24"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantics_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantics_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCplusPlusName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCplusPlusName::
cPtr_typeCplusPlusName (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCplusPlusName * GGS_typeCplusPlusName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCplusPlusName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCplusPlusName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
GGS_typeCplusPlusName (const GGS_typeCplusPlusName & inOperand) {
  mPointer = (cPtr_typeCplusPlusName *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName::
~GGS_typeCplusPlusName (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
operator = (const GGS_typeCplusPlusName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusName::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCplusPlusName) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCplusPlusName::
operator == (const GGS_typeCplusPlusName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCplusPlusName::
operator != (const GGS_typeCplusPlusName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCplusPlusName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeDirectName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectName::
cPtr_typeDirectName (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectName * GGS_typeDirectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectName * _p = dynamic_cast <const cPtr_typeDirectName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mName == _p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectName:"
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName::
GGS_typeDirectName (const GGS_typeDirectName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName::
~GGS_typeDirectName (void) {
  macroDetachPointer (mPointer, cPtr_typeDirectName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDirectName::
operator = (const GGS_typeDirectName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectName GGS_typeDirectName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectName result ;
  macroMyNew (result.mPointer, cPtr_typeDirectName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeDirectName::
reader_mName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDirectName::
operator == (const GGS_typeDirectName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDirectName::
operator != (const GGS_typeDirectName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDirectName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeCurrentObjectName'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCurrentObjectName::
cPtr_typeCurrentObjectName (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCurrentObjectName * GGS_typeCurrentObjectName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCurrentObjectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCurrentObjectName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCurrentObjectName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCurrentObjectName * _p = dynamic_cast <const cPtr_typeCurrentObjectName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mName == _p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCurrentObjectName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCurrentObjectName:"
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCurrentObjectName'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
GGS_typeCurrentObjectName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
GGS_typeCurrentObjectName (const GGS_typeCurrentObjectName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName::
~GGS_typeCurrentObjectName (void) {
  macroDetachPointer (mPointer, cPtr_typeCurrentObjectName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCurrentObjectName::
operator = (const GGS_typeCurrentObjectName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCurrentObjectName GGS_typeCurrentObjectName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeCurrentObjectName result ;
  macroMyNew (result.mPointer, cPtr_typeCurrentObjectName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCurrentObjectName::
reader_mName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCurrentObjectName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCurrentObjectName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCurrentObjectName::
operator == (const GGS_typeCurrentObjectName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCurrentObjectName::
operator != (const GGS_typeCurrentObjectName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCurrentObjectName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCurrentObjectName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeCppThisName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppThisName::
cPtr_typeCppThisName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppThisName * GGS_typeCppThisName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppThisName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppThisName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppThisName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppThisName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCppThisName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppThisName::
GGS_typeCppThisName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisName::
GGS_typeCppThisName (const GGS_typeCppThisName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisName::
~GGS_typeCppThisName (void) {
  macroDetachPointer (mPointer, cPtr_typeCppThisName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCppThisName::
operator = (const GGS_typeCppThisName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppThisName GGS_typeCppThisName::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppThisName result ;
  macroMyNew (result.mPointer, cPtr_typeCppThisName (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCppThisName::
operator == (const GGS_typeCppThisName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCppThisName::
operator != (const GGS_typeCppThisName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCppThisName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCppThisName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeCppInheritedName'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCppInheritedName::
cPtr_typeCppInheritedName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCppInheritedName * GGS_typeCppInheritedName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCppInheritedName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCppInheritedName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCppInheritedName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCppInheritedName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCppInheritedName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
GGS_typeCppInheritedName (const GGS_typeCppInheritedName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName::
~GGS_typeCppInheritedName (void) {
  macroDetachPointer (mPointer, cPtr_typeCppInheritedName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCppInheritedName::
operator = (const GGS_typeCppInheritedName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCppInheritedName GGS_typeCppInheritedName::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeCppInheritedName result ;
  macroMyNew (result.mPointer, cPtr_typeCppInheritedName (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCppInheritedName::
operator == (const GGS_typeCppInheritedName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCppInheritedName::
operator != (const GGS_typeCppInheritedName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCppInheritedName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCppInheritedName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeAutomaticName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAutomaticName::
cPtr_typeAutomaticName (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAutomaticName * GGS_typeAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAutomaticName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAutomaticName * _p = dynamic_cast <const cPtr_typeAutomaticName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mName == _p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAutomaticName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAutomaticName:"
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
GGS_typeAutomaticName (const GGS_typeAutomaticName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName::
~GGS_typeAutomaticName (void) {
  macroDetachPointer (mPointer, cPtr_typeAutomaticName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAutomaticName::
operator = (const GGS_typeAutomaticName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAutomaticName GGS_typeAutomaticName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeAutomaticName result ;
  macroMyNew (result.mPointer, cPtr_typeAutomaticName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeAutomaticName::
reader_mName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAutomaticName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAutomaticName::
operator == (const GGS_typeAutomaticName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAutomaticName::
operator != (const GGS_typeAutomaticName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAutomaticName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAutomaticName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLocationAutomaticName'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLocationAutomaticName::
cPtr_typeLocationAutomaticName (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mSequenceNumber (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLocationAutomaticName * GGS_typeLocationAutomaticName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLocationAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLocationAutomaticName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLocationAutomaticName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLocationAutomaticName * _p = dynamic_cast <const cPtr_typeLocationAutomaticName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSequenceNumber == _p->mSequenceNumber).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLocationAutomaticName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLocationAutomaticName:"
           << mSequenceNumber.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
GGS_typeLocationAutomaticName (const GGS_typeLocationAutomaticName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName::
~GGS_typeLocationAutomaticName (void) {
  macroDetachPointer (mPointer, cPtr_typeLocationAutomaticName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLocationAutomaticName::
operator = (const GGS_typeLocationAutomaticName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLocationAutomaticName GGS_typeLocationAutomaticName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLocationAutomaticName result ;
  macroMyNew (result.mPointer, cPtr_typeLocationAutomaticName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeLocationAutomaticName::
reader_mSequenceNumber (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLocationAutomaticName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLocationAutomaticName *) mPointer)->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLocationAutomaticName::
operator == (const GGS_typeLocationAutomaticName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLocationAutomaticName::
operator != (const GGS_typeLocationAutomaticName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLocationAutomaticName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLocationAutomaticName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeOperandName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOperandName::
cPtr_typeOperandName (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mName (argument_0),
mLocationOffset (argument_1),
mFieldKind (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOperandName * GGS_typeOperandName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOperandName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOperandName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOperandName * _p = dynamic_cast <const cPtr_typeOperandName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mName == _p->mName).boolValue ()
         && (mLocationOffset == _p->mLocationOffset).boolValue ()
         && (mFieldKind == _p->mFieldKind).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOperandName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOperandName:"
           << mName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFieldKind.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName::
GGS_typeOperandName (const GGS_typeOperandName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName::
~GGS_typeOperandName (void) {
  macroDetachPointer (mPointer, cPtr_typeOperandName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeOperandName::
operator = (const GGS_typeOperandName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOperandName GGS_typeOperandName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_location & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeOperandName result ;
  macroMyNew (result.mPointer, cPtr_typeOperandName (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeOperandName::
reader_mName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOperandName *) mPointer)->mName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeOperandName::
reader_mLocationOffset (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOperandName *) mPointer)->mLocationOffset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOperandName::
reader_mFieldKind (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOperandName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOperandName *) mPointer)->mFieldKind ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOperandName::
operator == (const GGS_typeOperandName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOperandName::
operator != (const GGS_typeOperandName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeOperandName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeOperandName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeKeyName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeKeyName::
cPtr_typeKeyName (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE),
mLocationOffset (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeKeyName * GGS_typeKeyName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeKeyName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeKeyName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeKeyName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeKeyName * _p = dynamic_cast <const cPtr_typeKeyName *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLocationOffset == _p->mLocationOffset).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeKeyName::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeKeyName:"
           << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName::
GGS_typeKeyName (const GGS_typeKeyName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName::
~GGS_typeKeyName (void) {
  macroDetachPointer (mPointer, cPtr_typeKeyName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeKeyName::
operator = (const GGS_typeKeyName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeKeyName GGS_typeKeyName::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeKeyName result ;
  macroMyNew (result.mPointer, cPtr_typeKeyName (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeKeyName::
reader_mLocationOffset (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeKeyName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeKeyName *) mPointer)->mLocationOffset ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKeyName::
operator == (const GGS_typeKeyName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeKeyName::
operator != (const GGS_typeKeyName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeKeyName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeKeyName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeNullName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNullName::
cPtr_typeNullName (LOCATION_ARGS)
:cPtr_typeCplusPlusName (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNullName * GGS_typeNullName::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNullName *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNullName *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNullName::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNullName::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeNullName:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName::
GGS_typeNullName (const GGS_typeNullName & inOperand)
:GGS_typeCplusPlusName () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName::
~GGS_typeNullName (void) {
  macroDetachPointer (mPointer, cPtr_typeNullName) ;
}

//---------------------------------------------------------------------------*

void GGS_typeNullName::
operator = (const GGS_typeNullName & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNullName GGS_typeNullName::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeNullName result ;
  macroMyNew (result.mPointer, cPtr_typeNullName (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeNullName::
operator == (const GGS_typeNullName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeNullName::
operator != (const GGS_typeNullName & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeNullName::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeNullName" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeCplusPlusNameList::
elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCppName (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeCplusPlusNameList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeCplusPlusNameList * _p = dynamic_cast <const elementOf_GGS_typeCplusPlusNameList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mCppName == _p->mCppName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeCplusPlusNameList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::GGS_typeCplusPlusNameList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList::
GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCplusPlusNameList::
operator == (const GGS_typeCplusPlusNameList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCplusPlusNameList::
operator != (const GGS_typeCplusPlusNameList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList GGS_typeCplusPlusNameList::
operator + (const GGS_typeCplusPlusNameList & inOperand) const {
  GGS_typeCplusPlusNameList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeCplusPlusNameList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppName ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCppName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeCplusPlusNameList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeCplusPlusNameList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCplusPlusNameList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeCplusPlusNameList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeCplusPlusNameList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExpression::
cPtr_typeExpression (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExpression * GGS_typeExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
GGS_typeExpression (const GGS_typeExpression & inOperand) {
  mPointer = (cPtr_typeExpression *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression::
~GGS_typeExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
operator = (const GGS_typeExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpression::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeExpression) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExpression::
operator == (const GGS_typeExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExpression::
operator != (const GGS_typeExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeClassMessagesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeClassMessagesMap::
elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeClassMessagesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeClassMessagesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeClassMessagesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeClassMessagesMap * _p = dynamic_cast <const elementOf_GGS_typeClassMessagesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMessage == _p->mInfo.mMessage).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeClassMessagesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeClassMessagesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeClassMessagesMap * info = (e_typeClassMessagesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeClassMessagesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
operator == (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeClassMessagesMap::
operator != (const GGS_typeClassMessagesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeClassMessagesMap info  ;
    info.mMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the message '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeClassMessagesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the message '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeClassMessagesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeClassMessagesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap GGS_typeClassMessagesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeClassMessagesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeClassMessagesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeSemanticsTypesList::
elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mGalgasVariableName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeSemanticsTypesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeSemanticsTypesList * _p = dynamic_cast <const elementOf_GGS_typeSemanticsTypesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mType == _p->mType).boolValue ()
         && (mGalgasVariableName == _p->mGalgasVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeSemanticsTypesList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::GGS_typeSemanticsTypesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList::
GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticsTypesList::
operator == (const GGS_typeSemanticsTypesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSemanticsTypesList::
operator != (const GGS_typeSemanticsTypesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList GGS_typeSemanticsTypesList::
operator + (const GGS_typeSemanticsTypesList & inOperand) const {
  GGS_typeSemanticsTypesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeSemanticsTypesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mGalgasVariableName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mGalgasVariableName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSemanticsTypesList  GGS_typeSemanticsTypesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeSemanticsTypesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSemanticsTypesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeSemanticsTypesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeSemanticsTypesList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mGalgasVariableName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.hh"

//---------------------------------------------------------------------------*

template class cGalgasVariablesMap <e_typeVariablesMap> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         Map '@typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariablesMap GGS_typeVariablesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeVariablesMap t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadOnlyAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read only mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForDestructiveReadAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in destructive read mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForReadWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in read/write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::method_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) {
  GGS_typeVariablesMap::element_type * info = searchForWriteAccess (inLexique, inKey, inKey, "the variable '%' cannot be accessed in write mode" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outIndex._drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mArgumentType ;
    outParameter1 = info->mInfo.mCplusPlusName ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertListOfEntitiesLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertListOfEntitiesLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertListOfEntitiesLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertSingleEntityLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertSingleEntityLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertSingleEntityLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertEntityAttributeLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertEntityAttributeLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertEntityAttributeLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUnusedInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUsedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadow (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedConstInArgumentNoShadow (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedConstInArgumentNoShadowGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUsedConstInArgumentNoShadow (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedConstInArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUnusedConstInArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariable (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertLocalVariableGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertLocalVariable (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutProperty (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertOutPropertyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertOutProperty (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUsedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUsedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgument (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariablesMap::modifier_insertUnusedInOutArgumentGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) {
  e_typeVariablesMap info ;
  info.mArgumentType = inParameter0 ;
  info.mCplusPlusName = inParameter1 ;
  const sint32 attributeIndex = insertUnusedInOutArgument (_inLexique, info, inKey, inKey, "the variable '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariablesMap::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeVariablesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_assignedVariables::
elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
aNomVariableCible (argument_0),
aNomAttributSource (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_assignedVariables::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_assignedVariables * _p = dynamic_cast <const elementOf_GGS_L_assignedVariables *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomVariableCible == _p->aNomVariableCible).boolValue ()
         && (aNomAttributSource == _p->aNomAttributSource).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_assignedVariables::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomVariableCible.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aNomAttributSource.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_assignedVariables::GGS_L_assignedVariables (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables::
GGS_L_assignedVariables (const GGS_L_assignedVariables & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_assignedVariables::
operator == (const GGS_L_assignedVariables & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_assignedVariables::
operator != (const GGS_L_assignedVariables & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables GGS_L_assignedVariables::
operator + (const GGS_L_assignedVariables & inOperand) const {
  GGS_L_assignedVariables result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_assignedVariables * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->aNomVariableCible ;
          GGS_lstring  p_1 = p->aNomAttributSource ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aNomVariableCible,
                                _p->aNomAttributSource
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_L_assignedVariables::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_assignedVariables result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_assignedVariables::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_assignedVariables", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_assignedVariables::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aNomVariableCible ;
    _out_1 = _p->aNomAttributSource ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCible'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCible::
cPtr_typeCible (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCible * GGS_typeCible::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCible::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCible:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
GGS_typeCible (const GGS_typeCible & inOperand) {
  mPointer = (cPtr_typeCible *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCible::
~GGS_typeCible (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
operator = (const GGS_typeCible & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCible::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCible) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCible::
operator == (const GGS_typeCible & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCible::
operator != (const GGS_typeCible & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCible::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCible" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCibles::
elementOf_GGS_typeListeCibles (const GGS_typeCible & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
aCible (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCibles::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCibles * _p = dynamic_cast <const elementOf_GGS_typeListeCibles *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aCible == _p->aCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCibles::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << aCible.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCibles::GGS_typeListeCibles (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles::
GGS_typeListeCibles (const GGS_typeListeCibles & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeCibles::
operator == (const GGS_typeListeCibles & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeCibles::
operator != (const GGS_typeListeCibles & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalAppendValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_internalPrependValues (const GGS_typeCible & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_addAssign_operation (const GGS_typeCible & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles GGS_typeListeCibles::
operator + (const GGS_typeListeCibles & inOperand) const {
  GGS_typeListeCibles result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeCibles * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCible  p_0 = p->aCible ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCible & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->aCible
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCibles  GGS_typeListeCibles::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCible & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCibles result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCibles::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeCibles", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_first (C_Lexique & _inLexique,
              GGS_typeCible & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
method_last (C_Lexique & _inLexique,
             GGS_typeCible & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeCible & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCibles::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeCible & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->aCible ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTypesEtNomsArgMethode::
elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mFormalArgumentPassingMode (argument_1),
mCppName (argument_2),
mModeIn (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeTypesEtNomsArgMethode::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeTypesEtNomsArgMethode * _p = dynamic_cast <const elementOf_GGS_typeListeTypesEtNomsArgMethode *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mType == _p->mType).boolValue ()
         && (mFormalArgumentPassingMode == _p->mFormalArgumentPassingMode).boolValue ()
         && (mCppName == _p->mCppName).boolValue ()
         && (mModeIn == _p->mModeIn).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTypesEtNomsArgMethode::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mModeIn.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::GGS_typeListeTypesEtNomsArgMethode (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode::
GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeTypesEtNomsArgMethode::
operator == (const GGS_typeListeTypesEtNomsArgMethode & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeTypesEtNomsArgMethode::
operator != (const GGS_typeListeTypesEtNomsArgMethode & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_internalAppendValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_internalPrependValues (const GGS_AC_galgasType & argument_0,
                    const GGS_formalArgumentPassingMode& argument_1,
                    const GGS_typeCplusPlusName & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode GGS_typeListeTypesEtNomsArgMethode::
operator + (const GGS_typeListeTypesEtNomsArgMethode & inOperand) const {
  GGS_typeListeTypesEtNomsArgMethode result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeTypesEtNomsArgMethode * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_AC_galgasType  p_0 = p->mType ;
          GGS_formalArgumentPassingMode p_1 = p->mFormalArgumentPassingMode ;
          GGS_typeCplusPlusName  p_2 = p->mCppName ;
          GGS_bool p_3 = p->mModeIn ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_AC_galgasType & argument_0,
                     const GGS_formalArgumentPassingMode& argument_1,
                     const GGS_typeCplusPlusName & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mFormalArgumentPassingMode,
                                _p->mCppName,
                                _p->mModeIn
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeListeTypesEtNomsArgMethode::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_AC_galgasType & argument_0,
                           const GGS_formalArgumentPassingMode& argument_1,
                           const GGS_typeCplusPlusName & argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTypesEtNomsArgMethode result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTypesEtNomsArgMethode::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeTypesEtNomsArgMethode", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_first (C_Lexique & _inLexique,
              GGS_AC_galgasType & _out_0,
              GGS_formalArgumentPassingMode& _out_1,
              GGS_typeCplusPlusName & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
method_last (C_Lexique & _inLexique,
             GGS_AC_galgasType & _out_0,
             GGS_formalArgumentPassingMode& _out_1,
             GGS_typeCplusPlusName & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_AC_galgasType & _out_0,
                 GGS_formalArgumentPassingMode& _out_1,
                 GGS_typeCplusPlusName & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTypesEtNomsArgMethode::
modifier_popLast (C_Lexique & _inLexique,
                GGS_AC_galgasType & _out_0,
                GGS_formalArgumentPassingMode& _out_1,
                GGS_typeCplusPlusName & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mFormalArgumentPassingMode ;
    _out_2 = _p->mCppName ;
    _out_3 = _p->mModeIn ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstruction::
cPtr_typeInstruction (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstruction * GGS_typeInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeInstruction::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
GGS_typeInstruction (const GGS_typeInstruction & inOperand) {
  mPointer = (cPtr_typeInstruction *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstruction::
~GGS_typeInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
operator = (const GGS_typeInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstruction::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstruction::
operator == (const GGS_typeInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstruction::
operator != (const GGS_typeInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeInstructionList::
elementOf_GGS_typeInstructionList (const GGS_typeInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeInstructionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeInstructionList * _p = dynamic_cast <const elementOf_GGS_typeInstructionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInstruction == _p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeInstructionList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionList::GGS_typeInstructionList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList::
GGS_typeInstructionList (const GGS_typeInstructionList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionList::
operator == (const GGS_typeInstructionList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionList::
operator != (const GGS_typeInstructionList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_internalAppendValues (const GGS_typeInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_internalPrependValues (const GGS_typeInstruction & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_addAssign_operation (const GGS_typeInstruction & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList GGS_typeInstructionList::
operator + (const GGS_typeInstructionList & inOperand) const {
  GGS_typeInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeInstructionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstruction  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeInstructionList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeInstruction & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeInstructionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_first (C_Lexique & _inLexique,
              GGS_typeInstruction & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
method_last (C_Lexique & _inLexique,
             GGS_typeInstruction & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeInstruction & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeInstruction & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_nameWithType::
elementOf_GGS_L_nameWithType (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mType (argument_0),
mName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_nameWithType::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_nameWithType * _p = dynamic_cast <const elementOf_GGS_L_nameWithType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mType == _p->mType).boolValue ()
         && (mName == _p->mName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_nameWithType::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mType.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_nameWithType::GGS_L_nameWithType (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType::
GGS_L_nameWithType (const GGS_L_nameWithType & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_nameWithType::
operator == (const GGS_L_nameWithType & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_nameWithType::
operator != (const GGS_L_nameWithType & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType GGS_L_nameWithType::
operator + (const GGS_L_nameWithType & inOperand) const {
  GGS_L_nameWithType result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_nameWithType * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mType ;
          GGS_lstring  p_1 = p->mName ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mType,
                                _p->mName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_nameWithType  GGS_L_nameWithType::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_nameWithType result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_nameWithType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_nameWithType", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_nameWithType::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mType ;
    _out_1 = _p->mName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableMethodesAimplementer.hh"

//---------------------------------------------------------------------------*

template class cTableMethodesAimplementer <e_typeTableMethodesAimplementer> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableMethodesAimplementer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer GGS_typeTableMethodesAimplementer::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMethodesAimplementer t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 attributeIndex = insertAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstract (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMethodesAimplementer::modifier_insertNotAbstractGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) {
  e_typeTableMethodesAimplementer info ;
  info.aListeTypesParametres = inParameter0 ;
  info.aListeTypeEtNomsArguments = inParameter1 ;
  info.mInstructionList = inParameter2 ;
  const sint32 attributeIndex = insertNotAbstract (_inLexique, info, inKey, inKey, "the method '%' is already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (attributeIndex >= 0, (uint32) attributeIndex), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMethodesAimplementer::
reader_description (C_Lexique & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<map @typeTableMethodesAimplementer " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeExpressionList::
elementOf_GGS_typeExpressionList (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeExpressionList * _p = dynamic_cast <const elementOf_GGS_typeExpressionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeExpressionList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExpressionList::GGS_typeExpressionList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList::
GGS_typeExpressionList (const GGS_typeExpressionList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExpressionList::
operator == (const GGS_typeExpressionList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExpressionList::
operator != (const GGS_typeExpressionList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalAppendValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_internalPrependValues (const GGS_typeExpression & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_addAssign_operation (const GGS_typeExpression & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList GGS_typeExpressionList::
operator + (const GGS_typeExpressionList & inOperand) const {
  GGS_typeExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mExpression ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeExpression & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeExpressionList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeExpression & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeExpressionList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExpressionList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_first (C_Lexique & _inLexique,
              GGS_typeExpression & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
method_last (C_Lexique & _inLexique,
             GGS_typeExpression & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeExpression & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeExpressionList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeExpression & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mExpression ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_varToDropList::
elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mVarToDrop (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_varToDropList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_varToDropList * _p = dynamic_cast <const elementOf_GGS_varToDropList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mVarToDrop == _p->mVarToDrop).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_varToDropList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarToDrop.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_varToDropList::GGS_varToDropList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_varToDropList::
GGS_varToDropList (const GGS_varToDropList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_varToDropList::
operator == (const GGS_varToDropList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_varToDropList::
operator != (const GGS_varToDropList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList GGS_varToDropList::
operator + (const GGS_varToDropList & inOperand) const {
  GGS_varToDropList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_varToDropList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mVarToDrop ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVarToDrop
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_varToDropList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varToDropList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varToDropList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@varToDropList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varToDropList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVarToDrop ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeErrorInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeErrorInstruction::
cPtr_typeErrorInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mErrorLocationExpression (argument_0),
mErrorMessageExpression (argument_1),
mLocation (argument_2),
mVarToDropList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeErrorInstruction * GGS_typeErrorInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeErrorInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeErrorInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeErrorInstruction * _p = dynamic_cast <const cPtr_typeErrorInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mErrorLocationExpression == _p->mErrorLocationExpression).boolValue ()
         && (mErrorMessageExpression == _p->mErrorMessageExpression).boolValue ()
         && (mLocation == _p->mLocation).boolValue ()
         && (mVarToDropList == _p->mVarToDropList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeErrorInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeErrorInstruction:"
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mVarToDropList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
GGS_typeErrorInstruction (const GGS_typeErrorInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction::
~GGS_typeErrorInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeErrorInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeErrorInstruction::
operator = (const GGS_typeErrorInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeErrorInstruction GGS_typeErrorInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2,
                 const GGS_varToDropList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeErrorInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeErrorInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorLocationExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeErrorInstruction::
reader_mErrorMessageExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mErrorMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeErrorInstruction::
reader_mLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varToDropList  GGS_typeErrorInstruction::
reader_mVarToDropList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_varToDropList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeErrorInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeErrorInstruction *) mPointer)->mVarToDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeErrorInstruction::
operator == (const GGS_typeErrorInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeErrorInstruction::
operator != (const GGS_typeErrorInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeErrorInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeErrorInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeWarningInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeWarningInstruction::
cPtr_typeWarningInstruction (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mWarningLocationExpression (argument_0),
mWarningMessageExpression (argument_1),
mLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeWarningInstruction * GGS_typeWarningInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeWarningInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeWarningInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeWarningInstruction * _p = dynamic_cast <const cPtr_typeWarningInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mWarningLocationExpression == _p->mWarningLocationExpression).boolValue ()
         && (mWarningMessageExpression == _p->mWarningMessageExpression).boolValue ()
         && (mLocation == _p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeWarningInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeWarningInstruction:"
           << mWarningLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWarningMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
GGS_typeWarningInstruction (const GGS_typeWarningInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction::
~GGS_typeWarningInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeWarningInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeWarningInstruction::
operator = (const GGS_typeWarningInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeWarningInstruction GGS_typeWarningInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeWarningInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeWarningInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningLocationExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeWarningInstruction::
reader_mWarningMessageExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mWarningMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeWarningInstruction::
reader_mLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeWarningInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeWarningInstruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeWarningInstruction::
operator == (const GGS_typeWarningInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeWarningInstruction::
operator != (const GGS_typeWarningInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeWarningInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeWarningInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeMessageInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMessageInstruction::
cPtr_typeMessageInstruction (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mMessageExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMessageInstruction * GGS_typeMessageInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMessageInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMessageInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMessageInstruction * _p = dynamic_cast <const cPtr_typeMessageInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMessageExpression == _p->mMessageExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMessageInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMessageInstruction:"
           << mMessageExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
GGS_typeMessageInstruction (const GGS_typeMessageInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction::
~GGS_typeMessageInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeMessageInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMessageInstruction::
operator = (const GGS_typeMessageInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMessageInstruction GGS_typeMessageInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeMessageInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMessageInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMessageInstruction::
reader_mMessageExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMessageInstruction::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMessageInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMessageInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMessageInstruction::
operator == (const GGS_typeMessageInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMessageInstruction::
operator != (const GGS_typeMessageInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMessageInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMessageInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeMethodCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodCallInstruction::
cPtr_typeMethodCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodCallInstruction * GGS_typeMethodCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMethodCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodCallInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodCallInstruction * _p = dynamic_cast <const cPtr_typeMethodCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomCppVariable == _p->aNomCppVariable).boolValue ()
         && (aNomMethodeSimple == _p->aNomMethodeSimple).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodCallInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMethodCallInstruction:"
           << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMethodCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
GGS_typeMethodCallInstruction (const GGS_typeMethodCallInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction::
~GGS_typeMethodCallInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeMethodCallInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMethodCallInstruction::
operator = (const GGS_typeMethodCallInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstruction GGS_typeMethodCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMethodCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMethodCallInstruction::
reader_aNomCppVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodCallInstruction::
reader_aNomMethodeSimple (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->aNomMethodeSimple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMethodCallInstruction::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMethodCallInstruction::
operator == (const GGS_typeMethodCallInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMethodCallInstruction::
operator != (const GGS_typeMethodCallInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMethodCallInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMethodCallInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeCallOfTypeMethodInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCallOfTypeMethodInstruction::
cPtr_typeCallOfTypeMethodInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTypeName (argument_0),
mTypeMethodName (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCallOfTypeMethodInstruction * GGS_typeCallOfTypeMethodInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCallOfTypeMethodInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCallOfTypeMethodInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCallOfTypeMethodInstruction * _p = dynamic_cast <const cPtr_typeCallOfTypeMethodInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTypeName == _p->mTypeName).boolValue ()
         && (mTypeMethodName == _p->mTypeMethodName).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCallOfTypeMethodInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCallOfTypeMethodInstruction:"
           << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTypeMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeCallOfTypeMethodInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
GGS_typeCallOfTypeMethodInstruction (const GGS_typeCallOfTypeMethodInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction::
~GGS_typeCallOfTypeMethodInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeCallOfTypeMethodInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCallOfTypeMethodInstruction::
operator = (const GGS_typeCallOfTypeMethodInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCallOfTypeMethodInstruction GGS_typeCallOfTypeMethodInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeCallOfTypeMethodInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeCallOfTypeMethodInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCallOfTypeMethodInstruction::
reader_mTypeMethodName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mTypeMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeCallOfTypeMethodInstruction::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCallOfTypeMethodInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCallOfTypeMethodInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCallOfTypeMethodInstruction::
operator == (const GGS_typeCallOfTypeMethodInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCallOfTypeMethodInstruction::
operator != (const GGS_typeCallOfTypeMethodInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCallOfTypeMethodInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCallOfTypeMethodInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeModifierCallInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModifierCallInstruction::
cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aNomMethodeSimple (argument_1),
mExpressionsList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModifierCallInstruction * GGS_typeModifierCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModifierCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModifierCallInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModifierCallInstruction * _p = dynamic_cast <const cPtr_typeModifierCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomCppVariable == _p->aNomCppVariable).boolValue ()
         && (aNomMethodeSimple == _p->aNomMethodeSimple).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModifierCallInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModifierCallInstruction:"
           << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeSimple.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
GGS_typeModifierCallInstruction (const GGS_typeModifierCallInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction::
~GGS_typeModifierCallInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeModifierCallInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeModifierCallInstruction::
operator = (const GGS_typeModifierCallInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModifierCallInstruction GGS_typeModifierCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeModifierCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeModifierCallInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeModifierCallInstruction::
reader_aNomCppVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeModifierCallInstruction::
reader_aNomMethodeSimple (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->aNomMethodeSimple ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeModifierCallInstruction::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModifierCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModifierCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeModifierCallInstruction::
operator == (const GGS_typeModifierCallInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeModifierCallInstruction::
operator != (const GGS_typeModifierCallInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeModifierCallInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeModifierCallInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeInstructionAppelMethodeListe'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelMethodeListe::
cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppAttribut (argument_0),
aMethodeDeListe (argument_1),
aListeNomsCppArguments (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelMethodeListe * GGS_typeInstructionAppelMethodeListe::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelMethodeListe *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelMethodeListe::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelMethodeListe * _p = dynamic_cast <const cPtr_typeInstructionAppelMethodeListe *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomCppAttribut == _p->aNomCppAttribut).boolValue ()
         && (aMethodeDeListe == _p->aMethodeDeListe).boolValue ()
         && (aListeNomsCppArguments == _p->aListeNomsCppArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelMethodeListe::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelMethodeListe:"
           << aNomCppAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aMethodeDeListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeNomsCppArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
GGS_typeInstructionAppelMethodeListe (const GGS_typeInstructionAppelMethodeListe & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe::
~GGS_typeInstructionAppelMethodeListe (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionAppelMethodeListe) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionAppelMethodeListe::
operator = (const GGS_typeInstructionAppelMethodeListe & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelMethodeListe GGS_typeInstructionAppelMethodeListe::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusNameList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelMethodeListe result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelMethodeListe (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionAppelMethodeListe::
reader_aNomCppAttribut (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aNomCppAttribut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelMethodeListe::
reader_aMethodeDeListe (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aMethodeDeListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusNameList  GGS_typeInstructionAppelMethodeListe::
reader_aListeNomsCppArguments (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusNameList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelMethodeListe *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelMethodeListe *) mPointer)->aListeNomsCppArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelMethodeListe::
operator == (const GGS_typeInstructionAppelMethodeListe & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelMethodeListe::
operator != (const GGS_typeInstructionAppelMethodeListe & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelMethodeListe::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionAppelMethodeListe" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_typeInstructionDeclarationVarLocale'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionDeclarationVarLocale::
cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomCppVariable (argument_0),
aTypeVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionDeclarationVarLocale * GGS_typeInstructionDeclarationVarLocale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionDeclarationVarLocale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionDeclarationVarLocale::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionDeclarationVarLocale * _p = dynamic_cast <const cPtr_typeInstructionDeclarationVarLocale *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomCppVariable == _p->aNomCppVariable).boolValue ()
         && (aTypeVariable == _p->aTypeVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionDeclarationVarLocale::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionDeclarationVarLocale:"
           << aNomCppVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTypeVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
GGS_typeInstructionDeclarationVarLocale (const GGS_typeInstructionDeclarationVarLocale & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale::
~GGS_typeInstructionDeclarationVarLocale (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionDeclarationVarLocale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionDeclarationVarLocale::
operator = (const GGS_typeInstructionDeclarationVarLocale & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionDeclarationVarLocale GGS_typeInstructionDeclarationVarLocale::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionDeclarationVarLocale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionDeclarationVarLocale (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeInstructionDeclarationVarLocale::
reader_aNomCppVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aNomCppVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeInstructionDeclarationVarLocale::
reader_aTypeVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionDeclarationVarLocale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionDeclarationVarLocale *) mPointer)->aTypeVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionDeclarationVarLocale::
operator == (const GGS_typeInstructionDeclarationVarLocale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionDeclarationVarLocale::
operator != (const GGS_typeInstructionDeclarationVarLocale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionDeclarationVarLocale::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionDeclarationVarLocale" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeMapBlockPrologueInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockPrologueInstruction::
cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mPrologueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockPrologueInstruction * GGS_typeMapBlockPrologueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockPrologueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockPrologueInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockPrologueInstruction * _p = dynamic_cast <const cPtr_typeMapBlockPrologueInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomVariableTable == _p->aNomVariableTable).boolValue ()
         && (aNomMethodeBloc == _p->aNomMethodeBloc).boolValue ()
         && (mPrologueExpressionList == _p->mPrologueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockPrologueInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockPrologueInstruction:"
           << aNomVariableTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPrologueExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
GGS_typeMapBlockPrologueInstruction (const GGS_typeMapBlockPrologueInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction::
~GGS_typeMapBlockPrologueInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeMapBlockPrologueInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMapBlockPrologueInstruction::
operator = (const GGS_typeMapBlockPrologueInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockPrologueInstruction GGS_typeMapBlockPrologueInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockPrologueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockPrologueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockPrologueInstruction::
reader_aNomVariableTable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockPrologueInstruction::
reader_aNomMethodeBloc (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockPrologueInstruction::
reader_mPrologueExpressionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockPrologueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockPrologueInstruction *) mPointer)->mPrologueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapBlockPrologueInstruction::
operator == (const GGS_typeMapBlockPrologueInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapBlockPrologueInstruction::
operator != (const GGS_typeMapBlockPrologueInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapBlockPrologueInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMapBlockPrologueInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeMapBlockEpilogueInstruction'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMapBlockEpilogueInstruction::
cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariableTable (argument_0),
aNomMethodeBloc (argument_1),
mEpilogueExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMapBlockEpilogueInstruction * GGS_typeMapBlockEpilogueInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMapBlockEpilogueInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMapBlockEpilogueInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMapBlockEpilogueInstruction * _p = dynamic_cast <const cPtr_typeMapBlockEpilogueInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomVariableTable == _p->aNomVariableTable).boolValue ()
         && (aNomMethodeBloc == _p->aNomMethodeBloc).boolValue ()
         && (mEpilogueExpressionList == _p->mEpilogueExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMapBlockEpilogueInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMapBlockEpilogueInstruction:"
           << aNomVariableTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeBloc.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEpilogueExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
GGS_typeMapBlockEpilogueInstruction (const GGS_typeMapBlockEpilogueInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction::
~GGS_typeMapBlockEpilogueInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeMapBlockEpilogueInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMapBlockEpilogueInstruction::
operator = (const GGS_typeMapBlockEpilogueInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMapBlockEpilogueInstruction GGS_typeMapBlockEpilogueInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMapBlockEpilogueInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMapBlockEpilogueInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMapBlockEpilogueInstruction::
reader_aNomVariableTable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomVariableTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMapBlockEpilogueInstruction::
reader_aNomMethodeBloc (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->aNomMethodeBloc ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeMapBlockEpilogueInstruction::
reader_mEpilogueExpressionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMapBlockEpilogueInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMapBlockEpilogueInstruction *) mPointer)->mEpilogueExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapBlockEpilogueInstruction::
operator == (const GGS_typeMapBlockEpilogueInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMapBlockEpilogueInstruction::
operator != (const GGS_typeMapBlockEpilogueInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMapBlockEpilogueInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMapBlockEpilogueInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeReaderCallInExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeReaderCallInExpression::
cPtr_typeReaderCallInExpression (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_location & argument_3,
                                const GGS_string& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpressionValue (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2),
mInstructionLocation (argument_3),
mConversionMethod (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeReaderCallInExpression * GGS_typeReaderCallInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeReaderCallInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeReaderCallInExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeReaderCallInExpression * _p = dynamic_cast <const cPtr_typeReaderCallInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpressionValue == _p->mExpressionValue).boolValue ()
         && (mReaderName == _p->mReaderName).boolValue ()
         && (mExpressionList == _p->mExpressionList).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue ()
         && (mConversionMethod == _p->mConversionMethod).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeReaderCallInExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeReaderCallInExpression:"
           << mExpressionValue.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReaderName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConversionMethod.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
GGS_typeReaderCallInExpression (const GGS_typeReaderCallInExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression::
~GGS_typeReaderCallInExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeReaderCallInExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeReaderCallInExpression::
operator = (const GGS_typeReaderCallInExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeReaderCallInExpression GGS_typeReaderCallInExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_location & argument_3,
                 const GGS_string& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeReaderCallInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeReaderCallInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeReaderCallInExpression::
reader_mExpressionValue (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeReaderCallInExpression::
reader_mReaderName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeReaderCallInExpression::
reader_mExpressionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeReaderCallInExpression::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_mConversionMethod (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeReaderCallInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeReaderCallInExpression *) mPointer)->mConversionMethod ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeReaderCallInExpression::
operator == (const GGS_typeReaderCallInExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeReaderCallInExpression::
operator != (const GGS_typeReaderCallInExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeReaderCallInExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeReaderCallInExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeAndOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAndOperation::
cPtr_typeAndOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAndOperation * GGS_typeAndOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAndOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAndOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAndOperation * _p = dynamic_cast <const cPtr_typeAndOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAndOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAndOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation::
GGS_typeAndOperation (const GGS_typeAndOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation::
~GGS_typeAndOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeAndOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAndOperation::
operator = (const GGS_typeAndOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAndOperation GGS_typeAndOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeAndOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAndOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAndOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAndOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAndOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAndOperation::
operator == (const GGS_typeAndOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAndOperation::
operator != (const GGS_typeAndOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAndOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAndOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeOrOperation'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeOrOperation::
cPtr_typeOrOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeOrOperation * GGS_typeOrOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeOrOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeOrOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeOrOperation * _p = dynamic_cast <const cPtr_typeOrOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeOrOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeOrOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation::
GGS_typeOrOperation (const GGS_typeOrOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation::
~GGS_typeOrOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeOrOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeOrOperation::
operator = (const GGS_typeOrOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeOrOperation GGS_typeOrOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeOrOperation result ;
  macroMyNew (result.mPointer, cPtr_typeOrOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeOrOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeOrOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeOrOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOrOperation::
operator == (const GGS_typeOrOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeOrOperation::
operator != (const GGS_typeOrOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeOrOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeOrOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeXorOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeXorOperation::
cPtr_typeXorOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeXorOperation * GGS_typeXorOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeXorOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeXorOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeXorOperation * _p = dynamic_cast <const cPtr_typeXorOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeXorOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeXorOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation::
GGS_typeXorOperation (const GGS_typeXorOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation::
~GGS_typeXorOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeXorOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeXorOperation::
operator = (const GGS_typeXorOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeXorOperation GGS_typeXorOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeXorOperation result ;
  macroMyNew (result.mPointer, cPtr_typeXorOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeXorOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeXorOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeXorOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeXorOperation::
operator == (const GGS_typeXorOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeXorOperation::
operator != (const GGS_typeXorOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeXorOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeXorOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeConcatOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConcatOperation::
cPtr_typeConcatOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConcatOperation * GGS_typeConcatOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConcatOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConcatOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConcatOperation * _p = dynamic_cast <const cPtr_typeConcatOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConcatOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConcatOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
GGS_typeConcatOperation (const GGS_typeConcatOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation::
~GGS_typeConcatOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeConcatOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConcatOperation::
operator = (const GGS_typeConcatOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConcatOperation GGS_typeConcatOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeConcatOperation result ;
  macroMyNew (result.mPointer, cPtr_typeConcatOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeConcatOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConcatOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConcatOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConcatOperation::
operator == (const GGS_typeConcatOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConcatOperation::
operator != (const GGS_typeConcatOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConcatOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConcatOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeTrueBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTrueBool::
cPtr_typeTrueBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTrueBool * GGS_typeTrueBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTrueBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTrueBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTrueBool::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTrueBool::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeTrueBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool::
GGS_typeTrueBool (const GGS_typeTrueBool & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool::
~GGS_typeTrueBool (void) {
  macroDetachPointer (mPointer, cPtr_typeTrueBool) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTrueBool::
operator = (const GGS_typeTrueBool & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTrueBool GGS_typeTrueBool::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeTrueBool result ;
  macroMyNew (result.mPointer, cPtr_typeTrueBool (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTrueBool::
operator == (const GGS_typeTrueBool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTrueBool::
operator != (const GGS_typeTrueBool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTrueBool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeTrueBool" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFalseBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFalseBool::
cPtr_typeFalseBool (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFalseBool * GGS_typeFalseBool::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFalseBool *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFalseBool *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFalseBool::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFalseBool::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFalseBool:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool::
GGS_typeFalseBool (const GGS_typeFalseBool & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool::
~GGS_typeFalseBool (void) {
  macroDetachPointer (mPointer, cPtr_typeFalseBool) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFalseBool::
operator = (const GGS_typeFalseBool & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFalseBool GGS_typeFalseBool::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFalseBool result ;
  macroMyNew (result.mPointer, cPtr_typeFalseBool (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFalseBool::
operator == (const GGS_typeFalseBool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFalseBool::
operator != (const GGS_typeFalseBool & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFalseBool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFalseBool" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralStringExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralStringExpression::
cPtr_typeLiteralStringExpression (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralStringExpression * GGS_typeLiteralStringExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralStringExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralStringExpression * _p = dynamic_cast <const cPtr_typeLiteralStringExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralString == _p->mLiteralString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralStringExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralStringExpression:"
           << mLiteralString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
GGS_typeLiteralStringExpression (const GGS_typeLiteralStringExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression::
~GGS_typeLiteralStringExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralStringExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralStringExpression::
operator = (const GGS_typeLiteralStringExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralStringExpression GGS_typeLiteralStringExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralStringExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralStringExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLiteralStringExpression::
reader_mLiteralString (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralStringExpression *) mPointer)->mLiteralString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralStringExpression::
operator == (const GGS_typeLiteralStringExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralStringExpression::
operator != (const GGS_typeLiteralStringExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralStringExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralStringExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLiteralUIntExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUIntExpression::
cPtr_typeLiteralUIntExpression (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUIntExpression * GGS_typeLiteralUIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUIntExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUIntExpression * _p = dynamic_cast <const cPtr_typeLiteralUIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralInt == _p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUIntExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUIntExpression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
GGS_typeLiteralUIntExpression (const GGS_typeLiteralUIntExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression::
~GGS_typeLiteralUIntExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralUIntExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralUIntExpression::
operator = (const GGS_typeLiteralUIntExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUIntExpression GGS_typeLiteralUIntExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeLiteralUIntExpression::
reader_mLiteralInt (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralUIntExpression::
operator == (const GGS_typeLiteralUIntExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralUIntExpression::
operator != (const GGS_typeLiteralUIntExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralUIntExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralUIntExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLiteralSIntExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSIntExpression::
cPtr_typeLiteralSIntExpression (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSIntExpression * GGS_typeLiteralSIntExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSIntExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSIntExpression * _p = dynamic_cast <const cPtr_typeLiteralSIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralInt == _p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSIntExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSIntExpression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
GGS_typeLiteralSIntExpression (const GGS_typeLiteralSIntExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression::
~GGS_typeLiteralSIntExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralSIntExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralSIntExpression::
operator = (const GGS_typeLiteralSIntExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSIntExpression GGS_typeLiteralSIntExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSIntExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_typeLiteralSIntExpression::
reader_mLiteralInt (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSIntExpression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralSIntExpression::
operator == (const GGS_typeLiteralSIntExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralSIntExpression::
operator != (const GGS_typeLiteralSIntExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralSIntExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralSIntExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralUInt64Expression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralUInt64Expression::
cPtr_typeLiteralUInt64Expression (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralUInt64Expression * GGS_typeLiteralUInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralUInt64Expression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralUInt64Expression * _p = dynamic_cast <const cPtr_typeLiteralUInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralInt == _p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralUInt64Expression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralUInt64Expression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralUInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
GGS_typeLiteralUInt64Expression (const GGS_typeLiteralUInt64Expression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression::
~GGS_typeLiteralUInt64Expression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralUInt64Expression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralUInt64Expression::
operator = (const GGS_typeLiteralUInt64Expression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralUInt64Expression GGS_typeLiteralUInt64Expression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralUInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralUInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_typeLiteralUInt64Expression::
reader_mLiteralInt (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralUInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralUInt64Expression::
operator == (const GGS_typeLiteralUInt64Expression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralUInt64Expression::
operator != (const GGS_typeLiteralUInt64Expression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralUInt64Expression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralUInt64Expression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralSInt64Expression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralSInt64Expression::
cPtr_typeLiteralSInt64Expression (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralSInt64Expression * GGS_typeLiteralSInt64Expression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralSInt64Expression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralSInt64Expression * _p = dynamic_cast <const cPtr_typeLiteralSInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralInt == _p->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralSInt64Expression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralSInt64Expression:"
           << mLiteralInt.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralSInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
GGS_typeLiteralSInt64Expression (const GGS_typeLiteralSInt64Expression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression::
~GGS_typeLiteralSInt64Expression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralSInt64Expression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralSInt64Expression::
operator = (const GGS_typeLiteralSInt64Expression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralSInt64Expression GGS_typeLiteralSInt64Expression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralSInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralSInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_typeLiteralSInt64Expression::
reader_mLiteralInt (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralSInt64Expression *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralSInt64Expression::
operator == (const GGS_typeLiteralSInt64Expression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralSInt64Expression::
operator != (const GGS_typeLiteralSInt64Expression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralSInt64Expression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralSInt64Expression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLiteralCharExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralCharExpression::
cPtr_typeLiteralCharExpression (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralCharExpression * GGS_typeLiteralCharExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralCharExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralCharExpression * _p = dynamic_cast <const cPtr_typeLiteralCharExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralChar == _p->mLiteralChar).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralCharExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralCharExpression:"
           << mLiteralChar.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
GGS_typeLiteralCharExpression (const GGS_typeLiteralCharExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression::
~GGS_typeLiteralCharExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralCharExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralCharExpression::
operator = (const GGS_typeLiteralCharExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralCharExpression GGS_typeLiteralCharExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralCharExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralCharExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeLiteralCharExpression::
reader_mLiteralChar (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralCharExpression *) mPointer)->mLiteralChar ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralCharExpression::
operator == (const GGS_typeLiteralCharExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralCharExpression::
operator != (const GGS_typeLiteralCharExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralCharExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralCharExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeLiteralDoubleExpression'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLiteralDoubleExpression::
cPtr_typeLiteralDoubleExpression (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLiteralDouble (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLiteralDoubleExpression * GGS_typeLiteralDoubleExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLiteralDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLiteralDoubleExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLiteralDoubleExpression * _p = dynamic_cast <const cPtr_typeLiteralDoubleExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLiteralDouble == _p->mLiteralDouble).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLiteralDoubleExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLiteralDoubleExpression:"
           << mLiteralDouble.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralDoubleExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
GGS_typeLiteralDoubleExpression (const GGS_typeLiteralDoubleExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression::
~GGS_typeLiteralDoubleExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeLiteralDoubleExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLiteralDoubleExpression::
operator = (const GGS_typeLiteralDoubleExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLiteralDoubleExpression GGS_typeLiteralDoubleExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLiteralDoubleExpression result ;
  macroMyNew (result.mPointer, cPtr_typeLiteralDoubleExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_typeLiteralDoubleExpression::
reader_mLiteralDouble (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLiteralDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLiteralDoubleExpression *) mPointer)->mLiteralDouble ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralDoubleExpression::
operator == (const GGS_typeLiteralDoubleExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLiteralDoubleExpression::
operator != (const GGS_typeLiteralDoubleExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLiteralDoubleExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLiteralDoubleExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeHereExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeHereExpression::
cPtr_typeHereExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeHereExpression * GGS_typeHereExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeHereExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeHereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeHereExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeHereExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeHereExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression::
GGS_typeHereExpression (const GGS_typeHereExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression::
~GGS_typeHereExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeHereExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeHereExpression::
operator = (const GGS_typeHereExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeHereExpression GGS_typeHereExpression::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeHereExpression result ;
  macroMyNew (result.mPointer, cPtr_typeHereExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeHereExpression::
operator == (const GGS_typeHereExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeHereExpression::
operator != (const GGS_typeHereExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeHereExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeHereExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeConstructorExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConstructorExpression::
cPtr_typeConstructorExpression (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mClassName (argument_0),
mClassMethodName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConstructorExpression * GGS_typeConstructorExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConstructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConstructorExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConstructorExpression * _p = dynamic_cast <const cPtr_typeConstructorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mClassName == _p->mClassName).boolValue ()
         && (mClassMethodName == _p->mClassMethodName).boolValue ()
         && (mExpressionList == _p->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConstructorExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConstructorExpression:"
           << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mClassMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
GGS_typeConstructorExpression (const GGS_typeConstructorExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression::
~GGS_typeConstructorExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeConstructorExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConstructorExpression::
operator = (const GGS_typeConstructorExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConstructorExpression GGS_typeConstructorExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_string& argument_1,
                 const GGS_typeExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeConstructorExpression result ;
  macroMyNew (result.mPointer, cPtr_typeConstructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConstructorExpression::
reader_mClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConstructorExpression::
reader_mClassMethodName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mClassMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeConstructorExpression::
reader_mExpressionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConstructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConstructorExpression *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConstructorExpression::
operator == (const GGS_typeConstructorExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConstructorExpression::
operator != (const GGS_typeConstructorExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConstructorExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConstructorExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeTestComplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTestComplement::
cPtr_typeTestComplement (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTestComplement * GGS_typeTestComplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTestComplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTestComplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTestComplement * _p = dynamic_cast <const cPtr_typeTestComplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTestComplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTestComplement:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement::
GGS_typeTestComplement (const GGS_typeTestComplement & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement::
~GGS_typeTestComplement (void) {
  macroDetachPointer (mPointer, cPtr_typeTestComplement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTestComplement::
operator = (const GGS_typeTestComplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTestComplement GGS_typeTestComplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeTestComplement result ;
  macroMyNew (result.mPointer, cPtr_typeTestComplement (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTestComplement::
reader_mExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTestComplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTestComplement *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTestComplement::
operator == (const GGS_typeTestComplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTestComplement::
operator != (const GGS_typeTestComplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTestComplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeTestComplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeLogicalNegate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogicalNegate::
cPtr_typeLogicalNegate (const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogicalNegate * GGS_typeLogicalNegate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogicalNegate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogicalNegate::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogicalNegate * _p = dynamic_cast <const cPtr_typeLogicalNegate *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogicalNegate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLogicalNegate:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeLogicalNegate'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
GGS_typeLogicalNegate (const GGS_typeLogicalNegate & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate::
~GGS_typeLogicalNegate (void) {
  macroDetachPointer (mPointer, cPtr_typeLogicalNegate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLogicalNegate::
operator = (const GGS_typeLogicalNegate & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogicalNegate GGS_typeLogicalNegate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogicalNegate result ;
  macroMyNew (result.mPointer, cPtr_typeLogicalNegate (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLogicalNegate::
reader_mExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogicalNegate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogicalNegate *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLogicalNegate::
operator == (const GGS_typeLogicalNegate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLogicalNegate::
operator != (const GGS_typeLogicalNegate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLogicalNegate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLogicalNegate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeBoolOption'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeBoolOption::
cPtr_typeBoolOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeBoolOption * GGS_typeBoolOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeBoolOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeBoolOption::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeBoolOption * _p = dynamic_cast <const cPtr_typeBoolOption *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOptionComponentName == _p->mOptionComponentName).boolValue ()
         && (mOptionName == _p->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeBoolOption::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeBoolOption:"
           << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption::
GGS_typeBoolOption (const GGS_typeBoolOption & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption::
~GGS_typeBoolOption (void) {
  macroDetachPointer (mPointer, cPtr_typeBoolOption) ;
}

//---------------------------------------------------------------------------*

void GGS_typeBoolOption::
operator = (const GGS_typeBoolOption & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeBoolOption GGS_typeBoolOption::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeBoolOption result ;
  macroMyNew (result.mPointer, cPtr_typeBoolOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeBoolOption::
reader_mOptionComponentName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeBoolOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeBoolOption::
reader_mOptionName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeBoolOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeBoolOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeBoolOption::
operator == (const GGS_typeBoolOption & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeBoolOption::
operator != (const GGS_typeBoolOption & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeBoolOption::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeBoolOption" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeUIntOption'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUIntOption::
cPtr_typeUIntOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUIntOption * GGS_typeUIntOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUIntOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUIntOption::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUIntOption * _p = dynamic_cast <const cPtr_typeUIntOption *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOptionComponentName == _p->mOptionComponentName).boolValue ()
         && (mOptionName == _p->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUIntOption::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUIntOption:"
           << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption::
GGS_typeUIntOption (const GGS_typeUIntOption & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption::
~GGS_typeUIntOption (void) {
  macroDetachPointer (mPointer, cPtr_typeUIntOption) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUIntOption::
operator = (const GGS_typeUIntOption & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUIntOption GGS_typeUIntOption::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUIntOption result ;
  macroMyNew (result.mPointer, cPtr_typeUIntOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUIntOption::
reader_mOptionComponentName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUIntOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeUIntOption::
reader_mOptionName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUIntOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUIntOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUIntOption::
operator == (const GGS_typeUIntOption & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUIntOption::
operator != (const GGS_typeUIntOption & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUIntOption::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUIntOption" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeStringOption'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStringOption::
cPtr_typeStringOption (const GGS_string& argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStringOption * GGS_typeStringOption::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStringOption *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStringOption::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStringOption * _p = dynamic_cast <const cPtr_typeStringOption *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOptionComponentName == _p->mOptionComponentName).boolValue ()
         && (mOptionName == _p->mOptionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStringOption::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStringOption:"
           << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOptionName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption::
GGS_typeStringOption (const GGS_typeStringOption & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption::
~GGS_typeStringOption (void) {
  macroDetachPointer (mPointer, cPtr_typeStringOption) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStringOption::
operator = (const GGS_typeStringOption & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStringOption GGS_typeStringOption::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_string& argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeStringOption result ;
  macroMyNew (result.mPointer, cPtr_typeStringOption (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStringOption::
reader_mOptionComponentName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStringOption *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeStringOption::
reader_mOptionName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStringOption *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStringOption *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStringOption::
operator == (const GGS_typeStringOption & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStringOption::
operator != (const GGS_typeStringOption & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStringOption::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStringOption" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeVarInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVarInExpression::
cPtr_typeVarInExpression (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mCppVarName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVarInExpression * GGS_typeVarInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeVarInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeVarInExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeVarInExpression * _p = dynamic_cast <const cPtr_typeVarInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mCppVarName == _p->mCppVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeVarInExpression::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeVarInExpression:"
           << mCppVarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
GGS_typeVarInExpression (const GGS_typeVarInExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression::
~GGS_typeVarInExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeVarInExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVarInExpression::
operator = (const GGS_typeVarInExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVarInExpression GGS_typeVarInExpression::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeVarInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeVarInExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeVarInExpression::
reader_mCppVarName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVarInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeVarInExpression *) mPointer)->mCppVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeVarInExpression::
operator == (const GGS_typeVarInExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeVarInExpression::
operator != (const GGS_typeVarInExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVarInExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeVarInExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeJokerInExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJokerInExpression::
cPtr_typeJokerInExpression (LOCATION_ARGS)
:cPtr_typeExpression (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJokerInExpression * GGS_typeJokerInExpression::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJokerInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJokerInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJokerInExpression::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJokerInExpression::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJokerInExpression:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
GGS_typeJokerInExpression (const GGS_typeJokerInExpression & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression::
~GGS_typeJokerInExpression (void) {
  macroDetachPointer (mPointer, cPtr_typeJokerInExpression) ;
}

//---------------------------------------------------------------------------*

void GGS_typeJokerInExpression::
operator = (const GGS_typeJokerInExpression & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJokerInExpression GGS_typeJokerInExpression::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJokerInExpression result ;
  macroMyNew (result.mPointer, cPtr_typeJokerInExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeJokerInExpression::
operator == (const GGS_typeJokerInExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeJokerInExpression::
operator != (const GGS_typeJokerInExpression & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeJokerInExpression::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeJokerInExpression" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeAddOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAddOperation::
cPtr_typeAddOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAddOperation * GGS_typeAddOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAddOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAddOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAddOperation * _p = dynamic_cast <const cPtr_typeAddOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAddOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAddOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation::
GGS_typeAddOperation (const GGS_typeAddOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation::
~GGS_typeAddOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeAddOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAddOperation::
operator = (const GGS_typeAddOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAddOperation GGS_typeAddOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeAddOperation result ;
  macroMyNew (result.mPointer, cPtr_typeAddOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeAddOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeAddOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAddOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAddOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAddOperation::
operator == (const GGS_typeAddOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAddOperation::
operator != (const GGS_typeAddOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAddOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAddOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeSubOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSubOperation::
cPtr_typeSubOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSubOperation * GGS_typeSubOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSubOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSubOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSubOperation * _p = dynamic_cast <const cPtr_typeSubOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSubOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSubOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation::
GGS_typeSubOperation (const GGS_typeSubOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation::
~GGS_typeSubOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeSubOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSubOperation::
operator = (const GGS_typeSubOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSubOperation GGS_typeSubOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeSubOperation result ;
  macroMyNew (result.mPointer, cPtr_typeSubOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSubOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeSubOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSubOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSubOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSubOperation::
operator == (const GGS_typeSubOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSubOperation::
operator != (const GGS_typeSubOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSubOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeSubOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeMultiplyOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMultiplyOperation::
cPtr_typeMultiplyOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMultiplyOperation * GGS_typeMultiplyOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMultiplyOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMultiplyOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMultiplyOperation * _p = dynamic_cast <const cPtr_typeMultiplyOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMultiplyOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMultiplyOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
GGS_typeMultiplyOperation (const GGS_typeMultiplyOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation::
~GGS_typeMultiplyOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeMultiplyOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMultiplyOperation::
operator = (const GGS_typeMultiplyOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMultiplyOperation GGS_typeMultiplyOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeMultiplyOperation result ;
  macroMyNew (result.mPointer, cPtr_typeMultiplyOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeMultiplyOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMultiplyOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMultiplyOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMultiplyOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMultiplyOperation::
operator == (const GGS_typeMultiplyOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMultiplyOperation::
operator != (const GGS_typeMultiplyOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMultiplyOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMultiplyOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeDivideOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDivideOperation::
cPtr_typeDivideOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDivideOperation * GGS_typeDivideOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDivideOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDivideOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDivideOperation * _p = dynamic_cast <const cPtr_typeDivideOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDivideOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDivideOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
GGS_typeDivideOperation (const GGS_typeDivideOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation::
~GGS_typeDivideOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeDivideOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDivideOperation::
operator = (const GGS_typeDivideOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDivideOperation GGS_typeDivideOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDivideOperation result ;
  macroMyNew (result.mPointer, cPtr_typeDivideOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeDivideOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDivideOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDivideOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDivideOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDivideOperation::
operator == (const GGS_typeDivideOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDivideOperation::
operator != (const GGS_typeDivideOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDivideOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDivideOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeModuloOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeModuloOperation::
cPtr_typeModuloOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeModuloOperation * GGS_typeModuloOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeModuloOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeModuloOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeModuloOperation * _p = dynamic_cast <const cPtr_typeModuloOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeModuloOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeModuloOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
GGS_typeModuloOperation (const GGS_typeModuloOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation::
~GGS_typeModuloOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeModuloOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeModuloOperation::
operator = (const GGS_typeModuloOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeModuloOperation GGS_typeModuloOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeModuloOperation result ;
  macroMyNew (result.mPointer, cPtr_typeModuloOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeModuloOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeModuloOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeModuloOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeModuloOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeModuloOperation::
operator == (const GGS_typeModuloOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeModuloOperation::
operator != (const GGS_typeModuloOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeModuloOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeModuloOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeUnaryMinusOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnaryMinusOperation::
cPtr_typeUnaryMinusOperation (const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnaryMinusOperation * GGS_typeUnaryMinusOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUnaryMinusOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUnaryMinusOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUnaryMinusOperation * _p = dynamic_cast <const cPtr_typeUnaryMinusOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUnaryMinusOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeUnaryMinusOperation:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
GGS_typeUnaryMinusOperation (const GGS_typeUnaryMinusOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation::
~GGS_typeUnaryMinusOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeUnaryMinusOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUnaryMinusOperation::
operator = (const GGS_typeUnaryMinusOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUnaryMinusOperation GGS_typeUnaryMinusOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeUnaryMinusOperation result ;
  macroMyNew (result.mPointer, cPtr_typeUnaryMinusOperation (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeUnaryMinusOperation::
reader_mExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeUnaryMinusOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnaryMinusOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnaryMinusOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUnaryMinusOperation::
operator == (const GGS_typeUnaryMinusOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUnaryMinusOperation::
operator != (const GGS_typeUnaryMinusOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUnaryMinusOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUnaryMinusOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEqualTest::
cPtr_typeEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEqualTest * GGS_typeEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEqualTest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEqualTest * _p = dynamic_cast <const cPtr_typeEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEqualTest:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest::
GGS_typeEqualTest (const GGS_typeEqualTest & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest::
~GGS_typeEqualTest (void) {
  macroDetachPointer (mPointer, cPtr_typeEqualTest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEqualTest::
operator = (const GGS_typeEqualTest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEqualTest GGS_typeEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeEqualTest::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEqualTest::
operator == (const GGS_typeEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEqualTest::
operator != (const GGS_typeEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeNonEqualTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonEqualTest::
cPtr_typeNonEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonEqualTest * GGS_typeNonEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonEqualTest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonEqualTest * _p = dynamic_cast <const cPtr_typeNonEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonEqualTest:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
GGS_typeNonEqualTest (const GGS_typeNonEqualTest & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest::
~GGS_typeNonEqualTest (void) {
  macroDetachPointer (mPointer, cPtr_typeNonEqualTest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeNonEqualTest::
operator = (const GGS_typeNonEqualTest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonEqualTest GGS_typeNonEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeNonEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeNonEqualTest::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeNonEqualTest::
operator == (const GGS_typeNonEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeNonEqualTest::
operator != (const GGS_typeNonEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeNonEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeStrictInfTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictInfTest::
cPtr_typeStrictInfTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictInfTest * GGS_typeStrictInfTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictInfTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictInfTest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictInfTest * _p = dynamic_cast <const cPtr_typeStrictInfTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictInfTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictInfTest:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
GGS_typeStrictInfTest (const GGS_typeStrictInfTest & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest::
~GGS_typeStrictInfTest (void) {
  macroDetachPointer (mPointer, cPtr_typeStrictInfTest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStrictInfTest::
operator = (const GGS_typeStrictInfTest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictInfTest GGS_typeStrictInfTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictInfTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictInfTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictInfTest::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictInfTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictInfTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStrictInfTest::
operator == (const GGS_typeStrictInfTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStrictInfTest::
operator != (const GGS_typeStrictInfTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStrictInfTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStrictInfTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeInfOrEqualTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInfOrEqualTest::
cPtr_typeInfOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInfOrEqualTest * GGS_typeInfOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInfOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInfOrEqualTest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInfOrEqualTest * _p = dynamic_cast <const cPtr_typeInfOrEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInfOrEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInfOrEqualTest:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
GGS_typeInfOrEqualTest (const GGS_typeInfOrEqualTest & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest::
~GGS_typeInfOrEqualTest (void) {
  macroDetachPointer (mPointer, cPtr_typeInfOrEqualTest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInfOrEqualTest::
operator = (const GGS_typeInfOrEqualTest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInfOrEqualTest GGS_typeInfOrEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInfOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeInfOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeInfOrEqualTest::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInfOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInfOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInfOrEqualTest::
operator == (const GGS_typeInfOrEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInfOrEqualTest::
operator != (const GGS_typeInfOrEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInfOrEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInfOrEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeStrictSupTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStrictSupTest::
cPtr_typeStrictSupTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStrictSupTest * GGS_typeStrictSupTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStrictSupTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStrictSupTest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStrictSupTest * _p = dynamic_cast <const cPtr_typeStrictSupTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStrictSupTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStrictSupTest:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
GGS_typeStrictSupTest (const GGS_typeStrictSupTest & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest::
~GGS_typeStrictSupTest (void) {
  macroDetachPointer (mPointer, cPtr_typeStrictSupTest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStrictSupTest::
operator = (const GGS_typeStrictSupTest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStrictSupTest GGS_typeStrictSupTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeStrictSupTest result ;
  macroMyNew (result.mPointer, cPtr_typeStrictSupTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeStrictSupTest::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStrictSupTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStrictSupTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStrictSupTest::
operator == (const GGS_typeStrictSupTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStrictSupTest::
operator != (const GGS_typeStrictSupTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStrictSupTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStrictSupTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeSupOrEqualTest'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSupOrEqualTest::
cPtr_typeSupOrEqualTest (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSupOrEqualTest * GGS_typeSupOrEqualTest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSupOrEqualTest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSupOrEqualTest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSupOrEqualTest * _p = dynamic_cast <const cPtr_typeSupOrEqualTest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSupOrEqualTest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSupOrEqualTest:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
GGS_typeSupOrEqualTest (const GGS_typeSupOrEqualTest & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest::
~GGS_typeSupOrEqualTest (void) {
  macroDetachPointer (mPointer, cPtr_typeSupOrEqualTest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSupOrEqualTest::
operator = (const GGS_typeSupOrEqualTest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSupOrEqualTest GGS_typeSupOrEqualTest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeSupOrEqualTest result ;
  macroMyNew (result.mPointer, cPtr_typeSupOrEqualTest (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSupOrEqualTest::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSupOrEqualTest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSupOrEqualTest *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSupOrEqualTest::
operator == (const GGS_typeSupOrEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSupOrEqualTest::
operator != (const GGS_typeSupOrEqualTest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSupOrEqualTest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeSupOrEqualTest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeLeftShiftOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLeftShiftOperation::
cPtr_typeLeftShiftOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLeftShiftOperation * GGS_typeLeftShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLeftShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLeftShiftOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLeftShiftOperation * _p = dynamic_cast <const cPtr_typeLeftShiftOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLeftShiftOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLeftShiftOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeLeftShiftOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
GGS_typeLeftShiftOperation (const GGS_typeLeftShiftOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation::
~GGS_typeLeftShiftOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeLeftShiftOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLeftShiftOperation::
operator = (const GGS_typeLeftShiftOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLeftShiftOperation GGS_typeLeftShiftOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeLeftShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeLeftShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeLeftShiftOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeLeftShiftOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLeftShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLeftShiftOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLeftShiftOperation::
operator == (const GGS_typeLeftShiftOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLeftShiftOperation::
operator != (const GGS_typeLeftShiftOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLeftShiftOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLeftShiftOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeRightShiftOperation'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRightShiftOperation::
cPtr_typeRightShiftOperation (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mLeftExpression (argument_0),
mRightExpression (argument_1),
mInstructionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRightShiftOperation * GGS_typeRightShiftOperation::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRightShiftOperation *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRightShiftOperation::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRightShiftOperation * _p = dynamic_cast <const cPtr_typeRightShiftOperation *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLeftExpression == _p->mLeftExpression).boolValue ()
         && (mRightExpression == _p->mRightExpression).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRightShiftOperation::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRightShiftOperation:"
           << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeRightShiftOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
GGS_typeRightShiftOperation (const GGS_typeRightShiftOperation & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation::
~GGS_typeRightShiftOperation (void) {
  macroDetachPointer (mPointer, cPtr_typeRightShiftOperation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeRightShiftOperation::
operator = (const GGS_typeRightShiftOperation & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRightShiftOperation GGS_typeRightShiftOperation::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRightShiftOperation result ;
  macroMyNew (result.mPointer, cPtr_typeRightShiftOperation (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mLeftExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeRightShiftOperation::
reader_mRightExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeRightShiftOperation::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRightShiftOperation *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRightShiftOperation *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRightShiftOperation::
operator == (const GGS_typeRightShiftOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRightShiftOperation::
operator != (const GGS_typeRightShiftOperation & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRightShiftOperation::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRightShiftOperation" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeTextTableCall'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeTextTableCall::
cPtr_typeTextTableCall (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeExpression (THERE),
mExpression (argument_0),
aNomMethodeTest (argument_1),
aNomCppClef (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeTextTableCall * GGS_typeTextTableCall::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeTextTableCall *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeTextTableCall::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeTextTableCall * _p = dynamic_cast <const cPtr_typeTextTableCall *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mExpression == _p->mExpression).boolValue ()
         && (aNomMethodeTest == _p->aNomMethodeTest).boolValue ()
         && (aNomCppClef == _p->aNomCppClef).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeTextTableCall::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeTextTableCall:"
           << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMethodeTest.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppClef.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
GGS_typeTextTableCall (const GGS_typeTextTableCall & inOperand)
:GGS_typeExpression () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall::
~GGS_typeTextTableCall (void) {
  macroDetachPointer (mPointer, cPtr_typeTextTableCall) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTextTableCall::
operator = (const GGS_typeTextTableCall & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeTextTableCall GGS_typeTextTableCall::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeCplusPlusName & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeTextTableCall result ;
  macroMyNew (result.mPointer, cPtr_typeTextTableCall (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeTextTableCall::
reader_mExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeTextTableCall::
reader_aNomMethodeTest (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomMethodeTest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeTextTableCall::
reader_aNomCppClef (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeTextTableCall *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeTextTableCall *) mPointer)->aNomCppClef ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTextTableCall::
operator == (const GGS_typeTextTableCall & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTextTableCall::
operator != (const GGS_typeTextTableCall & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTextTableCall::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeTextTableCall" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_C_assignmentInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_assignmentInstruction::
cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_assignmentInstruction * GGS_C_assignmentInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_assignmentInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_assignmentInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_assignmentInstruction * _p = dynamic_cast <const cPtr_C_assignmentInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mSourceExpression == _p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_assignmentInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_assignmentInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
GGS_C_assignmentInstruction (const GGS_C_assignmentInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction::
~GGS_C_assignmentInstruction (void) {
  macroDetachPointer (mPointer, cPtr_C_assignmentInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_assignmentInstruction::
operator = (const GGS_C_assignmentInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_assignmentInstruction GGS_C_assignmentInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_assignmentInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_assignmentInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_assignmentInstruction::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_assignmentInstruction::
reader_mSourceExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_assignmentInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_assignmentInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_assignmentInstruction::
operator == (const GGS_C_assignmentInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_assignmentInstruction::
operator != (const GGS_C_assignmentInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_assignmentInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_assignmentInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_dotEqualInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_dotEqualInstruction::
cPtr_C_dotEqualInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpression (argument_1),
mSourceExpressionConverter (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_dotEqualInstruction * GGS_C_dotEqualInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_dotEqualInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_dotEqualInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_dotEqualInstruction * _p = dynamic_cast <const cPtr_C_dotEqualInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mSourceExpression == _p->mSourceExpression).boolValue ()
         && (mSourceExpressionConverter == _p->mSourceExpressionConverter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_dotEqualInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_dotEqualInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressionConverter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_dotEqualInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
GGS_C_dotEqualInstruction (const GGS_C_dotEqualInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction::
~GGS_C_dotEqualInstruction (void) {
  macroDetachPointer (mPointer, cPtr_C_dotEqualInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_dotEqualInstruction::
operator = (const GGS_C_dotEqualInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_dotEqualInstruction GGS_C_dotEqualInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_dotEqualInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_dotEqualInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_dotEqualInstruction::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_dotEqualInstruction::
reader_mSourceExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_dotEqualInstruction::
reader_mSourceExpressionConverter (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_dotEqualInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_dotEqualInstruction *) mPointer)->mSourceExpressionConverter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_dotEqualInstruction::
operator == (const GGS_C_dotEqualInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_dotEqualInstruction::
operator != (const GGS_C_dotEqualInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_dotEqualInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_dotEqualInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       abstract class 'cPtr_C_declarationInstructionWithAssignment'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_declarationInstructionWithAssignment::
cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableType (argument_0),
mTargetVarCppName (argument_1),
mSourceExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_declarationInstructionWithAssignment * GGS_C_declarationInstructionWithAssignment::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_declarationInstructionWithAssignment *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_declarationInstructionWithAssignment::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_declarationInstructionWithAssignment * _p = dynamic_cast <const cPtr_C_declarationInstructionWithAssignment *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mVariableType == _p->mVariableType).boolValue ()
         && (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mSourceExpression == _p->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_declarationInstructionWithAssignment::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_declarationInstructionWithAssignment:"
           << mVariableType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
GGS_C_declarationInstructionWithAssignment (const GGS_C_declarationInstructionWithAssignment & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment::
~GGS_C_declarationInstructionWithAssignment (void) {
  macroDetachPointer (mPointer, cPtr_C_declarationInstructionWithAssignment) ;
}

//---------------------------------------------------------------------------*

void GGS_C_declarationInstructionWithAssignment::
operator = (const GGS_C_declarationInstructionWithAssignment & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_declarationInstructionWithAssignment GGS_C_declarationInstructionWithAssignment::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_typeExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_declarationInstructionWithAssignment result ;
  macroMyNew (result.mPointer, cPtr_C_declarationInstructionWithAssignment (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_C_declarationInstructionWithAssignment::
reader_mVariableType (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mVariableType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_declarationInstructionWithAssignment::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_declarationInstructionWithAssignment::
reader_mSourceExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_declarationInstructionWithAssignment *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_declarationInstructionWithAssignment *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_declarationInstructionWithAssignment::
operator == (const GGS_C_declarationInstructionWithAssignment & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_declarationInstructionWithAssignment::
operator != (const GGS_C_declarationInstructionWithAssignment & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_declarationInstructionWithAssignment::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_declarationInstructionWithAssignment" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_while_instruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_while_instruction::
cPtr_C_while_instruction (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariantExpression (argument_0),
mInstructionList1 (argument_1),
mWhileExpression (argument_2),
mInstructionList2 (argument_3),
mLocation (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_while_instruction * GGS_C_while_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_while_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_while_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_while_instruction * _p = dynamic_cast <const cPtr_C_while_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mVariantExpression == _p->mVariantExpression).boolValue ()
         && (mInstructionList1 == _p->mInstructionList1).boolValue ()
         && (mWhileExpression == _p->mWhileExpression).boolValue ()
         && (mInstructionList2 == _p->mInstructionList2).boolValue ()
         && (mLocation == _p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_while_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_while_instruction:"
           << mVariantExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction::
GGS_C_while_instruction (const GGS_C_while_instruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction::
~GGS_C_while_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_while_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_while_instruction::
operator = (const GGS_C_while_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_while_instruction GGS_C_while_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_typeInstructionList & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_while_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_while_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mVariantExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_while_instruction::
reader_mWhileExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_while_instruction::
reader_mInstructionList2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mInstructionList2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_while_instruction::
reader_mLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_while_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_while_instruction *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_while_instruction::
operator == (const GGS_C_while_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_while_instruction::
operator != (const GGS_C_while_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_while_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_while_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_expression_instructionsList_list::
elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mIFexpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_expression_instructionsList_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_expression_instructionsList_list * _p = dynamic_cast <const elementOf_GGS_L_expression_instructionsList_list *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIFexpression == _p->mIFexpression).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_expression_instructionsList_list::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::GGS_L_expression_instructionsList_list (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list::
GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_expression_instructionsList_list::
operator == (const GGS_L_expression_instructionsList_list & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_expression_instructionsList_list::
operator != (const GGS_L_expression_instructionsList_list & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalAppendValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_internalPrependValues (const GGS_typeExpression & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list GGS_L_expression_instructionsList_list::
operator + (const GGS_L_expression_instructionsList_list & inOperand) const {
  GGS_L_expression_instructionsList_list result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_expression_instructionsList_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeExpression  p_0 = p->mIFexpression ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeExpression & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mIFexpression,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_L_expression_instructionsList_list::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeExpression & argument_0,
                           const GGS_typeInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_expression_instructionsList_list result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_expression_instructionsList_list::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_expression_instructionsList_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_first (C_Lexique & _inLexique,
              GGS_typeExpression & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
method_last (C_Lexique & _inLexique,
             GGS_typeExpression & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeExpression & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_expression_instructionsList_list::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeExpression & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mIFexpression ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_if_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_if_instruction::
cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_if_instruction * GGS_C_if_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_if_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_if_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_if_instruction * _p = dynamic_cast <const cPtr_C_if_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIFbranchesList == _p->mIFbranchesList).boolValue ()
         && (mElseInstructionsList == _p->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_if_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_if_instruction:"
           << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction::
GGS_C_if_instruction (const GGS_C_if_instruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction::
~GGS_C_if_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_if_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_if_instruction::
operator = (const GGS_C_if_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_if_instruction GGS_C_if_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_if_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_if_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_if_instruction::
reader_mIFbranchesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_if_instruction::
reader_mElseInstructionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_if_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_if_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_if_instruction::
operator == (const GGS_C_if_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_if_instruction::
operator != (const GGS_C_if_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_if_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_if_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_switchBranchlist'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_switchBranchlist::
elementOf_GGS_L_switchBranchlist (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mConstantSet (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_switchBranchlist::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_switchBranchlist * _p = dynamic_cast <const elementOf_GGS_L_switchBranchlist *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mConstantSet == _p->mConstantSet).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_switchBranchlist::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantSet.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@L_switchBranchlist'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_switchBranchlist::GGS_L_switchBranchlist (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist::
GGS_L_switchBranchlist (const GGS_L_switchBranchlist & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_switchBranchlist::
operator == (const GGS_L_switchBranchlist & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_switchBranchlist::
operator != (const GGS_L_switchBranchlist & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalAppendValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_internalPrependValues (const GGS_stringset & argument_0,
                    const GGS_typeInstructionList & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_addAssign_operation (const GGS_stringset & argument_0,
                                const GGS_typeInstructionList & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist GGS_L_switchBranchlist::
operator + (const GGS_L_switchBranchlist & inOperand) const {
  GGS_L_switchBranchlist result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_switchBranchlist * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_stringset  p_0 = p->mConstantSet ;
          GGS_typeInstructionList  p_1 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_stringset & argument_0,
                     const GGS_typeInstructionList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mConstantSet,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_L_switchBranchlist::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_stringset & argument_0,
                           const GGS_typeInstructionList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_switchBranchlist result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_switchBranchlist::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_switchBranchlist", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_first (C_Lexique & _inLexique,
              GGS_stringset & _out_0,
              GGS_typeInstructionList & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
method_last (C_Lexique & _inLexique,
             GGS_stringset & _out_0,
             GGS_typeInstructionList & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_stringset & _out_0,
                 GGS_typeInstructionList & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_switchBranchlist::
modifier_popLast (C_Lexique & _inLexique,
                GGS_stringset & _out_0,
                GGS_typeInstructionList & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mConstantSet ;
    _out_1 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_switch_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_switch_instruction::
cPtr_C_switch_instruction (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSwitchExpression (argument_0),
mEnumTypeName (argument_1),
mBranchList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_switch_instruction * GGS_C_switch_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_switch_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_switch_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_switch_instruction * _p = dynamic_cast <const cPtr_C_switch_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSwitchExpression == _p->mSwitchExpression).boolValue ()
         && (mEnumTypeName == _p->mEnumTypeName).boolValue ()
         && (mBranchList == _p->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_switch_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_switch_instruction:"
           << mSwitchExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_switch_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
GGS_C_switch_instruction (const GGS_C_switch_instruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction::
~GGS_C_switch_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_switch_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_switch_instruction::
operator = (const GGS_C_switch_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_switch_instruction GGS_C_switch_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_switchBranchlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_switch_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_switch_instruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_switch_instruction::
reader_mSwitchExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_switch_instruction::
reader_mEnumTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_switchBranchlist  GGS_C_switch_instruction::
reader_mBranchList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_switchBranchlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_switch_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_switch_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_switch_instruction::
operator == (const GGS_C_switch_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_switch_instruction::
operator != (const GGS_C_switch_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_switch_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_switch_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableRoutinesAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableRoutinesAimplementer::
elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableRoutinesAimplementer & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableRoutinesAimplementer::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableRoutinesAimplementer::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableRoutinesAimplementer::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableRoutinesAimplementer *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeTableRoutinesAimplementer * info = (e_typeTableRoutinesAimplementer *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableRoutinesAimplementer info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
operator == (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableRoutinesAimplementer::
operator != (const GGS_typeTableRoutinesAimplementer & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableRoutinesAimplementer info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableRoutinesAimplementer::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableRoutinesAimplementer GGS_typeTableRoutinesAimplementer::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableRoutinesAimplementer result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableRoutinesAimplementer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableRoutinesAimplementer " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableAttributsSemantiques'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableAttributsSemantiques::
elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableAttributsSemantiques & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableAttributsSemantiques::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aNomCppAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableAttributsSemantiques::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableAttributsSemantiques * _p = dynamic_cast <const elementOf_GGS_typeTableAttributsSemantiques *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aNomCppAttribut == _p->mInfo.aNomCppAttribut).boolValue ()
           && (mInfo.mAttributType == _p->mInfo.mAttributType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableAttributsSemantiques::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableAttributsSemantiques *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeTableAttributsSemantiques * info = (e_typeTableAttributsSemantiques *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableAttributsSemantiques info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
operator == (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableAttributsSemantiques::
operator != (const GGS_typeTableAttributsSemantiques & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeCplusPlusName & inParameter0,
                const GGS_AC_galgasType & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableAttributsSemantiques info  ;
    info.aNomCppAttribut = inParameter0 ;
    info.mAttributType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeCplusPlusName   & outParameter0,
               GGS_AC_galgasType   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aNomCppAttribut ;
    outParameter1 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the attribute '%K' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableAttributsSemantiques::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName & inParameter0,
                                const GGS_AC_galgasType & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the attribute '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableAttributsSemantiques & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableAttributsSemantiques GGS_typeTableAttributsSemantiques::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableAttributsSemantiques result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableAttributsSemantiques::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableAttributsSemantiques " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "buildMapWithLocalConstants"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildMapWithLocalConstants (C_Lexique & _inLexique,
                                GGS_L_nameWithType   var_cas_inLocalDeclarationsList,
                                GGS_typeListeAttributsSemantiques   var_cas_inSemanticAttributsList,
                                GGS_typeVariablesMap  & var_cas_ioVariablesMap,
                                GGS_location   var_cas_inLocation,
                                GGS_localConstantBuildStyleEnum  var_cas_inLocalConstantStyle,
                                GGS_bool  var_cas_inEllipsisFound COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildMapWithLocalConstants at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_bool var_cas_mapStyle ;
  var_cas_mapStyle = (var_cas_inLocalConstantStyle) != (GGS_localConstantBuildStyleEnum::constructor_listStyle (_inLexique COMMA_HERE)) ;
  GGS_bool var_cas_firstOne ;
  var_cas_firstOne = GGS_bool (true, true) ;
  GGS_L_nameWithType::element_type * operand_32789 = var_cas_inLocalDeclarationsList.firstObject () ;
  GGS_typeListeAttributsSemantiques::element_type * operand_32874 = var_cas_inSemanticAttributsList.firstObject () ;
  while ((operand_32789 != NULL)
      && (operand_32874 != NULL)) {
    macroValidPointer (operand_32789) ;
    macroValidPointer (operand_32874) ;
    if (((operand_32789->mName.reader_string (_inLexique SOURCE_FILE_AT_LINE (801))) != (GGS_string (true, ""))).isBuiltAndTrue ()) {
      GGS_string var_cas_typeName ;
      if (operand_32874->mAttributType._isBuilt ()) {
        operand_32874->mAttributType (HERE)->method_getTypeName (_inLexique, var_cas_typeName SOURCE_FILE_AT_LINE (803)) ;
      }
      if (((operand_32789->mType.reader_string (_inLexique SOURCE_FILE_AT_LINE (804))) == (var_cas_typeName)).isBuiltAndTrue ()) {
        GGS_typeCplusPlusName  var_cas_cppName ;
        if (((((var_cas_inLocalConstantStyle) == (GGS_localConstantBuildStyleEnum::constructor_firstIsKeyOtherMapStyle (_inLexique COMMA_HERE))) & (var_cas_firstOne))).isBuiltAndTrue ()) {
          var_cas_cppName = GGS_typeKeyName::constructor_new (_inLexique, var_cas_inLocation COMMA_HERE) ;
        }else{
          var_cas_cppName = GGS_typeOperandName::constructor_new (_inLexique, operand_32874->aNomAttribut, var_cas_inLocation, var_cas_mapStyle COMMA_HERE) ;
        }
        var_cas_ioVariablesMap.modifier_insertUsedConstInArgument (_inLexique, operand_32789->mName, operand_32874->mAttributType, var_cas_cppName SOURCE_FILE_AT_LINE (811)) ;
      }else{
        operand_32789->mType.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "I have found the '@")) + (operand_32789->mType.reader_string (_inLexique SOURCE_FILE_AT_LINE (813))))) + (GGS_string (true, "' type, I was expected the '@")))) + (var_cas_typeName))) + (GGS_string (true, "' type"))) SOURCE_FILE_AT_LINE (815)) ;
      }
    }
    var_cas_firstOne = GGS_bool (true, false) ;
    operand_32789 = operand_32789->nextObject () ;
    operand_32874 = operand_32874->nextObject () ;
  }
  if (((((var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (820))) < (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (820)))) & ((! (var_cas_inEllipsisFound))))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "one or more parameters missing: found ")) + (var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (822)).reader_string (_inLexique SOURCE_FILE_AT_LINE (822))))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (823)).reader_string (_inLexique SOURCE_FILE_AT_LINE (823))))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (824)) ;
  }else if (((var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (824))) > (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (824)))).isBuiltAndTrue ()) {
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((((((GGS_string (true, "too much parameters: found ")) + (var_cas_inLocalDeclarationsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (826)).reader_string (_inLexique SOURCE_FILE_AT_LINE (826))))) + (GGS_string (true, " effective parameters, while ")))) + (var_cas_inSemanticAttributsList.reader_length (_inLexique SOURCE_FILE_AT_LINE (827)).reader_string (_inLexique SOURCE_FILE_AT_LINE (827))))) + (GGS_string (true, " are needed"))) SOURCE_FILE_AT_LINE (828)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildMapWithLocalConstants\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "verifierCompatibiliteTypes"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteTypes (C_Lexique & _inLexique,
                                const GGS_typeSemanticsTypesList  & var_cas_t1,
                                const GGS_typeListeAttributsSemantiques  & var_cas_t2,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (843))) < (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (843)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more identifiers missing") SOURCE_FILE_AT_LINE (845)) ;
  }else if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (845))) > (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (845)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much identifiers") SOURCE_FILE_AT_LINE (847)) ;
  }else{
    GGS_typeSemanticsTypesList::element_type * operand_35180 = var_cas_t1.firstObject () ;
    GGS_typeListeAttributsSemantiques::element_type * operand_35261 = var_cas_t2.firstObject () ;
    while ((operand_35180 != NULL)
        && (operand_35261 != NULL)) {
      macroValidPointer (operand_35180) ;
      macroValidPointer (operand_35261) ;
      ::routine_checkAssignmentTypesCompatibility (_inLexique, operand_35180->mType, operand_35261->mAttributType, operand_35180->mGalgasVariableName.reader_location (_inLexique SOURCE_FILE_AT_LINE (853)), GGS_bool (true, false) SOURCE_FILE_AT_LINE (850)) ;
      operand_35180 = operand_35180->nextObject () ;
      operand_35261 = operand_35261->nextObject () ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Implementation of routine "verifierCompatibiliteArgEffectifsSignature"   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique & _inLexique,
                                const GGS_L_EXsignature  & var_cas_signatureReference,
                                const GGS_L_actualParametersSignature  & var_cas_inEffectiveArgumentsSignature,
                                const GGS_location  & var_cas_inErrorLocation,
                                GGS_typeInstructionList  & var_cas_ioInstructionsList,
                                GGS_typeExpressionList  & var_cas_ioExpressionList COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierCompatibiliteArgEffectifsSignature at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (873))) > (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (873)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more arguments missing") SOURCE_FILE_AT_LINE (875)) ;
  }else if (((var_cas_signatureReference.reader_length (_inLexique SOURCE_FILE_AT_LINE (875))) < (var_cas_inEffectiveArgumentsSignature.reader_length (_inLexique SOURCE_FILE_AT_LINE (875)))).isBuiltAndTrue ()) {
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much arguments") SOURCE_FILE_AT_LINE (877)) ;
  }else{
    GGS_L_EXsignature::element_type * operand_36534 = var_cas_signatureReference.firstObject () ;
    GGS_L_actualParametersSignature::element_type * operand_36659 = var_cas_inEffectiveArgumentsSignature.firstObject () ;
    while ((operand_36534 != NULL)
        && (operand_36659 != NULL)) {
      macroValidPointer (operand_36534) ;
      macroValidPointer (operand_36659) ;
      if (operand_36534->mFormalArgumentPassingMode._isBuilt () && operand_36659->mFormalArgumentPassingMode._isBuilt ()) {
        if ((operand_36534->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentConstantIn) && (operand_36659->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
          ::routine_checkAssignmentTypesCompatibility (_inLexique, operand_36534->mType, operand_36659->mType, var_cas_inErrorLocation, GGS_bool (true, true) SOURCE_FILE_AT_LINE (883)) ;
        }else{
          if ((operand_36534->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentIn) && (operand_36659->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOut)) {
            ::routine_checkAssignmentTypesCompatibility (_inLexique, operand_36534->mType, operand_36659->mType, var_cas_inErrorLocation, GGS_bool (true, true) SOURCE_FILE_AT_LINE (885)) ;
          }else{
            if ((operand_36534->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentInOut) && (operand_36659->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterOutIn)) {
              ::routine_checkAssignmentTypesCompatibility (_inLexique, operand_36534->mType, operand_36659->mType, var_cas_inErrorLocation, GGS_bool (true, false) SOURCE_FILE_AT_LINE (887)) ;
            }else{
              if ((operand_36534->mFormalArgumentPassingMode.enumValue () == GGS_formalArgumentPassingMode::enum_argumentOut) && (operand_36659->mFormalArgumentPassingMode.enumValue () == GGS_actualParametersPassingMode::enum_parameterIn)) {
                if (operand_36659->mType._isBuilt ()) {
                  cPtr_typeGalgas_jokerInParameterList * operand_37333 = dynamic_cast <cPtr_typeGalgas_jokerInParameterList *> (operand_36659->mType.getPtr ()) ;
                  if (operand_37333 != NULL) {
                    macroValidPointer (operand_37333) ; 
                  }else{ // Else part
                    ::routine_checkAssignmentTypesCompatibility (_inLexique, operand_36534->mType, operand_36659->mType, var_cas_inErrorLocation, GGS_bool (true, false) SOURCE_FILE_AT_LINE (892)) ;
                  }
                }
              }else{
                var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((operand_36659->mFormalArgumentPassingMode.reader_actualArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (895))) + (GGS_string (true, " is not compatible with ")))) + (operand_36534->mFormalArgumentPassingMode.reader_formalArgumentMessage (_inLexique SOURCE_FILE_AT_LINE (896)))) SOURCE_FILE_AT_LINE (897)) ;
              }
            }
          }
        }
      }
      operand_36534 = operand_36534->nextObject () ;
      operand_36659 = operand_36659->nextObject () ;
    }
    GGS_typeExpressionList  var_cas_expressionList ;
    var_cas_expressionList = var_cas_ioExpressionList ;
    var_cas_ioExpressionList = GGS_typeExpressionList::constructor_emptyList (_inLexique COMMA_HERE) ;
    GGS_L_EXsignature::element_type * operand_37926 = var_cas_signatureReference.firstObject () ;
    GGS_typeExpressionList::element_type * operand_37990 = var_cas_expressionList.firstObject () ;
    while ((operand_37926 != NULL)
        && (operand_37990 != NULL)) {
      macroValidPointer (operand_37926) ;
      macroValidPointer (operand_37990) ;
      if (operand_37990->mExpression._isBuilt ()) {
        cPtr_typeJokerInExpression * operand_38073 = dynamic_cast <cPtr_typeJokerInExpression *> (operand_37990->mExpression.getPtr ()) ;
        if (operand_38073 != NULL) {
          macroValidPointer (operand_38073) ; 
          GGS_typeCplusPlusName  var_cas_cppVarName ;
          var_cas_cppVarName = GGS_typeLocationAutomaticName::constructor_new (_inLexique, GGS_uint::constructor_sequenceNumber (_inLexique COMMA_HERE) COMMA_HERE) ;
          GGS_typeExpression  var_cas_e ;
          var_cas_e = GGS_typeVarInExpression::constructor_new (_inLexique, var_cas_cppVarName COMMA_HERE) ;
          var_cas_ioExpressionList._addAssign_operation (var_cas_e) ;
          GGS_typeInstruction  var_cas_i ;
          var_cas_i = GGS_typeInstructionDeclarationVarLocale::constructor_new (_inLexique, var_cas_cppVarName, operand_37926->mType COMMA_HERE) ;
          var_cas_ioInstructionsList._addAssign_operation (var_cas_i) ;
        }else{ // Else part
          var_cas_ioExpressionList._addAssign_operation (operand_37990->mExpression) ;
        }
      }
      operand_37926 = operand_37926->nextObject () ;
      operand_37990 = operand_37990->nextObject () ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierCompatibiliteArgEffectifsSignature\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeJoker'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeJoker::
cPtr_typeJoker (LOCATION_ARGS)
:cPtr_typeCible (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeJoker * GGS_typeJoker::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeJoker *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeJoker *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeJoker::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
method_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  /* var_cas_typeArgumentFormel */,
                                GGS_lstring & /* var_cas_nomAttributSource */,
                                GGS_L_assignedVariables & /* var_cas_listeAffectations */,
                                GGS_typeCplusPlusNameList & var_cas_outAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  var_cas_outAllVariablesList._addAssign_operation (GGS_typeNullName::constructor_new (_inLexique COMMA_HERE)) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeJoker::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeJoker:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker::
GGS_typeJoker (const GGS_typeJoker & inOperand)
:GGS_typeCible () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker::
~GGS_typeJoker (void) {
  macroDetachPointer (mPointer, cPtr_typeJoker) ;
}

//---------------------------------------------------------------------------*

void GGS_typeJoker::
operator = (const GGS_typeJoker & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeJoker GGS_typeJoker::
constructor_new (C_Lexique & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeJoker result ;
  macroMyNew (result.mPointer, cPtr_typeJoker (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeJoker::
operator == (const GGS_typeJoker & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeJoker::
operator != (const GGS_typeJoker & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeJoker::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeJoker" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeEntiteDest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteDest::
cPtr_typeEntiteDest (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeCible (THERE),
aTypeVarDest (argument_0),
mCppName (argument_1),
aPositionVariableCible (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteDest * GGS_typeEntiteDest::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteDest *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteDest::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteDest * _p = dynamic_cast <const cPtr_typeEntiteDest *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aTypeVarDest == _p->aTypeVarDest).boolValue ()
         && (mCppName == _p->mCppName).boolValue ()
         && (aPositionVariableCible == _p->aPositionVariableCible).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
method_verifierType (C_Lexique & _inLexique,
                                GGS_AC_galgasType  var_cas_typeArgumentFormel,
                                GGS_lstring & var_cas_nomAttributSource,
                                GGS_L_assignedVariables & var_cas_listeAffectations,
                                GGS_typeCplusPlusNameList & var_cas_ioAllVariablesList COMMA_UNUSED_LOCATION_ARGS) {
  ::routine_checkAssignmentTypesCompatibility (_inLexique, aTypeVarDest, var_cas_typeArgumentFormel, aPositionVariableCible, GGS_bool (true, false) SOURCE_FILE_AT_LINE (949)) ;
  var_cas_listeAffectations._addAssign_operation (mCppName, var_cas_nomAttributSource) ;
  var_cas_ioAllVariablesList._addAssign_operation (mCppName) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteDest::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteDest:"
           << aTypeVarDest.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aPositionVariableCible.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
GGS_typeEntiteDest (const GGS_typeEntiteDest & inOperand)
:GGS_typeCible () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest::
~GGS_typeEntiteDest (void) {
  macroDetachPointer (mPointer, cPtr_typeEntiteDest) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntiteDest::
operator = (const GGS_typeEntiteDest & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteDest GGS_typeEntiteDest::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_AC_galgasType & argument_0,
                 const GGS_typeCplusPlusName & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteDest result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteDest (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeEntiteDest::
reader_aTypeVarDest (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aTypeVarDest ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeEntiteDest::
reader_mCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->mCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeEntiteDest::
reader_aPositionVariableCible (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteDest *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteDest *) mPointer)->aPositionVariableCible ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteDest::
operator == (const GGS_typeEntiteDest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteDest::
operator != (const GGS_typeEntiteDest & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteDest::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntiteDest" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@M_nonTerminalSymbolForSyntax'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_nonTerminalSymbolForSyntax::
elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_nonTerminalSymbolForSyntax & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_nonTerminalSymbolForSyntax::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAltParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_nonTerminalSymbolForSyntax::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_nonTerminalSymbolForSyntax * _p = dynamic_cast <const elementOf_GGS_M_nonTerminalSymbolForSyntax *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAltParametersMap == _p->mInfo.mAltParametersMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_nonTerminalSymbolForSyntax::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_nonTerminalSymbolForSyntax *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_M_nonTerminalSymbolForSyntax * info = (e_M_nonTerminalSymbolForSyntax *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_nonTerminalSymbolForSyntax info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
operator == (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_nonTerminalSymbolForSyntax::
operator != (const GGS_M_nonTerminalSymbolForSyntax & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_M_nonterminalSymbolAlts & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_nonTerminalSymbolForSyntax info  ;
    info.mAltParametersMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_M_nonterminalSymbolAlts   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAltParametersMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' non terminal symbol is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_nonTerminalSymbolForSyntax::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' non terminal symbol is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonTerminalSymbolForSyntax GGS_M_nonTerminalSymbolForSyntax::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonTerminalSymbolForSyntax result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_nonTerminalSymbolForSyntax::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_nonTerminalSymbolForSyntax " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_grammarInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_grammarInstruction::
cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mSourceFileCppName (argument_0),
mGrammarName (argument_1),
mExpressionsList (argument_2),
mAltSymbol (argument_3),
mMetamodelClassVariableName (argument_4),
mLexiqueClassName (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_grammarInstruction * GGS_C_grammarInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_grammarInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_grammarInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_grammarInstruction * _p = dynamic_cast <const cPtr_C_grammarInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSourceFileCppName == _p->mSourceFileCppName).boolValue ()
         && (mGrammarName == _p->mGrammarName).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue ()
         && (mAltSymbol == _p->mAltSymbol).boolValue ()
         && (mMetamodelClassVariableName == _p->mMetamodelClassVariableName).boolValue ()
         && (mLexiqueClassName == _p->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_grammarInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_grammarInstruction:"
           << mSourceFileCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mGrammarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAltSymbol.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMetamodelClassVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
GGS_C_grammarInstruction (const GGS_C_grammarInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction::
~GGS_C_grammarInstruction (void) {
  macroDetachPointer (mPointer, cPtr_C_grammarInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_grammarInstruction::
operator = (const GGS_C_grammarInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_grammarInstruction GGS_C_grammarInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeExpressionList & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_C_grammarInstruction result ;
  macroMyNew (result.mPointer, cPtr_C_grammarInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_C_grammarInstruction::
reader_mSourceFileCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mSourceFileCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mGrammarName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mGrammarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_C_grammarInstruction::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mAltSymbol (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mAltSymbol ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mMetamodelClassVariableName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mMetamodelClassVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_grammarInstruction::
reader_mLexiqueClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_grammarInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_grammarInstruction *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarInstruction::
operator == (const GGS_C_grammarInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_grammarInstruction::
operator != (const GGS_C_grammarInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_grammarInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_grammarInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeAppendInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAppendInstruction::
cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAppendInstruction * GGS_typeAppendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAppendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAppendInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeAppendInstruction * _p = dynamic_cast <const cPtr_typeAppendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mSourceExpressions == _p->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAppendInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeAppendInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
GGS_typeAppendInstruction (const GGS_typeAppendInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction::
~GGS_typeAppendInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeAppendInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAppendInstruction::
operator = (const GGS_typeAppendInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAppendInstruction GGS_typeAppendInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeAppendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeAppendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeAppendInstruction::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeAppendInstruction::
reader_mSourceExpressions (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAppendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeAppendInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAppendInstruction::
operator == (const GGS_typeAppendInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAppendInstruction::
operator != (const GGS_typeAppendInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAppendInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAppendInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeRemoveInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRemoveInstruction::
cPtr_typeRemoveInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mSourceExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRemoveInstruction * GGS_typeRemoveInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRemoveInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRemoveInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRemoveInstruction * _p = dynamic_cast <const cPtr_typeRemoveInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mSourceExpressions == _p->mSourceExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRemoveInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRemoveInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSourceExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRemoveInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
GGS_typeRemoveInstruction (const GGS_typeRemoveInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction::
~GGS_typeRemoveInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeRemoveInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeRemoveInstruction::
operator = (const GGS_typeRemoveInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRemoveInstruction GGS_typeRemoveInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeRemoveInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRemoveInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeRemoveInstruction::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRemoveInstruction::
reader_mSourceExpressions (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRemoveInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRemoveInstruction *) mPointer)->mSourceExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRemoveInstruction::
operator == (const GGS_typeRemoveInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRemoveInstruction::
operator != (const GGS_typeRemoveInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRemoveInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRemoveInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeIncrementInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeIncrementInstruction::
cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeIncrementInstruction * GGS_typeIncrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeIncrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeIncrementInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeIncrementInstruction * _p = dynamic_cast <const cPtr_typeIncrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeIncrementInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeIncrementInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
GGS_typeIncrementInstruction (const GGS_typeIncrementInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction::
~GGS_typeIncrementInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeIncrementInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeIncrementInstruction::
operator = (const GGS_typeIncrementInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeIncrementInstruction GGS_typeIncrementInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeIncrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeIncrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeIncrementInstruction::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeIncrementInstruction::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeIncrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeIncrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeIncrementInstruction::
operator == (const GGS_typeIncrementInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeIncrementInstruction::
operator != (const GGS_typeIncrementInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeIncrementInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeIncrementInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDecrementInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDecrementInstruction::
cPtr_typeDecrementInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mTargetVarCppName (argument_0),
mInstructionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDecrementInstruction * GGS_typeDecrementInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDecrementInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDecrementInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDecrementInstruction * _p = dynamic_cast <const cPtr_typeDecrementInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTargetVarCppName == _p->mTargetVarCppName).boolValue ()
         && (mInstructionLocation == _p->mInstructionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDecrementInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDecrementInstruction:"
           << mTargetVarCppName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
GGS_typeDecrementInstruction (const GGS_typeDecrementInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction::
~GGS_typeDecrementInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeDecrementInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDecrementInstruction::
operator = (const GGS_typeDecrementInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDecrementInstruction GGS_typeDecrementInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeDecrementInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDecrementInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDecrementInstruction::
reader_mTargetVarCppName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mTargetVarCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeDecrementInstruction::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDecrementInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDecrementInstruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDecrementInstruction::
operator == (const GGS_typeDecrementInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDecrementInstruction::
operator != (const GGS_typeDecrementInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDecrementInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDecrementInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_typeInstructionAppelActionExterne'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelActionExterne::
cPtr_typeInstructionAppelActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomAction (argument_0),
mExpressionsList (argument_1),
aListeTypesParametresFormels (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelActionExterne * GGS_typeInstructionAppelActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelActionExterne::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelActionExterne * _p = dynamic_cast <const cPtr_typeInstructionAppelActionExterne *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomAction == _p->aNomAction).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue ()
         && (aListeTypesParametresFormels == _p->aListeTypesParametresFormels).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelActionExterne::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelActionExterne:"
           << aNomAction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypesParametresFormels.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelActionExterne::
GGS_typeInstructionAppelActionExterne (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelActionExterne::
GGS_typeInstructionAppelActionExterne (const GGS_typeInstructionAppelActionExterne & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelActionExterne::
~GGS_typeInstructionAppelActionExterne (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionAppelActionExterne) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionAppelActionExterne::
operator = (const GGS_typeInstructionAppelActionExterne & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelActionExterne GGS_typeInstructionAppelActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_L_EXsignature & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelActionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelActionExterne (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelActionExterne::
reader_aNomAction (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelActionExterne *) mPointer)->aNomAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeInstructionAppelActionExterne::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelActionExterne *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeInstructionAppelActionExterne::
reader_aListeTypesParametresFormels (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelActionExterne *) mPointer)->aListeTypesParametresFormels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelActionExterne::
operator == (const GGS_typeInstructionAppelActionExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelActionExterne::
operator != (const GGS_typeInstructionAppelActionExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelActionExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionAppelActionExterne" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_matchInstructionCasesList::
elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCase1_name (argument_0),
mCase2_name (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_matchInstructionCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_matchInstructionCasesList * _p = dynamic_cast <const elementOf_GGS_L_matchInstructionCasesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mCase1_name == _p->mCase1_name).boolValue ()
         && (mCase2_name == _p->mCase2_name).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_matchInstructionCasesList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase1_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCase2_name.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::GGS_L_matchInstructionCasesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList::
GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_matchInstructionCasesList::
operator == (const GGS_L_matchInstructionCasesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_matchInstructionCasesList::
operator != (const GGS_L_matchInstructionCasesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList GGS_L_matchInstructionCasesList::
operator + (const GGS_L_matchInstructionCasesList & inOperand) const {
  GGS_L_matchInstructionCasesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_matchInstructionCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCase1_name ;
          GGS_lstring  p_1 = p->mCase2_name ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCase1_name,
                                _p->mCase2_name,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_L_matchInstructionCasesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_typeInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_matchInstructionCasesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_matchInstructionCasesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_matchInstructionCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_matchInstructionCasesList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCase1_name ;
    _out_1 = _p->mCase2_name ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeMatchInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMatchInstruction::
cPtr_typeMatchInstruction (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aIndicatif1 (argument_0),
aIndicatif2 (argument_1),
aNomCppVariable1 (argument_2),
aNomCppVariable2 (argument_3),
aNomTypeBase1 (argument_4),
aNomTypeBase2 (argument_5),
mOperand1_isEnumeration (argument_6),
mOperand2_isEnumeration (argument_7),
aListeCas (argument_8),
mElseInstructionsList (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMatchInstruction * GGS_typeMatchInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeMatchInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMatchInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMatchInstruction * _p = dynamic_cast <const cPtr_typeMatchInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aIndicatif1 == _p->aIndicatif1).boolValue ()
         && (aIndicatif2 == _p->aIndicatif2).boolValue ()
         && (aNomCppVariable1 == _p->aNomCppVariable1).boolValue ()
         && (aNomCppVariable2 == _p->aNomCppVariable2).boolValue ()
         && (aNomTypeBase1 == _p->aNomTypeBase1).boolValue ()
         && (aNomTypeBase2 == _p->aNomTypeBase2).boolValue ()
         && (mOperand1_isEnumeration == _p->mOperand1_isEnumeration).boolValue ()
         && (mOperand2_isEnumeration == _p->mOperand2_isEnumeration).boolValue ()
         && (aListeCas == _p->aListeCas).boolValue ()
         && (mElseInstructionsList == _p->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMatchInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeMatchInstruction:"
           << aIndicatif1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aIndicatif2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppVariable1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomCppVariable2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomTypeBase1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomTypeBase2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand1_isEnumeration.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2_isEnumeration.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeCas.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
GGS_typeMatchInstruction (const GGS_typeMatchInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction::
~GGS_typeMatchInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeMatchInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeMatchInstruction::
operator = (const GGS_typeMatchInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMatchInstruction GGS_typeMatchInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_location & argument_1,
                 const GGS_typeCplusPlusName & argument_2,
                 const GGS_typeCplusPlusName & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_bool& argument_6,
                 const GGS_bool& argument_7,
                 const GGS_L_matchInstructionCasesList & argument_8,
                 const GGS_typeInstructionList & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_typeMatchInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeMatchInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeMatchInstruction::
reader_aIndicatif2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aIndicatif2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeMatchInstruction::
reader_aNomCppVariable2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomCppVariable2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMatchInstruction::
reader_aNomTypeBase2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aNomTypeBase2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand1_isEnumeration (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand1_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
reader_mOperand2_isEnumeration (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mOperand2_isEnumeration ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_matchInstructionCasesList  GGS_typeMatchInstruction::
reader_aListeCas (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_matchInstructionCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->aListeCas ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeMatchInstruction::
reader_mElseInstructionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMatchInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMatchInstruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
operator == (const GGS_typeMatchInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeMatchInstruction::
operator != (const GGS_typeMatchInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeMatchInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeMatchInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachEnumerationList::
elementOf_GGS_foreachEnumerationList (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCppEnumeratedVariableName (argument_0),
mLocationOffset (argument_1),
mCppTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachEnumerationList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachEnumerationList * _p = dynamic_cast <const elementOf_GGS_foreachEnumerationList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mCppEnumeratedVariableName == _p->mCppEnumeratedVariableName).boolValue ()
         && (mLocationOffset == _p->mLocationOffset).boolValue ()
         && (mCppTypeName == _p->mCppTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachEnumerationList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppEnumeratedVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationOffset.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCppTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::GGS_foreachEnumerationList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList::
GGS_foreachEnumerationList (const GGS_foreachEnumerationList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
operator == (const GGS_foreachEnumerationList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachEnumerationList::
operator != (const GGS_foreachEnumerationList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalAppendValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_internalPrependValues (const GGS_typeCplusPlusName & argument_0,
                    const GGS_location & argument_1,
                    const GGS_string& argument_2
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList GGS_foreachEnumerationList::
operator + (const GGS_foreachEnumerationList & inOperand) const {
  GGS_foreachEnumerationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_foreachEnumerationList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCplusPlusName  p_0 = p->mCppEnumeratedVariableName ;
          GGS_location  p_1 = p->mLocationOffset ;
          GGS_string p_2 = p->mCppTypeName ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCplusPlusName & argument_0,
                     const GGS_location & argument_1,
                     const GGS_string& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCppEnumeratedVariableName,
                                _p->mLocationOffset,
                                _p->mCppTypeName
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_foreachEnumerationList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCplusPlusName & argument_0,
                           const GGS_location & argument_1,
                           const GGS_string& argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_foreachEnumerationList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachEnumerationList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@foreachEnumerationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_first (C_Lexique & _inLexique,
              GGS_typeCplusPlusName & _out_0,
              GGS_location & _out_1,
              GGS_string& _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
method_last (C_Lexique & _inLexique,
             GGS_typeCplusPlusName & _out_0,
             GGS_location & _out_1,
             GGS_string& _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeCplusPlusName & _out_0,
                 GGS_location & _out_1,
                 GGS_string& _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachEnumerationList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeCplusPlusName & _out_0,
                GGS_location & _out_1,
                GGS_string& _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCppEnumeratedVariableName ;
    _out_1 = _p->mLocationOffset ;
    _out_2 = _p->mCppTypeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeForeachInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeForeachInstruction::
cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mForeachEnumerationList (argument_0),
mWhileExpression (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeForeachInstruction * GGS_typeForeachInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeForeachInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeForeachInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeForeachInstruction * _p = dynamic_cast <const cPtr_typeForeachInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mForeachEnumerationList == _p->mForeachEnumerationList).boolValue ()
         && (mWhileExpression == _p->mWhileExpression).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeForeachInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeForeachInstruction:"
           << mForeachEnumerationList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
GGS_typeForeachInstruction (const GGS_typeForeachInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction::
~GGS_typeForeachInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeForeachInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeForeachInstruction::
operator = (const GGS_typeForeachInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeForeachInstruction GGS_typeForeachInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_foreachEnumerationList & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeForeachInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeForeachInstruction (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachEnumerationList  GGS_typeForeachInstruction::
reader_mForeachEnumerationList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachEnumerationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mForeachEnumerationList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeForeachInstruction::
reader_mWhileExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeForeachInstruction::
reader_mInstructionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeForeachInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeForeachInstruction *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeForeachInstruction::
operator == (const GGS_typeForeachInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeForeachInstruction::
operator != (const GGS_typeForeachInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeForeachInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeForeachInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeSimpleExtractInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeSimpleExtractInstruction::
cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomVariable (argument_0),
aNomClasse (argument_1),
aListeAffectationParametresEffectifs (argument_2),
mErrorLocationExpression (argument_3),
aNomMessage (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeSimpleExtractInstruction * GGS_typeSimpleExtractInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeSimpleExtractInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeSimpleExtractInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeSimpleExtractInstruction * _p = dynamic_cast <const cPtr_typeSimpleExtractInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomVariable == _p->aNomVariable).boolValue ()
         && (aNomClasse == _p->aNomClasse).boolValue ()
         && (aListeAffectationParametresEffectifs == _p->aListeAffectationParametresEffectifs).boolValue ()
         && (mErrorLocationExpression == _p->mErrorLocationExpression).boolValue ()
         && (aNomMessage == _p->aNomMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeSimpleExtractInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeSimpleExtractInstruction:"
           << aNomVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeAffectationParametresEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
GGS_typeSimpleExtractInstruction (const GGS_typeSimpleExtractInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction::
~GGS_typeSimpleExtractInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeSimpleExtractInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeSimpleExtractInstruction::
operator = (const GGS_typeSimpleExtractInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeSimpleExtractInstruction GGS_typeSimpleExtractInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_L_assignedVariables & argument_2,
                 const GGS_typeExpression & argument_3,
                 const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeSimpleExtractInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeSimpleExtractInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeSimpleExtractInstruction::
reader_aNomVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSimpleExtractInstruction::
reader_aNomClasse (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_typeSimpleExtractInstruction::
reader_aListeAffectationParametresEffectifs (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_assignedVariables   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aListeAffectationParametresEffectifs ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_typeSimpleExtractInstruction::
reader_mErrorLocationExpression (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeSimpleExtractInstruction::
reader_aNomMessage (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeSimpleExtractInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeSimpleExtractInstruction *) mPointer)->aNomMessage ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSimpleExtractInstruction::
operator == (const GGS_typeSimpleExtractInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeSimpleExtractInstruction::
operator != (const GGS_typeSimpleExtractInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeSimpleExtractInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeSimpleExtractInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeStructuredExtractCasesList::
elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mClassName (argument_0),
mResultVarID (argument_1),
mInstructionList (argument_2),
mNoUsedParameter (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeStructuredExtractCasesList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeStructuredExtractCasesList * _p = dynamic_cast <const elementOf_GGS_typeStructuredExtractCasesList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mClassName == _p->mClassName).boolValue ()
         && (mResultVarID == _p->mResultVarID).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue ()
         && (mNoUsedParameter == _p->mNoUsedParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeStructuredExtractCasesList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mResultVarID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNoUsedParameter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::GGS_typeStructuredExtractCasesList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList::
GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractCasesList::
operator == (const GGS_typeStructuredExtractCasesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractCasesList::
operator != (const GGS_typeStructuredExtractCasesList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_location & argument_1,
                    const GGS_typeInstructionList & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList GGS_typeStructuredExtractCasesList::
operator + (const GGS_typeStructuredExtractCasesList & inOperand) const {
  GGS_typeStructuredExtractCasesList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeStructuredExtractCasesList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mClassName ;
          GGS_location  p_1 = p->mResultVarID ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          GGS_bool p_3 = p->mNoUsedParameter ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_location & argument_1,
                     const GGS_typeInstructionList & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mClassName,
                                _p->mResultVarID,
                                _p->mInstructionList,
                                _p->mNoUsedParameter
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractCasesList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_location & argument_1,
                           const GGS_typeInstructionList & argument_2,
                           const GGS_bool& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeStructuredExtractCasesList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractCasesList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeStructuredExtractCasesList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_location & _out_1,
              GGS_typeInstructionList & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_location & _out_1,
             GGS_typeInstructionList & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_location & _out_1,
                 GGS_typeInstructionList & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractCasesList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_location & _out_1,
                GGS_typeInstructionList & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mClassName ;
    _out_1 = _p->mResultVarID ;
    _out_2 = _p->mInstructionList ;
    _out_3 = _p->mNoUsedParameter ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      abstract class 'cPtr_typeStructuredExtractInstructionWithElse'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeStructuredExtractInstructionWithElse::
cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mVariableName (argument_0),
mCasesList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeStructuredExtractInstructionWithElse * GGS_typeStructuredExtractInstructionWithElse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeStructuredExtractInstructionWithElse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeStructuredExtractInstructionWithElse::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeStructuredExtractInstructionWithElse * _p = dynamic_cast <const cPtr_typeStructuredExtractInstructionWithElse *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mVariableName == _p->mVariableName).boolValue ()
         && (mCasesList == _p->mCasesList).boolValue ()
         && (mElseInstructionList == _p->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeStructuredExtractInstructionWithElse::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeStructuredExtractInstructionWithElse:"
           << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCasesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
GGS_typeStructuredExtractInstructionWithElse (const GGS_typeStructuredExtractInstructionWithElse & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse::
~GGS_typeStructuredExtractInstructionWithElse (void) {
  macroDetachPointer (mPointer, cPtr_typeStructuredExtractInstructionWithElse) ;
}

//---------------------------------------------------------------------------*

void GGS_typeStructuredExtractInstructionWithElse::
operator = (const GGS_typeStructuredExtractInstructionWithElse & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractInstructionWithElse GGS_typeStructuredExtractInstructionWithElse::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0,
                 const GGS_typeStructuredExtractCasesList & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeStructuredExtractInstructionWithElse result ;
  macroMyNew (result.mPointer, cPtr_typeStructuredExtractInstructionWithElse (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeStructuredExtractInstructionWithElse::
reader_mVariableName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeStructuredExtractCasesList  GGS_typeStructuredExtractInstructionWithElse::
reader_mCasesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeStructuredExtractCasesList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mCasesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeStructuredExtractInstructionWithElse::
reader_mElseInstructionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeStructuredExtractInstructionWithElse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeStructuredExtractInstructionWithElse *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractInstructionWithElse::
operator == (const GGS_typeStructuredExtractInstructionWithElse & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeStructuredExtractInstructionWithElse::
operator != (const GGS_typeStructuredExtractInstructionWithElse & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeStructuredExtractInstructionWithElse::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeStructuredExtractInstructionWithElse" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeRoutineCallInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineCallInstruction::
cPtr_typeRoutineCallInstruction (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aNomRoutine (argument_0),
mExpressionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineCallInstruction * GGS_typeRoutineCallInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineCallInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineCallInstruction * _p = dynamic_cast <const cPtr_typeRoutineCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomRoutine == _p->aNomRoutine).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineCallInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineCallInstruction:"
           << aNomRoutine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
GGS_typeRoutineCallInstruction (const GGS_typeRoutineCallInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction::
~GGS_typeRoutineCallInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeRoutineCallInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeRoutineCallInstruction::
operator = (const GGS_typeRoutineCallInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineCallInstruction GGS_typeRoutineCallInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineCallInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeRoutineCallInstruction::
reader_aNomRoutine (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->aNomRoutine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeRoutineCallInstruction::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineCallInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineCallInstruction::
operator == (const GGS_typeRoutineCallInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineCallInstruction::
operator != (const GGS_typeRoutineCallInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRoutineCallInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRoutineCallInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeLogInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLogInstruction::
cPtr_typeLogInstruction (const GGS_lstring & argument_0,
                                const GGS_typeCplusPlusName & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mGalgasVariableName (argument_0),
mLoggedVariable (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLogInstruction * GGS_typeLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLogInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLogInstruction * _p = dynamic_cast <const cPtr_typeLogInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGalgasVariableName == _p->mGalgasVariableName).boolValue ()
         && (mLoggedVariable == _p->mLoggedVariable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLogInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLogInstruction:"
           << mGalgasVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLoggedVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeLogInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
GGS_typeLogInstruction (const GGS_typeLogInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction::
~GGS_typeLogInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeLogInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLogInstruction::
operator = (const GGS_typeLogInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLogInstruction GGS_typeLogInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeCplusPlusName & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLogInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLogInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLogInstruction::
reader_mGalgasVariableName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mGalgasVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeLogInstruction::
reader_mLoggedVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLogInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLogInstruction *) mPointer)->mLoggedVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLogInstruction::
operator == (const GGS_typeLogInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLogInstruction::
operator != (const GGS_typeLogInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLogInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLogInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeDropInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDropInstruction::
cPtr_typeDropInstruction (const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
aVariableConsommee (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDropInstruction * GGS_typeDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDropInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDropInstruction * _p = dynamic_cast <const cPtr_typeDropInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aVariableConsommee == _p->aVariableConsommee).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDropInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDropInstruction:"
           << aVariableConsommee.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
GGS_typeDropInstruction (const GGS_typeDropInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction::
~GGS_typeDropInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeDropInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDropInstruction::
operator = (const GGS_typeDropInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDropInstruction GGS_typeDropInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeCplusPlusName & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCplusPlusName  GGS_typeDropInstruction::
reader_aVariableConsommee (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeCplusPlusName   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDropInstruction *) mPointer)->aVariableConsommee ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDropInstruction::
operator == (const GGS_typeDropInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDropInstruction::
operator != (const GGS_typeDropInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDropInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDropInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableNomRoutinesDeclarees'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableNomRoutinesDeclarees::
elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableNomRoutinesDeclarees & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableNomRoutinesDeclarees::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableNomRoutinesDeclarees::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableNomRoutinesDeclarees::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableNomRoutinesDeclarees *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeTableNomRoutinesDeclarees * info = (e_typeTableNomRoutinesDeclarees *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableNomRoutinesDeclarees info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
operator == (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableNomRoutinesDeclarees::
operator != (const GGS_typeTableNomRoutinesDeclarees & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableNomRoutinesDeclarees info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableNomRoutinesDeclarees::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the routine '%K' is already declared in %L",
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableNomRoutinesDeclarees GGS_typeTableNomRoutinesDeclarees::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableNomRoutinesDeclarees result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableNomRoutinesDeclarees::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableNomRoutinesDeclarees " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeEntityToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntityToGenerate::
cPtr_typeEntityToGenerate (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntityToGenerate * GGS_typeEntityToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeEntityToGenerate::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeEntityToGenerate:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate & inOperand) {
  mPointer = (cPtr_typeEntityToGenerate *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntityToGenerate::
~GGS_typeEntityToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
operator = (const GGS_typeEntityToGenerate & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntityToGenerate::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEntityToGenerate) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntityToGenerate::
operator == (const GGS_typeEntityToGenerate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntityToGenerate::
operator != (const GGS_typeEntityToGenerate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntityToGenerate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntityToGenerate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeExternTypeToGenerate'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeExternTypeToGenerate::
cPtr_typeExternTypeToGenerate (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mGalgasName (argument_0),
mCppClassName (argument_1),
mIncludePath (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeExternTypeToGenerate * GGS_typeExternTypeToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeExternTypeToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeExternTypeToGenerate::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeExternTypeToGenerate * _p = dynamic_cast <const cPtr_typeExternTypeToGenerate *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGalgasName == _p->mGalgasName).boolValue ()
         && (mCppClassName == _p->mCppClassName).boolValue ()
         && (mIncludePath == _p->mIncludePath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeExternTypeToGenerate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeExternTypeToGenerate:"
           << mGalgasName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mCppClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIncludePath.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
GGS_typeExternTypeToGenerate (const GGS_typeExternTypeToGenerate & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate::
~GGS_typeExternTypeToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeExternTypeToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeExternTypeToGenerate::
operator = (const GGS_typeExternTypeToGenerate & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeExternTypeToGenerate GGS_typeExternTypeToGenerate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeExternTypeToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeExternTypeToGenerate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeExternTypeToGenerate::
reader_mGalgasName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mGalgasName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeExternTypeToGenerate::
reader_mCppClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mCppClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeExternTypeToGenerate::
reader_mIncludePath (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeExternTypeToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeExternTypeToGenerate *) mPointer)->mIncludePath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExternTypeToGenerate::
operator == (const GGS_typeExternTypeToGenerate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeExternTypeToGenerate::
operator != (const GGS_typeExternTypeToGenerate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeExternTypeToGenerate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeExternTypeToGenerate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeRoutineAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRoutineAengendrer::
cPtr_typeRoutineAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomRoutine (argument_0),
aListeTypeEtNomsArguments (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRoutineAengendrer * GGS_typeRoutineAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRoutineAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRoutineAengendrer::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRoutineAengendrer * _p = dynamic_cast <const cPtr_typeRoutineAengendrer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomRoutine == _p->aNomRoutine).boolValue ()
         && (aListeTypeEtNomsArguments == _p->aListeTypeEtNomsArguments).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRoutineAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRoutineAengendrer:"
           << aNomRoutine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEtNomsArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
GGS_typeRoutineAengendrer (const GGS_typeRoutineAengendrer & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer::
~GGS_typeRoutineAengendrer (void) {
  macroDetachPointer (mPointer, cPtr_typeRoutineAengendrer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeRoutineAengendrer::
operator = (const GGS_typeRoutineAengendrer & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRoutineAengendrer GGS_typeRoutineAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                 const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeRoutineAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeRoutineAengendrer (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeRoutineAengendrer::
reader_aNomRoutine (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineAengendrer *) mPointer)->aNomRoutine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTypesEtNomsArgMethode  GGS_typeRoutineAengendrer::
reader_aListeTypeEtNomsArguments (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTypesEtNomsArgMethode   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineAengendrer *) mPointer)->aListeTypeEtNomsArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeRoutineAengendrer::
reader_mInstructionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRoutineAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRoutineAengendrer *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineAengendrer::
operator == (const GGS_typeRoutineAengendrer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRoutineAengendrer::
operator != (const GGS_typeRoutineAengendrer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRoutineAengendrer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRoutineAengendrer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_listTypeToImplement'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_listTypeToImplement::
cPtr_C_listTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_listTypeToImplement * GGS_C_listTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_listTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_listTypeToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_listTypeToImplement * _p = dynamic_cast <const cPtr_C_listTypeToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomListe == _p->aNomListe).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_listTypeToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_listTypeToImplement:"
           << aNomListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
GGS_C_listTypeToImplement (const GGS_C_listTypeToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement::
~GGS_C_listTypeToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_listTypeToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_listTypeToImplement::
operator = (const GGS_C_listTypeToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_listTypeToImplement GGS_C_listTypeToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_listTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_listTypeToImplement (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_listTypeToImplement::
reader_aNomListe (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_listTypeToImplement *) mPointer)->aNomListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_listTypeToImplement::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_listTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_listTypeToImplement *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_listTypeToImplement::
operator == (const GGS_C_listTypeToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_listTypeToImplement::
operator != (const GGS_C_listTypeToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_listTypeToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_listTypeToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sortDescriptorList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortDescriptorList::
elementOf_GGS_sortDescriptorList (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSortAttribute (argument_0),
mAscendingOrder (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortDescriptorList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortDescriptorList * _p = dynamic_cast <const elementOf_GGS_sortDescriptorList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSortAttribute == _p->mSortAttribute).boolValue ()
         && (mAscendingOrder == _p->mAscendingOrder).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortDescriptorList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortAttribute.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscendingOrder.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@sortDescriptorList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_sortDescriptorList::GGS_sortDescriptorList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList::
GGS_sortDescriptorList (const GGS_sortDescriptorList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortDescriptorList::
operator == (const GGS_sortDescriptorList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortDescriptorList::
operator != (const GGS_sortDescriptorList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList GGS_sortDescriptorList::
operator + (const GGS_sortDescriptorList & inOperand) const {
  GGS_sortDescriptorList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_sortDescriptorList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortAttribute ;
          GGS_bool p_1 = p->mAscendingOrder ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSortAttribute,
                                _p->mAscendingOrder
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortDescriptorList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_sortDescriptorList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_bool& argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_sortDescriptorList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortDescriptorList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@sortDescriptorList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortDescriptorList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSortAttribute ;
    _out_1 = _p->mAscendingOrder ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_C_sortedListTypeToImplement'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_sortedListTypeToImplement::
cPtr_C_sortedListTypeToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomListe (argument_0),
mNonExternAttributesList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_sortedListTypeToImplement * GGS_C_sortedListTypeToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_sortedListTypeToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_sortedListTypeToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_sortedListTypeToImplement * _p = dynamic_cast <const cPtr_C_sortedListTypeToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomListe == _p->aNomListe).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (mSortDescriptorList == _p->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_sortedListTypeToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_sortedListTypeToImplement:"
           << aNomListe.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSortDescriptorList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_sortedListTypeToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
GGS_C_sortedListTypeToImplement (const GGS_C_sortedListTypeToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement::
~GGS_C_sortedListTypeToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_sortedListTypeToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_sortedListTypeToImplement::
operator = (const GGS_C_sortedListTypeToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_sortedListTypeToImplement GGS_C_sortedListTypeToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_sortDescriptorList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_sortedListTypeToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_sortedListTypeToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_sortedListTypeToImplement::
reader_aNomListe (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_sortedListTypeToImplement *) mPointer)->aNomListe ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_sortedListTypeToImplement::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_sortedListTypeToImplement *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortDescriptorList  GGS_C_sortedListTypeToImplement::
reader_mSortDescriptorList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortDescriptorList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_sortedListTypeToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_sortedListTypeToImplement *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_sortedListTypeToImplement::
operator == (const GGS_C_sortedListTypeToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_sortedListTypeToImplement::
operator != (const GGS_C_sortedListTypeToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_sortedListTypeToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_sortedListTypeToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeDefinitionTableAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDefinitionTableAimplementer::
cPtr_typeDefinitionTableAimplementer (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
aNomClasseGenerique (argument_2),
mInsertMethodList (argument_3),
mSearchMethodList (argument_4),
aTableMethodesSurcharger (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDefinitionTableAimplementer * GGS_typeDefinitionTableAimplementer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDefinitionTableAimplementer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDefinitionTableAimplementer::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDefinitionTableAimplementer * _p = dynamic_cast <const cPtr_typeDefinitionTableAimplementer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomTable == _p->aNomTable).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (aNomClasseGenerique == _p->aNomClasseGenerique).boolValue ()
         && (mInsertMethodList == _p->mInsertMethodList).boolValue ()
         && (mSearchMethodList == _p->mSearchMethodList).boolValue ()
         && (aTableMethodesSurcharger == _p->aTableMethodesSurcharger).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDefinitionTableAimplementer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDefinitionTableAimplementer:"
           << aNomTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aNomClasseGenerique.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableMethodesSurcharger.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
GGS_typeDefinitionTableAimplementer (const GGS_typeDefinitionTableAimplementer & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer::
~GGS_typeDefinitionTableAimplementer (void) {
  macroDetachPointer (mPointer, cPtr_typeDefinitionTableAimplementer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDefinitionTableAimplementer::
operator = (const GGS_typeDefinitionTableAimplementer & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDefinitionTableAimplementer GGS_typeDefinitionTableAimplementer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4,
                 const GGS_typeTableBlocsDeTable & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeDefinitionTableAimplementer result ;
  macroMyNew (result.mPointer, cPtr_typeDefinitionTableAimplementer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeDefinitionTableAimplementer::
reader_aNomTable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->aNomTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_typeDefinitionTableAimplementer::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeDefinitionTableAimplementer::
reader_aNomClasseGenerique (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->aNomClasseGenerique ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_typeDefinitionTableAimplementer::
reader_mInsertMethodList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_typeDefinitionTableAimplementer::
reader_mSearchMethodList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableBlocsDeTable  GGS_typeDefinitionTableAimplementer::
reader_aTableMethodesSurcharger (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableBlocsDeTable   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDefinitionTableAimplementer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDefinitionTableAimplementer *) mPointer)->aTableMethodesSurcharger ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDefinitionTableAimplementer::
operator == (const GGS_typeDefinitionTableAimplementer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDefinitionTableAimplementer::
operator != (const GGS_typeDefinitionTableAimplementer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDefinitionTableAimplementer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDefinitionTableAimplementer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_C_mapToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapToImplement::
cPtr_C_mapToImplement (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_insertOrSearchMethodList & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomTable (argument_0),
mNonExternAttributesList (argument_1),
mInsertMethodList (argument_2),
mSearchMethodList (argument_3),
mRemoveMethodList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapToImplement * GGS_C_mapToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapToImplement * _p = dynamic_cast <const cPtr_C_mapToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomTable == _p->aNomTable).boolValue ()
         && (mNonExternAttributesList == _p->mNonExternAttributesList).boolValue ()
         && (mInsertMethodList == _p->mInsertMethodList).boolValue ()
         && (mSearchMethodList == _p->mSearchMethodList).boolValue ()
         && (mRemoveMethodList == _p->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapToImplement:"
           << aNomTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonExternAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mInsertMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSearchMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRemoveMethodList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
GGS_C_mapToImplement (const GGS_C_mapToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement::
~GGS_C_mapToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_mapToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_mapToImplement::
operator = (const GGS_C_mapToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapToImplement GGS_C_mapToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeAttributsSemantiques & argument_1,
                 const GGS_insertOrSearchMethodList & argument_2,
                 const GGS_insertOrSearchMethodList & argument_3,
                 const GGS_insertOrSearchMethodList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapToImplement::
reader_aNomTable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->aNomTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_mapToImplement::
reader_mNonExternAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mNonExternAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_C_mapToImplement::
reader_mInsertMethodList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_C_mapToImplement::
reader_mSearchMethodList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrSearchMethodList  GGS_C_mapToImplement::
reader_mRemoveMethodList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrSearchMethodList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapToImplement *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_mapToImplement::
operator == (const GGS_C_mapToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_mapToImplement::
operator != (const GGS_C_mapToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_mapToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_mapToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_C_classToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_classToImplement::
cPtr_C_classToImplement (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeTableMethodes & argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
mIsAbstract (argument_1),
aListeTousAttributsNonExternes (argument_2),
aTableToutesMethodes (argument_3),
mMethodsMap (argument_4),
aListeAttributsCourants (argument_5),
mAncestorClassesMap (argument_6),
mMessagesMap (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_classToImplement * GGS_C_classToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_classToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_classToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_classToImplement * _p = dynamic_cast <const cPtr_C_classToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomClasse == _p->aNomClasse).boolValue ()
         && (mIsAbstract == _p->mIsAbstract).boolValue ()
         && (aListeTousAttributsNonExternes == _p->aListeTousAttributsNonExternes).boolValue ()
         && (aTableToutesMethodes == _p->aTableToutesMethodes).boolValue ()
         && (mMethodsMap == _p->mMethodsMap).boolValue ()
         && (aListeAttributsCourants == _p->aListeAttributsCourants).boolValue ()
         && (mAncestorClassesMap == _p->mAncestorClassesMap).boolValue ()
         && (mMessagesMap == _p->mMessagesMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_classToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_classToImplement:"
           << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aTableToutesMethodes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMethodsMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAncestorClassesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMessagesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_classToImplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement::
GGS_C_classToImplement (const GGS_C_classToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement::
~GGS_C_classToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_classToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_classToImplement::
operator = (const GGS_C_classToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_classToImplement GGS_C_classToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeTableMethodes & argument_3,
                 const GGS_typeTableMethodesAimplementer & argument_4,
                 const GGS_typeListeAttributsSemantiques & argument_5,
                 const GGS_typeSuperClassesMap & argument_6,
                 const GGS_typeClassMessagesMap & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_C_classToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_classToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_classToImplement::
reader_aNomClasse (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_classToImplement::
reader_mIsAbstract (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_classToImplement::
reader_aListeTousAttributsNonExternes (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aListeTousAttributsNonExternes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodes  GGS_C_classToImplement::
reader_aTableToutesMethodes (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodes   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aTableToutesMethodes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMethodesAimplementer  GGS_C_classToImplement::
reader_mMethodsMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMethodesAimplementer   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mMethodsMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_classToImplement::
reader_aListeAttributsCourants (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->aListeAttributsCourants ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeSuperClassesMap  GGS_C_classToImplement::
reader_mAncestorClassesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeSuperClassesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mAncestorClassesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeClassMessagesMap  GGS_C_classToImplement::
reader_mMessagesMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeClassMessagesMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_classToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_classToImplement *) mPointer)->mMessagesMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_classToImplement::
operator == (const GGS_C_classToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_classToImplement::
operator != (const GGS_C_classToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_classToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_classToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_C_mapindexToImplement'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_mapindexToImplement::
cPtr_C_mapindexToImplement (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_mapIndexSearchReaderMap & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mMapindexTypeName (argument_0),
mMapTypeName (argument_1),
mMapAttributesList (argument_2),
mMapIndexSearchReaderMap (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_mapindexToImplement * GGS_C_mapindexToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_mapindexToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_mapindexToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_mapindexToImplement * _p = dynamic_cast <const cPtr_C_mapindexToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMapindexTypeName == _p->mMapindexTypeName).boolValue ()
         && (mMapTypeName == _p->mMapTypeName).boolValue ()
         && (mMapAttributesList == _p->mMapAttributesList).boolValue ()
         && (mMapIndexSearchReaderMap == _p->mMapIndexSearchReaderMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_mapindexToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_mapindexToImplement:"
           << mMapindexTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMapIndexSearchReaderMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_mapindexToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
GGS_C_mapindexToImplement (const GGS_C_mapindexToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement::
~GGS_C_mapindexToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_mapindexToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_mapindexToImplement::
operator = (const GGS_C_mapindexToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_mapindexToImplement GGS_C_mapindexToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_mapIndexSearchReaderMap & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_mapindexToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_mapindexToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapindexToImplement::
reader_mMapindexTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapindexTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_mapindexToImplement::
reader_mMapTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_mapindexToImplement::
reader_mMapAttributesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapAttributesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapIndexSearchReaderMap  GGS_C_mapindexToImplement::
reader_mMapIndexSearchReaderMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapIndexSearchReaderMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_mapindexToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_mapindexToImplement *) mPointer)->mMapIndexSearchReaderMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_mapindexToImplement::
operator == (const GGS_C_mapindexToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_mapindexToImplement::
operator != (const GGS_C_mapindexToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_mapindexToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_mapindexToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@domainRelationMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_domainRelationMap::
elementOf_GGS_domainRelationMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_domainRelationMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_domainRelationMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDomains.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_domainRelationMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_domainRelationMap * _p = dynamic_cast <const elementOf_GGS_domainRelationMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mDomains == _p->mInfo.mDomains).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_domainRelationMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_domainRelationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_domainRelationMap * info = (e_domainRelationMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_domainRelationMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_domainRelationMap * info = (e_domainRelationMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainRelationMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_domainRelationMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainRelationMap::
operator == (const GGS_domainRelationMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_domainRelationMap::
operator != (const GGS_domainRelationMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_stringlist & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_domainRelationMap info  ;
    info.mDomains = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_stringlist   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomains ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringlist   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' domain relation is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_domainRelationMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringlist & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' domain relation has been already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_domainRelationMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_domainRelationMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap GGS_domainRelationMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainRelationMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_domainRelationMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @domainRelationMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_domainToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_domainToImplement::
cPtr_C_domainToImplement (const GGS_lstring & argument_0,
                                const GGS_domainAttributeMap & argument_1,
                                const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mDomainName (argument_0),
mAttributeMap (argument_1),
mRelationMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_domainToImplement * GGS_C_domainToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_domainToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_domainToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_domainToImplement * _p = dynamic_cast <const cPtr_C_domainToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mDomainName == _p->mDomainName).boolValue ()
         && (mAttributeMap == _p->mAttributeMap).boolValue ()
         && (mRelationMap == _p->mRelationMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_domainToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_domainToImplement:"
           << mDomainName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAttributeMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRelationMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_domainToImplement'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
GGS_C_domainToImplement (const GGS_C_domainToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement::
~GGS_C_domainToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_domainToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_domainToImplement::
operator = (const GGS_C_domainToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_domainToImplement GGS_C_domainToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_domainAttributeMap & argument_1,
                 const GGS_domainRelationMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_C_domainToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_domainToImplement (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_domainToImplement::
reader_mDomainName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_domainToImplement *) mPointer)->mDomainName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainAttributeMap  GGS_C_domainToImplement::
reader_mAttributeMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainAttributeMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_domainToImplement *) mPointer)->mAttributeMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_domainRelationMap  GGS_C_domainToImplement::
reader_mRelationMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_domainRelationMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_domainToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_domainToImplement *) mPointer)->mRelationMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_domainToImplement::
operator == (const GGS_C_domainToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_domainToImplement::
operator != (const GGS_C_domainToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_domainToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_domainToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeEntiteActionExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEntiteActionExterne::
cPtr_typeEntiteActionExterne (const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_AC_semanticsEntity (THERE),
aSignature (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEntiteActionExterne * GGS_typeEntiteActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEntiteActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEntiteActionExterne::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEntiteActionExterne * _p = dynamic_cast <const cPtr_typeEntiteActionExterne *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aSignature == _p->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEntiteActionExterne::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEntiteActionExterne:"
           << aSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteActionExterne
::static_string_message_messageTypeEntite (void) {
  return "an external action" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEntiteActionExterne::
message_messageTypeEntite (void) const {
  return "an external action" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne::
GGS_typeEntiteActionExterne (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne::
GGS_typeEntiteActionExterne (const GGS_typeEntiteActionExterne & inOperand)
:GGS_AC_semanticsEntity () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne::
~GGS_typeEntiteActionExterne (void) {
  macroDetachPointer (mPointer, cPtr_typeEntiteActionExterne) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntiteActionExterne::
operator = (const GGS_typeEntiteActionExterne & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEntiteActionExterne GGS_typeEntiteActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_EXsignature & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEntiteActionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeEntiteActionExterne (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteActionExterne::
reader_messageTypeEntite (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageTypeEntite ())) ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeEntiteActionExterne::
reader_aSignature (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEntiteActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEntiteActionExterne *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteActionExterne::
operator == (const GGS_typeEntiteActionExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntiteActionExterne::
operator != (const GGS_typeEntiteActionExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntiteActionExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEntiteActionExterne" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeActionExterneAengendrer'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeActionExterneAengendrer::
cPtr_typeActionExterneAengendrer (const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomAction (argument_0),
aSignature (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeActionExterneAengendrer * GGS_typeActionExterneAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeActionExterneAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeActionExterneAengendrer::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeActionExterneAengendrer * _p = dynamic_cast <const cPtr_typeActionExterneAengendrer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomAction == _p->aNomAction).boolValue ()
         && (aSignature == _p->aSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeActionExterneAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeActionExterneAengendrer:"
           << aNomAction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer::
GGS_typeActionExterneAengendrer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer::
GGS_typeActionExterneAengendrer (const GGS_typeActionExterneAengendrer & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer::
~GGS_typeActionExterneAengendrer (void) {
  macroDetachPointer (mPointer, cPtr_typeActionExterneAengendrer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActionExterneAengendrer::
operator = (const GGS_typeActionExterneAengendrer & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeActionExterneAengendrer GGS_typeActionExterneAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_EXsignature & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeActionExterneAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeActionExterneAengendrer (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeActionExterneAengendrer::
reader_aNomAction (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeActionExterneAengendrer *) mPointer)->aNomAction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_EXsignature  GGS_typeActionExterneAengendrer::
reader_aSignature (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_EXsignature   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeActionExterneAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeActionExterneAengendrer *) mPointer)->aSignature ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeActionExterneAengendrer::
operator == (const GGS_typeActionExterneAengendrer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeActionExterneAengendrer::
operator != (const GGS_typeActionExterneAengendrer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActionExterneAengendrer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeActionExterneAengendrer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEntitiesToGenerateList::
elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mEntityToGenerate (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEntitiesToGenerateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeEntitiesToGenerateList * _p = dynamic_cast <const elementOf_GGS_typeEntitiesToGenerateList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEntityToGenerate == _p->mEntityToGenerate).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEntitiesToGenerateList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityToGenerate.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::GGS_typeEntitiesToGenerateList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList::
GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntitiesToGenerateList::
operator == (const GGS_typeEntitiesToGenerateList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEntitiesToGenerateList::
operator != (const GGS_typeEntitiesToGenerateList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalAppendValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_internalPrependValues (const GGS_typeEntityToGenerate & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_addAssign_operation (const GGS_typeEntityToGenerate & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList GGS_typeEntitiesToGenerateList::
operator + (const GGS_typeEntitiesToGenerateList & inOperand) const {
  GGS_typeEntitiesToGenerateList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeEntitiesToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeEntityToGenerate  p_0 = p->mEntityToGenerate ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeEntityToGenerate & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntityToGenerate
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEntitiesToGenerateList  GGS_typeEntitiesToGenerateList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeEntityToGenerate & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEntitiesToGenerateList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEntitiesToGenerateList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeEntitiesToGenerateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_first (C_Lexique & _inLexique,
              GGS_typeEntityToGenerate & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
method_last (C_Lexique & _inLexique,
             GGS_typeEntityToGenerate & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeEntityToGenerate & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEntitiesToGenerateList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeEntityToGenerate & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityToGenerate ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@typeEnumCstMessageStringMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeEnumCstMessageStringMap::
elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeEnumCstMessageStringMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeEnumCstMessageStringMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMessageString.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeEnumCstMessageStringMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeEnumCstMessageStringMap * _p = dynamic_cast <const elementOf_GGS_typeEnumCstMessageStringMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mMessageString == _p->mInfo.mMessageString).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeEnumCstMessageStringMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeEnumCstMessageStringMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeEnumCstMessageStringMap * info = (e_typeEnumCstMessageStringMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeEnumCstMessageStringMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
operator == (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEnumCstMessageStringMap::
operator != (const GGS_typeEnumCstMessageStringMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeEnumCstMessageStringMap info  ;
    info.mMessageString = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mMessageString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the message for '%K' constant is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEnumCstMessageStringMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the message for '%K' constant is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumCstMessageStringMap GGS_typeEnumCstMessageStringMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumCstMessageStringMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEnumCstMessageStringMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeEnumCstMessageStringMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_enumGalgasType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumGalgasType::
cPtr_enumGalgasType (const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
mEnumTypeName (argument_0),
mConstantMap (argument_1),
mEnumMessageMap (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumGalgasType * GGS_enumGalgasType::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_enumGalgasType *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumGalgasType::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumGalgasType * _p = dynamic_cast <const cPtr_enumGalgasType *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mEnumTypeName == _p->mEnumTypeName).boolValue ()
         && (mConstantMap == _p->mConstantMap).boolValue ()
         && (mEnumMessageMap == _p->mEnumMessageMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumGalgasType::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@enumGalgasType:"
           << mEnumTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mConstantMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEnumMessageMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType::
GGS_enumGalgasType (const GGS_enumGalgasType & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType::
~GGS_enumGalgasType (void) {
  macroDetachPointer (mPointer, cPtr_enumGalgasType) ;
}

//---------------------------------------------------------------------------*

void GGS_enumGalgasType::
operator = (const GGS_enumGalgasType & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumGalgasType GGS_enumGalgasType::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_enumConstantMap & argument_1,
                 const GGS_typeEnumMessageMap & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumGalgasType result ;
  macroMyNew (result.mPointer, cPtr_enumGalgasType (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumGalgasType::
reader_mEnumTypeName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumConstantMap  GGS_enumGalgasType::
reader_mConstantMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumConstantMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mConstantMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEnumMessageMap  GGS_enumGalgasType::
reader_mEnumMessageMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEnumMessageMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumGalgasType *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumGalgasType *) mPointer)->mEnumMessageMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumGalgasType::
operator == (const GGS_enumGalgasType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_enumGalgasType::
operator != (const GGS_enumGalgasType & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumGalgasType::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @enumGalgasType" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map '@treewalkingRoutineHeaderMap'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_treewalkingRoutineHeaderMap::
elementOf_GGS_treewalkingRoutineHeaderMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_treewalkingRoutineHeaderMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_treewalkingRoutineHeaderMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mRoutineSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_treewalkingRoutineHeaderMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_treewalkingRoutineHeaderMap * _p = dynamic_cast <const elementOf_GGS_treewalkingRoutineHeaderMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mRoutineSignature == _p->mInfo.mRoutineSignature).boolValue ()
           && (mInfo.mFormalArgumentList == _p->mInfo.mFormalArgumentList).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_treewalkingRoutineHeaderMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_treewalkingRoutineHeaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_treewalkingRoutineHeaderMap * info = (e_treewalkingRoutineHeaderMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_treewalkingRoutineHeaderMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_treewalkingRoutineHeaderMap * info = (e_treewalkingRoutineHeaderMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineHeaderMap GGS_treewalkingRoutineHeaderMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineHeaderMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_treewalkingRoutineHeaderMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_treewalkingRoutineHeaderMap::
operator == (const GGS_treewalkingRoutineHeaderMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_treewalkingRoutineHeaderMap::
operator != (const GGS_treewalkingRoutineHeaderMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_L_EXsignature & inParameter0,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_treewalkingRoutineHeaderMap info  ;
    info.mRoutineSignature = inParameter0 ;
    info.mFormalArgumentList = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_L_EXsignature   & outParameter0,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    outParameter1 = node->mInfo.mFormalArgumentList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_L_EXsignature   & outParameter0,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' treewalking routine is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineHeaderMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature & inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' treewalking routine has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineHeaderMap GGS_treewalkingRoutineHeaderMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_treewalkingRoutineHeaderMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineHeaderMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineHeaderMap GGS_treewalkingRoutineHeaderMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_treewalkingRoutineHeaderMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_treewalkingRoutineHeaderMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @treewalkingRoutineHeaderMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@treewalkingRoutineToGenerateList'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_treewalkingRoutineToGenerateList::
elementOf_GGS_treewalkingRoutineToGenerateList (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mMetamodelClass (argument_0),
mFormalArgumentList (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_treewalkingRoutineToGenerateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_treewalkingRoutineToGenerateList * _p = dynamic_cast <const elementOf_GGS_treewalkingRoutineToGenerateList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMetamodelClass == _p->mMetamodelClass).boolValue ()
         && (mFormalArgumentList == _p->mFormalArgumentList).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_treewalkingRoutineToGenerateList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@treewalkingRoutineToGenerateList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList::GGS_treewalkingRoutineToGenerateList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList::
GGS_treewalkingRoutineToGenerateList (const GGS_treewalkingRoutineToGenerateList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_treewalkingRoutineToGenerateList::
operator == (const GGS_treewalkingRoutineToGenerateList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_treewalkingRoutineToGenerateList::
operator != (const GGS_treewalkingRoutineToGenerateList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                    const GGS_typeInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList GGS_treewalkingRoutineToGenerateList::
operator + (const GGS_treewalkingRoutineToGenerateList & inOperand) const {
  GGS_treewalkingRoutineToGenerateList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_treewalkingRoutineToGenerateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMetamodelClass ;
          GGS_typeListeTypesEtNomsArgMethode  p_1 = p->mFormalArgumentList ;
          GGS_typeInstructionList  p_2 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                     const GGS_typeInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMetamodelClass,
                                _p->mFormalArgumentList,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList  GGS_treewalkingRoutineToGenerateList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineToGenerateList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_treewalkingRoutineToGenerateList  GGS_treewalkingRoutineToGenerateList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                           const GGS_typeInstructionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_treewalkingRoutineToGenerateList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_treewalkingRoutineToGenerateList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@treewalkingRoutineToGenerateList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_typeListeTypesEtNomsArgMethode & _out_1,
              GGS_typeInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_typeListeTypesEtNomsArgMethode & _out_1,
             GGS_typeInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_typeListeTypesEtNomsArgMethode & _out_1,
                 GGS_typeInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_treewalkingRoutineToGenerateList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_typeListeTypesEtNomsArgMethode & _out_1,
                GGS_typeInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClass ;
    _out_1 = _p->mFormalArgumentList ;
    _out_2 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@routineDispatcherSortedList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_routineDispatcherSortedList::
elementOf_GGS_routineDispatcherSortedList (const GGS_string& argument_0,
                                const GGS_uint & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3):
mMetamodelClassIDString (argument_0),
mMetamodelClassID (argument_1),
mRoutineName (argument_2),
mEntityName (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineDispatcherSortedList::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_routineDispatcherSortedList * _p = dynamic_cast <const elementOf_GGS_routineDispatcherSortedList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMetamodelClassIDString == _p->mMetamodelClassIDString).boolValue ()
         && (mMetamodelClassID == _p->mMetamodelClassID).boolValue ()
         && (mRoutineName == _p->mRoutineName).boolValue ()
         && (mEntityName == _p->mEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

sint32 elementOf_GGS_routineDispatcherSortedList::
compareForSorting (const cSortedListElement * inOperand) const {
  elementOf_GGS_routineDispatcherSortedList * operand = (elementOf_GGS_routineDispatcherSortedList *) inOperand ;
  sint32 result = mMetamodelClassIDString.compare (operand->mMetamodelClassIDString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineDispatcherSortedList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelClassIDString.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelClassID.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@routineDispatcherSortedList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList::GGS_routineDispatcherSortedList (void): AC_galgas_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList::
GGS_routineDispatcherSortedList (const GGS_routineDispatcherSortedList & inSource): AC_galgas_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDispatcherSortedList::
operator == (const GGS_routineDispatcherSortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineDispatcherSortedList::
operator != (const GGS_routineDispatcherSortedList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_uint & argument_1,
                    const GGS_string& argument_2,
                    const GGS_string& argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_uint & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList GGS_routineDispatcherSortedList::
operator + (const GGS_routineDispatcherSortedList & inOperand) const {
  GGS_routineDispatcherSortedList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_routineDispatcherSortedList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mMetamodelClassIDString ;
          GGS_uint  p_1 = p->mMetamodelClassID ;
          GGS_string p_2 = p->mRoutineName ;
          GGS_string p_3 = p->mEntityName ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMetamodelClassIDString,
                                _p->mMetamodelClassID,
                                _p->mRoutineName,
                                _p->mEntityName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList  GGS_routineDispatcherSortedList::
constructor_emptySortedList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineDispatcherSortedList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDispatcherSortedList  GGS_routineDispatcherSortedList::
constructor_sortedListWithValue (C_Lexique & /* _inLexique */,
                           const GGS_string& argument_0,
                           const GGS_uint & argument_1,
                           const GGS_string& argument_2,
                           const GGS_string& argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineDispatcherSortedList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineDispatcherSortedList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@routineDispatcherSortedList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
method_smallest (C_Lexique & _inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1,
                 GGS_string& _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
method_greatest (C_Lexique & _inLexique,
             GGS_string& _out_0,
             GGS_uint & _out_1,
             GGS_string& _out_2,
             GGS_string& _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
modifier_popSmallest (C_Lexique & _inLexique,
                 GGS_string& _out_0,
                 GGS_uint & _out_1,
                 GGS_string& _out_2,
                 GGS_string& _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
    _insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineDispatcherSortedList::
modifier_popGreatest (C_Lexique & _inLexique,
                GGS_string& _out_0,
                GGS_uint & _out_1,
                GGS_string& _out_2,
                GGS_string& _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelClassIDString ;
    _out_1 = _p->mMetamodelClassID ;
    _out_2 = _p->mRoutineName ;
    _out_3 = _p->mEntityName ;
    _insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_callInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_callInstruction::
cPtr_callInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_AC_galgasType & argument_2,
                                const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstruction (THERE),
mCalledPropertyName (argument_0),
mEntityName (argument_1),
mPropertyType (argument_2),
mExpressionsList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_callInstruction * GGS_callInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_callInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_callInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_callInstruction * _p = dynamic_cast <const cPtr_callInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mCalledPropertyName == _p->mCalledPropertyName).boolValue ()
         && (mEntityName == _p->mEntityName).boolValue ()
         && (mPropertyType == _p->mPropertyType).boolValue ()
         && (mExpressionsList == _p->mExpressionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_callInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@callInstruction:"
           << mCalledPropertyName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mPropertyType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mExpressionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_callInstruction::
GGS_callInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_callInstruction::
GGS_callInstruction (const GGS_callInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_callInstruction::
~GGS_callInstruction (void) {
  macroDetachPointer (mPointer, cPtr_callInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_callInstruction::
operator = (const GGS_callInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_callInstruction GGS_callInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_AC_galgasType & argument_2,
                 const GGS_typeExpressionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_callInstruction result ;
  macroMyNew (result.mPointer, cPtr_callInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_callInstruction::
reader_mCalledPropertyName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mCalledPropertyName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_callInstruction::
reader_mEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_callInstruction::
reader_mPropertyType (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mPropertyType ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_callInstruction::
reader_mExpressionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_callInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_callInstruction *) mPointer)->mExpressionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_callInstruction::
operator == (const GGS_callInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_callInstruction::
operator != (const GGS_callInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_callInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @callInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_C_metamodelEntityToImplement'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_metamodelEntityToImplement::
cPtr_C_metamodelEntityToImplement (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_typeListeAttributsSemantiques & argument_3,
                                const GGS_string& argument_4,
                                const GGS_uint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomClasse (argument_0),
mIsAbstract (argument_1),
aListeTousAttributsNonExternes (argument_2),
aListeAttributsCourants (argument_3),
mSuperClassName (argument_4),
mMetamodelClassID (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_metamodelEntityToImplement * GGS_C_metamodelEntityToImplement::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_metamodelEntityToImplement *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_metamodelEntityToImplement::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_metamodelEntityToImplement * _p = dynamic_cast <const cPtr_C_metamodelEntityToImplement *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomClasse == _p->aNomClasse).boolValue ()
         && (mIsAbstract == _p->mIsAbstract).boolValue ()
         && (aListeTousAttributsNonExternes == _p->aListeTousAttributsNonExternes).boolValue ()
         && (aListeAttributsCourants == _p->aListeAttributsCourants).boolValue ()
         && (mSuperClassName == _p->mSuperClassName).boolValue ()
         && (mMetamodelClassID == _p->mMetamodelClassID).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_metamodelEntityToImplement::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_metamodelEntityToImplement:"
           << aNomClasse.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTousAttributsNonExternes.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeAttributsCourants.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSuperClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mMetamodelClassID.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_metamodelEntityToImplement'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement::
GGS_C_metamodelEntityToImplement (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement::
GGS_C_metamodelEntityToImplement (const GGS_C_metamodelEntityToImplement & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement::
~GGS_C_metamodelEntityToImplement (void) {
  macroDetachPointer (mPointer, cPtr_C_metamodelEntityToImplement) ;
}

//---------------------------------------------------------------------------*

void GGS_C_metamodelEntityToImplement::
operator = (const GGS_C_metamodelEntityToImplement & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_metamodelEntityToImplement GGS_C_metamodelEntityToImplement::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_typeListeAttributsSemantiques & argument_2,
                 const GGS_typeListeAttributsSemantiques & argument_3,
                 const GGS_string& argument_4,
                 const GGS_uint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_C_metamodelEntityToImplement result ;
  macroMyNew (result.mPointer, cPtr_C_metamodelEntityToImplement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_C_metamodelEntityToImplement::
reader_aNomClasse (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->aNomClasse ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_metamodelEntityToImplement::
reader_mIsAbstract (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_metamodelEntityToImplement::
reader_aListeTousAttributsNonExternes (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->aListeTousAttributsNonExternes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsSemantiques  GGS_C_metamodelEntityToImplement::
reader_aListeAttributsCourants (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeAttributsSemantiques   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->aListeAttributsCourants ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_metamodelEntityToImplement::
reader_mSuperClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_C_metamodelEntityToImplement::
reader_mMetamodelClassID (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_metamodelEntityToImplement *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_metamodelEntityToImplement *) mPointer)->mMetamodelClassID ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_metamodelEntityToImplement::
operator == (const GGS_C_metamodelEntityToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_metamodelEntityToImplement::
operator != (const GGS_C_metamodelEntityToImplement & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_metamodelEntityToImplement::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_metamodelEntityToImplement" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@ruleDescriptorForProgramList'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ruleDescriptorForProgramList::
elementOf_GGS_ruleDescriptorForProgramList (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSourceExtension (argument_0),
mHelpMessage (argument_1),
mSourceFileName (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ruleDescriptorForProgramList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ruleDescriptorForProgramList * _p = dynamic_cast <const elementOf_GGS_ruleDescriptorForProgramList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSourceExtension == _p->mSourceExtension).boolValue ()
         && (mHelpMessage == _p->mHelpMessage).boolValue ()
         && (mSourceFileName == _p->mSourceFileName).boolValue ()
         && (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ruleDescriptorForProgramList::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExtension.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHelpMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceFileName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@ruleDescriptorForProgramList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList::GGS_ruleDescriptorForProgramList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList::
GGS_ruleDescriptorForProgramList (const GGS_ruleDescriptorForProgramList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ruleDescriptorForProgramList::
operator == (const GGS_ruleDescriptorForProgramList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_ruleDescriptorForProgramList::
operator != (const GGS_ruleDescriptorForProgramList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_string& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_typeInstructionList & argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_string& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeInstructionList & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList GGS_ruleDescriptorForProgramList::
operator + (const GGS_ruleDescriptorForProgramList & inOperand) const {
  GGS_ruleDescriptorForProgramList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_ruleDescriptorForProgramList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSourceExtension ;
          GGS_string p_1 = p->mHelpMessage ;
          GGS_lstring  p_2 = p->mSourceFileName ;
          GGS_typeInstructionList  p_3 = p->mInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_string& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_typeInstructionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSourceExtension,
                                _p->mHelpMessage,
                                _p->mSourceFileName,
                                _p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ruleDescriptorForProgramList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ruleDescriptorForProgramList  GGS_ruleDescriptorForProgramList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_string& argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_typeInstructionList & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_ruleDescriptorForProgramList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ruleDescriptorForProgramList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@ruleDescriptorForProgramList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_string& _out_1,
              GGS_lstring & _out_2,
              GGS_typeInstructionList & _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_string& _out_1,
             GGS_lstring & _out_2,
             GGS_typeInstructionList & _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_string& _out_1,
                 GGS_lstring & _out_2,
                 GGS_typeInstructionList & _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ruleDescriptorForProgramList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_string& _out_1,
                GGS_lstring & _out_2,
                GGS_typeInstructionList & _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSourceExtension ;
    _out_1 = _p->mHelpMessage ;
    _out_2 = _p->mSourceFileName ;
    _out_3 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_grammarDescriptorForProgram'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarDescriptorForProgram::
elementOf_GGS_L_grammarDescriptorForProgram (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_L_lstringList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_lstring & argument_7,
                                const GGS_string& argument_8
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mGrammarPostfix (argument_0),
mGrammarName (argument_1),
mStartSymbolSignature (argument_2),
mStartSymbolAttributesList (argument_3),
mLexiqueClassName (argument_4),
mReturnedMetamodelName (argument_5),
mReturnedRootEntityName (argument_6),
mSourceExtension (argument_7),
mHelpMessage (argument_8) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_grammarDescriptorForProgram::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_grammarDescriptorForProgram * _p = dynamic_cast <const elementOf_GGS_L_grammarDescriptorForProgram *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mGrammarPostfix == _p->mGrammarPostfix).boolValue ()
         && (mGrammarName == _p->mGrammarName).boolValue ()
         && (mStartSymbolSignature == _p->mStartSymbolSignature).boolValue ()
         && (mStartSymbolAttributesList == _p->mStartSymbolAttributesList).boolValue ()
         && (mLexiqueClassName == _p->mLexiqueClassName).boolValue ()
         && (mReturnedMetamodelName == _p->mReturnedMetamodelName).boolValue ()
         && (mReturnedRootEntityName == _p->mReturnedRootEntityName).boolValue ()
         && (mSourceExtension == _p->mSourceExtension).boolValue ()
         && (mHelpMessage == _p->mHelpMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_grammarDescriptorForProgram::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarPostfix.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mGrammarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartSymbolSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStartSymbolAttributesList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedMetamodelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedRootEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSourceExtension.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHelpMessage.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_grammarDescriptorForProgram'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::GGS_L_grammarDescriptorForProgram (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::
GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarDescriptorForProgram::
operator == (const GGS_L_grammarDescriptorForProgram & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_grammarDescriptorForProgram::
operator != (const GGS_L_grammarDescriptorForProgram & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_L_EXsignature & argument_2,
                    const GGS_L_lstringList & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_lstring & argument_5,
                    const GGS_lstring & argument_6,
                    const GGS_lstring & argument_7,
                    const GGS_string& argument_8
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_L_EXsignature & argument_2,
                    const GGS_L_lstringList & argument_3,
                    const GGS_lstring & argument_4,
                    const GGS_lstring & argument_5,
                    const GGS_lstring & argument_6,
                    const GGS_lstring & argument_7,
                    const GGS_string& argument_8
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_addAssign_operation (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_EXsignature & argument_2,
                                const GGS_L_lstringList & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_lstring & argument_6,
                                const GGS_lstring & argument_7,
                                const GGS_string& argument_8) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram GGS_L_grammarDescriptorForProgram::
operator + (const GGS_L_grammarDescriptorForProgram & inOperand) const {
  GGS_L_grammarDescriptorForProgram result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_grammarDescriptorForProgram * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mGrammarPostfix ;
          GGS_lstring  p_1 = p->mGrammarName ;
          GGS_L_EXsignature  p_2 = p->mStartSymbolSignature ;
          GGS_L_lstringList  p_3 = p->mStartSymbolAttributesList ;
          GGS_lstring  p_4 = p->mLexiqueClassName ;
          GGS_lstring  p_5 = p->mReturnedMetamodelName ;
          GGS_lstring  p_6 = p->mReturnedRootEntityName ;
          GGS_lstring  p_7 = p->mSourceExtension ;
          GGS_string p_8 = p->mHelpMessage ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_L_EXsignature & argument_2,
                     const GGS_L_lstringList & argument_3,
                     const GGS_lstring & argument_4,
                     const GGS_lstring & argument_5,
                     const GGS_lstring & argument_6,
                     const GGS_lstring & argument_7,
                     const GGS_string& argument_8
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mGrammarPostfix,
                                _p->mGrammarName,
                                _p->mStartSymbolSignature,
                                _p->mStartSymbolAttributesList,
                                _p->mLexiqueClassName,
                                _p->mReturnedMetamodelName,
                                _p->mReturnedRootEntityName,
                                _p->mSourceExtension,
                                _p->mHelpMessage
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarDescriptorForProgram result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_string& argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_L_EXsignature & argument_2,
                           const GGS_L_lstringList & argument_3,
                           const GGS_lstring & argument_4,
                           const GGS_lstring & argument_5,
                           const GGS_lstring & argument_6,
                           const GGS_lstring & argument_7,
                           const GGS_string& argument_8
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_grammarDescriptorForProgram result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6, argument_7, argument_8) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_grammarDescriptorForProgram::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_grammarDescriptorForProgram", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
method_first (C_Lexique & _inLexique,
              GGS_string& _out_0,
              GGS_lstring & _out_1,
              GGS_L_EXsignature & _out_2,
              GGS_L_lstringList & _out_3,
              GGS_lstring & _out_4,
              GGS_lstring & _out_5,
              GGS_lstring & _out_6,
              GGS_lstring & _out_7,
              GGS_string& _out_8
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mSourceExtension ;
    _out_8 = _p->mHelpMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
method_last (C_Lexique & _inLexique,
             GGS_string& _out_0,
             GGS_lstring & _out_1,
             GGS_L_EXsignature & _out_2,
             GGS_L_lstringList & _out_3,
             GGS_lstring & _out_4,
             GGS_lstring & _out_5,
             GGS_lstring & _out_6,
             GGS_lstring & _out_7,
             GGS_string& _out_8
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mSourceExtension ;
    _out_8 = _p->mHelpMessage ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_string& _out_0,
                 GGS_lstring & _out_1,
                 GGS_L_EXsignature & _out_2,
                 GGS_L_lstringList & _out_3,
                 GGS_lstring & _out_4,
                 GGS_lstring & _out_5,
                 GGS_lstring & _out_6,
                 GGS_lstring & _out_7,
                 GGS_string& _out_8
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mSourceExtension ;
    _out_8 = _p->mHelpMessage ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
modifier_popLast (C_Lexique & _inLexique,
                GGS_string& _out_0,
                GGS_lstring & _out_1,
                GGS_L_EXsignature & _out_2,
                GGS_L_lstringList & _out_3,
                GGS_lstring & _out_4,
                GGS_lstring & _out_5,
                GGS_lstring & _out_6,
                GGS_lstring & _out_7,
                GGS_string& _out_8
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mGrammarPostfix ;
    _out_1 = _p->mGrammarName ;
    _out_2 = _p->mStartSymbolSignature ;
    _out_3 = _p->mStartSymbolAttributesList ;
    _out_4 = _p->mLexiqueClassName ;
    _out_5 = _p->mReturnedMetamodelName ;
    _out_6 = _p->mReturnedRootEntityName ;
    _out_7 = _p->mSourceExtension ;
    _out_8 = _p->mHelpMessage ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
    _out_5._drop_operation () ;
    _out_6._drop_operation () ;
    _out_7._drop_operation () ;
    _out_8._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

