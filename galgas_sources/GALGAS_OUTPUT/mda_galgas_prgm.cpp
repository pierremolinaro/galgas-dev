//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'mda_galgas_prgm.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 10th, 2008, at 20h27'21"                     *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include "utilities/F_DisplayException.h"
#include "utilities/MF_MemoryControl.h"
#include "collections/TC_UniqueArray.h"
#include "command_line_interface/F_Analyze_CLI_Options.h"
#include "command_line_interface/mainForLIBPM.h"
#include "utilities/MF_MemoryControl.h"

#ifdef TARGET_API_MAC_CARBON
  #include <SIOUX.H>
#endif

#ifdef COMPILE_FOR_WIN32
  #ifdef __MWERKS__
    #include <WINSIOUX.H>
  #endif
#endif

#include <typeinfo>

//---------------------------------------------------------------------------*

#include "galgas_LL1_grammar.h"
#include "grammarLL1grammar.h"
#include "grammarMetamodel.h"
#include "guiCompilation.h"
#include "guiLL1grammar.h"
#include "guiMetamodel.h"
#include "lexiqueCompilation.h"
#include "lexiqueLL1grammar.h"
#include "lexiqueSemantics.h"
#include "mda_galgas_prgm.h"
#include "mda_galgas_routines.h"
#include "optionCompilation.h"
#include "optionMetamodel.h"
#include "optionSemantics.h"
#include "programMetamodel.h"
#include "programSLRgrammar.h"
#include "projectCreation.h"
#include "projectLL1grammar.h"
#include "semanticsMetamodel.h"
#include "semanticsSemantics.h"
#include "semantics_semantics.h"
#include "syntaxMetamodel.h"
#include "syntaxSLRgrammar.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "mda_galgas_prgm.gProgram", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                C_options_for_mda_galgas_prgm  CONSTRUCTOR                 *
//                                                                           *
//---------------------------------------------------------------------------*

C_options_for_mda_galgas_prgm::
C_options_for_mda_galgas_prgm (const bool inAcceptsDebugOption) :
mBuiltinOptions (inAcceptsDebugOption),
mGalgasOptions (),
mOptions_galgas_cli_options (){
  add (& mBuiltinOptions) ;
  add (& mGalgasOptions) ;
  add (& mOptions_galgas_cli_options) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    P R O L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
mda_galgas_prgm_prologue (C_Compiler & _inLexique,
                     const TC_UniqueArray <C_String> & /* inSourceFilesArray */) {
  GGS_string var_cas_creationProjectName ;
  var_cas_creationProjectName = GGS_string (true, _inLexique.stringOptionValueFromKeys ("galgas_cli_options", "create_project" COMMA_SOURCE_FILE_AT_LINE (48))) ;
  ::routine_projectCreation (_inLexique,  var_cas_creationProjectName COMMA_SOURCE_FILE_AT_LINE (49)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    E P I L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
mda_galgas_prgm_epilogue (C_Compiler & /* _inLexique */,
                     const TC_UniqueArray <C_String> & /* inSourceFilesArray */) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      M A I N    F O R    L I B P M                        *
//                                                                           *
//---------------------------------------------------------------------------*

#include <iostream>
using namespace std;
#include "DDD.h"
#include "DED.h"
#include "Hom.h"
#include "MemoryManager.h"

typedef enum {A, B, C, D,E, F, G} var;
var variables;
const char* vn[]= {"A", "B", "C", "D", "E", "F", "G"};


// incremente all values of X
class _plusplus:public StrongHom {
  int var;
public:
  _plusplus(int vr):var(vr) {}

  GDDD phiOne() const {
    return GDDD::one;
  }                   

  GHom phi(int vr, int vl) const {
    if (vr == var)
      return GHom(vr,vl+1)&GHom(this);
    else 
      return GHom(vr,vl)&GHom(this); 
  }

  size_t hash() const {
    return var;
  }

  bool operator==(const StrongHom &s) const {
    _plusplus* ps = (_plusplus*)&s;
    return var == ps->var;
  }
};

// User function : Construct a Hom for a Strong Hom _plusplus
GHom plusplus(int vr){return new _plusplus(vr);};


int mainForLIBPM  (const int argc, const char * argv []) {
  for (int i=A; i<=G; i++) DDD::varName(i,vn[i]);

  DDD a=DDD(A,1,DDD(A,1));
  DDD b=DDD(C,1,DDD(A,1))+DDD(C,2,DDD(B,3));
  DDD u=a^b;

  cout <<"u="<< endl<<u<<endl;

  Hom fa = plusplus(A);
  Hom fb = plusplus(B);
//  Hom fc = plusplus(C);
//  Hom fd = plusplus(D);
  Hom ff = fa & fb ;

//  cout <<"<!A++>(u)="<< endl<<fb(fa(u)) <<endl;
  cout <<"<!A++o!B++>(u)="<< endl<<ff(u)<<endl;
//  cout <<"<!C++>(u)="<< endl<<fc(u)<<endl;
//  cout <<"<!D++>(u)="<< endl<<fd(u)<<endl;

  MemoryManager::pstats();





  bool verboseOptionOn = true ;
  sint16 returnCode = 0 ; // No error
//--- Fix parameters for BDD package
  C_BDD::setHashMapSize (18) ;
  C_BDD::setITEcacheSize (15) ;
  C_BDD::setANDcacheSize (1) ;
  C_BDD::forAllOnBitsGreaterCacheSize (17) ;
  C_PrologueEpilogueAction::runPrologueActions () ;
  {
  //--- Input/output parameters
    C_options_for_mda_galgas_prgm options (false) ;
    const char * extensions [] = {"ggs", "gOption", "gLexique", "gSemantics", "gSyntax", "gGrammar", "gGui", "gProgram", "gProject", NULL} ;
    const char * helpMessages [] = {"a '.ggs' GALGAS source file", "a GALGAS option source file", "a GALGAS lexique source file", "a GALGAS semantics source file", "a GALGAS syntax source file", "a GALGAS grammar source file", "a GALGAS GUI source file", "a GALGAS program source file", "a GALGAS project source file", NULL} ;
    TC_UniqueArray <C_String> sourceFilesArray ;
  //--- Analyze Command Line Options
    bool cocoaOutput = false ;
    F_Analyze_CLI_Options (argc, argv,
                           "version GALGAS_BETA_VERSION",
                           options,
                           sourceFilesArray,
                           extensions,
                           helpMessages,
                           cocoaOutput) ;
    C_galgas_io_parameters IOparameters  (& options,
      cocoaOutput,
      #ifndef DO_NOT_GENERATE_CHECKINGS
        "version GALGAS_BETA_VERSION" " [debug]",
      #else
        "version GALGAS_BETA_VERSION",
      #endif
      argv [1],
      10000,
      10000) ;
  //--- Build galgas io object
    C_galgas_io * galgasIOptr = NULL ;
    macroMyNew (galgasIOptr, C_galgas_io (IOparameters, C_galgas_io::kTerminalOutputKind COMMA_HERE)) ;
  //--- Common lexique object
    C_Compiler * _commonLexique = NULL ;
    macroMyNew (_commonLexique, C_Compiler (galgasIOptr COMMA_HERE)) ;
  //--- Ask Save On Close ? (Carbon and Windows SIOUX Only)
    #ifdef SIOUX_IS_IMPLEMENTED
      SIOUXSettings.asktosaveonclose = options.boolOptionValueFromKeys ("generic_cli_options",
                                                                        ASK_TO_SAVE_ON_CLOSE,
                                                                        false) ;
    #endif
  //--- Enable 64 bit alloc debug ? Only if compiled in 64 bit and in debug mode
    #ifndef DO_NOT_GENERATE_CHECKINGS
      #ifdef __LP64__
        if (options.boolOptionValueFromKeys ("generic_cli_options",
                                             "enable_allocation_debugging",
                                             false)) {
          enableAllocDebugFor64BitTool () ;
        }
      #endif
    #endif
    try{
      verboseOptionOn = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                                         "verbose_output",
                                                         false) ;
      mda_galgas_prgm_prologue (* _commonLexique, sourceFilesArray) ;
      for (sint32 i=0 ; i<sourceFilesArray.count () ; i++) {
        try {
          const C_String fileExtension = sourceFilesArray (i COMMA_HERE).pathExtension () ;
          sint16 r = 0 ;
          if (fileExtension.compare ("ggs") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            if (var_cas_inSourceFile._isBuilt ()) {
              ::routine_fixFileGenerationStartDirectory (_inLexique,  var_cas_inSourceFile COMMA_SOURCE_FILE_AT_LINE (57)) ;
            }
            GGS_M_lexiqueComponents  var_cas_lexiqueMapForUse ;
            var_cas_lexiqueMapForUse = GGS_M_lexiqueComponents ::constructor_emptyMap (_inLexique COMMA_HERE) ;
            GGS_M_semanticsComponents  var_cas_semanticsComponentsMap ;
            var_cas_semanticsComponentsMap = GGS_M_semanticsComponents ::constructor_emptyMap (_inLexique COMMA_HERE) ;
            GGS_M_syntaxComponents  var_cas_syntaxComponentsMap ;
            var_cas_syntaxComponentsMap = GGS_M_syntaxComponents ::constructor_emptyMap (_inLexique COMMA_HERE) ;
            GGS_M_grammarComponents  var_cas_grammarComponentsMap ;
            var_cas_grammarComponentsMap = GGS_M_grammarComponents ::constructor_emptyMap (_inLexique COMMA_HERE) ;
            GGS_M_optionComponents  var_cas_optionComponentsMap ;
            var_cas_optionComponentsMap = GGS_M_optionComponents ::constructor_emptyMap (_inLexique COMMA_HERE) ;
            GGS_EXsemanticContext var_cas_semanticContext ;
            var_cas_semanticContext = GGS_EXsemanticContext::constructor_new (GGS_M_filewrappers ::constructor_emptyMap (_inLexique COMMA_HERE), GGS_stringset ::constructor_emptySet (), GGS_EXcategoryMethodMap ::constructor_emptyMap (_inLexique COMMA_HERE)) ;
            galgas_LL1_grammar::_performSourceFileParsing_ (_inLexique,
                                            NULL,
                                            var_cas_inSourceFile,
                                            var_cas_lexiqueMapForUse,
                                            var_cas_semanticsComponentsMap,
                                            var_cas_syntaxComponentsMap,
                                            var_cas_grammarComponentsMap,
                                            var_cas_optionComponentsMap,
                                            var_cas_semanticContext
                                            COMMA_SOURCE_FILE_AT_LINE (68)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gOption") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (84)) ;
            ::routine_compileOptionComponent (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (85)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gLexique") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (94)) ;
            ::routine_compileLexiqueComponent (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (95)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gSemantics") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (104)) ;
            GGS_parsedComponentStruct var_cas_parsedComponentStruct ;
            var_cas_parsedComponentStruct = GGS_parsedComponentStruct::constructor_new (GGS_parsedSemanticsComponentMap ::constructor_emptyMap (_inLexique COMMA_HERE)) ;
            ::routine_compileSemanticsComponent (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory,  var_cas_parsedComponentStruct COMMA_SOURCE_FILE_AT_LINE (108)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gSyntax") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (117)) ;
            GGS_syntaxComponentRoot  var_cas_syntaxComponentRoot ;
            syntaxSLRgrammar::_performSourceFileParsing_ (_inLexique,
                                            NULL,
                                            var_cas_inSourceFile,
                                            var_cas_syntaxComponentRoot
                                            COMMA_SOURCE_FILE_AT_LINE (119)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gGrammar") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (128)) ;
            GGS_grammarComponentRoot  var_cas_grammarComponentRoot ;
            grammarLL1grammar::_performSourceFileParsing_ (_inLexique,
                                            NULL,
                                            var_cas_inSourceFile,
                                            var_cas_grammarComponentRoot
                                            COMMA_SOURCE_FILE_AT_LINE (130)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gGui") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (139)) ;
            ::routine_compileGuiComponent (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (140)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gProgram") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (149)) ;
            GGS_programComponentRoot  var_cas_programComponentRoot ;
            programSLRgrammar::_performSourceFileParsing_ (_inLexique,
                                            NULL,
                                            var_cas_inSourceFile,
                                            var_cas_programComponentRoot
                                            COMMA_SOURCE_FILE_AT_LINE (151)) ;
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else if (fileExtension.compare ("gProject") == 0) {
            C_Compiler & _inLexique = * _commonLexique ;
            const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
            const GGS_location _here (_inLexique) ;
            const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
            GGS_string var_cas_outputDirectory ;
            ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (161)) ;
            GGS_lstringlist  var_cas_fileList ;
            GGS_location  var_cas_endOfSourceFile ;
            projectLL1grammar::_performSourceFileParsing_ (_inLexique,
                                            NULL,
                                            var_cas_inSourceFile,
                                            var_cas_fileList,
                                            var_cas_endOfSourceFile
                                            COMMA_SOURCE_FILE_AT_LINE (168)) ;
            GGS_parsedComponentStruct var_cas_parsedComponentStruct ;
            var_cas_parsedComponentStruct = GGS_parsedComponentStruct::constructor_new (GGS_parsedSemanticsComponentMap ::constructor_emptyMap (_inLexique COMMA_HERE)) ;
            {
              GGS_lstringlist::cEnumerator enumerator_7075 (var_cas_fileList, true) ;
              const GGS_lstringlist::cElement * operand_7075 = NULL ;
              while (((operand_7075 = enumerator_7075.nextObject ()))) {
                macroValidPointer (operand_7075) ;
                _inLexique.printMessage (((GGS_string (true, "----- Compiling '"))._operator_concat (operand_7075->mValue))._operator_concat (GGS_string (true, "'\n")) COMMA_SOURCE_FILE_AT_LINE (174)) ;
                GGS_string var_cas_extension ;
                var_cas_extension = operand_7075->mValue.ggs_string ().reader_pathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (175)) ;
                GGS_lstring  var_cas_fullFilePath ;
                var_cas_fullFilePath = GGS_lstring ::constructor_new (_inLexique, ((var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (177)))._operator_concat (GGS_string (true, "/")))._operator_concat (operand_7075->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (177))), operand_7075->mValue.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (178)) COMMA_HERE) ;
                if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gSemantics"))).isBuiltAndTrue ()) {
                  ::routine_compileSemanticsComponent (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory,  var_cas_parsedComponentStruct COMMA_SOURCE_FILE_AT_LINE (181)) ;
                }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gLexique"))).isBuiltAndTrue ()) {
                  ::routine_compileLexiqueComponent (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (183)) ;
                }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gSyntax"))).isBuiltAndTrue ()) {
                }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gOption"))).isBuiltAndTrue ()) {
                  ::routine_compileOptionComponent (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (187)) ;
                }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gGrammar"))).isBuiltAndTrue ()) {
                }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gProgram"))).isBuiltAndTrue ()) {
                }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gGui"))).isBuiltAndTrue ()) {
                  ::routine_compileGuiComponent (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (193)) ;
                }else{
                  operand_7075->mValue.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "unhandled extension") COMMA_SOURCE_FILE_AT_LINE (196)) ;
                }
              }
            }
            if (((GGS_uint ::constructor_errorCount (_inLexique COMMA_HERE))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
              _inLexique.printMessage (GGS_string (true, "----- Perform global checkings\n") COMMA_SOURCE_FILE_AT_LINE (200)) ;
              ::routine_performProjectGlobalCheckings (_inLexique,  var_cas_parsedComponentStruct,  var_cas_endOfSourceFile COMMA_SOURCE_FILE_AT_LINE (201)) ;
            }
            if (verboseOptionOn) {
              co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
              switch (_commonLexique->totalErrorCount ()) {
              case 0 :
                co << "No error, " ;
                break ;
              case 1 :
                co << "1 error, " ;
                returnCode = 1 ; // Error code
                break ;
              default :
                co << _commonLexique->totalErrorCount () << " errors, " ;
                returnCode = 1 ; // Error code
                break ;
              }
              switch (_commonLexique->totalWarningCount ()) {
              case 0 :
                co << "no warning" ;
                break ;
              case 1 :
                co << "1 warning" ;
                break ;
              default :
                co << _commonLexique->totalWarningCount () << " warnings" ;
                break ;
              }
              if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
                co << ".\n" ;
              }
            }
          }else{
            printf ("*** Error: unhandled extension for file '%s' ***\n", sourceFilesArray (i COMMA_HERE).cString ()) ;
            r = 1 ;
          }
          if (r != 0) {
            returnCode = r ;
          }
        }catch (C_ScanOrParseOnlyException) { // Raised when scan only or parse only options are set
          // Do nothing: accept silently exception
        }
      }
    //--- Error or warnings ?
      if (_commonLexique->totalErrorCount () > 0) {
        returnCode = 1 ; // Error code
      }else if (_commonLexique->totalWarningCount () > 0) {
        const bool warningsAreTreatedAsError
            = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                               TREAT_WARNINGS_AS_ERRORS,
                                               false) ;
        if (warningsAreTreatedAsError) {
          returnCode = 1 ; // Error code
          if (verboseOptionOn) {
            printf ("** Note: warnings are treated as errors. **\n") ;
          }
        }
      }
    //--- Epilogue
      mda_galgas_prgm_epilogue (* _commonLexique, sourceFilesArray) ;
    }catch (const M_STD_NAMESPACE exception & e) {
      F_default_display_exception (e) ;
      returnCode = 1 ; // Error code
    }catch (...) {
      F_default_display_unknown_exception () ;
      returnCode = 2 ; // Error code
    }
    macroDetachPointer (galgasIOptr, C_galgas_io) ;
    macroDetachPointer (_commonLexique, C_Compiler) ;
    C_PrologueEpilogueAction::runEpilogueActions () ;
    runAllReleaseRoutines () ;
  }
  #ifndef DO_NOT_GENERATE_CHECKINGS
    C_GGS_Object::checkAllObjectsHaveBeenReleased () ;
  #endif
  if (verboseOptionOn) {
    #ifndef DO_NOT_GENERATE_CHECKINGS
      const uint64 maxUsedMemorySize = getMaxUsedMemorySize () ;
      const uint64 oneMegaByte = 1 << 20 ;
      const uint64 megaBytes = maxUsedMemorySize / oneMegaByte ;
      const uint64 fraction = ((maxUsedMemorySize % oneMegaByte) * 1000) / oneMegaByte ;
      co << getCreatedDynamicObjectsTotalCount ()
         << " C++ objects have been created ("
         << megaBytes << "." << widthWithZeroFill (3) << fraction
         << " MB).\n" ;
      deactivateMemoryControl () ;
      if ((getAllocationBalance () != 0) && (returnCode == 0)) {
        display_pointers () ;
      }
    #endif
  }
  return returnCode ;
}

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2


