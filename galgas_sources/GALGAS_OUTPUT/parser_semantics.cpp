//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'parser_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     october 20th, 2006, at 15h37'14"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "parser_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "parser_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeParserInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeParserInstruction::
cPtr_typeParserInstruction (LOCATION_ARGS)
:cPtr_typeInstruction (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeParserInstruction::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeParserInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeParserInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (const GGS_typeParserInstruction & inOperand)
:GGS_typeInstruction () {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
~GGS_typeParserInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeParserInstruction::
operator = (const GGS_typeParserInstruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeParserInstruction * GGS_typeParserInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeParserInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeParserInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeParserInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeParserInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelNonTerminal'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelNonTerminal::cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_bool& argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mNonterminalName (argument_0),
mParametersExpressionList (argument_1),
mAltName (argument_2),
mReturnedEntityVarName (argument_3),
mReturnedEntityShouldInsertedInList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelNonTerminal::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeInstructionAppelNonTerminal:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mParametersExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mAltName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mReturnedEntityVarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mReturnedEntityShouldInsertedInList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_bool& argument_4 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionAppelNonTerminal * _ptr = (cPtr_typeInstructionAppelNonTerminal *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionAppelNonTerminal (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_typeInstructionAppelNonTerminal result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelNonTerminal *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelNonTerminal::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionAppelNonTerminal" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeInstructionVerifSyntaxique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionVerifSyntaxique::cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aNomTerminal (argument_0),
aListeTypeEffectifs (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionVerifSyntaxique::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeInstructionVerifSyntaxique:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListeTypeEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_assignedVariables & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionVerifSyntaxique * _ptr = (cPtr_typeInstructionVerifSyntaxique *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionVerifSyntaxique (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeInstructionVerifSyntaxique result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionVerifSyntaxique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionVerifSyntaxique::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionVerifSyntaxique" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeBranchesInstructions'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeBranchesInstructions::
elementOf_GGS_typeListeBranchesInstructions (const GGS_typeInstructionList & argument_0):
mNextItem (NULL),
mPreviousItem (NULL),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeBranchesInstructions::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeBranchesInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::GGS_typeListeBranchesInstructions (void) { // Default Constructor
  _mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::~GGS_typeListeBranchesInstructions (void) {
  _drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::
GGS_typeListeBranchesInstructions (const GGS_typeListeBranchesInstructions & inSource) {
  _mRoot = inSource._mRoot ;
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    _mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
operator = (const GGS_typeListeBranchesInstructions & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::element_type * GGS_typeListeBranchesInstructions::
firstObject (void) const {
  return (_mRoot == NULL) ? NULL : _mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::element_type * GGS_typeListeBranchesInstructions::
lastObject (void) const {
  return (_mRoot == NULL) ? NULL : _mRoot->mLastItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_internalAppendItem (const GGS_typeInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (_mRoot->mLastItem == NULL) {
      _mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (_mRoot->mLastItem) ;
      _mRoot->mLastItem->mNextItem = nouvelElement ;
      nouvelElement->mPreviousItem = _mRoot->mLastItem ;
    }
    _mRoot->mLastItem = nouvelElement ;
    _mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_internalPrependItem (const GGS_typeInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (_mRoot->mFirstItem == NULL) {
      _mRoot->mLastItem = nouvelElement ;
    }else{
      macroValidPointer (_mRoot->mFirstItem) ;
      _mRoot->mFirstItem->mPreviousItem = nouvelElement ;
      nouvelElement->mNextItem = _mRoot->mFirstItem ;
    }
    _mRoot->mFirstItem = nouvelElement ;
    _mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_addAssign_operation (const GGS_typeInstructionList & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
operator + (const GGS_typeListeBranchesInstructions & inOperand) const {
  GGS_typeListeBranchesInstructions result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeBranchesInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstructionList  p_0 = p->mInstructionList ;
          result._internalAppendItem (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeInstructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()
) {
    _insulateList () ;
    _internalPrependItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_insulateList (void) {
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    if (_mRoot->mCountReference > 1) {
      element_type * p = _mRoot->mFirstItem ;
      _mRoot->mCountReference -- ;
      _mRoot = NULL ;
      macroMyNew (_mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        _internalAppendItem (p->mInstructionList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  macroMyNew (result._mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeInstructionList & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  macroMyNew (result._mRoot, cRootList) ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeBranchesInstructions::
count (void) const {
  return (_mRoot == NULL) ? 0 : _mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeBranchesInstructions::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<list @typeListeBranchesInstructions" ;
  if (_isBuilt ()) {
    s << " " << _mRoot->mListLength << " object" << ((_mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = _mRoot->mFirstItem ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      s << "\n" ;
      s.writeStringMultiple ("| ", inIndentation) ;
      s << "|-at " << elementIndex << " " ;
      p->appendForListDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
      p = p->mNextItem ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_first (C_Lexique & _inLexique,
              GGS_typeInstructionList & _out_0
              COMMA_LOCATION_ARGS) const {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mFirstItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mFirstItem->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_last (C_Lexique & _inLexique,
             GGS_typeInstructionList & _out_0
             COMMA_LOCATION_ARGS) const {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mLastItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mLastItem->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_popFirst (C_Lexique & _inLexique,
                 GGS_typeInstructionList & _out_0
                 COMMA_LOCATION_ARGS) {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mFirstItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mFirstItem->mInstructionList ;
    _insulateList () ;
    element_type * _p = _mRoot->mFirstItem ;
    _mRoot->mFirstItem = _mRoot->mFirstItem->mNextItem ;
    if (_mRoot->mFirstItem == NULL) {
      _mRoot->mLastItem = NULL ;
    }else{
      _mRoot->mFirstItem->mPreviousItem = NULL ;
    }
    _mRoot->mListLength -- ;
    macroMyDelete (_p, element_type) ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_popLast (C_Lexique & _inLexique,
                GGS_typeInstructionList & _out_0
                COMMA_LOCATION_ARGS) {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mLastItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mLastItem->mInstructionList ;
    _insulateList () ;
    element_type * _p = _mRoot->mLastItem ;
    _mRoot->mLastItem = _mRoot->mLastItem->mPreviousItem ;
    if (_mRoot->mLastItem == NULL) {
      _mRoot->mFirstItem = NULL ;
    }else{
      _mRoot->mLastItem->mNextItem = NULL ;
    }
    _mRoot->mListLength -- ;
    macroMyDelete (_p, element_type) ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeBranchesInstructions::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (_mRoot != NULL,
                   (_mRoot == NULL) ? 0 : (uint32) _mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_drop_operation (void) {
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    if (_mRoot->mCountReference == 1) {
      macroMyDelete (_mRoot, cRootList) ;
    }else{
      _mRoot->mCountReference -- ;
      _mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_select_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_select_instruction::cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_select_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_select_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aPositionDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_select_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction GGS_C_select_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_select_instruction * _ptr = (cPtr_C_select_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_select_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_select_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_select_instruction * GGS_C_select_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_select_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_select_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_select_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_repeat_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_repeat_instruction::cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aListesBranchesRepeter (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_repeat_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_repeat_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aListesBranchesRepeter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aPositionDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_repeat_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction GGS_C_repeat_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_repeat_instruction * _ptr = (cPtr_C_repeat_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_repeat_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_repeat_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_repeat_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_repeat_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_repeat_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_parse_rewind_signature_list'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_parse_rewind_signature_list::
elementOf_GGS_L_parse_rewind_signature_list (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1):
mNextItem (NULL),
mPreviousItem (NULL),
mSignature (argument_0),
mErrorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_parse_rewind_signature_list::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_parse_rewind_signature_list'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::GGS_L_parse_rewind_signature_list (void) { // Default Constructor
  _mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::~GGS_L_parse_rewind_signature_list (void) {
  _drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::
GGS_L_parse_rewind_signature_list (const GGS_L_parse_rewind_signature_list & inSource) {
  _mRoot = inSource._mRoot ;
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    _mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
operator = (const GGS_L_parse_rewind_signature_list & inSource) {
  if (this != & inSource) {
    _drop_operation () ;
    _mRoot = inSource._mRoot ;
    if (_mRoot != NULL) {
      macroValidPointer (_mRoot) ;
      _mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::element_type * GGS_L_parse_rewind_signature_list::
firstObject (void) const {
  return (_mRoot == NULL) ? NULL : _mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::element_type * GGS_L_parse_rewind_signature_list::
lastObject (void) const {
  return (_mRoot == NULL) ? NULL : _mRoot->mLastItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (_mRoot->mLastItem == NULL) {
      _mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (_mRoot->mLastItem) ;
      _mRoot->mLastItem->mNextItem = nouvelElement ;
      nouvelElement->mPreviousItem = _mRoot->mLastItem ;
    }
    _mRoot->mLastItem = nouvelElement ;
    _mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_internalPrependItem (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (_mRoot->mFirstItem == NULL) {
      _mRoot->mLastItem = nouvelElement ;
    }else{
      macroValidPointer (_mRoot->mFirstItem) ;
      _mRoot->mFirstItem->mPreviousItem = nouvelElement ;
      nouvelElement->mNextItem = _mRoot->mFirstItem ;
    }
    _mRoot->mFirstItem = nouvelElement ;
    _mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
operator + (const GGS_L_parse_rewind_signature_list & inOperand) const {
  GGS_L_parse_rewind_signature_list result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_parse_rewind_signature_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_ruleSyntaxSignature  p_0 = p->mSignature ;
          GGS_location  p_1 = p->mErrorLocation ;
          result._internalAppendItem (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_prependValue (C_Lexique & /* inLexique */,
                     const GGS_L_ruleSyntaxSignature & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()
) {
    _insulateList () ;
    _internalPrependItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_insulateList (void) {
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    if (_mRoot->mCountReference > 1) {
      element_type * p = _mRoot->mFirstItem ;
      _mRoot->mCountReference -- ;
      _mRoot = NULL ;
      macroMyNew (_mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        _internalAppendItem (p->mSignature,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  macroMyNew (result._mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_L_ruleSyntaxSignature & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  macroMyNew (result._mRoot, cRootList) ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_parse_rewind_signature_list::
count (void) const {
  return (_mRoot == NULL) ? 0 : _mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_parse_rewind_signature_list::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<list @L_parse_rewind_signature_list" ;
  if (_isBuilt ()) {
    s << " " << _mRoot->mListLength << " object" << ((_mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = _mRoot->mFirstItem ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      s << "\n" ;
      s.writeStringMultiple ("| ", inIndentation) ;
      s << "|-at " << elementIndex << " " ;
      p->appendForListDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
      p = p->mNextItem ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_first (C_Lexique & _inLexique,
              GGS_L_ruleSyntaxSignature & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mFirstItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mFirstItem->mSignature ;
    _out_1 = _mRoot->mFirstItem->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_last (C_Lexique & _inLexique,
             GGS_L_ruleSyntaxSignature & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mLastItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mLastItem->mSignature ;
    _out_1 = _mRoot->mLastItem->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_popFirst (C_Lexique & _inLexique,
                 GGS_L_ruleSyntaxSignature & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mFirstItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mFirstItem->mSignature ;
    _out_1 = _mRoot->mFirstItem->mErrorLocation ;
    _insulateList () ;
    element_type * _p = _mRoot->mFirstItem ;
    _mRoot->mFirstItem = _mRoot->mFirstItem->mNextItem ;
    if (_mRoot->mFirstItem == NULL) {
      _mRoot->mLastItem = NULL ;
    }else{
      _mRoot->mFirstItem->mPreviousItem = NULL ;
    }
    _mRoot->mListLength -- ;
    macroMyDelete (_p, element_type) ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_popLast (C_Lexique & _inLexique,
                GGS_L_ruleSyntaxSignature & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  bool _ok = _isBuilt () ;
  if (_ok) {
    _ok = _mRoot->mLastItem != NULL ;
    if (! _ok) {
      _inLexique.onTheFlyRunTimeError ("'popLast' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_ok) {
    _out_0 = _mRoot->mLastItem->mSignature ;
    _out_1 = _mRoot->mLastItem->mErrorLocation ;
    _insulateList () ;
    element_type * _p = _mRoot->mLastItem ;
    _mRoot->mLastItem = _mRoot->mLastItem->mPreviousItem ;
    if (_mRoot->mLastItem == NULL) {
      _mRoot->mFirstItem = NULL ;
    }else{
      _mRoot->mLastItem->mNextItem = NULL ;
    }
    _mRoot->mListLength -- ;
    macroMyDelete (_p, element_type) ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_parse_rewind_signature_list::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (_mRoot != NULL,
                   (_mRoot == NULL) ? 0 : (uint32) _mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_drop_operation (void) {
  if (_mRoot != NULL) {
    macroValidPointer (_mRoot) ;
    if (_mRoot->mCountReference == 1) {
      macroMyDelete (_mRoot, cRootList) ;
    }else{
      _mRoot->mCountReference -- ;
      _mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'C_parse_rewind_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_rewind_instruction::cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mInstructionLocation (argument_0),
mBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_rewind_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_parse_rewind_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_parse_rewind_instruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeListeBranchesInstructions & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_parse_rewind_instruction * _ptr = (cPtr_C_parse_rewind_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_parse_rewind_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_parse_rewind_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_rewind_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_parse_rewind_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_parse_rewind_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'C_parse_when_else_instruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_when_else_instruction::cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_when_else_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@C_parse_when_else_instruction:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_parse_when_else_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_parse_when_else_instruction * _ptr = (cPtr_C_parse_when_else_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_parse_when_else_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_parse_when_else_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_when_else_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_parse_when_else_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_parse_when_else_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeNonterminalToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonterminalToGenerate::cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomNonTerminal (argument_0),
mNonterminalSymbolParametersMap (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNonterminalToGenerate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeNonterminalToGenerate:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomNonTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeNonterminalToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_nonterminalSymbolAlts & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeNonterminalToGenerate * _ptr = (cPtr_typeNonterminalToGenerate *) NULL ;
  macroMyNew (_ptr, cPtr_typeNonterminalToGenerate (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeNonterminalToGenerate result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonterminalToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonterminalToGenerate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeNonterminalToGenerate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeAltProductionsMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeAltProductionsMap::
elementOf_GGS_typeAltProductionsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeAltProductionsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeAltProductionsMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeDeTypesEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSyntaxSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mEndOfInstructionListLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedEntityTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllPropertiesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeAltProductionsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeTypesEtNomsArgMethode &  inParameter0,
               const GGS_typeInstructionList &  inParameter1,
               const GGS_L_ruleSyntaxSignature &  inParameter2,
               const GGS_location &  inParameter3,
               const GGS_string&  inParameter4,
               const GGS_entityPropertyMap &  inParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeAltProductionsMap info  ;
    info.aListeDeTypesEffectifs = inParameter0 ;
    info.mAllInstructionsList = inParameter1 ;
    info.mSyntaxSignature = inParameter2 ;
    info.mEndOfInstructionListLocation = inParameter3 ;
    info.mReturnedEntityTypeName = inParameter4 ;
    info.mAllPropertiesMap = inParameter5 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
               GGS_typeInstructionList   & outParameter1,
               GGS_L_ruleSyntaxSignature   & outParameter2,
               GGS_location   & outParameter3,
               GGS_string  & outParameter4,
               GGS_entityPropertyMap   & outParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDeTypesEffectifs ;
    outParameter1 = node->mInfo.mAllInstructionsList ;
    outParameter2 = node->mInfo.mSyntaxSignature ;
    outParameter3 = node->mInfo.mEndOfInstructionListLocation ;
    outParameter4 = node->mInfo.mReturnedEntityTypeName ;
    outParameter5 = node->mInfo.mAllPropertiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
                                GGS_typeInstructionList   & outParameter1,
                                GGS_L_ruleSyntaxSignature   & outParameter2,
                                GGS_location   & outParameter3,
                                GGS_string  & outParameter4,
                                GGS_entityPropertyMap   & outParameter5 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' label is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                                const GGS_typeInstructionList & inParameter1,
                                const GGS_L_ruleSyntaxSignature & inParameter2,
                                const GGS_location & inParameter3,
                                const GGS_string& inParameter4,
                                const GGS_entityPropertyMap & inParameter5 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' label has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeAltProductionsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAltProductionsMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeAltProductionsMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeProductionAengendrer'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeProductionAengendrer::cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomProduction (argument_0),
mAltProductionMap (argument_1),
mProductionTagName (argument_2),
mHasParseLabel (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeProductionAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << " ->@typeProductionAengendrer:" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << aNomProduction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mAltProductionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mProductionTagName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << mHasParseLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ; ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeProductionAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeAltProductionsMap & argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeProductionAengendrer * _ptr = (cPtr_typeProductionAengendrer *) NULL ;
  macroMyNew (_ptr, cPtr_typeProductionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeProductionAengendrer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeProductionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeProductionAengendrer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

