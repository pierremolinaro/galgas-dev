//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'parser_semantics.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 20th, 2009, at 15h9'45"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "parser_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "parser_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeParserInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeParserInstruction::
cPtr_typeParserInstruction (LOCATION_ARGS)
:cPtr_typeInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeParserInstruction * GGS_typeParserInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeParserInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeParserInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeParserInstruction::
appendForDescription (C_Compiler & /* inLexique */,
                      C_String & ioString,
                      const PMSInt32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeParserInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeParserInstruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeParserInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeParserInstruction (& typeid (cPtr_typeParserInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeParserInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeParserInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeParserInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeParserInstruction GGS_typeParserInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeParserInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeParserInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeParserInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeParserInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeParserInstruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeParserInstruction::actualTypeName (void) const {
  return "typeParserInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeParserInstruction ("typeParserInstruction", gClassInfoFor__typeInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeInstructionAppelNonTerminal'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelNonTerminal::
cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mNonterminalName (argument_0),
mParametersExpressionList (argument_1),
mAltName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelNonTerminal *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelNonTerminal::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelNonTerminal * ptr = dynamic_cast <const cPtr_typeInstructionAppelNonTerminal *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNonterminalName.operator_isEqual (ptr->mNonterminalName).boolValue ()
         && mParametersExpressionList.operator_isEqual (ptr->mParametersExpressionList).boolValue ()
         && mAltName.operator_isEqual (ptr->mAltName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelNonTerminal::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelNonTerminal:"
           << mNonterminalName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mParametersExpressionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAltName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelNonTerminal::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelNonTerminal::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionAppelNonTerminal (& typeid (cPtr_typeInstructionAppelNonTerminal), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeInstructionAppelNonTerminal::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionAppelNonTerminal ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionAppelNonTerminal::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionAppelNonTerminal (mNonterminalName, mParametersExpressionList, mAltName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelNonTerminal result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionAppelNonTerminal) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionAppelNonTerminal (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionAppelNonTerminal),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelNonTerminal result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelNonTerminal (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeInstructionAppelNonTerminal::
reader_mParametersExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mParametersExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mAltName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mAltName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionAppelNonTerminal::actualTypeName (void) const {
  return "typeInstructionAppelNonTerminal" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInstructionAppelNonTerminal ("typeInstructionAppelNonTerminal", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeInstructionVerifSyntaxique'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionVerifSyntaxique::
cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aNomTerminal (argument_0),
aListeTypeEffectifs (argument_1),
mLexiqueClassName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionVerifSyntaxique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionVerifSyntaxique::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionVerifSyntaxique * ptr = dynamic_cast <const cPtr_typeInstructionVerifSyntaxique *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomTerminal.operator_isEqual (ptr->aNomTerminal).boolValue ()
         && aListeTypeEffectifs.operator_isEqual (ptr->aListeTypeEffectifs).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionVerifSyntaxique::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionVerifSyntaxique:"
           << aNomTerminal.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEffectifs.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionVerifSyntaxique::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionVerifSyntaxique::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionVerifSyntaxique (& typeid (cPtr_typeInstructionVerifSyntaxique), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeInstructionVerifSyntaxique::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionVerifSyntaxique ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionVerifSyntaxique::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionVerifSyntaxique (aNomTerminal, aListeTypeEffectifs, mLexiqueClassName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionVerifSyntaxique result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionVerifSyntaxique) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionVerifSyntaxique (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionVerifSyntaxique),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_assignedVariables & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionVerifSyntaxique result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionVerifSyntaxique (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionVerifSyntaxique::
reader_aNomTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->aNomTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_typeInstructionVerifSyntaxique::
reader_aListeTypeEffectifs (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_assignedVariables   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->aListeTypeEffectifs ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionVerifSyntaxique::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionVerifSyntaxique::actualTypeName (void) const {
  return "typeInstructionVerifSyntaxique" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeInstructionVerifSyntaxique ("typeInstructionVerifSyntaxique", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeBranchesInstructions'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeBranchesInstructions::
elementOf_GGS_typeListeBranchesInstructions (const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeBranchesInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeBranchesInstructions * ptr = dynamic_cast <const elementOf_GGS_typeListeBranchesInstructions *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeBranchesInstructions::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeBranchesInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_internalAppendValues (const GGS_typeInstructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_internalPrependValues (const GGS_typeInstructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
addAssign_operation (const GGS_typeInstructionList & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
operator_concat (const GGS_typeListeBranchesInstructions & inOperand) const {
  GGS_typeListeBranchesInstructions result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
dotAssign_operation (const GGS_typeListeBranchesInstructions inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_typeListeBranchesInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstructionList  p_0 = p->mInstructionList ;
          _internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeInstructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_emptyList (void) {
  GGS_typeListeBranchesInstructions result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_listWithValue (const GGS_typeInstructionList & argument_0) {
  GGS_typeListeBranchesInstructions result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
internalSubListWithRange (GGS_typeListeBranchesInstructions & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeBranchesInstructions::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@typeListeBranchesInstructions", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_first (C_Compiler & inLexique,
              GGS_typeInstructionList & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_last (C_Compiler & inLexique,
             GGS_typeInstructionList & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeInstructionList & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeInstructionList & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeListeBranchesInstructions::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeListeBranchesInstructions::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_select_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_select_instruction::
cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_select_instruction * GGS_C_select_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_select_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_select_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_select_instruction * ptr = dynamic_cast <const cPtr_C_select_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFbranchesList.operator_isEqual (ptr->mIFbranchesList).boolValue ()
         && aPositionDebut.operator_isEqual (ptr->aPositionDebut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_select_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_select_instruction:"
           << mIFbranchesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aPositionDebut.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_select_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_select_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_select_instruction (& typeid (cPtr_C_select_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_select_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_select_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_select_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_select_instruction (mIFbranchesList, aPositionDebut COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_select_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_select_instruction GGS_C_select_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_select_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_select_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_select_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_select_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_select_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction GGS_C_select_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_select_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_select_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_select_instruction::
reader_mIFbranchesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_select_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_select_instruction::
reader_aPositionDebut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_select_instruction *) mPointer)->aPositionDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_select_instruction::actualTypeName (void) const {
  return "C_select_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_select_instruction ("C_select_instruction", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_repeat_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_repeat_instruction::
cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aListesBranchesRepeter (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_repeat_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_repeat_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_repeat_instruction * ptr = dynamic_cast <const cPtr_C_repeat_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aListesBranchesRepeter.operator_isEqual (ptr->aListesBranchesRepeter).boolValue ()
         && aPositionDebut.operator_isEqual (ptr->aPositionDebut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_repeat_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_repeat_instruction:"
           << aListesBranchesRepeter.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << aPositionDebut.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_repeat_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_repeat_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_repeat_instruction (& typeid (cPtr_C_repeat_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_repeat_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_repeat_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_repeat_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_repeat_instruction (aListesBranchesRepeter, aPositionDebut COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_repeat_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_repeat_instruction GGS_C_repeat_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_repeat_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_repeat_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_repeat_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_repeat_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_repeat_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction GGS_C_repeat_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_repeat_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_repeat_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_repeat_instruction::
reader_aListesBranchesRepeter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_repeat_instruction *) mPointer)->aListesBranchesRepeter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_repeat_instruction::
reader_aPositionDebut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_repeat_instruction *) mPointer)->aPositionDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_repeat_instruction::actualTypeName (void) const {
  return "C_repeat_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_repeat_instruction ("C_repeat_instruction", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_parse_rewind_signature_list'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_parse_rewind_signature_list::
elementOf_GGS_L_parse_rewind_signature_list (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSignature (argument_0),
mErrorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_parse_rewind_signature_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_parse_rewind_signature_list * ptr = dynamic_cast <const elementOf_GGS_L_parse_rewind_signature_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mErrorLocation.operator_isEqual (ptr->mErrorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_parse_rewind_signature_list::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_parse_rewind_signature_list'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_internalAppendValues (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_internalPrependValues (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
operator_concat (const GGS_L_parse_rewind_signature_list & inOperand) const {
  GGS_L_parse_rewind_signature_list result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
dotAssign_operation (const GGS_L_parse_rewind_signature_list inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_L_parse_rewind_signature_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_ruleSyntaxSignature  p_0 = p->mSignature ;
          GGS_location  p_1 = p->mErrorLocation ;
          _internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_L_ruleSyntaxSignature & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSignature,
                                ptr->mErrorLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_emptyList (void) {
  GGS_L_parse_rewind_signature_list result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_listWithValue (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  GGS_L_parse_rewind_signature_list result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
internalSubListWithRange (GGS_L_parse_rewind_signature_list & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSignature, ptr->mErrorLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_parse_rewind_signature_list result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_parse_rewind_signature_list result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_parse_rewind_signature_list::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@L_parse_rewind_signature_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_first (C_Compiler & inLexique,
              GGS_L_ruleSyntaxSignature & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_last (C_Compiler & inLexique,
             GGS_L_ruleSyntaxSignature & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_L_ruleSyntaxSignature & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_popLast (C_Compiler & inLexique,
                GGS_L_ruleSyntaxSignature & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_ruleSyntaxSignature  GGS_L_parse_rewind_signature_list::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_L_ruleSyntaxSignature  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_parse_rewind_signature_list::
reader_mErrorLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_L_ruleSyntaxSignature  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_setMErrorLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_ruleSyntaxSignature  & GGS_L_parse_rewind_signature_list::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_parse_rewind_signature_list::cEnumerator::_mErrorLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_parse_rewind_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_rewind_instruction::
cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mInstructionLocation (argument_0),
mBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_rewind_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_rewind_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_rewind_instruction * ptr = dynamic_cast <const cPtr_C_parse_rewind_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_rewind_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_rewind_instruction:"
           << mInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parse_rewind_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parse_rewind_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parse_rewind_instruction (& typeid (cPtr_C_parse_rewind_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_parse_rewind_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_parse_rewind_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parse_rewind_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parse_rewind_instruction (mInstructionLocation, mBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_parse_rewind_instruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parse_rewind_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parse_rewind_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_parse_rewind_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parse_rewind_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parse_rewind_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeListeBranchesInstructions & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_rewind_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_rewind_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_parse_rewind_instruction::
reader_mInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_rewind_instruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_parse_rewind_instruction::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_rewind_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parse_rewind_instruction::actualTypeName (void) const {
  return "C_parse_rewind_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_parse_rewind_instruction ("C_parse_rewind_instruction", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_parse_loop_instruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_loop_instruction::
cPtr_C_parse_loop_instruction (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mEndOfInstructionLocation (argument_0),
mVariantExpression (argument_1),
mWhileExpression (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_loop_instruction * GGS_C_parse_loop_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_loop_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_loop_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_loop_instruction * ptr = dynamic_cast <const cPtr_C_parse_loop_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEndOfInstructionLocation.operator_isEqual (ptr->mEndOfInstructionLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_loop_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_loop_instruction:"
           << mEndOfInstructionLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mVariantExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mWhileExpression.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parse_loop_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parse_loop_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parse_loop_instruction (& typeid (cPtr_C_parse_loop_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_parse_loop_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_parse_loop_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parse_loop_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parse_loop_instruction (mEndOfInstructionLocation, mVariantExpression, mWhileExpression, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_parse_loop_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction::
GGS_C_parse_loop_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction::
GGS_C_parse_loop_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parse_loop_instruction GGS_C_parse_loop_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parse_loop_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parse_loop_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_parse_loop_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parse_loop_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parse_loop_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction GGS_C_parse_loop_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_loop_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_loop_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_parse_loop_instruction::
reader_mEndOfInstructionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mEndOfInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_parse_loop_instruction::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_parse_loop_instruction::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_parse_loop_instruction::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parse_loop_instruction::actualTypeName (void) const {
  return "C_parse_loop_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_parse_loop_instruction ("C_parse_loop_instruction", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_C_parse_when_else_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_when_else_instruction::
cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_when_else_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_when_else_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_when_else_instruction * ptr = dynamic_cast <const cPtr_C_parse_when_else_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFbranchesList.operator_isEqual (ptr->mIFbranchesList).boolValue ()
         && mElseInstructionsList.operator_isEqual (ptr->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_when_else_instruction::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_when_else_instruction:"
           << mIFbranchesList.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parse_when_else_instruction::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parse_when_else_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parse_when_else_instruction (& typeid (cPtr_C_parse_when_else_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_C_parse_when_else_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_parse_when_else_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parse_when_else_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parse_when_else_instruction (mIFbranchesList, mElseInstructionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_parse_when_else_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parse_when_else_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parse_when_else_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_parse_when_else_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parse_when_else_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parse_when_else_instruction),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_when_else_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_when_else_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_parse_when_else_instruction::
reader_mIFbranchesList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_when_else_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_parse_when_else_instruction::
reader_mElseInstructionsList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_when_else_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parse_when_else_instruction::actualTypeName (void) const {
  return "C_parse_when_else_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__C_parse_when_else_instruction ("C_parse_when_else_instruction", gClassInfoFor__typeParserInstruction) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeNonterminalToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonterminalToGenerate::
cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomNonTerminal (argument_0),
mNonterminalSymbolParametersMap (argument_1),
mLexiqueClassName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonterminalToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonterminalToGenerate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonterminalToGenerate * ptr = dynamic_cast <const cPtr_typeNonterminalToGenerate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomNonTerminal.operator_isEqual (ptr->aNomNonTerminal).boolValue ()
         && mNonterminalSymbolParametersMap.operator_isEqual (ptr->mNonterminalSymbolParametersMap).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonterminalToGenerate::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonterminalToGenerate:"
           << aNomNonTerminal.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mNonterminalSymbolParametersMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNonterminalToGenerate::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNonterminalToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNonterminalToGenerate (& typeid (cPtr_typeNonterminalToGenerate), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeNonterminalToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeNonterminalToGenerate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeNonterminalToGenerate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeNonterminalToGenerate (aNomNonTerminal, mNonterminalSymbolParametersMap, mLexiqueClassName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeNonterminalToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNonterminalToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNonterminalToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeNonterminalToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeNonterminalToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNonterminalToGenerate),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_nonterminalSymbolAlts & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonterminalToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeNonterminalToGenerate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeNonterminalToGenerate::
reader_aNomNonTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->aNomNonTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts  GGS_typeNonterminalToGenerate::
reader_mNonterminalSymbolParametersMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->mNonterminalSymbolParametersMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonterminalToGenerate::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNonterminalToGenerate::actualTypeName (void) const {
  return "typeNonterminalToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeNonterminalToGenerate ("typeNonterminalToGenerate", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_typeAltProductionsMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeAltProductionsMap::e_typeAltProductionsMap (void) :
aListeDeTypesEffectifs (),
mAllInstructionsList (),
mSyntaxSignature (),
mEndOfInstructionListLocation () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeAltProductionsMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeAltProductionsMap::
elementOf_GGS_typeAltProductionsMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeAltProductionsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeAltProductionsMap::
appendForMapDescription (C_Compiler & inLexique,
                         const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeDeTypesEffectifs.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAllInstructionsList.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSyntaxSignature.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEndOfInstructionListLocation.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeAltProductionsMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeAltProductionsMap * ptr = dynamic_cast <const elementOf_GGS_typeAltProductionsMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aListeDeTypesEffectifs.operator_isEqual (ptr->mInfo.aListeDeTypesEffectifs)).boolValue ()
           && (mInfo.mAllInstructionsList.operator_isEqual (ptr->mInfo.mAllInstructionsList)).boolValue ()
           && (mInfo.mSyntaxSignature.operator_isEqual (ptr->mInfo.mSyntaxSignature)).boolValue ()
           && (mInfo.mEndOfInstructionListLocation.operator_isEqual (ptr->mInfo.mEndOfInstructionListLocation)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeAltProductionsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeAltProductionsMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAltProductionsMap::
operator_isEqual (const GGS_typeAltProductionsMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAltProductionsMap::
operator_isNotEqual (const GGS_typeAltProductionsMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                const GGS_typeInstructionList & inParameter1,
                const GGS_L_ruleSyntaxSignature & inParameter2,
                const GGS_location & inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeAltProductionsMap info  ;
    info.aListeDeTypesEffectifs = inParameter0 ;
    info.mAllInstructionsList = inParameter1 ;
    info.mSyntaxSignature = inParameter2 ;
    info.mEndOfInstructionListLocation = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
               GGS_typeInstructionList   & outParameter1,
               GGS_L_ruleSyntaxSignature   & outParameter2,
               GGS_location   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDeTypesEffectifs ;
    outParameter1 = node->mInfo.mAllInstructionsList ;
    outParameter2 = node->mInfo.mSyntaxSignature ;
    outParameter3 = node->mInfo.mEndOfInstructionListLocation ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeAltProductionsMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
                                GGS_typeInstructionList   & outParameter1,
                                GGS_L_ruleSyntaxSignature   & outParameter2,
                                GGS_location   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeAltProductionsMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                                const GGS_typeInstructionList & inParameter1,
                                const GGS_L_ruleSyntaxSignature & inParameter2,
                                const GGS_location & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeAltProductionsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAltProductionsMap::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeAltProductionsMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cElement * p = firstObject () ;
    PMSInt32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_typeAltProductionsMap::cEnumerator::_aListeDeTypesEffectifs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeDeTypesEffectifs ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeAltProductionsMap::cEnumerator::_mAllInstructionsList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAllInstructionsList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_L_ruleSyntaxSignature  & GGS_typeAltProductionsMap::cEnumerator::_mSyntaxSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSyntaxSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeAltProductionsMap::cEnumerator::_mEndOfInstructionListLocation (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEndOfInstructionListLocation ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeProductionAengendrer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeProductionAengendrer::
cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomProduction (argument_0),
mAltProductionMap (argument_1),
mProductionTagName (argument_2),
mLexiqueClassName (argument_3),
mHasParseLabel (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeProductionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeProductionAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeProductionAengendrer * ptr = dynamic_cast <const cPtr_typeProductionAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomProduction.operator_isEqual (ptr->aNomProduction).boolValue ()
         && mAltProductionMap.operator_isEqual (ptr->mAltProductionMap).boolValue ()
         && mProductionTagName.operator_isEqual (ptr->mProductionTagName).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue ()
         && mHasParseLabel.operator_isEqual (ptr->mHasParseLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeProductionAengendrer::
appendForDescription (C_Compiler & inLexique,
                      C_String & ioString,
                      const PMSInt32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeProductionAengendrer:"
           << aNomProduction.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mAltProductionMap.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mProductionTagName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (inLexique COMMA_THERE, inIndentation + 1)
           << mHasParseLabel.reader_description  (inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeProductionAengendrer::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeProductionAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeProductionAengendrer (& typeid (cPtr_typeProductionAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformation * cPtr_typeProductionAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeProductionAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeProductionAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeProductionAengendrer (aNomProduction, mAltProductionMap, mProductionTagName, mLexiqueClassName, mHasParseLabel COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeProductionAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignPointer (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeProductionAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeProductionAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeProductionAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeProductionAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeProductionAengendrer),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeAltProductionsMap & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeProductionAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeProductionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeProductionAengendrer::
reader_aNomProduction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->aNomProduction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap  GGS_typeProductionAengendrer::
reader_mAltProductionMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mAltProductionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_mProductionTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mProductionTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_mLexiqueClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeProductionAengendrer::
reader_mHasParseLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mHasParseLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeProductionAengendrer::actualTypeName (void) const {
  return "typeProductionAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformation gClassInfoFor__typeProductionAengendrer ("typeProductionAengendrer", gClassInfoFor__typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

