//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'parser_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 6th, 2006, at 22h33'47"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "parser_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "parser_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeParserInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeParserInstruction::
cPtr_typeParserInstruction (LOCATION_ARGS)
:cPtr_typeInstruction (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeParserInstruction::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeParserInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeParserInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (void) {
  mPointer = (cPtr_typeParserInstruction *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (const GGS_typeParserInstruction & inOperand) {
  mPointer = (cPtr_typeParserInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
~GGS_typeParserInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeParserInstruction::
operator = (const GGS_typeParserInstruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeParserInstruction * GGS_typeParserInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeParserInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeParserInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeParserInstruction::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeParserInstruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelNonTerminal'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelNonTerminal::cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_bool& argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mNonterminalName (argument_0),
mParametersExpressionList (argument_1),
mAltName (argument_2),
mReturnedEntityVarName (argument_3),
mReturnedEntityShouldInsertedInList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelNonTerminal::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelNonTerminal:"
           << mNonterminalName.reader_description  (_inLexique COMMA_THERE)
           << mParametersExpressionList.reader_description  (_inLexique COMMA_THERE)
           << mAltName.reader_description  (_inLexique COMMA_THERE)
           << mReturnedEntityVarName.reader_description  (_inLexique COMMA_THERE)
           << mReturnedEntityShouldInsertedInList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (void) {
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (const GGS_typeInstructionAppelNonTerminal & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_bool& argument_4 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionAppelNonTerminal * _ptr = (cPtr_typeInstructionAppelNonTerminal *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionAppelNonTerminal (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_typeInstructionAppelNonTerminal result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelNonTerminal *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelNonTerminal::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeInstructionAppelNonTerminal" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeInstructionVerifSyntaxique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionVerifSyntaxique::cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aNomTerminal (argument_0),
aListeTypeEffectifs (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionVerifSyntaxique::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionVerifSyntaxique:"
           << aNomTerminal.reader_description  (_inLexique COMMA_THERE)
           << aListeTypeEffectifs.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (void) {
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (const GGS_typeInstructionVerifSyntaxique & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_assignedVariables & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeInstructionVerifSyntaxique * _ptr = (cPtr_typeInstructionVerifSyntaxique *) NULL ;
  macroMyNew (_ptr, cPtr_typeInstructionVerifSyntaxique (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeInstructionVerifSyntaxique result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionVerifSyntaxique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionVerifSyntaxique::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeInstructionVerifSyntaxique" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeBranchesInstructions'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeBranchesInstructions::
elementOf_GGS_typeListeBranchesInstructions (const GGS_typeInstructionList & argument_0):
mNextItem (NULL),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeBranchesInstructions::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeBranchesInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::GGS_typeListeBranchesInstructions (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::~GGS_typeListeBranchesInstructions (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::
GGS_typeListeBranchesInstructions (const GGS_typeListeBranchesInstructions & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
operator = (const GGS_typeListeBranchesInstructions & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::element_type * GGS_typeListeBranchesInstructions::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
internalAppendItem (const GGS_typeInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
addAssign_operation (const GGS_typeInstructionList & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstructionList) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeBranchesInstructions::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeBranchesInstructions::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeBranchesInstructions" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeBranchesInstructions::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_select_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_select_instruction::cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_select_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_select_instruction:"
           << mIFbranchesList.reader_description  (_inLexique COMMA_THERE)
           << aPositionDebut.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_select_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (void) {
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (const GGS_C_select_instruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction GGS_C_select_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_select_instruction * _ptr = (cPtr_C_select_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_select_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_select_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_select_instruction * GGS_C_select_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_select_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_select_instruction::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @C_select_instruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_repeat_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_repeat_instruction::cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aListesBranchesRepeter (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_repeat_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_repeat_instruction:"
           << aListesBranchesRepeter.reader_description  (_inLexique COMMA_THERE)
           << aPositionDebut.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_repeat_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (void) {
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (const GGS_C_repeat_instruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction GGS_C_repeat_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_repeat_instruction * _ptr = (cPtr_C_repeat_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_repeat_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_repeat_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_repeat_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_repeat_instruction::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @C_repeat_instruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_parse_rewind_signature_list'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_parse_rewind_signature_list::
elementOf_GGS_L_parse_rewind_signature_list (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1):
mNextItem (NULL),
mSignature (argument_0),
mErrorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_parse_rewind_signature_list::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_parse_rewind_signature_list'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::GGS_L_parse_rewind_signature_list (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::~GGS_L_parse_rewind_signature_list (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::
GGS_L_parse_rewind_signature_list (const GGS_L_parse_rewind_signature_list & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
operator = (const GGS_L_parse_rewind_signature_list & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::element_type * GGS_L_parse_rewind_signature_list::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mSignature,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_L_parse_rewind_signature_list::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_parse_rewind_signature_list::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_parse_rewind_signature_list" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_L_parse_rewind_signature_list::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'C_parse_rewind_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_rewind_instruction::cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mInstructionLocation (argument_0),
mBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_rewind_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_rewind_instruction:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE)
           << mBranchList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_parse_rewind_instruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (void) {
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (const GGS_C_parse_rewind_instruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeListeBranchesInstructions & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_parse_rewind_instruction * _ptr = (cPtr_C_parse_rewind_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_parse_rewind_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_parse_rewind_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_rewind_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_parse_rewind_instruction::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @C_parse_rewind_instruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'C_parse_when_else_instruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_when_else_instruction::cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_when_else_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_when_else_instruction:"
           << mIFbranchesList.reader_description  (_inLexique COMMA_THERE)
           << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_parse_when_else_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (void) {
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (const GGS_C_parse_when_else_instruction & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_C_parse_when_else_instruction * _ptr = (cPtr_C_parse_when_else_instruction *) NULL ;
  macroMyNew (_ptr, cPtr_C_parse_when_else_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_C_parse_when_else_instruction result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_when_else_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_C_parse_when_else_instruction::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @C_parse_when_else_instruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeNonterminalToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonterminalToGenerate::cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomNonTerminal (argument_0),
mNonterminalSymbolParametersMap (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNonterminalToGenerate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonterminalToGenerate:"
           << aNomNonTerminal.reader_description  (_inLexique COMMA_THERE)
           << mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeNonterminalToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (void) {
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (const GGS_typeNonterminalToGenerate & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_nonterminalSymbolAlts & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeNonterminalToGenerate * _ptr = (cPtr_typeNonterminalToGenerate *) NULL ;
  macroMyNew (_ptr, cPtr_typeNonterminalToGenerate (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeNonterminalToGenerate result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonterminalToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonterminalToGenerate::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeNonterminalToGenerate" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeAltProductionsMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeAltProductionsMap::
elementOf_GGS_typeAltProductionsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeAltProductionsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeAltProductionsMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeDeTypesEffectifs.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mAllInstructionsList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSyntaxSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mEndOfInstructionListLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mReturnedEntityTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mAllPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeAltProductionsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeTypesEtNomsArgMethode &  inParameter0,
               const GGS_typeInstructionList &  inParameter1,
               const GGS_L_ruleSyntaxSignature &  inParameter2,
               const GGS_location &  inParameter3,
               const GGS_string&  inParameter4,
               const GGS_entityPropertyMap &  inParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inParameter5.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeAltProductionsMap info  ;
    info.aListeDeTypesEffectifs = inParameter0 ;
    info.mAllInstructionsList = inParameter1 ;
    info.mSyntaxSignature = inParameter2 ;
    info.mEndOfInstructionListLocation = inParameter3 ;
    info.mReturnedEntityTypeName = inParameter4 ;
    info.mAllPropertiesMap = inParameter5 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
               GGS_typeInstructionList   & outParameter1,
               GGS_L_ruleSyntaxSignature   & outParameter2,
               GGS_location   & outParameter3,
               GGS_string  & outParameter4,
               GGS_entityPropertyMap   & outParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDeTypesEffectifs ;
    outParameter1 = node->mInfo.mAllInstructionsList ;
    outParameter2 = node->mInfo.mSyntaxSignature ;
    outParameter3 = node->mInfo.mEndOfInstructionListLocation ;
    outParameter4 = node->mInfo.mReturnedEntityTypeName ;
    outParameter5 = node->mInfo.mAllPropertiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
                                GGS_typeInstructionList   & outParameter1,
                                GGS_L_ruleSyntaxSignature   & outParameter2,
                                GGS_location   & outParameter3,
                                GGS_string  & outParameter4,
                                GGS_entityPropertyMap   & outParameter5 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' label is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                                const GGS_typeInstructionList & inParameter1,
                                const GGS_L_ruleSyntaxSignature & inParameter2,
                                const GGS_location & inParameter3,
                                const GGS_string& inParameter4,
                                const GGS_entityPropertyMap & inParameter5 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' label has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeAltProductionsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAltProductionsMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeAltProductionsMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeProductionAengendrer'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeProductionAengendrer::cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomProduction (argument_0),
mAltProductionMap (argument_1),
mProductionTagName (argument_2),
mHasParseLabel (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeProductionAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeProductionAengendrer:"
           << aNomProduction.reader_description  (_inLexique COMMA_THERE)
           << mAltProductionMap.reader_description  (_inLexique COMMA_THERE)
           << mProductionTagName.reader_description  (_inLexique COMMA_THERE)
           << mHasParseLabel.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeProductionAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (void) {
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (const GGS_typeProductionAengendrer & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeAltProductionsMap & argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeProductionAengendrer * _ptr = (cPtr_typeProductionAengendrer *) NULL ;
  macroMyNew (_ptr, cPtr_typeProductionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeProductionAengendrer result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeProductionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeProductionAengendrer" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

