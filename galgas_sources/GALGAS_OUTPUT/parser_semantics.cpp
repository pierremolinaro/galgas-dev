//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'parser_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      april 25th, 2006, at 18h37'4"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "parser_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "parser_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeParserInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeParserInstruction::
cPtr_typeParserInstruction (LOCATION_ARGS)
:cPtr_typeInstruction (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeParserInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (void) {
  mPointer = (cPtr_typeParserInstruction *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (const GGS_typeParserInstruction & inOperand) {
  mPointer = (cPtr_typeParserInstruction *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
~GGS_typeParserInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeParserInstruction::
operator = (const GGS_typeParserInstruction & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeParserInstruction::
operator = (cPtr_typeParserInstruction * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (cPtr_typeParserInstruction * inSource) {
  mPointer = (cPtr_typeParserInstruction *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeParserInstruction * GGS_typeParserInstruction
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeParserInstruction
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeParserInstruction
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeParserInstruction" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelNonTerminal'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelNonTerminal::cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_bool& argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mNonterminalName (argument_0),
mParametersExpressionList (argument_1),
mAltName (argument_2),
mReturnedEntityVarName (argument_3),
mReturnedEntityShouldInsertedInList (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelNonTerminal::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelNonTerminal:" ;
mNonterminalName.reader_description  (_inLexique COMMA_THERE) ;
mParametersExpressionList.reader_description  (_inLexique COMMA_THERE) ;
mAltName.reader_description  (_inLexique COMMA_THERE) ;
mReturnedEntityVarName.reader_description  (_inLexique COMMA_THERE) ;
mReturnedEntityShouldInsertedInList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_bool& argument_4 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionAppelNonTerminal * ptr_ = (cPtr_typeInstructionAppelNonTerminal *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionAppelNonTerminal (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeInstructionVerifSyntaxique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionVerifSyntaxique::cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aNomTerminal (argument_0),
aListeTypeEffectifs (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionVerifSyntaxique::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionVerifSyntaxique:" ;
aNomTerminal.reader_description  (_inLexique COMMA_THERE) ;
aListeTypeEffectifs.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeInstructionVerifSyntaxique * ptr_ = (cPtr_typeInstructionVerifSyntaxique *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionVerifSyntaxique (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeBranchesInstructions'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeBranchesInstructions::
elementOf_GGS_typeListeBranchesInstructions (const GGS_typeInstructionList & argument_0) {
  mNextItem = (elementOf_GGS_typeListeBranchesInstructions *) NULL ;
  mInstructionList = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeBranchesInstructions::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeBranchesInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions
::GGS_typeListeBranchesInstructions (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeListeBranchesInstructions
::GGS_typeListeBranchesInstructions (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::~GGS_typeListeBranchesInstructions (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::GGS_typeListeBranchesInstructions (const GGS_typeListeBranchesInstructions & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions
::operator = (const GGS_typeListeBranchesInstructions & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
internalAppendItem (const GGS_typeInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
addAssign_operation (const GGS_typeInstructionList & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mInstructionList) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeBranchesInstructions::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeBranchesInstructions" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListeBranchesInstructions
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_select_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_select_instruction::cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_select_instruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_select_instruction:" ;
mIFbranchesList.reader_description  (_inLexique COMMA_THERE) ;
aPositionDebut.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_select_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_select_instruction * GGS_C_select_instruction::
    constructor_new (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_select_instruction * ptr_ = (cPtr_C_select_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_select_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_repeat_instruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_repeat_instruction::cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aListesBranchesRepeter (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_repeat_instruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_repeat_instruction:" ;
aListesBranchesRepeter.reader_description  (_inLexique COMMA_THERE) ;
aPositionDebut.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_repeat_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::
    constructor_new (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_repeat_instruction * ptr_ = (cPtr_C_repeat_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_repeat_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_parse_rewind_signature_list'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_parse_rewind_signature_list::
elementOf_GGS_L_parse_rewind_signature_list (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  mNextItem = (elementOf_GGS_L_parse_rewind_signature_list *) NULL ;
  mSignature = argument_0 ;
  mErrorLocation = argument_1 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_parse_rewind_signature_list::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_parse_rewind_signature_list'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list
::GGS_L_parse_rewind_signature_list (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_L_parse_rewind_signature_list
::GGS_L_parse_rewind_signature_list (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::~GGS_L_parse_rewind_signature_list (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::GGS_L_parse_rewind_signature_list (const GGS_L_parse_rewind_signature_list & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list
::operator = (const GGS_L_parse_rewind_signature_list & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mSignature,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_parse_rewind_signature_list::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @L_parse_rewind_signature_list" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_L_parse_rewind_signature_list
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'C_parse_rewind_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_rewind_instruction::cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mInstructionLocation (argument_0),
mBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_rewind_instruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_rewind_instruction:" ;
mInstructionLocation.reader_description  (_inLexique COMMA_THERE) ;
mBranchList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_parse_rewind_instruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::
    constructor_new (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_parse_rewind_instruction * ptr_ = (cPtr_C_parse_rewind_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_parse_rewind_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'C_parse_when_else_instruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_when_else_instruction::cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_when_else_instruction::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_when_else_instruction:" ;
mIFbranchesList.reader_description  (_inLexique COMMA_THERE) ;
mElseInstructionsList.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_parse_when_else_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::
    constructor_new (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_C_parse_when_else_instruction * ptr_ = (cPtr_C_parse_when_else_instruction *) NULL ;
    macroMyNew (ptr_, cPtr_C_parse_when_else_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeNonterminalToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonterminalToGenerate::cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomNonTerminal (argument_0),
mNonterminalSymbolParametersMap (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeNonterminalToGenerate::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonterminalToGenerate:" ;
aNomNonTerminal.reader_description  (_inLexique COMMA_THERE) ;
mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeNonterminalToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeNonterminalToGenerate * ptr_ = (cPtr_typeNonterminalToGenerate *) NULL ;
    macroMyNew (ptr_, cPtr_typeNonterminalToGenerate (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeAltProductionsMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeAltProductionsMap::
elementOf_GGS_typeAltProductionsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeAltProductionsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeAltProductionsMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeDeTypesEffectifs.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mAllInstructionsList.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mSyntaxSignature.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mEndOfInstructionListLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mReturnedEntityTypeName.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.mAllPropertiesMap.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeAltProductionsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeTypesEtNomsArgMethode &  inParameter0,
               const GGS_typeInstructionList &  inParameter1,
               const GGS_L_ruleSyntaxSignature &  inParameter2,
               const GGS_location &  inParameter3,
               const GGS_string&  inParameter4,
               const GGS_entityPropertyMap &  inParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeAltProductionsMap info  ;
    info.aListeDeTypesEffectifs = inParameter0 ;
    info.mAllInstructionsList = inParameter1 ;
    info.mSyntaxSignature = inParameter2 ;
    info.mEndOfInstructionListLocation = inParameter3 ;
    info.mReturnedEntityTypeName = inParameter4 ;
    info.mAllPropertiesMap = inParameter5 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
               GGS_typeInstructionList   & outParameter1,
               GGS_L_ruleSyntaxSignature   & outParameter2,
               GGS_location   & outParameter3,
               GGS_string  & outParameter4,
               GGS_entityPropertyMap   & outParameter5,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    outParameter2.drop_operation () ;
    outParameter3.drop_operation () ;
    outParameter4.drop_operation () ;
    outParameter5.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDeTypesEffectifs ;
    outParameter1 = node->mInfo.mAllInstructionsList ;
    outParameter2 = node->mInfo.mSyntaxSignature ;
    outParameter3 = node->mInfo.mEndOfInstructionListLocation ;
    outParameter4 = node->mInfo.mReturnedEntityTypeName ;
    outParameter5 = node->mInfo.mAllPropertiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
                                GGS_typeInstructionList   & outParameter1,
                                GGS_L_ruleSyntaxSignature   & outParameter2,
                                GGS_location   & outParameter3,
                                GGS_string  & outParameter4,
                                GGS_entityPropertyMap   & outParameter5 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' label is not declared",
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 outParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                                const GGS_typeInstructionList & inParameter1,
                                const GGS_L_ruleSyntaxSignature & inParameter2,
                                const GGS_location & inParameter3,
                                const GGS_string& inParameter4,
                                const GGS_entityPropertyMap & inParameter5 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' label has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAltProductionsMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeAltProductionsMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeProductionAengendrer'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeProductionAengendrer::cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomProduction (argument_0),
mAltProductionMap (argument_1),
mProductionTagName (argument_2),
mHasParseLabel (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeProductionAengendrer::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeProductionAengendrer:" ;
aNomProduction.reader_description  (_inLexique COMMA_THERE) ;
mAltProductionMap.reader_description  (_inLexique COMMA_THERE) ;
mProductionTagName.reader_description  (_inLexique COMMA_THERE) ;
mHasParseLabel.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeProductionAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeProductionAengendrer * ptr_ = (cPtr_typeProductionAengendrer *) NULL ;
    macroMyNew (ptr_, cPtr_typeProductionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*

