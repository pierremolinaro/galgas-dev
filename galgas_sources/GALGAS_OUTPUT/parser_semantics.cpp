//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'parser_semantics.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 29th, 2010, at 22h17'43"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "parser_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "parser_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeParserInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeParserInstruction::
cPtr_typeParserInstruction (LOCATION_ARGS)
:cPtr_typeInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeParserInstruction * GGS_typeParserInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeParserInstruction) ;
    return (cPtr_typeParserInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeParserInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeParserInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeParserInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeParserInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeParserInstruction (& typeid (cPtr_typeParserInstruction), & typeid (cPtr_typeInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeParserInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeParserInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeParserInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeParserInstruction ("typeParserInstruction", true, & kTypeDescriptor_GGS_typeInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeParserInstruction GGS_typeParserInstruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeParserInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeParserInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeParserInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeParserInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeParserInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeParserInstruction::actualTypeName (void) const {
  return "typeParserInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeParserInstruction ("typeParserInstruction", gClassInfoFor__typeInstruction, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeParserInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeParserInstruction * p = NULL ;
    macroMyNew (p, GGS_typeParserInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction GGS_typeParserInstruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeParserInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeParserInstruction * p = dynamic_cast <const GGS_typeParserInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeParserInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeParserInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeParserInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeInstructionAppelNonTerminal'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelNonTerminal::
cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mNonterminalName (argument_0),
mParametersExpressionList (argument_1),
mAltName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionAppelNonTerminal) ;
    return (cPtr_typeInstructionAppelNonTerminal *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelNonTerminal::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelNonTerminal * ptr = dynamic_cast <const cPtr_typeInstructionAppelNonTerminal *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNonterminalName.operator_isEqual (ptr->mNonterminalName).boolValue ()
         && mParametersExpressionList.operator_isEqual (ptr->mParametersExpressionList).boolValue ()
         && mAltName.operator_isEqual (ptr->mAltName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelNonTerminal::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionAppelNonTerminal:"
           << mNonterminalName.reader_description (inIndentation + 1)
           << mParametersExpressionList.reader_description (inIndentation + 1)
           << mAltName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelNonTerminal::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionAppelNonTerminal::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionAppelNonTerminal (& typeid (cPtr_typeInstructionAppelNonTerminal), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionAppelNonTerminal::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionAppelNonTerminal ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionAppelNonTerminal::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionAppelNonTerminal (mNonterminalName, mParametersExpressionList, mAltName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionAppelNonTerminal ("typeInstructionAppelNonTerminal", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelNonTerminal result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionAppelNonTerminal) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionAppelNonTerminal (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionAppelNonTerminal),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelNonTerminal result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelNonTerminal (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mNonterminalName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeInstructionAppelNonTerminal::
reader_mParametersExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mParametersExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mAltName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mAltName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionAppelNonTerminal::actualTypeName (void) const {
  return "typeInstructionAppelNonTerminal" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionAppelNonTerminal ("typeInstructionAppelNonTerminal", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_typeInstructionAppelNonTerminal) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionAppelNonTerminal::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionAppelNonTerminal * p = NULL ;
    macroMyNew (p, GGS_typeInstructionAppelNonTerminal (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelNonTerminal result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionAppelNonTerminal * p = dynamic_cast <const GGS_typeInstructionAppelNonTerminal *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionAppelNonTerminal, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionAppelNonTerminal::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionAppelNonTerminal ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeInstructionVerifSyntaxique'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionVerifSyntaxique::
cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aNomTerminal (argument_0),
aListeTypeEffectifs (argument_1),
mLexiqueClassName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionVerifSyntaxique) ;
    return (cPtr_typeInstructionVerifSyntaxique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionVerifSyntaxique::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionVerifSyntaxique * ptr = dynamic_cast <const cPtr_typeInstructionVerifSyntaxique *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomTerminal.operator_isEqual (ptr->aNomTerminal).boolValue ()
         && aListeTypeEffectifs.operator_isEqual (ptr->aListeTypeEffectifs).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionVerifSyntaxique::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionVerifSyntaxique:"
           << aNomTerminal.reader_description (inIndentation + 1)
           << aListeTypeEffectifs.reader_description (inIndentation + 1)
           << mLexiqueClassName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionVerifSyntaxique::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionVerifSyntaxique::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionVerifSyntaxique (& typeid (cPtr_typeInstructionVerifSyntaxique), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionVerifSyntaxique::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionVerifSyntaxique ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionVerifSyntaxique::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionVerifSyntaxique (aNomTerminal, aListeTypeEffectifs, mLexiqueClassName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionVerifSyntaxique ("typeInstructionVerifSyntaxique", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionVerifSyntaxique result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionVerifSyntaxique) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionVerifSyntaxique (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionVerifSyntaxique),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_assignedVariables & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionVerifSyntaxique result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionVerifSyntaxique (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionVerifSyntaxique::
reader_aNomTerminal (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->aNomTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_typeInstructionVerifSyntaxique::
reader_aListeTypeEffectifs (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_assignedVariables   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->aListeTypeEffectifs ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionVerifSyntaxique::
reader_mLexiqueClassName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionVerifSyntaxique::actualTypeName (void) const {
  return "typeInstructionVerifSyntaxique" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionVerifSyntaxique ("typeInstructionVerifSyntaxique", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_typeInstructionVerifSyntaxique) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionVerifSyntaxique::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionVerifSyntaxique * p = NULL ;
    macroMyNew (p, GGS_typeInstructionVerifSyntaxique (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionVerifSyntaxique result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionVerifSyntaxique * p = dynamic_cast <const GGS_typeInstructionVerifSyntaxique *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionVerifSyntaxique, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionVerifSyntaxique::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionVerifSyntaxique ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeBranchesInstructions'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeBranchesInstructions::
elementOf_GGS_typeListeBranchesInstructions (const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeBranchesInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeBranchesInstructions * ptr = dynamic_cast <const elementOf_GGS_typeListeBranchesInstructions *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeBranchesInstructions::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeBranchesInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeBranchesInstructions ("typeListeBranchesInstructions", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
internalAppendValues (const GGS_typeInstructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
internalPrependValues (const GGS_typeInstructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
addAssign_operation (const GGS_typeInstructionList & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
operator_concat (const GGS_typeListeBranchesInstructions & inOperand) const {
  GGS_typeListeBranchesInstructions result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
dotAssign_operation (const GGS_typeListeBranchesInstructions inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeBranchesInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstructionList  p_0 = p->mInstructionList ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_typeInstructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_emptyList (void) {
  GGS_typeListeBranchesInstructions result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_listWithValue (const GGS_typeInstructionList & argument_0) {
  GGS_typeListeBranchesInstructions result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
internalSubListWithRange (GGS_typeListeBranchesInstructions & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeBranchesInstructions::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeBranchesInstructions", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_first (C_CompilerEx & inLexique,
              GGS_typeInstructionList & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_last (C_CompilerEx & inLexique,
             GGS_typeInstructionList & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_typeInstructionList & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_typeInstructionList & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_typeListeBranchesInstructions::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_typeInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeListeBranchesInstructions::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeBranchesInstructions::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeBranchesInstructions * p = NULL ;
    macroMyNew (p, GGS_typeListeBranchesInstructions (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeBranchesInstructions * p = dynamic_cast <const GGS_typeListeBranchesInstructions *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeBranchesInstructions, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeBranchesInstructions::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeBranchesInstructions ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_select_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_select_instruction::
cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_select_instruction * GGS_C_select_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_select_instruction) ;
    return (cPtr_C_select_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_select_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_select_instruction * ptr = dynamic_cast <const cPtr_C_select_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFbranchesList.operator_isEqual (ptr->mIFbranchesList).boolValue ()
         && aPositionDebut.operator_isEqual (ptr->aPositionDebut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_select_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_select_instruction:"
           << mIFbranchesList.reader_description (inIndentation + 1)
           << aPositionDebut.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_select_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_select_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_select_instruction (& typeid (cPtr_C_select_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_select_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_select_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_select_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_select_instruction (mIFbranchesList, aPositionDebut COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_select_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_select_instruction ("C_select_instruction", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_select_instruction GGS_C_select_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_select_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_select_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_select_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_select_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_select_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction GGS_C_select_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_select_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_select_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_select_instruction::
reader_mIFbranchesList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_select_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_select_instruction::
reader_aPositionDebut (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_select_instruction *) mPointer)->aPositionDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_select_instruction::actualTypeName (void) const {
  return "C_select_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_select_instruction ("C_select_instruction", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_C_select_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_select_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_select_instruction * p = NULL ;
    macroMyNew (p, GGS_C_select_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction GGS_C_select_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_select_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_select_instruction * p = dynamic_cast <const GGS_C_select_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_select_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_select_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_select_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_C_repeat_instruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_repeat_instruction::
cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aListesBranchesRepeter (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_repeat_instruction) ;
    return (cPtr_C_repeat_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_repeat_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_repeat_instruction * ptr = dynamic_cast <const cPtr_C_repeat_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aListesBranchesRepeter.operator_isEqual (ptr->aListesBranchesRepeter).boolValue ()
         && aPositionDebut.operator_isEqual (ptr->aPositionDebut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_repeat_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_repeat_instruction:"
           << aListesBranchesRepeter.reader_description (inIndentation + 1)
           << aPositionDebut.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_repeat_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_repeat_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_repeat_instruction (& typeid (cPtr_C_repeat_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_repeat_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_repeat_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_repeat_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_repeat_instruction (aListesBranchesRepeter, aPositionDebut COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_repeat_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_repeat_instruction ("C_repeat_instruction", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_repeat_instruction GGS_C_repeat_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_repeat_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_repeat_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_repeat_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_repeat_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_repeat_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction GGS_C_repeat_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_repeat_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_repeat_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_repeat_instruction::
reader_aListesBranchesRepeter (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_repeat_instruction *) mPointer)->aListesBranchesRepeter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_repeat_instruction::
reader_aPositionDebut (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_repeat_instruction *) mPointer)->aPositionDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_repeat_instruction::actualTypeName (void) const {
  return "C_repeat_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_repeat_instruction ("C_repeat_instruction", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_C_repeat_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_repeat_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_repeat_instruction * p = NULL ;
    macroMyNew (p, GGS_C_repeat_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction GGS_C_repeat_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_repeat_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_repeat_instruction * p = dynamic_cast <const GGS_C_repeat_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_repeat_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_repeat_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_repeat_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_parse_rewind_signature_list'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_parse_rewind_signature_list::
elementOf_GGS_L_parse_rewind_signature_list (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSignature (argument_0),
mErrorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_parse_rewind_signature_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_parse_rewind_signature_list * ptr = dynamic_cast <const elementOf_GGS_L_parse_rewind_signature_list *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mErrorLocation.operator_isEqual (ptr->mErrorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_parse_rewind_signature_list::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_parse_rewind_signature_list'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_L_parse_rewind_signature_list ("L_parse_rewind_signature_list", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
internalAppendValues (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
internalPrependValues (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
addAssign_operation (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
operator_concat (const GGS_L_parse_rewind_signature_list & inOperand) const {
  GGS_L_parse_rewind_signature_list result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
dotAssign_operation (const GGS_L_parse_rewind_signature_list inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_L_parse_rewind_signature_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_syntaxInstructionListForGrammarAnalysis  p_0 = p->mSignature ;
          GGS_location  p_1 = p->mErrorLocation ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_syntaxInstructionListForGrammarAnalysis & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSignature,
                                ptr->mErrorLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_emptyList (void) {
  GGS_L_parse_rewind_signature_list result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_listWithValue (const GGS_syntaxInstructionListForGrammarAnalysis & argument_0,
                                const GGS_location & argument_1) {
  GGS_L_parse_rewind_signature_list result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
internalSubListWithRange (GGS_L_parse_rewind_signature_list & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSignature, ptr->mErrorLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_L_parse_rewind_signature_list result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_L_parse_rewind_signature_list result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_parse_rewind_signature_list::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@L_parse_rewind_signature_list", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_first (C_CompilerEx & inLexique,
              GGS_syntaxInstructionListForGrammarAnalysis & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_last (C_CompilerEx & inLexique,
             GGS_syntaxInstructionListForGrammarAnalysis & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_syntaxInstructionListForGrammarAnalysis & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_syntaxInstructionListForGrammarAnalysis & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSignature ;
    _out_1 = ptr->mErrorLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionListForGrammarAnalysis  GGS_L_parse_rewind_signature_list::
reader_mSignatureAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_syntaxInstructionListForGrammarAnalysis  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_L_parse_rewind_signature_list::
reader_mErrorLocationAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_setMSignatureAtIndex (C_CompilerEx & inLexique,
                              const GGS_syntaxInstructionListForGrammarAnalysis  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_setMErrorLocationAtIndex (C_CompilerEx & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_syntaxInstructionListForGrammarAnalysis  & GGS_L_parse_rewind_signature_list::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_L_parse_rewind_signature_list::cEnumerator::_mErrorLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_L_parse_rewind_signature_list::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_L_parse_rewind_signature_list * p = NULL ;
    macroMyNew (p, GGS_L_parse_rewind_signature_list (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_L_parse_rewind_signature_list * p = dynamic_cast <const GGS_L_parse_rewind_signature_list *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_L_parse_rewind_signature_list, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_L_parse_rewind_signature_list::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_L_parse_rewind_signature_list ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_C_parse_rewind_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_rewind_instruction::
cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mInstructionLocation (argument_0),
mBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_parse_rewind_instruction) ;
    return (cPtr_C_parse_rewind_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_rewind_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_rewind_instruction * ptr = dynamic_cast <const cPtr_C_parse_rewind_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_rewind_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_parse_rewind_instruction:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mBranchList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parse_rewind_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parse_rewind_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parse_rewind_instruction (& typeid (cPtr_C_parse_rewind_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_parse_rewind_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_parse_rewind_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parse_rewind_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parse_rewind_instruction (mInstructionLocation, mBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_parse_rewind_instruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_parse_rewind_instruction ("C_parse_rewind_instruction", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parse_rewind_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parse_rewind_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_parse_rewind_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parse_rewind_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parse_rewind_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeListeBranchesInstructions & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_rewind_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_rewind_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_parse_rewind_instruction::
reader_mInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_rewind_instruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_parse_rewind_instruction::
reader_mBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_rewind_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parse_rewind_instruction::actualTypeName (void) const {
  return "C_parse_rewind_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_parse_rewind_instruction ("C_parse_rewind_instruction", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_C_parse_rewind_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_parse_rewind_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_parse_rewind_instruction * p = NULL ;
    macroMyNew (p, GGS_C_parse_rewind_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_parse_rewind_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_parse_rewind_instruction * p = dynamic_cast <const GGS_C_parse_rewind_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_parse_rewind_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_parse_rewind_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_parse_rewind_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_C_parse_loop_instruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_loop_instruction::
cPtr_C_parse_loop_instruction (const GGS_location & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mEndOfInstructionLocation (argument_0),
mVariantExpression (argument_1),
mWhileExpression (argument_2),
mInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_loop_instruction * GGS_C_parse_loop_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_parse_loop_instruction) ;
    return (cPtr_C_parse_loop_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_loop_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_loop_instruction * ptr = dynamic_cast <const cPtr_C_parse_loop_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEndOfInstructionLocation.operator_isEqual (ptr->mEndOfInstructionLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_loop_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_parse_loop_instruction:"
           << mEndOfInstructionLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parse_loop_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parse_loop_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parse_loop_instruction (& typeid (cPtr_C_parse_loop_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_parse_loop_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_parse_loop_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parse_loop_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parse_loop_instruction (mEndOfInstructionLocation, mVariantExpression, mWhileExpression, mInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_C_parse_loop_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_parse_loop_instruction ("C_parse_loop_instruction", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction::
GGS_C_parse_loop_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction::
GGS_C_parse_loop_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parse_loop_instruction GGS_C_parse_loop_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parse_loop_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parse_loop_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_parse_loop_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parse_loop_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parse_loop_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction GGS_C_parse_loop_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeExpression & argument_1,
                 const GGS_typeExpression & argument_2,
                 const GGS_typeInstructionList & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_loop_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_loop_instruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_parse_loop_instruction::
reader_mEndOfInstructionLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mEndOfInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_parse_loop_instruction::
reader_mVariantExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpression  GGS_C_parse_loop_instruction::
reader_mWhileExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_parse_loop_instruction::
reader_mInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_loop_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_loop_instruction *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parse_loop_instruction::actualTypeName (void) const {
  return "C_parse_loop_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_parse_loop_instruction ("C_parse_loop_instruction", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_C_parse_loop_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_parse_loop_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_parse_loop_instruction * p = NULL ;
    macroMyNew (p, GGS_C_parse_loop_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_loop_instruction GGS_C_parse_loop_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_parse_loop_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_parse_loop_instruction * p = dynamic_cast <const GGS_C_parse_loop_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_parse_loop_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_parse_loop_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_parse_loop_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_C_parse_when_else_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_when_else_instruction::
cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_C_parse_when_else_instruction) ;
    return (cPtr_C_parse_when_else_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_when_else_instruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_when_else_instruction * ptr = dynamic_cast <const cPtr_C_parse_when_else_instruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFbranchesList.operator_isEqual (ptr->mIFbranchesList).boolValue ()
         && mElseInstructionsList.operator_isEqual (ptr->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_when_else_instruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@C_parse_when_else_instruction:"
           << mIFbranchesList.reader_description (inIndentation + 1)
           << mElseInstructionsList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C_parse_when_else_instruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C_parse_when_else_instruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C_parse_when_else_instruction (& typeid (cPtr_C_parse_when_else_instruction), & typeid (cPtr_typeParserInstruction), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_C_parse_when_else_instruction::galgasRTTI (void) const {
  return & gClassInfoFor__C_parse_when_else_instruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_C_parse_when_else_instruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_C_parse_when_else_instruction (mIFbranchesList, mElseInstructionsList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_parse_when_else_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_C_parse_when_else_instruction ("C_parse_when_else_instruction", true, & kTypeDescriptor_GGS_typeParserInstruction) ;

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C_parse_when_else_instruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C_parse_when_else_instruction *> (inPointer) != NULL)
      : (typeid (cPtr_C_parse_when_else_instruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_C_parse_when_else_instruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C_parse_when_else_instruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_when_else_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_when_else_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_parse_when_else_instruction::
reader_mIFbranchesList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_when_else_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_parse_when_else_instruction::
reader_mElseInstructionsList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_when_else_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C_parse_when_else_instruction::actualTypeName (void) const {
  return "C_parse_when_else_instruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__C_parse_when_else_instruction ("C_parse_when_else_instruction", gClassInfoFor__typeParserInstruction, & kTypeDescriptor_GGS_C_parse_when_else_instruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_C_parse_when_else_instruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_C_parse_when_else_instruction * p = NULL ;
    macroMyNew (p, GGS_C_parse_when_else_instruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_C_parse_when_else_instruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_C_parse_when_else_instruction * p = dynamic_cast <const GGS_C_parse_when_else_instruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_C_parse_when_else_instruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_C_parse_when_else_instruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_C_parse_when_else_instruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeNonterminalToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonterminalToGenerate::
cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomNonTerminal (argument_0),
mNonterminalSymbolParametersMap (argument_1),
mLexiqueClassName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeNonterminalToGenerate) ;
    return (cPtr_typeNonterminalToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonterminalToGenerate::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonterminalToGenerate * ptr = dynamic_cast <const cPtr_typeNonterminalToGenerate *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomNonTerminal.operator_isEqual (ptr->aNomNonTerminal).boolValue ()
         && mNonterminalSymbolParametersMap.operator_isEqual (ptr->mNonterminalSymbolParametersMap).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonterminalToGenerate::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeNonterminalToGenerate:"
           << aNomNonTerminal.reader_description (inIndentation + 1)
           << mNonterminalSymbolParametersMap.reader_description (inIndentation + 1)
           << mLexiqueClassName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeNonterminalToGenerate::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeNonterminalToGenerate::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeNonterminalToGenerate (& typeid (cPtr_typeNonterminalToGenerate), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeNonterminalToGenerate::galgasRTTI (void) const {
  return & gClassInfoFor__typeNonterminalToGenerate ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeNonterminalToGenerate::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeNonterminalToGenerate (aNomNonTerminal, mNonterminalSymbolParametersMap, mLexiqueClassName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeNonterminalToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeNonterminalToGenerate ("typeNonterminalToGenerate", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeNonterminalToGenerate result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeNonterminalToGenerate *> (inPointer) != NULL)
      : (typeid (cPtr_typeNonterminalToGenerate) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeNonterminalToGenerate (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeNonterminalToGenerate),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_nonterminalSymbolAlts & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonterminalToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeNonterminalToGenerate (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeNonterminalToGenerate::
reader_aNomNonTerminal (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->aNomNonTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts  GGS_typeNonterminalToGenerate::
reader_mNonterminalSymbolParametersMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->mNonterminalSymbolParametersMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonterminalToGenerate::
reader_mLexiqueClassName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeNonterminalToGenerate::actualTypeName (void) const {
  return "typeNonterminalToGenerate" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeNonterminalToGenerate ("typeNonterminalToGenerate", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeNonterminalToGenerate) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeNonterminalToGenerate::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeNonterminalToGenerate * p = NULL ;
    macroMyNew (p, GGS_typeNonterminalToGenerate (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeNonterminalToGenerate result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeNonterminalToGenerate * p = dynamic_cast <const GGS_typeNonterminalToGenerate *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeNonterminalToGenerate, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeNonterminalToGenerate::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeNonterminalToGenerate ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_typeAltProductionsMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeAltProductionsMap::e_typeAltProductionsMap (void) :
aListeDeTypesEffectifs (),
mAllInstructionsList (),
mSyntaxSignature (),
mEndOfInstructionListLocation () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeAltProductionsMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeAltProductionsMap ("typeAltProductionsMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeAltProductionsMap::
elementOf_GGS_typeAltProductionsMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeAltProductionsMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeAltProductionsMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeDeTypesEffectifs.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAllInstructionsList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mSyntaxSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEndOfInstructionListLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeAltProductionsMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeAltProductionsMap * ptr = dynamic_cast <const elementOf_GGS_typeAltProductionsMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.aListeDeTypesEffectifs.operator_isEqual (ptr->mInfo.aListeDeTypesEffectifs)).boolValue ()
           && (mInfo.mAllInstructionsList.operator_isEqual (ptr->mInfo.mAllInstructionsList)).boolValue ()
           && (mInfo.mSyntaxSignature.operator_isEqual (ptr->mInfo.mSyntaxSignature)).boolValue ()
           && (mInfo.mEndOfInstructionListLocation.operator_isEqual (ptr->mInfo.mEndOfInstructionListLocation)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeAltProductionsMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeAltProductionsMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_typeAltProductionsMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAltProductionsMap::
operator_isEqual (const GGS_typeAltProductionsMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAltProductionsMap::
operator_isNotEqual (const GGS_typeAltProductionsMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
               const GGS_typeInstructionList & inParameter1,
               const GGS_syntaxInstructionListForGrammarAnalysis & inParameter2,
               const GGS_location & inParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeAltProductionsMap info  ;
    info.aListeDeTypesEffectifs = inParameter0 ;
    info.mAllInstructionsList = inParameter1 ;
    info.mSyntaxSignature = inParameter2 ;
    info.mEndOfInstructionListLocation = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
               GGS_typeInstructionList   & outParameter1,
               GGS_syntaxInstructionListForGrammarAnalysis   & outParameter2,
               GGS_location   & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.aListeDeTypesEffectifs ;
    outParameter1 = node->mInfo.mAllInstructionsList ;
    outParameter2 = node->mInfo.mSyntaxSignature ;
    outParameter3 = node->mInfo.mEndOfInstructionListLocation ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeAltProductionsMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
                                GGS_typeInstructionList   & outParameter1,
                                GGS_syntaxInstructionListForGrammarAnalysis   & outParameter2,
                                GGS_location   & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeAltProductionsMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                                const GGS_typeInstructionList & inParameter1,
                                const GGS_syntaxInstructionListForGrammarAnalysis & inParameter2,
                                const GGS_location & inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_typeAltProductionsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAltProductionsMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeAltProductionsMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeTypesEtNomsArgMethode  & GGS_typeAltProductionsMap::cEnumerator::_aListeDeTypesEffectifs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeDeTypesEffectifs ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionList  & GGS_typeAltProductionsMap::cEnumerator::_mAllInstructionsList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAllInstructionsList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_syntaxInstructionListForGrammarAnalysis  & GGS_typeAltProductionsMap::cEnumerator::_mSyntaxSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mSyntaxSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeAltProductionsMap::cEnumerator::_mEndOfInstructionListLocation (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEndOfInstructionListLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeAltProductionsMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeAltProductionsMap * p = NULL ;
    macroMyNew (p, GGS_typeAltProductionsMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeAltProductionsMap * p = dynamic_cast <const GGS_typeAltProductionsMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeAltProductionsMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeAltProductionsMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeAltProductionsMap ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_typeListeTypesEtNomsArgMethode & inValue0,
                                             const GGS_typeInstructionList & inValue1,
                                             const GGS_syntaxInstructionListForGrammarAnalysis & inValue2,
                                             const GGS_location & inValue3
                                             COMMA_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        inValue3,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeProductionAengendrer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeProductionAengendrer::
cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_string& argument_3,
                                const GGS_bool& argument_4,
                                const GGS_uint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomProduction (argument_0),
mAltProductionMap (argument_1),
mProductionTagName (argument_2),
mLexiqueClassName (argument_3),
mHasParseLabel (argument_4),
mProductionIndex (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeProductionAengendrer) ;
    return (cPtr_typeProductionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeProductionAengendrer::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeProductionAengendrer * ptr = dynamic_cast <const cPtr_typeProductionAengendrer *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = aNomProduction.operator_isEqual (ptr->aNomProduction).boolValue ()
         && mAltProductionMap.operator_isEqual (ptr->mAltProductionMap).boolValue ()
         && mProductionTagName.operator_isEqual (ptr->mProductionTagName).boolValue ()
         && mLexiqueClassName.operator_isEqual (ptr->mLexiqueClassName).boolValue ()
         && mHasParseLabel.operator_isEqual (ptr->mHasParseLabel).boolValue ()
         && mProductionIndex.operator_isEqual (ptr->mProductionIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeProductionAengendrer::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeProductionAengendrer:"
           << aNomProduction.reader_description (inIndentation + 1)
           << mAltProductionMap.reader_description (inIndentation + 1)
           << mProductionTagName.reader_description (inIndentation + 1)
           << mLexiqueClassName.reader_description (inIndentation + 1)
           << mHasParseLabel.reader_description (inIndentation + 1)
           << mProductionIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeProductionAengendrer::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeProductionAengendrer::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeProductionAengendrer (& typeid (cPtr_typeProductionAengendrer), & typeid (cPtr_typeEntityToGenerate), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeProductionAengendrer::galgasRTTI (void) const {
  return & gClassInfoFor__typeProductionAengendrer ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeProductionAengendrer::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeProductionAengendrer (aNomProduction, mAltProductionMap, mProductionTagName, mLexiqueClassName, mHasParseLabel, mProductionIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeProductionAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeProductionAengendrer ("typeProductionAengendrer", true, & kTypeDescriptor_GGS_typeEntityToGenerate) ;

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeProductionAengendrer result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeProductionAengendrer *> (inPointer) != NULL)
      : (typeid (cPtr_typeProductionAengendrer) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeProductionAengendrer (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeProductionAengendrer),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeAltProductionsMap & argument_1,
                 const GGS_string& argument_2,
                 const GGS_string& argument_3,
                 const GGS_bool& argument_4,
                 const GGS_uint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeProductionAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeProductionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeProductionAengendrer::
reader_aNomProduction (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->aNomProduction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap  GGS_typeProductionAengendrer::
reader_mAltProductionMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mAltProductionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_mProductionTagName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mProductionTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_mLexiqueClassName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeProductionAengendrer::
reader_mHasParseLabel (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mHasParseLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeProductionAengendrer::
reader_mProductionIndex (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mProductionIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeProductionAengendrer::actualTypeName (void) const {
  return "typeProductionAengendrer" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeProductionAengendrer ("typeProductionAengendrer", gClassInfoFor__typeEntityToGenerate, & kTypeDescriptor_GGS_typeProductionAengendrer) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeProductionAengendrer::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeProductionAengendrer * p = NULL ;
    macroMyNew (p, GGS_typeProductionAengendrer (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer GGS_typeProductionAengendrer::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeProductionAengendrer result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeProductionAengendrer * p = dynamic_cast <const GGS_typeProductionAengendrer *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeProductionAengendrer, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeProductionAengendrer::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeProductionAengendrer ;
}

//---------------------------------------------------------------------------*

