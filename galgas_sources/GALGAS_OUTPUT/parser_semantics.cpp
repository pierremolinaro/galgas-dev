//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'parser_semantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      march 6th, 2007, at 10h42'17"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "parser_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "parser_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeParserInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeParserInstruction::
cPtr_typeParserInstruction (LOCATION_ARGS)
:cPtr_typeInstruction (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeParserInstruction * GGS_typeParserInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeParserInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeParserInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeParserInstruction::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeParserInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeParserInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
GGS_typeParserInstruction (const GGS_typeParserInstruction & inOperand)
:GGS_typeInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeParserInstruction::
~GGS_typeParserInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeParserInstruction::
operator = (const GGS_typeParserInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeParserInstruction::
operator == (const GGS_typeParserInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeParserInstruction::
operator != (const GGS_typeParserInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeParserInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeParserInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          abstract class 'cPtr_typeInstructionAppelNonTerminal'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionAppelNonTerminal::
cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mNonterminalName (argument_0),
mParametersExpressionList (argument_1),
mAltName (argument_2),
mReturnedEntityVarName (argument_3),
mReturnedEntityName (argument_4),
mReturnedEntityShouldInsertedInList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionAppelNonTerminal *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionAppelNonTerminal::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionAppelNonTerminal * _p = dynamic_cast <const cPtr_typeInstructionAppelNonTerminal *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNonterminalName == _p->mNonterminalName).boolValue ()
         && (mParametersExpressionList == _p->mParametersExpressionList).boolValue ()
         && (mAltName == _p->mAltName).boolValue ()
         && (mReturnedEntityVarName == _p->mReturnedEntityVarName).boolValue ()
         && (mReturnedEntityName == _p->mReturnedEntityName).boolValue ()
         && (mReturnedEntityShouldInsertedInList == _p->mReturnedEntityShouldInsertedInList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionAppelNonTerminal::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionAppelNonTerminal:"
           << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mParametersExpressionList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAltName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedEntityVarName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mReturnedEntityShouldInsertedInList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
GGS_typeInstructionAppelNonTerminal (const GGS_typeInstructionAppelNonTerminal & inOperand)
:GGS_typeParserInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal::
~GGS_typeInstructionAppelNonTerminal (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionAppelNonTerminal) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionAppelNonTerminal::
operator = (const GGS_typeInstructionAppelNonTerminal & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionAppelNonTerminal GGS_typeInstructionAppelNonTerminal::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeExpressionList & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_bool& argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionAppelNonTerminal result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionAppelNonTerminal (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mNonterminalName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeExpressionList  GGS_typeInstructionAppelNonTerminal::
reader_mParametersExpressionList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mParametersExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mAltName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mAltName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mReturnedEntityVarName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mReturnedEntityVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionAppelNonTerminal::
reader_mReturnedEntityName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mReturnedEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelNonTerminal::
reader_mReturnedEntityShouldInsertedInList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionAppelNonTerminal *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionAppelNonTerminal *) mPointer)->mReturnedEntityShouldInsertedInList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelNonTerminal::
operator == (const GGS_typeInstructionAppelNonTerminal & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionAppelNonTerminal::
operator != (const GGS_typeInstructionAppelNonTerminal & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionAppelNonTerminal::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionAppelNonTerminal" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeInstructionVerifSyntaxique'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionVerifSyntaxique::
cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,
                                const GGS_L_assignedVariables & argument_1,
                                const GGS_string& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aNomTerminal (argument_0),
aListeTypeEffectifs (argument_1),
mLexiqueClassName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionVerifSyntaxique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionVerifSyntaxique::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionVerifSyntaxique * _p = dynamic_cast <const cPtr_typeInstructionVerifSyntaxique *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomTerminal == _p->aNomTerminal).boolValue ()
         && (aListeTypeEffectifs == _p->aListeTypeEffectifs).boolValue ()
         && (mLexiqueClassName == _p->mLexiqueClassName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionVerifSyntaxique::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionVerifSyntaxique:"
           << aNomTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aListeTypeEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLexiqueClassName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
GGS_typeInstructionVerifSyntaxique (const GGS_typeInstructionVerifSyntaxique & inOperand)
:GGS_typeParserInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique::
~GGS_typeInstructionVerifSyntaxique (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionVerifSyntaxique) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionVerifSyntaxique::
operator = (const GGS_typeInstructionVerifSyntaxique & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionVerifSyntaxique GGS_typeInstructionVerifSyntaxique::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_L_assignedVariables & argument_1,
                 const GGS_string& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionVerifSyntaxique result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionVerifSyntaxique (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionVerifSyntaxique::
reader_aNomTerminal (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->aNomTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_assignedVariables  GGS_typeInstructionVerifSyntaxique::
reader_aListeTypeEffectifs (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_assignedVariables   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->aListeTypeEffectifs ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionVerifSyntaxique::
reader_mLexiqueClassName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionVerifSyntaxique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionVerifSyntaxique *) mPointer)->mLexiqueClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionVerifSyntaxique::
operator == (const GGS_typeInstructionVerifSyntaxique & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionVerifSyntaxique::
operator != (const GGS_typeInstructionVerifSyntaxique & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionVerifSyntaxique::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionVerifSyntaxique" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeBranchesInstructions'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeBranchesInstructions::
elementOf_GGS_typeListeBranchesInstructions (const GGS_typeInstructionList & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeBranchesInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeBranchesInstructions * _p = dynamic_cast <const elementOf_GGS_typeListeBranchesInstructions *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInstructionList == _p->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeBranchesInstructions::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeBranchesInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::GGS_typeListeBranchesInstructions (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions::
GGS_typeListeBranchesInstructions (const GGS_typeListeBranchesInstructions & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeBranchesInstructions::
operator == (const GGS_typeListeBranchesInstructions & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeBranchesInstructions::
operator != (const GGS_typeListeBranchesInstructions & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_internalAppendValues (const GGS_typeInstructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_internalPrependValues (const GGS_typeInstructionList & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_addAssign_operation (const GGS_typeInstructionList & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions GGS_typeListeBranchesInstructions::
operator + (const GGS_typeListeBranchesInstructions & inOperand) const {
  GGS_typeListeBranchesInstructions result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeBranchesInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstructionList  p_0 = p->mInstructionList ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeInstructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstructionList
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeInstructionList & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeBranchesInstructions result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeBranchesInstructions::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeBranchesInstructions", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_first (C_Lexique & _inLexique,
              GGS_typeInstructionList & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
method_last (C_Lexique & _inLexique,
             GGS_typeInstructionList & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeInstructionList & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeBranchesInstructions::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeInstructionList & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_select_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_select_instruction::
cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_select_instruction * GGS_C_select_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_select_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_select_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_select_instruction * _p = dynamic_cast <const cPtr_C_select_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIFbranchesList == _p->mIFbranchesList).boolValue ()
         && (aPositionDebut == _p->aPositionDebut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_select_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_select_instruction:"
           << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aPositionDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_select_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction::
GGS_C_select_instruction (const GGS_C_select_instruction & inOperand)
:GGS_typeParserInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction::
~GGS_C_select_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_select_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_select_instruction::
operator = (const GGS_C_select_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_select_instruction GGS_C_select_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_select_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_select_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_select_instruction::
reader_mIFbranchesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_select_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_select_instruction::
reader_aPositionDebut (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_select_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_select_instruction *) mPointer)->aPositionDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_select_instruction::
operator == (const GGS_C_select_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_select_instruction::
operator != (const GGS_C_select_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_select_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_select_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_C_repeat_instruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_repeat_instruction::
cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
aListesBranchesRepeter (argument_0),
aPositionDebut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_repeat_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_repeat_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_repeat_instruction * _p = dynamic_cast <const cPtr_C_repeat_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aListesBranchesRepeter == _p->aListesBranchesRepeter).boolValue ()
         && (aPositionDebut == _p->aPositionDebut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_repeat_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_repeat_instruction:"
           << aListesBranchesRepeter.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << aPositionDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_repeat_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
GGS_C_repeat_instruction (const GGS_C_repeat_instruction & inOperand)
:GGS_typeParserInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction::
~GGS_C_repeat_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_repeat_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_repeat_instruction::
operator = (const GGS_C_repeat_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_repeat_instruction GGS_C_repeat_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeBranchesInstructions & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_repeat_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_repeat_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_repeat_instruction::
reader_aListesBranchesRepeter (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_repeat_instruction *) mPointer)->aListesBranchesRepeter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_repeat_instruction::
reader_aPositionDebut (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_repeat_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_repeat_instruction *) mPointer)->aPositionDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_repeat_instruction::
operator == (const GGS_C_repeat_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_repeat_instruction::
operator != (const GGS_C_repeat_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_repeat_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_repeat_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_parse_rewind_signature_list'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_parse_rewind_signature_list::
elementOf_GGS_L_parse_rewind_signature_list (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSignature (argument_0),
mErrorLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_L_parse_rewind_signature_list::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_L_parse_rewind_signature_list * _p = dynamic_cast <const elementOf_GGS_L_parse_rewind_signature_list *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mSignature == _p->mSignature).boolValue ()
         && (mErrorLocation == _p->mErrorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_L_parse_rewind_signature_list::
appendForDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_parse_rewind_signature_list'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::GGS_L_parse_rewind_signature_list (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list::
GGS_L_parse_rewind_signature_list (const GGS_L_parse_rewind_signature_list & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_parse_rewind_signature_list::
operator == (const GGS_L_parse_rewind_signature_list & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_L_parse_rewind_signature_list::
operator != (const GGS_L_parse_rewind_signature_list & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_internalAppendValues (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_internalPrependValues (const GGS_L_ruleSyntaxSignature & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,
                                const GGS_location & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list GGS_L_parse_rewind_signature_list::
operator + (const GGS_L_parse_rewind_signature_list & inOperand) const {
  GGS_L_parse_rewind_signature_list result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_L_parse_rewind_signature_list * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_L_ruleSyntaxSignature  p_0 = p->mSignature ;
          GGS_location  p_1 = p->mErrorLocation ;
          result._internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_L_ruleSyntaxSignature & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSignature,
                                _p->mErrorLocation
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_L_ruleSyntaxSignature & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_L_parse_rewind_signature_list result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_L_parse_rewind_signature_list::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@L_parse_rewind_signature_list", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_first (C_Lexique & _inLexique,
              GGS_L_ruleSyntaxSignature & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSignature ;
    _out_1 = _p->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
method_last (C_Lexique & _inLexique,
             GGS_L_ruleSyntaxSignature & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSignature ;
    _out_1 = _p->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_L_ruleSyntaxSignature & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSignature ;
    _out_1 = _p->mErrorLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_parse_rewind_signature_list::
modifier_popLast (C_Lexique & _inLexique,
                GGS_L_ruleSyntaxSignature & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mSignature ;
    _out_1 = _p->mErrorLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_C_parse_rewind_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_rewind_instruction::
cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,
                                const GGS_typeListeBranchesInstructions & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mInstructionLocation (argument_0),
mBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_rewind_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_rewind_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_rewind_instruction * _p = dynamic_cast <const cPtr_C_parse_rewind_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mInstructionLocation == _p->mInstructionLocation).boolValue ()
         && (mBranchList == _p->mBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_rewind_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_rewind_instruction:"
           << mInstructionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_C_parse_rewind_instruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
GGS_C_parse_rewind_instruction (const GGS_C_parse_rewind_instruction & inOperand)
:GGS_typeParserInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction::
~GGS_C_parse_rewind_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_parse_rewind_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_parse_rewind_instruction::
operator = (const GGS_C_parse_rewind_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_rewind_instruction GGS_C_parse_rewind_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_typeListeBranchesInstructions & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_rewind_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_rewind_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_C_parse_rewind_instruction::
reader_mInstructionLocation (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_rewind_instruction *) mPointer)->mInstructionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeBranchesInstructions  GGS_C_parse_rewind_instruction::
reader_mBranchList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeBranchesInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_rewind_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_rewind_instruction *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_parse_rewind_instruction::
operator == (const GGS_C_parse_rewind_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_parse_rewind_instruction::
operator != (const GGS_C_parse_rewind_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_parse_rewind_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_parse_rewind_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_C_parse_when_else_instruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C_parse_when_else_instruction::
cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeParserInstruction (THERE),
mIFbranchesList (argument_0),
mElseInstructionsList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C_parse_when_else_instruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C_parse_when_else_instruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_C_parse_when_else_instruction * _p = dynamic_cast <const cPtr_C_parse_when_else_instruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIFbranchesList == _p->mIFbranchesList).boolValue ()
         && (mElseInstructionsList == _p->mElseInstructionsList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_C_parse_when_else_instruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@C_parse_when_else_instruction:"
           << mIFbranchesList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mElseInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_C_parse_when_else_instruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
GGS_C_parse_when_else_instruction (const GGS_C_parse_when_else_instruction & inOperand)
:GGS_typeParserInstruction () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction::
~GGS_C_parse_when_else_instruction (void) {
  macroDetachPointer (mPointer, cPtr_C_parse_when_else_instruction) ;
}

//---------------------------------------------------------------------------*

void GGS_C_parse_when_else_instruction::
operator = (const GGS_C_parse_when_else_instruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_C_parse_when_else_instruction GGS_C_parse_when_else_instruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_L_expression_instructionsList_list & argument_0,
                 const GGS_typeInstructionList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_C_parse_when_else_instruction result ;
  macroMyNew (result.mPointer, cPtr_C_parse_when_else_instruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_L_expression_instructionsList_list  GGS_C_parse_when_else_instruction::
reader_mIFbranchesList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_L_expression_instructionsList_list   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_when_else_instruction *) mPointer)->mIFbranchesList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionList  GGS_C_parse_when_else_instruction::
reader_mElseInstructionsList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C_parse_when_else_instruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_C_parse_when_else_instruction *) mPointer)->mElseInstructionsList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_parse_when_else_instruction::
operator == (const GGS_C_parse_when_else_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_C_parse_when_else_instruction::
operator != (const GGS_C_parse_when_else_instruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_C_parse_when_else_instruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @C_parse_when_else_instruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeNonterminalToGenerate'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeNonterminalToGenerate::
cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,
                                const GGS_M_nonterminalSymbolAlts & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomNonTerminal (argument_0),
mNonterminalSymbolParametersMap (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeNonterminalToGenerate *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeNonterminalToGenerate::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeNonterminalToGenerate * _p = dynamic_cast <const cPtr_typeNonterminalToGenerate *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomNonTerminal == _p->aNomNonTerminal).boolValue ()
         && (mNonterminalSymbolParametersMap == _p->mNonterminalSymbolParametersMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeNonterminalToGenerate::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeNonterminalToGenerate:"
           << aNomNonTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNonterminalSymbolParametersMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeNonterminalToGenerate'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
GGS_typeNonterminalToGenerate (const GGS_typeNonterminalToGenerate & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate::
~GGS_typeNonterminalToGenerate (void) {
  macroDetachPointer (mPointer, cPtr_typeNonterminalToGenerate) ;
}

//---------------------------------------------------------------------------*

void GGS_typeNonterminalToGenerate::
operator = (const GGS_typeNonterminalToGenerate & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeNonterminalToGenerate GGS_typeNonterminalToGenerate::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_M_nonterminalSymbolAlts & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeNonterminalToGenerate result ;
  macroMyNew (result.mPointer, cPtr_typeNonterminalToGenerate (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeNonterminalToGenerate::
reader_aNomNonTerminal (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->aNomNonTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_nonterminalSymbolAlts  GGS_typeNonterminalToGenerate::
reader_mNonterminalSymbolParametersMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_nonterminalSymbolAlts   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeNonterminalToGenerate *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeNonterminalToGenerate *) mPointer)->mNonterminalSymbolParametersMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeNonterminalToGenerate::
operator == (const GGS_typeNonterminalToGenerate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeNonterminalToGenerate::
operator != (const GGS_typeNonterminalToGenerate & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeNonterminalToGenerate::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeNonterminalToGenerate" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeAltProductionsMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeAltProductionsMap::
elementOf_GGS_typeAltProductionsMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeAltProductionsMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeAltProductionsMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeDeTypesEffectifs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllInstructionsList.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mSyntaxSignature.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mEndOfInstructionListLocation.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mReturnedEntityTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mMDAResultVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAllPropertiesMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeAltProductionsMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeAltProductionsMap * _p = dynamic_cast <const elementOf_GGS_typeAltProductionsMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeDeTypesEffectifs == _p->mInfo.aListeDeTypesEffectifs).boolValue ()
           && (mInfo.mAllInstructionsList == _p->mInfo.mAllInstructionsList).boolValue ()
           && (mInfo.mSyntaxSignature == _p->mInfo.mSyntaxSignature).boolValue ()
           && (mInfo.mEndOfInstructionListLocation == _p->mInfo.mEndOfInstructionListLocation).boolValue ()
           && (mInfo.mReturnedEntityTypeName == _p->mInfo.mReturnedEntityTypeName).boolValue ()
           && (mInfo.mMDAResultVariableName == _p->mInfo.mMDAResultVariableName).boolValue ()
           && (mInfo.mAllPropertiesMap == _p->mInfo.mAllPropertiesMap).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeAltProductionsMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeAltProductionsMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAltProductionsMap::
operator == (const GGS_typeAltProductionsMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAltProductionsMap::
operator != (const GGS_typeAltProductionsMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                const GGS_typeInstructionList & inParameter1,
                const GGS_L_ruleSyntaxSignature & inParameter2,
                const GGS_location & inParameter3,
                const GGS_string& inParameter4,
                const GGS_string& inParameter5,
                const GGS_entityPropertyMap & inParameter6,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inParameter3._isBuilt ()
   && inParameter4._isBuilt ()
   && inParameter5._isBuilt ()
   && inParameter6._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeAltProductionsMap info  ;
    info.aListeDeTypesEffectifs = inParameter0 ;
    info.mAllInstructionsList = inParameter1 ;
    info.mSyntaxSignature = inParameter2 ;
    info.mEndOfInstructionListLocation = inParameter3 ;
    info.mReturnedEntityTypeName = inParameter4 ;
    info.mMDAResultVariableName = inParameter5 ;
    info.mAllPropertiesMap = inParameter6 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
               GGS_typeInstructionList   & outParameter1,
               GGS_L_ruleSyntaxSignature   & outParameter2,
               GGS_location   & outParameter3,
               GGS_string  & outParameter4,
               GGS_string  & outParameter5,
               GGS_entityPropertyMap   & outParameter6,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    outParameter3._drop_operation () ;
    outParameter4._drop_operation () ;
    outParameter5._drop_operation () ;
    outParameter6._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeDeTypesEffectifs ;
    outParameter1 = node->mInfo.mAllInstructionsList ;
    outParameter2 = node->mInfo.mSyntaxSignature ;
    outParameter3 = node->mInfo.mEndOfInstructionListLocation ;
    outParameter4 = node->mInfo.mReturnedEntityTypeName ;
    outParameter5 = node->mInfo.mMDAResultVariableName ;
    outParameter6 = node->mInfo.mAllPropertiesMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeListeTypesEtNomsArgMethode   & outParameter0,
                                GGS_typeInstructionList   & outParameter1,
                                GGS_L_ruleSyntaxSignature   & outParameter2,
                                GGS_location   & outParameter3,
                                GGS_string  & outParameter4,
                                GGS_string  & outParameter5,
                                GGS_entityPropertyMap   & outParameter6 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' label is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  outParameter3,
                  outParameter4,
                  outParameter5,
                  outParameter6,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAltProductionsMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,
                                const GGS_typeInstructionList & inParameter1,
                                const GGS_L_ruleSyntaxSignature & inParameter2,
                                const GGS_location & inParameter3,
                                const GGS_string& inParameter4,
                                const GGS_string& inParameter5,
                                const GGS_entityPropertyMap & inParameter6 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' label has been already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                 inParameter5,
                 inParameter6,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeAltProductionsMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeAltProductionsMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap GGS_typeAltProductionsMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAltProductionsMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeAltProductionsMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeProductionAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeProductionAengendrer::
cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,
                                const GGS_typeAltProductionsMap & argument_1,
                                const GGS_string& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeEntityToGenerate (THERE),
aNomProduction (argument_0),
mAltProductionMap (argument_1),
mProductionTagName (argument_2),
mHasParseLabel (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeProductionAengendrer *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeProductionAengendrer::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeProductionAengendrer * _p = dynamic_cast <const cPtr_typeProductionAengendrer *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (aNomProduction == _p->aNomProduction).boolValue ()
         && (mAltProductionMap == _p->mAltProductionMap).boolValue ()
         && (mProductionTagName == _p->mProductionTagName).boolValue ()
         && (mHasParseLabel == _p->mHasParseLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeProductionAengendrer::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeProductionAengendrer:"
           << aNomProduction.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAltProductionMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mProductionTagName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHasParseLabel.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeProductionAengendrer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
GGS_typeProductionAengendrer (const GGS_typeProductionAengendrer & inOperand)
:GGS_typeEntityToGenerate () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer::
~GGS_typeProductionAengendrer (void) {
  macroDetachPointer (mPointer, cPtr_typeProductionAengendrer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeProductionAengendrer::
operator = (const GGS_typeProductionAengendrer & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeProductionAengendrer GGS_typeProductionAengendrer::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeAltProductionsMap & argument_1,
                 const GGS_string& argument_2,
                 const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeProductionAengendrer result ;
  macroMyNew (result.mPointer, cPtr_typeProductionAengendrer (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeProductionAengendrer::
reader_aNomProduction (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->aNomProduction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAltProductionsMap  GGS_typeProductionAengendrer::
reader_mAltProductionMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeAltProductionsMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mAltProductionMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_mProductionTagName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mProductionTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeProductionAengendrer::
reader_mHasParseLabel (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeProductionAengendrer *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeProductionAengendrer *) mPointer)->mHasParseLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeProductionAengendrer::
operator == (const GGS_typeProductionAengendrer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeProductionAengendrer::
operator != (const GGS_typeProductionAengendrer & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeProductionAengendrer::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeProductionAengendrer" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

