//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'syntaxMetamodel.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 1st, 2007, at 21h20'5"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "syntaxMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "syntaxMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ;

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_syntaxMetamodel (void) {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@syntaxComponentRootList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxComponentRoot::
cPtr_syntaxComponentRoot (const GGS_lstring & argument_0,
                                const GGS_nonterminalDeclarationList & argument_1,
                                const GGS_syntaxRuleList & argument_2
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mSyntaxComponentName (argument_0),
mNonterminalDeclarations (argument_1),
mRules (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxComponentRoot * _p = dynamic_cast <const cPtr_syntaxComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSyntaxComponentName._operator_isEqual (_p->mSyntaxComponentName).boolValue ()
         && mNonterminalDeclarations._operator_isEqual (_p->mNonterminalDeclarations).boolValue ()
         && mRules._operator_isEqual (_p->mRules).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalDeclarations.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRules.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxComponentRoot::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxComponentRoot::_metamodelClassID (void) const {
  return 0 ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxComponentRoot * cPtr_syntaxComponentRoot::
_cloneObject (void) const {
  cPtr_syntaxComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxComponentRoot (mSyntaxComponentName, mNonterminalDeclarations, mRules COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@syntaxComponentRootList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_syntaxComponentRootList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_nonterminalDeclarationList & argument_1,
                    const GGS_syntaxRuleList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentRootList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_nonterminalDeclarationList & argument_1,
                    const GGS_syntaxRuleList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentRootList::
_addAssign_operation (const GGS_syntaxComponentRoot & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mSyntaxComponentName,
                                ((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mNonterminalDeclarations,
                                ((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mRules) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentRootList GGS_syntaxComponentRootList::
_operator_concat (const GGS_syntaxComponentRootList & inOperand) const {
  GGS_syntaxComponentRootList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSyntaxComponentName ;
          GGS_nonterminalDeclarationList  p_1 = p->mNonterminalDeclarations ;
          GGS_syntaxRuleList  p_2 = p->mRules ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentRootList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_nonterminalDeclarationList & argument_1,
                     const GGS_syntaxRuleList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentRootList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSyntaxComponentName,
                                _p->mNonterminalDeclarations,
                                _p->mRules) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentRootList  GGS_syntaxComponentRootList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxComponentRootList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxComponentRootList  GGS_syntaxComponentRootList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_nonterminalDeclarationList & argument_1,
                           const GGS_syntaxRuleList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxComponentRootList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxComponentRootList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@syntaxComponentRootList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxComponentRootList::
_addModel (const GGS_syntaxComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_syntaxComponentRootList::
method_first (C_Compiler & _inLexique,
              GGS_syntaxComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxComponentRootList::
method_last (C_Compiler & _inLexique,
             GGS_syntaxComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxComponentRootList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxComponentRootList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_syntaxComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxComponentRoot GGS_syntaxComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_nonterminalDeclarationList & argument_1,
                 const GGS_syntaxRuleList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_syntaxComponentRoot (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxComponentRoot::
reader_mSyntaxComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mSyntaxComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalDeclarationList  GGS_syntaxComponentRoot::
reader_mNonterminalDeclarations (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_nonterminalDeclarationList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mNonterminalDeclarations ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleList  GGS_syntaxComponentRoot::
reader_mRules (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxRuleList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mRules ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxComponentRoot::actualTypeName (void) const {
 return "syntaxComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxComponentRoot * GGS_syntaxComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@syntaxInstructionsList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstructions::
cPtr_syntaxInstructions (const GGS_syntaxInstructionList & argument_0
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxInstructions * _p = dynamic_cast <const cPtr_syntaxInstructions *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxInstructions::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxInstructions" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxInstructions::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxInstructions::_metamodelClassID (void) const {
  return 1 ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxInstructions * cPtr_syntaxInstructions::
_cloneObject (void) const {
  cPtr_syntaxInstructions * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxInstructions (mInstruction COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@syntaxInstructionsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_syntaxInstructionsList::
_internalAppendValues (const GGS_syntaxInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionsList::
_internalPrependValues (const GGS_syntaxInstructionList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionsList::
_addAssign_operation (const GGS_syntaxInstructions & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxInstructions *) inElement.getPtr ())->mInstruction) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionsList GGS_syntaxInstructionsList::
_operator_concat (const GGS_syntaxInstructionsList & inOperand) const {
  GGS_syntaxInstructionsList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_syntaxInstructionList  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionsList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_syntaxInstructionList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionsList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionsList  GGS_syntaxInstructionsList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxInstructionsList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionsList  GGS_syntaxInstructionsList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_syntaxInstructionList & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxInstructionsList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxInstructionsList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@syntaxInstructionsList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxInstructionsList::
_addModel (const GGS_syntaxInstructions & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_syntaxInstructionsList::
method_first (C_Compiler & _inLexique,
              GGS_syntaxInstructions & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxInstructionsList::
method_last (C_Compiler & _inLexique,
             GGS_syntaxInstructions & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxInstructionsList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxInstructions & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxInstructionsList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxInstructions & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_syntaxInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxInstructions GGS_syntaxInstructions::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_syntaxInstructionList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructions result ;
  macroMyNew (result.mPointer, cPtr_syntaxInstructions (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionList  GGS_syntaxInstructions::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxInstructions *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxInstructions *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstructions::actualTypeName (void) const {
 return "syntaxInstructions" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstructions * GGS_syntaxInstructions::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxInstructions *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@nonTerminalLabelList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonTerminalLabel::
cPtr_nonTerminalLabel (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mLabelName (argument_0),
mFormalParameters (argument_1),
mReturnedEntityName (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_nonTerminalLabel::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_nonTerminalLabel * _p = dynamic_cast <const cPtr_nonTerminalLabel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue ()
         && mReturnedEntityName._operator_isEqual (_p->mReturnedEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonTerminalLabel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @nonTerminalLabel" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_nonTerminalLabel::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_nonTerminalLabel::_metamodelClassID (void) const {
  return 2 ;
}

//---------------------------------------------------------------------------*

cPtr_nonTerminalLabel * cPtr_nonTerminalLabel::
_cloneObject (void) const {
  cPtr_nonTerminalLabel * _p = NULL ;
  macroMyNew (_p, cPtr_nonTerminalLabel (mLabelName, mFormalParameters, mReturnedEntityName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@nonTerminalLabelList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_nonTerminalLabelList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalLabelList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalLabelList::
_addAssign_operation (const GGS_nonTerminalLabel & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_nonTerminalLabel *) inElement.getPtr ())->mLabelName,
                                ((cPtr_nonTerminalLabel *) inElement.getPtr ())->mFormalParameters,
                                ((cPtr_nonTerminalLabel *) inElement.getPtr ())->mReturnedEntityName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalLabelList GGS_nonTerminalLabelList::
_operator_concat (const GGS_nonTerminalLabelList & inOperand) const {
  GGS_nonTerminalLabelList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_nonTerminalLabel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLabelName ;
          GGS_formalParameters  p_1 = p->mFormalParameters ;
          GGS_lstring  p_2 = p->mReturnedEntityName ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalLabelList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalLabelList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLabelName,
                                _p->mFormalParameters,
                                _p->mReturnedEntityName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonTerminalLabelList  GGS_nonTerminalLabelList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalLabelList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalLabelList  GGS_nonTerminalLabelList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_lstring & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonTerminalLabelList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonTerminalLabelList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@nonTerminalLabelList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_nonTerminalLabelList::
_addModel (const GGS_nonTerminalLabel & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_nonTerminalLabelList::
method_first (C_Compiler & _inLexique,
              GGS_nonTerminalLabel & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonTerminalLabelList::
method_last (C_Compiler & _inLexique,
             GGS_nonTerminalLabel & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonTerminalLabelList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_nonTerminalLabel & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonTerminalLabelList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_nonTerminalLabel & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_nonTerminalLabel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonTerminalLabel GGS_nonTerminalLabel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nonTerminalLabel result ;
  macroMyNew (result.mPointer, cPtr_nonTerminalLabel (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonTerminalLabel::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonTerminalLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonTerminalLabel *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_nonTerminalLabel::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonTerminalLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonTerminalLabel *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonTerminalLabel::
reader_mReturnedEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonTerminalLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonTerminalLabel *) mPointer)->mReturnedEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonTerminalLabel::actualTypeName (void) const {
 return "nonTerminalLabel" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonTerminalLabel * GGS_nonTerminalLabel::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_nonTerminalLabel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@nonterminalDeclarationList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonterminalDeclaration::
cPtr_nonterminalDeclaration (const GGS_lstring & argument_0,
                                const GGS_nonTerminalLabelList & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mNonterminalName (argument_0),
mLabels (argument_1),
mHasParseLabel (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_nonterminalDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_nonterminalDeclaration * _p = dynamic_cast <const cPtr_nonterminalDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalName._operator_isEqual (_p->mNonterminalName).boolValue ()
         && mLabels._operator_isEqual (_p->mLabels).boolValue ()
         && mHasParseLabel._operator_isEqual (_p->mHasParseLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonterminalDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @nonterminalDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabels.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHasParseLabel.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_nonterminalDeclaration::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_nonterminalDeclaration::_metamodelClassID (void) const {
  return 3 ;
}

//---------------------------------------------------------------------------*

cPtr_nonterminalDeclaration * cPtr_nonterminalDeclaration::
_cloneObject (void) const {
  cPtr_nonterminalDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_nonterminalDeclaration (mNonterminalName, mLabels, mHasParseLabel COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@nonterminalDeclarationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_nonterminalDeclarationList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_nonTerminalLabelList & argument_1,
                    const GGS_bool& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalDeclarationList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_nonTerminalLabelList & argument_1,
                    const GGS_bool& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalDeclarationList::
_addAssign_operation (const GGS_nonterminalDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_nonterminalDeclaration *) inElement.getPtr ())->mNonterminalName,
                                ((cPtr_nonterminalDeclaration *) inElement.getPtr ())->mLabels,
                                ((cPtr_nonterminalDeclaration *) inElement.getPtr ())->mHasParseLabel) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nonterminalDeclarationList GGS_nonterminalDeclarationList::
_operator_concat (const GGS_nonterminalDeclarationList & inOperand) const {
  GGS_nonterminalDeclarationList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_nonterminalDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mNonterminalName ;
          GGS_nonTerminalLabelList  p_1 = p->mLabels ;
          GGS_bool p_2 = p->mHasParseLabel ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalDeclarationList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_nonTerminalLabelList & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonterminalDeclarationList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalName,
                                _p->mLabels,
                                _p->mHasParseLabel) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonterminalDeclarationList  GGS_nonterminalDeclarationList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonterminalDeclarationList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalDeclarationList  GGS_nonterminalDeclarationList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_nonTerminalLabelList & argument_1,
                           const GGS_bool& argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonterminalDeclarationList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonterminalDeclarationList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@nonterminalDeclarationList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalDeclarationList::
_addModel (const GGS_nonterminalDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_nonterminalDeclarationList::
method_first (C_Compiler & _inLexique,
              GGS_nonterminalDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonterminalDeclarationList::
method_last (C_Compiler & _inLexique,
             GGS_nonterminalDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonterminalDeclarationList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_nonterminalDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonterminalDeclarationList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_nonterminalDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_nonterminalDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalDeclaration GGS_nonterminalDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_nonTerminalLabelList & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nonterminalDeclaration result ;
  macroMyNew (result.mPointer, cPtr_nonterminalDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalDeclaration::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalDeclaration *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonTerminalLabelList  GGS_nonterminalDeclaration::
reader_mLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_nonTerminalLabelList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalDeclaration *) mPointer)->mLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonterminalDeclaration::
reader_mHasParseLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalDeclaration *) mPointer)->mHasParseLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonterminalDeclaration::actualTypeName (void) const {
 return "nonterminalDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonterminalDeclaration * GGS_nonterminalDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_nonterminalDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@syntaxRuleLabelList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxRuleLabel::
cPtr_syntaxRuleLabel (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_syntaxInstructions & argument_4
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mLabelName (argument_0),
mFormalParameters (argument_1),
mReturnedEntityName (argument_2),
mReturnedVariableName (argument_3),
mSyntaxInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxRuleLabel::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxRuleLabel * _p = dynamic_cast <const cPtr_syntaxRuleLabel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue ()
         && mReturnedEntityName._operator_isEqual (_p->mReturnedEntityName).boolValue ()
         && mReturnedVariableName._operator_isEqual (_p->mReturnedVariableName).boolValue ()
         && mSyntaxInstructionList._operator_isEqual (_p->mSyntaxInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxRuleLabel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxRuleLabel" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxRuleLabel::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxRuleLabel::_metamodelClassID (void) const {
  return 4 ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxRuleLabel * cPtr_syntaxRuleLabel::
_cloneObject (void) const {
  cPtr_syntaxRuleLabel * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxRuleLabel (mLabelName, mFormalParameters, mReturnedEntityName, mReturnedVariableName, mSyntaxInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@syntaxRuleLabelList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_syntaxRuleLabelList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_syntaxInstructions & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleLabelList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_syntaxInstructions & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleLabelList::
_addAssign_operation (const GGS_syntaxRuleLabel & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mLabelName,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mFormalParameters,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mReturnedEntityName,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mReturnedVariableName,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mSyntaxInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleLabelList GGS_syntaxRuleLabelList::
_operator_concat (const GGS_syntaxRuleLabelList & inOperand) const {
  GGS_syntaxRuleLabelList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxRuleLabel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLabelName ;
          GGS_formalParameters  p_1 = p->mFormalParameters ;
          GGS_lstring  p_2 = p->mReturnedEntityName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_syntaxInstructions  p_4 = p->mSyntaxInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleLabelList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_syntaxInstructions & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleLabelList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLabelName,
                                _p->mFormalParameters,
                                _p->mReturnedEntityName,
                                _p->mReturnedVariableName,
                                _p->mSyntaxInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleLabelList  GGS_syntaxRuleLabelList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxRuleLabelList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleLabelList  GGS_syntaxRuleLabelList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3,
                           const GGS_syntaxInstructions & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxRuleLabelList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxRuleLabelList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@syntaxRuleLabelList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleLabelList::
_addModel (const GGS_syntaxRuleLabel & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleLabelList::
method_first (C_Compiler & _inLexique,
              GGS_syntaxRuleLabel & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleLabelList::
method_last (C_Compiler & _inLexique,
             GGS_syntaxRuleLabel & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleLabelList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxRuleLabel & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleLabelList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxRuleLabel & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_syntaxRuleLabel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxRuleLabel GGS_syntaxRuleLabel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_syntaxInstructions & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxRuleLabel result ;
  macroMyNew (result.mPointer, cPtr_syntaxRuleLabel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleLabel::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_syntaxRuleLabel::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleLabel::
reader_mReturnedEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mReturnedEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleLabel::
reader_mReturnedVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mReturnedVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructions  GGS_syntaxRuleLabel::
reader_mSyntaxInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mSyntaxInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxRuleLabel::actualTypeName (void) const {
 return "syntaxRuleLabel" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxRuleLabel * GGS_syntaxRuleLabel::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxRuleLabel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@syntaxRuleList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxRule::
cPtr_syntaxRule (const GGS_lstring & argument_0,
                                const GGS_syntaxRuleLabelList & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mNonterminalName (argument_0),
mLabelList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxRule::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxRule * _p = dynamic_cast <const cPtr_syntaxRule *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalName._operator_isEqual (_p->mNonterminalName).boolValue ()
         && mLabelList._operator_isEqual (_p->mLabelList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxRule::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxRule" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxRule::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_syntaxRule::_metamodelClassID (void) const {
  return 5 ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxRule * cPtr_syntaxRule::
_cloneObject (void) const {
  cPtr_syntaxRule * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxRule (mNonterminalName, mLabelList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          List '@syntaxRuleList'                           *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_syntaxRuleList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_syntaxRuleLabelList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_syntaxRuleLabelList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleList::
_addAssign_operation (const GGS_syntaxRule & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxRule *) inElement.getPtr ())->mNonterminalName,
                                ((cPtr_syntaxRule *) inElement.getPtr ())->mLabelList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleList GGS_syntaxRuleList::
_operator_concat (const GGS_syntaxRuleList & inOperand) const {
  GGS_syntaxRuleList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxRule * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mNonterminalName ;
          GGS_syntaxRuleLabelList  p_1 = p->mLabelList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_syntaxRuleLabelList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalName,
                                _p->mLabelList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleList  GGS_syntaxRuleList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxRuleList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleList  GGS_syntaxRuleList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_syntaxRuleLabelList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_syntaxRuleList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxRuleList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@syntaxRuleList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleList::
_addModel (const GGS_syntaxRule & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleList::
method_first (C_Compiler & _inLexique,
              GGS_syntaxRule & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleList::
method_last (C_Compiler & _inLexique,
             GGS_syntaxRule & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxRule & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_syntaxRuleList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxRule & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_syntaxRule'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxRule GGS_syntaxRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_syntaxRuleLabelList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxRule result ;
  macroMyNew (result.mPointer, cPtr_syntaxRule (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRule::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRule *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleLabelList  GGS_syntaxRule::
reader_mLabelList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxRuleLabelList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRule *) mPointer)->mLabelList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxRule::actualTypeName (void) const {
 return "syntaxRule" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxRule * GGS_syntaxRule::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@nonterminalCallInstructionList'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonterminalCallInstruction::
cPtr_nonterminalCallInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mNonterminalName (argument_0),
mLabelName (argument_1),
mActualParameterList (argument_2),
mReturnedValueTargetVariableName (argument_3),
mReturnedValueIsAssigned (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_nonterminalCallInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_nonterminalCallInstruction * _p = dynamic_cast <const cPtr_nonterminalCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalName._operator_isEqual (_p->mNonterminalName).boolValue ()
         && mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue ()
         && mReturnedValueTargetVariableName._operator_isEqual (_p->mReturnedValueTargetVariableName).boolValue ()
         && mReturnedValueIsAssigned._operator_isEqual (_p->mReturnedValueIsAssigned).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonterminalCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @nonterminalCallInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedValueTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedValueIsAssigned.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_nonterminalCallInstruction::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_nonterminalCallInstruction::_metamodelClassID (void) const {
  return 6 ;
}

//---------------------------------------------------------------------------*

cPtr_nonterminalCallInstruction * cPtr_nonterminalCallInstruction::
_cloneObject (void) const {
  cPtr_nonterminalCallInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_nonterminalCallInstruction (mNonterminalName, mLabelName, mActualParameterList, mReturnedValueTargetVariableName, mReturnedValueIsAssigned COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@nonterminalCallInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_nonterminalCallInstructionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_bool& argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalCallInstructionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_bool& argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalCallInstructionList::
_addAssign_operation (const GGS_nonterminalCallInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mNonterminalName,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mLabelName,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mActualParameterList,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mReturnedValueTargetVariableName,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mReturnedValueIsAssigned) ;
  }
}

//---------------------------------------------------------------------------*

GGS_nonterminalCallInstructionList GGS_nonterminalCallInstructionList::
_operator_concat (const GGS_nonterminalCallInstructionList & inOperand) const {
  GGS_nonterminalCallInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_nonterminalCallInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mNonterminalName ;
          GGS_lstring  p_1 = p->mLabelName ;
          GGS_actualParameters  p_2 = p->mActualParameterList ;
          GGS_lstring  p_3 = p->mReturnedValueTargetVariableName ;
          GGS_bool p_4 = p->mReturnedValueIsAssigned ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalCallInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_actualParameters & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_bool& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_nonterminalCallInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalName,
                                _p->mLabelName,
                                _p->mActualParameterList,
                                _p->mReturnedValueTargetVariableName,
                                _p->mReturnedValueIsAssigned) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_nonterminalCallInstructionList  GGS_nonterminalCallInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonterminalCallInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_nonterminalCallInstructionList  GGS_nonterminalCallInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_actualParameters & argument_2,
                           const GGS_lstring & argument_3,
                           const GGS_bool& argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_nonterminalCallInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_nonterminalCallInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@nonterminalCallInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_nonterminalCallInstructionList::
_addModel (const GGS_nonterminalCallInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_nonterminalCallInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_nonterminalCallInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonterminalCallInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_nonterminalCallInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonterminalCallInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_nonterminalCallInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_nonterminalCallInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_nonterminalCallInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_nonterminalCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalCallInstruction GGS_nonterminalCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_nonterminalCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_nonterminalCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalCallInstruction::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalCallInstruction::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_nonterminalCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalCallInstruction::
reader_mReturnedValueTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mReturnedValueTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonterminalCallInstruction::
reader_mReturnedValueIsAssigned (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mReturnedValueIsAssigned ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonterminalCallInstruction::actualTypeName (void) const {
 return "nonterminalCallInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonterminalCallInstruction * GGS_nonterminalCallInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_nonterminalCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@terminalCheckInstructionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_terminalCheckInstruction::
cPtr_terminalCheckInstruction (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mTerminalName (argument_0),
mReturnedValueTargetVariableNames (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_terminalCheckInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_terminalCheckInstruction * _p = dynamic_cast <const cPtr_terminalCheckInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTerminalName._operator_isEqual (_p->mTerminalName).boolValue ()
         && mReturnedValueTargetVariableNames._operator_isEqual (_p->mReturnedValueTargetVariableNames).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_terminalCheckInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @terminalCheckInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedValueTargetVariableNames.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_terminalCheckInstruction::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_terminalCheckInstruction::_metamodelClassID (void) const {
  return 7 ;
}

//---------------------------------------------------------------------------*

cPtr_terminalCheckInstruction * cPtr_terminalCheckInstruction::
_cloneObject (void) const {
  cPtr_terminalCheckInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_terminalCheckInstruction (mTerminalName, mReturnedValueTargetVariableNames COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@terminalCheckInstructionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_terminalCheckInstructionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckInstructionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckInstructionList::
_addAssign_operation (const GGS_terminalCheckInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_terminalCheckInstruction *) inElement.getPtr ())->mTerminalName,
                                ((cPtr_terminalCheckInstruction *) inElement.getPtr ())->mReturnedValueTargetVariableNames) ;
  }
}

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionList GGS_terminalCheckInstructionList::
_operator_concat (const GGS_terminalCheckInstructionList & inOperand) const {
  GGS_terminalCheckInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_terminalCheckInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTerminalName ;
          GGS_lstringlist  p_1 = p->mReturnedValueTargetVariableNames ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTerminalName,
                                _p->mReturnedValueTargetVariableNames) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionList  GGS_terminalCheckInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_terminalCheckInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_terminalCheckInstructionList  GGS_terminalCheckInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_terminalCheckInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_terminalCheckInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@terminalCheckInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_terminalCheckInstructionList::
_addModel (const GGS_terminalCheckInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_terminalCheckInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_terminalCheckInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_terminalCheckInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_terminalCheckInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_terminalCheckInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_terminalCheckInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_terminalCheckInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_terminalCheckInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_terminalCheckInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_terminalCheckInstruction GGS_terminalCheckInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_terminalCheckInstruction result ;
  macroMyNew (result.mPointer, cPtr_terminalCheckInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalCheckInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalCheckInstruction::
reader_mReturnedValueTargetVariableNames (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstruction *) mPointer)->mReturnedValueTargetVariableNames ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_terminalCheckInstruction::actualTypeName (void) const {
 return "terminalCheckInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_terminalCheckInstruction * GGS_terminalCheckInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_terminalCheckInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@repeatInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_repeatInstruction::
cPtr_repeatInstruction (const GGS_syntaxInstructions & argument_0,
                                const GGS_syntaxInstructionsList & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mRepeatedInstructionList (argument_0),
mRepeatBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_repeatInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_repeatInstruction * _p = dynamic_cast <const cPtr_repeatInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRepeatedInstructionList._operator_isEqual (_p->mRepeatedInstructionList).boolValue ()
         && mRepeatBranchList._operator_isEqual (_p->mRepeatBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_repeatInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @repeatInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRepeatedInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRepeatBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_repeatInstruction::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_repeatInstruction::_metamodelClassID (void) const {
  return 8 ;
}

//---------------------------------------------------------------------------*

cPtr_repeatInstruction * cPtr_repeatInstruction::
_cloneObject (void) const {
  cPtr_repeatInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_repeatInstruction (mRepeatedInstructionList, mRepeatBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@repeatInstructionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_repeatInstructionList::
_internalAppendValues (const GGS_syntaxInstructions & argument_0,
                    const GGS_syntaxInstructionsList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_repeatInstructionList::
_internalPrependValues (const GGS_syntaxInstructions & argument_0,
                    const GGS_syntaxInstructionsList & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_repeatInstructionList::
_addAssign_operation (const GGS_repeatInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_repeatInstruction *) inElement.getPtr ())->mRepeatedInstructionList,
                                ((cPtr_repeatInstruction *) inElement.getPtr ())->mRepeatBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionList GGS_repeatInstructionList::
_operator_concat (const GGS_repeatInstructionList & inOperand) const {
  GGS_repeatInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_repeatInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_syntaxInstructions  p_0 = p->mRepeatedInstructionList ;
          GGS_syntaxInstructionsList  p_1 = p->mRepeatBranchList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_repeatInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_syntaxInstructions & argument_0,
                     const GGS_syntaxInstructionsList & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_repeatInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRepeatedInstructionList,
                                _p->mRepeatBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionList  GGS_repeatInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_repeatInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_repeatInstructionList  GGS_repeatInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_syntaxInstructions & argument_0,
                           const GGS_syntaxInstructionsList & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_repeatInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_repeatInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@repeatInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_repeatInstructionList::
_addModel (const GGS_repeatInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_repeatInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_repeatInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_repeatInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_repeatInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_repeatInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_repeatInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_repeatInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_repeatInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_repeatInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_repeatInstruction GGS_repeatInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_syntaxInstructions & argument_0,
                 const GGS_syntaxInstructionsList & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_repeatInstruction result ;
  macroMyNew (result.mPointer, cPtr_repeatInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructions  GGS_repeatInstruction::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstruction *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionsList  GGS_repeatInstruction::
reader_mRepeatBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructionsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstruction *) mPointer)->mRepeatBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_repeatInstruction::actualTypeName (void) const {
 return "repeatInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_repeatInstruction * GGS_repeatInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_repeatInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@selectInstructionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selectInstruction::
cPtr_selectInstruction (const GGS_syntaxInstructionsList & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mSelectBranchList (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_selectInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_selectInstruction * _p = dynamic_cast <const cPtr_selectInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSelectBranchList._operator_isEqual (_p->mSelectBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selectInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @selectInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_selectInstruction::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_selectInstruction::_metamodelClassID (void) const {
  return 9 ;
}

//---------------------------------------------------------------------------*

cPtr_selectInstruction * cPtr_selectInstruction::
_cloneObject (void) const {
  cPtr_selectInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_selectInstruction (mSelectBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@selectInstructionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_selectInstructionList::
_internalAppendValues (const GGS_syntaxInstructionsList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_selectInstructionList::
_internalPrependValues (const GGS_syntaxInstructionsList & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_selectInstructionList::
_addAssign_operation (const GGS_selectInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_selectInstruction *) inElement.getPtr ())->mSelectBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS_selectInstructionList GGS_selectInstructionList::
_operator_concat (const GGS_selectInstructionList & inOperand) const {
  GGS_selectInstructionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_selectInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_syntaxInstructionsList  p_0 = p->mSelectBranchList ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_selectInstructionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_syntaxInstructionsList & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_selectInstructionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSelectBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_selectInstructionList  GGS_selectInstructionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_selectInstructionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selectInstructionList  GGS_selectInstructionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_syntaxInstructionsList & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_selectInstructionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_selectInstructionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@selectInstructionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_selectInstructionList::
_addModel (const GGS_selectInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_selectInstructionList::
method_first (C_Compiler & _inLexique,
              GGS_selectInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_selectInstructionList::
method_last (C_Compiler & _inLexique,
             GGS_selectInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_selectInstructionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_selectInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_selectInstructionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_selectInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_selectInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_selectInstruction GGS_selectInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_syntaxInstructionsList & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_selectInstruction result ;
  macroMyNew (result.mPointer, cPtr_selectInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionsList  GGS_selectInstruction::
reader_mSelectBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructionsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selectInstruction *) mPointer)->mSelectBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selectInstruction::actualTypeName (void) const {
 return "selectInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selectInstruction * GGS_selectInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_selectInstruction *) mPointer ;
  }
#endif

