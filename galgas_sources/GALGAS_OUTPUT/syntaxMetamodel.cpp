//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'syntaxMetamodel.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      june 24th, 2007, at 15h56'12"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "syntaxMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "syntaxMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("syntaxMetamodel", 12) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_syntaxMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@syntaxComponentRoot'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxComponentRoot::
cPtr_syntaxComponentRoot (const GGS_lstring & argument_0,
                                const GGS__list_nonterminalDeclaration & argument_1,
                                const GGS__list_syntaxRule & argument_2,
                                const GGS__list_semanticDeclaration & argument_3
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mSyntaxComponentName (argument_0),
mNonterminalDeclarations (argument_1),
mRules (argument_2),
mSemanticDeclarations (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxComponentRoot * _p = dynamic_cast <const cPtr_syntaxComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSyntaxComponentName._operator_isEqual (_p->mSyntaxComponentName).boolValue ()
         && mNonterminalDeclarations._operator_isEqual (_p->mNonterminalDeclarations).boolValue ()
         && mRules._operator_isEqual (_p->mRules).boolValue ()
         && mSemanticDeclarations._operator_isEqual (_p->mSemanticDeclarations).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalDeclarations.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRules.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclarations.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxComponentRoot::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxComponentRoot::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxComponentRoot::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxComponentRoot::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "syntaxComponentRoot" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxComponentRoot * cPtr_syntaxComponentRoot::
_cloneObject (void) const {
  cPtr_syntaxComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxComponentRoot (mSyntaxComponentName, mNonterminalDeclarations, mRules, mSemanticDeclarations COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_syntaxComponentRoot'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_syntaxComponentRoot::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_nonterminalDeclaration & argument_1,
                    const GGS__list_syntaxRule & argument_2,
                    const GGS__list_semanticDeclaration & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxComponentRoot::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_nonterminalDeclaration & argument_1,
                    const GGS__list_syntaxRule & argument_2,
                    const GGS__list_semanticDeclaration & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxComponentRoot::
_addAssign_operation (const GGS_syntaxComponentRoot & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mSyntaxComponentName,
                                ((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mNonterminalDeclarations,
                                ((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mRules,
                                ((cPtr_syntaxComponentRoot *) inElement.getPtr ())->mSemanticDeclarations) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxComponentRoot GGS__list_syntaxComponentRoot::
_operator_concat (const GGS__list_syntaxComponentRoot & inOperand) const {
  GGS__list_syntaxComponentRoot result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSyntaxComponentName ;
          GGS__list_nonterminalDeclaration  p_1 = p->mNonterminalDeclarations ;
          GGS__list_syntaxRule  p_2 = p->mRules ;
          GGS__list_semanticDeclaration  p_3 = p->mSemanticDeclarations ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxComponentRoot::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_nonterminalDeclaration & argument_1,
                     const GGS__list_syntaxRule & argument_2,
                     const GGS__list_semanticDeclaration & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxComponentRoot::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSyntaxComponentName,
                                _p->mNonterminalDeclarations,
                                _p->mRules,
                                _p->mSemanticDeclarations) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxComponentRoot  GGS__list_syntaxComponentRoot::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxComponentRoot result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxComponentRoot  GGS__list_syntaxComponentRoot::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_nonterminalDeclaration & argument_1,
                           const GGS__list_syntaxRule & argument_2,
                           const GGS__list_semanticDeclaration & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxComponentRoot result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_syntaxComponentRoot::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_syntaxComponentRoot", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxComponentRoot::
_addModel (const GGS_syntaxComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxComponentRoot::
method_first (C_Compiler & _inLexique,
              GGS_syntaxComponentRoot & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules,
       _p->mSemanticDeclarations) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxComponentRoot::
method_last (C_Compiler & _inLexique,
             GGS_syntaxComponentRoot & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules,
       _p->mSemanticDeclarations) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxComponentRoot::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxComponentRoot & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules,
       _p->mSemanticDeclarations) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxComponentRoot::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxComponentRoot & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxComponentRoot::constructor_new (_inLexique,
       _p->mSyntaxComponentName,
       _p->mNonterminalDeclarations,
       _p->mRules,
       _p->mSemanticDeclarations) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@syntaxComponentRoot'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxComponentRoot GGS_syntaxComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_nonterminalDeclaration & argument_1,
                 const GGS__list_syntaxRule & argument_2,
                 const GGS__list_semanticDeclaration & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_syntaxComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxComponentRoot::
reader_mSyntaxComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mSyntaxComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalDeclaration  GGS_syntaxComponentRoot::
reader_mNonterminalDeclarations (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_nonterminalDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mNonterminalDeclarations ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRule  GGS_syntaxComponentRoot::
reader_mRules (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_syntaxRule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mRules ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticDeclaration  GGS_syntaxComponentRoot::
reader_mSemanticDeclarations (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticDeclaration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxComponentRoot *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxComponentRoot *) mPointer)->mSemanticDeclarations ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxComponentRoot::actualTypeName (void) const {
 return "syntaxComponentRoot" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxComponentRoot * GGS_syntaxComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxComponentRoot *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@syntaxInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstructions::
cPtr_syntaxInstructions (const GGS__list_syntaxInstruction & argument_0
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxInstructions * _p = dynamic_cast <const cPtr_syntaxInstructions *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mInstruction._operator_isEqual (_p->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxInstructions::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxInstructions" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxInstructions::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructions::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxInstructions::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructions::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "syntaxInstructions" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxInstructions * cPtr_syntaxInstructions::
_cloneObject (void) const {
  cPtr_syntaxInstructions * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxInstructions (mInstruction COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_syntaxInstructions'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_syntaxInstructions::
_internalAppendValues (const GGS__list_syntaxInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstructions::
_internalPrependValues (const GGS__list_syntaxInstruction & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstructions::
_addAssign_operation (const GGS_syntaxInstructions & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxInstructions *) inElement.getPtr ())->mInstruction) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstructions GGS__list_syntaxInstructions::
_operator_concat (const GGS__list_syntaxInstructions & inOperand) const {
  GGS__list_syntaxInstructions result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS__list_syntaxInstruction  p_0 = p->mInstruction ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstructions::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS__list_syntaxInstruction & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstructions::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstructions  GGS__list_syntaxInstructions::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxInstructions result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstructions  GGS__list_syntaxInstructions::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS__list_syntaxInstruction & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxInstructions result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_syntaxInstructions::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_syntaxInstructions", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxInstructions::
_addModel (const GGS_syntaxInstructions & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstructions::
method_first (C_Compiler & _inLexique,
              GGS_syntaxInstructions & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstructions::
method_last (C_Compiler & _inLexique,
             GGS_syntaxInstructions & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstructions::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxInstructions & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxInstructions::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxInstructions & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxInstructions::constructor_new (_inLexique,
       _p->mInstruction) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@syntaxInstructions'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxInstructions GGS_syntaxInstructions::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_syntaxInstruction & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructions result ;
  macroMyNew (result.mPointer, cPtr_syntaxInstructions (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstruction  GGS_syntaxInstructions::
reader_mInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_syntaxInstruction   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxInstructions *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxInstructions *) mPointer)->mInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstructions::actualTypeName (void) const {
 return "syntaxInstructions" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstructions * GGS_syntaxInstructions::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxInstructions *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@nonTerminalLabel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonTerminalLabel::
cPtr_nonTerminalLabel (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mLabelName (argument_0),
mFormalParameters (argument_1),
mReturnedEntityName (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_nonTerminalLabel::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_nonTerminalLabel * _p = dynamic_cast <const cPtr_nonTerminalLabel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue ()
         && mReturnedEntityName._operator_isEqual (_p->mReturnedEntityName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonTerminalLabel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @nonTerminalLabel" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_nonTerminalLabel::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonTerminalLabel::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_nonTerminalLabel::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonTerminalLabel::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "nonTerminalLabel" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_nonTerminalLabel * cPtr_nonTerminalLabel::
_cloneObject (void) const {
  cPtr_nonTerminalLabel * _p = NULL ;
  macroMyNew (_p, cPtr_nonTerminalLabel (mLabelName, mFormalParameters, mReturnedEntityName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_nonTerminalLabel'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_nonTerminalLabel::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonTerminalLabel::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonTerminalLabel::
_addAssign_operation (const GGS_nonTerminalLabel & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_nonTerminalLabel *) inElement.getPtr ())->mLabelName,
                                ((cPtr_nonTerminalLabel *) inElement.getPtr ())->mFormalParameters,
                                ((cPtr_nonTerminalLabel *) inElement.getPtr ())->mReturnedEntityName) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_nonTerminalLabel GGS__list_nonTerminalLabel::
_operator_concat (const GGS__list_nonTerminalLabel & inOperand) const {
  GGS__list_nonTerminalLabel result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_nonTerminalLabel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLabelName ;
          GGS_formalParameters  p_1 = p->mFormalParameters ;
          GGS_lstring  p_2 = p->mReturnedEntityName ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonTerminalLabel::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_nonTerminalLabel::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLabelName,
                                _p->mFormalParameters,
                                _p->mReturnedEntityName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_nonTerminalLabel  GGS__list_nonTerminalLabel::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_nonTerminalLabel result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_nonTerminalLabel  GGS__list_nonTerminalLabel::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_lstring & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_nonTerminalLabel result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_nonTerminalLabel::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_nonTerminalLabel", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonTerminalLabel::
_addModel (const GGS_nonTerminalLabel & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_nonTerminalLabel::
method_first (C_Compiler & _inLexique,
              GGS_nonTerminalLabel & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonTerminalLabel::
method_last (C_Compiler & _inLexique,
             GGS_nonTerminalLabel & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonTerminalLabel::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_nonTerminalLabel & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonTerminalLabel::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_nonTerminalLabel & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonTerminalLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@nonTerminalLabel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonTerminalLabel GGS_nonTerminalLabel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nonTerminalLabel result ;
  macroMyNew (result.mPointer, cPtr_nonTerminalLabel (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonTerminalLabel::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonTerminalLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonTerminalLabel *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_nonTerminalLabel::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonTerminalLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonTerminalLabel *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonTerminalLabel::
reader_mReturnedEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonTerminalLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonTerminalLabel *) mPointer)->mReturnedEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonTerminalLabel::actualTypeName (void) const {
 return "nonTerminalLabel" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonTerminalLabel * GGS_nonTerminalLabel::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_nonTerminalLabel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@nonterminalDeclaration'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonterminalDeclaration::
cPtr_nonterminalDeclaration (const GGS_lstring & argument_0,
                                const GGS__list_nonTerminalLabel & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mNonterminalName (argument_0),
mLabels (argument_1),
mHasParseLabel (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_nonterminalDeclaration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_nonterminalDeclaration * _p = dynamic_cast <const cPtr_nonterminalDeclaration *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalName._operator_isEqual (_p->mNonterminalName).boolValue ()
         && mLabels._operator_isEqual (_p->mLabels).boolValue ()
         && mHasParseLabel._operator_isEqual (_p->mHasParseLabel).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonterminalDeclaration::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @nonterminalDeclaration" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabels.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHasParseLabel.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_nonterminalDeclaration::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonterminalDeclaration::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_nonterminalDeclaration::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonterminalDeclaration::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "nonterminalDeclaration" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_nonterminalDeclaration * cPtr_nonterminalDeclaration::
_cloneObject (void) const {
  cPtr_nonterminalDeclaration * _p = NULL ;
  macroMyNew (_p, cPtr_nonterminalDeclaration (mNonterminalName, mLabels, mHasParseLabel COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_nonterminalDeclaration'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_nonterminalDeclaration::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_nonTerminalLabel & argument_1,
                    const GGS_bool& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalDeclaration::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_nonTerminalLabel & argument_1,
                    const GGS_bool& argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalDeclaration::
_addAssign_operation (const GGS_nonterminalDeclaration & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_nonterminalDeclaration *) inElement.getPtr ())->mNonterminalName,
                                ((cPtr_nonterminalDeclaration *) inElement.getPtr ())->mLabels,
                                ((cPtr_nonterminalDeclaration *) inElement.getPtr ())->mHasParseLabel) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalDeclaration GGS__list_nonterminalDeclaration::
_operator_concat (const GGS__list_nonterminalDeclaration & inOperand) const {
  GGS__list_nonterminalDeclaration result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_nonterminalDeclaration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mNonterminalName ;
          GGS__list_nonTerminalLabel  p_1 = p->mLabels ;
          GGS_bool p_2 = p->mHasParseLabel ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalDeclaration::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_nonTerminalLabel & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalDeclaration::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalName,
                                _p->mLabels,
                                _p->mHasParseLabel) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalDeclaration  GGS__list_nonterminalDeclaration::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_nonterminalDeclaration result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalDeclaration  GGS__list_nonterminalDeclaration::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_nonTerminalLabel & argument_1,
                           const GGS_bool& argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_nonterminalDeclaration result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_nonterminalDeclaration::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_nonterminalDeclaration", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalDeclaration::
_addModel (const GGS_nonterminalDeclaration & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalDeclaration::
method_first (C_Compiler & _inLexique,
              GGS_nonterminalDeclaration & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalDeclaration::
method_last (C_Compiler & _inLexique,
             GGS_nonterminalDeclaration & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalDeclaration::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_nonterminalDeclaration & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalDeclaration::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_nonterminalDeclaration & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalDeclaration::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabels,
       _p->mHasParseLabel) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@nonterminalDeclaration'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalDeclaration GGS_nonterminalDeclaration::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_nonTerminalLabel & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_nonterminalDeclaration result ;
  macroMyNew (result.mPointer, cPtr_nonterminalDeclaration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalDeclaration::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalDeclaration *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_nonTerminalLabel  GGS_nonterminalDeclaration::
reader_mLabels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_nonTerminalLabel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalDeclaration *) mPointer)->mLabels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonterminalDeclaration::
reader_mHasParseLabel (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalDeclaration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalDeclaration *) mPointer)->mHasParseLabel ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonterminalDeclaration::actualTypeName (void) const {
 return "nonterminalDeclaration" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonterminalDeclaration * GGS_nonterminalDeclaration::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_nonterminalDeclaration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@syntaxRuleLabel'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxRuleLabel::
cPtr_syntaxRuleLabel (const GGS_lstring & argument_0,
                                const GGS_formalParameters & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_syntaxInstructions & argument_4
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mLabelName (argument_0),
mFormalParameters (argument_1),
mReturnedEntityName (argument_2),
mReturnedVariableName (argument_3),
mSyntaxInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxRuleLabel::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxRuleLabel * _p = dynamic_cast <const cPtr_syntaxRuleLabel *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mFormalParameters._operator_isEqual (_p->mFormalParameters).boolValue ()
         && mReturnedEntityName._operator_isEqual (_p->mReturnedEntityName).boolValue ()
         && mReturnedVariableName._operator_isEqual (_p->mReturnedVariableName).boolValue ()
         && mSyntaxInstructionList._operator_isEqual (_p->mSyntaxInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxRuleLabel::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxRuleLabel" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameters.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxRuleLabel::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxRuleLabel::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxRuleLabel::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxRuleLabel::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "syntaxRuleLabel" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxRuleLabel * cPtr_syntaxRuleLabel::
_cloneObject (void) const {
  cPtr_syntaxRuleLabel * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxRuleLabel (mLabelName, mFormalParameters, mReturnedEntityName, mReturnedVariableName, mSyntaxInstructionList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_syntaxRuleLabel'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_syntaxRuleLabel::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_syntaxInstructions & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRuleLabel::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameters & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_syntaxInstructions & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRuleLabel::
_addAssign_operation (const GGS_syntaxRuleLabel & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mLabelName,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mFormalParameters,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mReturnedEntityName,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mReturnedVariableName,
                                ((cPtr_syntaxRuleLabel *) inElement.getPtr ())->mSyntaxInstructionList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRuleLabel GGS__list_syntaxRuleLabel::
_operator_concat (const GGS__list_syntaxRuleLabel & inOperand) const {
  GGS__list_syntaxRuleLabel result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxRuleLabel * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLabelName ;
          GGS_formalParameters  p_1 = p->mFormalParameters ;
          GGS_lstring  p_2 = p->mReturnedEntityName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_syntaxInstructions  p_4 = p->mSyntaxInstructionList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRuleLabel::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameters & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_syntaxInstructions & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRuleLabel::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mLabelName,
                                _p->mFormalParameters,
                                _p->mReturnedEntityName,
                                _p->mReturnedVariableName,
                                _p->mSyntaxInstructionList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRuleLabel  GGS__list_syntaxRuleLabel::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxRuleLabel result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRuleLabel  GGS__list_syntaxRuleLabel::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_formalParameters & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstring & argument_3,
                           const GGS_syntaxInstructions & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxRuleLabel result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_syntaxRuleLabel::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_syntaxRuleLabel", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRuleLabel::
_addModel (const GGS_syntaxRuleLabel & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRuleLabel::
method_first (C_Compiler & _inLexique,
              GGS_syntaxRuleLabel & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRuleLabel::
method_last (C_Compiler & _inLexique,
             GGS_syntaxRuleLabel & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRuleLabel::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxRuleLabel & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRuleLabel::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxRuleLabel & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRuleLabel::constructor_new (_inLexique,
       _p->mLabelName,
       _p->mFormalParameters,
       _p->mReturnedEntityName,
       _p->mReturnedVariableName,
       _p->mSyntaxInstructionList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@syntaxRuleLabel'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxRuleLabel GGS_syntaxRuleLabel::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameters & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_syntaxInstructions & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxRuleLabel result ;
  macroMyNew (result.mPointer, cPtr_syntaxRuleLabel (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleLabel::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameters  GGS_syntaxRuleLabel::
reader_mFormalParameters (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mFormalParameters ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleLabel::
reader_mReturnedEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mReturnedEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleLabel::
reader_mReturnedVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mReturnedVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructions  GGS_syntaxRuleLabel::
reader_mSyntaxInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRuleLabel *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRuleLabel *) mPointer)->mSyntaxInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxRuleLabel::actualTypeName (void) const {
 return "syntaxRuleLabel" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxRuleLabel * GGS_syntaxRuleLabel::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxRuleLabel *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@syntaxRule'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxRule::
cPtr_syntaxRule (const GGS_lstring & argument_0,
                                const GGS__list_syntaxRuleLabel & argument_1
                                COMMA_LOCATION_ARGS) :
EX_C_GGS_MetamodelEntity (THERE),
mNonterminalName (argument_0),
mLabelList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_syntaxRule::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_syntaxRule * _p = dynamic_cast <const cPtr_syntaxRule *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalName._operator_isEqual (_p->mNonterminalName).boolValue ()
         && mLabelList._operator_isEqual (_p->mLabelList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_syntaxRule::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @syntaxRule" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxRule::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxRule::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_syntaxRule::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxRule::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "syntaxRule" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_syntaxRule * cPtr_syntaxRule::
_cloneObject (void) const {
  cPtr_syntaxRule * _p = NULL ;
  macroMyNew (_p, cPtr_syntaxRule (mNonterminalName, mLabelList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@_list_syntaxRule'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_syntaxRule::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS__list_syntaxRuleLabel & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRule::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS__list_syntaxRuleLabel & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRule::
_addAssign_operation (const GGS_syntaxRule & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_syntaxRule *) inElement.getPtr ())->mNonterminalName,
                                ((cPtr_syntaxRule *) inElement.getPtr ())->mLabelList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRule GGS__list_syntaxRule::
_operator_concat (const GGS__list_syntaxRule & inOperand) const {
  GGS__list_syntaxRule result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_syntaxRule * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mNonterminalName ;
          GGS__list_syntaxRuleLabel  p_1 = p->mLabelList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRule::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS__list_syntaxRuleLabel & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRule::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalName,
                                _p->mLabelList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRule  GGS__list_syntaxRule::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxRule result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRule  GGS__list_syntaxRule::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS__list_syntaxRuleLabel & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_syntaxRule result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_syntaxRule::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_syntaxRule", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_syntaxRule::
_addModel (const GGS_syntaxRule & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRule::
method_first (C_Compiler & _inLexique,
              GGS_syntaxRule & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRule::
method_last (C_Compiler & _inLexique,
             GGS_syntaxRule & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRule::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_syntaxRule & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_syntaxRule::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_syntaxRule & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_syntaxRule::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS entity '@syntaxRule'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_syntaxRule GGS_syntaxRule::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS__list_syntaxRuleLabel & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_syntaxRule result ;
  macroMyNew (result.mPointer, cPtr_syntaxRule (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRule::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRule *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxRuleLabel  GGS_syntaxRule::
reader_mLabelList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_syntaxRuleLabel   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_syntaxRule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_syntaxRule *) mPointer)->mLabelList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxRule::actualTypeName (void) const {
 return "syntaxRule" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxRule * GGS_syntaxRule::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_syntaxRule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@nonterminalCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_nonterminalCallInstruction::
cPtr_nonterminalCallInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mNonterminalName (argument_0),
mLabelName (argument_1),
mActualParameterList (argument_2),
mReturnedValueTargetVariableName (argument_3),
mReturnedValueIsAssigned (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_nonterminalCallInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_nonterminalCallInstruction * _p = dynamic_cast <const cPtr_nonterminalCallInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNonterminalName._operator_isEqual (_p->mNonterminalName).boolValue ()
         && mLabelName._operator_isEqual (_p->mLabelName).boolValue ()
         && mActualParameterList._operator_isEqual (_p->mActualParameterList).boolValue ()
         && mReturnedValueTargetVariableName._operator_isEqual (_p->mReturnedValueTargetVariableName).boolValue ()
         && mReturnedValueIsAssigned._operator_isEqual (_p->mReturnedValueIsAssigned).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_nonterminalCallInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @nonterminalCallInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mNonterminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLabelName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedValueTargetVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedValueIsAssigned.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_nonterminalCallInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonterminalCallInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_nonterminalCallInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_nonterminalCallInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "nonterminalCallInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_nonterminalCallInstruction * cPtr_nonterminalCallInstruction::
_cloneObject (void) const {
  cPtr_nonterminalCallInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_nonterminalCallInstruction (mNonterminalName, mLabelName, mActualParameterList, mReturnedValueTargetVariableName, mReturnedValueIsAssigned COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@_list_nonterminalCallInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_nonterminalCallInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_bool& argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalCallInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_bool& argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalCallInstruction::
_addAssign_operation (const GGS_nonterminalCallInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mNonterminalName,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mLabelName,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mActualParameterList,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mReturnedValueTargetVariableName,
                                ((cPtr_nonterminalCallInstruction *) inElement.getPtr ())->mReturnedValueIsAssigned) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalCallInstruction GGS__list_nonterminalCallInstruction::
_operator_concat (const GGS__list_nonterminalCallInstruction & inOperand) const {
  GGS__list_nonterminalCallInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_nonterminalCallInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mNonterminalName ;
          GGS_lstring  p_1 = p->mLabelName ;
          GGS_actualParameters  p_2 = p->mActualParameterList ;
          GGS_lstring  p_3 = p->mReturnedValueTargetVariableName ;
          GGS_bool p_4 = p->mReturnedValueIsAssigned ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalCallInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_actualParameters & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_bool& argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalCallInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mNonterminalName,
                                _p->mLabelName,
                                _p->mActualParameterList,
                                _p->mReturnedValueTargetVariableName,
                                _p->mReturnedValueIsAssigned) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalCallInstruction  GGS__list_nonterminalCallInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_nonterminalCallInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_nonterminalCallInstruction  GGS__list_nonterminalCallInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_actualParameters & argument_2,
                           const GGS_lstring & argument_3,
                           const GGS_bool& argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_nonterminalCallInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_nonterminalCallInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_nonterminalCallInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_nonterminalCallInstruction::
_addModel (const GGS_nonterminalCallInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalCallInstruction::
method_first (C_Compiler & _inLexique,
              GGS_nonterminalCallInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalCallInstruction::
method_last (C_Compiler & _inLexique,
             GGS_nonterminalCallInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalCallInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_nonterminalCallInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_nonterminalCallInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_nonterminalCallInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_nonterminalCallInstruction::constructor_new (_inLexique,
       _p->mNonterminalName,
       _p->mLabelName,
       _p->mActualParameterList,
       _p->mReturnedValueTargetVariableName,
       _p->mReturnedValueIsAssigned) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS entity '@nonterminalCallInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_nonterminalCallInstruction GGS_nonterminalCallInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_bool& argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_nonterminalCallInstruction result ;
  macroMyNew (result.mPointer, cPtr_nonterminalCallInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalCallInstruction::
reader_mNonterminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mNonterminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalCallInstruction::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_nonterminalCallInstruction::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_nonterminalCallInstruction::
reader_mReturnedValueTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mReturnedValueTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_nonterminalCallInstruction::
reader_mReturnedValueIsAssigned (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_nonterminalCallInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_nonterminalCallInstruction *) mPointer)->mReturnedValueIsAssigned ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_nonterminalCallInstruction::actualTypeName (void) const {
 return "nonterminalCallInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_nonterminalCallInstruction * GGS_nonterminalCallInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_nonterminalCallInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@terminalCheckInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_terminalCheckInstruction::
cPtr_terminalCheckInstruction (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mTerminalName (argument_0),
mReturnedValueTargetVariableNames (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_terminalCheckInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_terminalCheckInstruction * _p = dynamic_cast <const cPtr_terminalCheckInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTerminalName._operator_isEqual (_p->mTerminalName).boolValue ()
         && mReturnedValueTargetVariableNames._operator_isEqual (_p->mReturnedValueTargetVariableNames).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_terminalCheckInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @terminalCheckInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTerminalName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedValueTargetVariableNames.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_terminalCheckInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalCheckInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_terminalCheckInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_terminalCheckInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "terminalCheckInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_terminalCheckInstruction * cPtr_terminalCheckInstruction::
_cloneObject (void) const {
  cPtr_terminalCheckInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_terminalCheckInstruction (mTerminalName, mReturnedValueTargetVariableNames COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_terminalCheckInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_terminalCheckInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalCheckInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalCheckInstruction::
_addAssign_operation (const GGS_terminalCheckInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_terminalCheckInstruction *) inElement.getPtr ())->mTerminalName,
                                ((cPtr_terminalCheckInstruction *) inElement.getPtr ())->mReturnedValueTargetVariableNames) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_terminalCheckInstruction GGS__list_terminalCheckInstruction::
_operator_concat (const GGS__list_terminalCheckInstruction & inOperand) const {
  GGS__list_terminalCheckInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_terminalCheckInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTerminalName ;
          GGS_lstringlist  p_1 = p->mReturnedValueTargetVariableNames ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalCheckInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_terminalCheckInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTerminalName,
                                _p->mReturnedValueTargetVariableNames) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_terminalCheckInstruction  GGS__list_terminalCheckInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_terminalCheckInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_terminalCheckInstruction  GGS__list_terminalCheckInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_terminalCheckInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_terminalCheckInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_terminalCheckInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_terminalCheckInstruction::
_addModel (const GGS_terminalCheckInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_terminalCheckInstruction::
method_first (C_Compiler & _inLexique,
              GGS_terminalCheckInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_terminalCheckInstruction::
method_last (C_Compiler & _inLexique,
             GGS_terminalCheckInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_terminalCheckInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_terminalCheckInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_terminalCheckInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_terminalCheckInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_terminalCheckInstruction::constructor_new (_inLexique,
       _p->mTerminalName,
       _p->mReturnedValueTargetVariableNames) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@terminalCheckInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_terminalCheckInstruction GGS_terminalCheckInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_terminalCheckInstruction result ;
  macroMyNew (result.mPointer, cPtr_terminalCheckInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_terminalCheckInstruction::
reader_mTerminalName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstruction *) mPointer)->mTerminalName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_terminalCheckInstruction::
reader_mReturnedValueTargetVariableNames (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_terminalCheckInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_terminalCheckInstruction *) mPointer)->mReturnedValueTargetVariableNames ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_terminalCheckInstruction::actualTypeName (void) const {
 return "terminalCheckInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_terminalCheckInstruction * GGS_terminalCheckInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_terminalCheckInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@repeatInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_repeatInstruction::
cPtr_repeatInstruction (const GGS_syntaxInstructions & argument_0,
                                const GGS__list_syntaxInstructions & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mRepeatedInstructionList (argument_0),
mRepeatBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_repeatInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_repeatInstruction * _p = dynamic_cast <const cPtr_repeatInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRepeatedInstructionList._operator_isEqual (_p->mRepeatedInstructionList).boolValue ()
         && mRepeatBranchList._operator_isEqual (_p->mRepeatBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_repeatInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @repeatInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRepeatedInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRepeatBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_repeatInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_repeatInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_repeatInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_repeatInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "repeatInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_repeatInstruction * cPtr_repeatInstruction::
_cloneObject (void) const {
  cPtr_repeatInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_repeatInstruction (mRepeatedInstructionList, mRepeatBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_repeatInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_repeatInstruction::
_internalAppendValues (const GGS_syntaxInstructions & argument_0,
                    const GGS__list_syntaxInstructions & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_repeatInstruction::
_internalPrependValues (const GGS_syntaxInstructions & argument_0,
                    const GGS__list_syntaxInstructions & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_repeatInstruction::
_addAssign_operation (const GGS_repeatInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_repeatInstruction *) inElement.getPtr ())->mRepeatedInstructionList,
                                ((cPtr_repeatInstruction *) inElement.getPtr ())->mRepeatBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_repeatInstruction GGS__list_repeatInstruction::
_operator_concat (const GGS__list_repeatInstruction & inOperand) const {
  GGS__list_repeatInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_repeatInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_syntaxInstructions  p_0 = p->mRepeatedInstructionList ;
          GGS__list_syntaxInstructions  p_1 = p->mRepeatBranchList ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_repeatInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_syntaxInstructions & argument_0,
                     const GGS__list_syntaxInstructions & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_repeatInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mRepeatedInstructionList,
                                _p->mRepeatBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_repeatInstruction  GGS__list_repeatInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_repeatInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_repeatInstruction  GGS__list_repeatInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_syntaxInstructions & argument_0,
                           const GGS__list_syntaxInstructions & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_repeatInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_repeatInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_repeatInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_repeatInstruction::
_addModel (const GGS_repeatInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_repeatInstruction::
method_first (C_Compiler & _inLexique,
              GGS_repeatInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_repeatInstruction::
method_last (C_Compiler & _inLexique,
             GGS_repeatInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_repeatInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_repeatInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_repeatInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_repeatInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_repeatInstruction::constructor_new (_inLexique,
       _p->mRepeatedInstructionList,
       _p->mRepeatBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@repeatInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_repeatInstruction GGS_repeatInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_syntaxInstructions & argument_0,
                 const GGS__list_syntaxInstructions & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_repeatInstruction result ;
  macroMyNew (result.mPointer, cPtr_repeatInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructions  GGS_repeatInstruction::
reader_mRepeatedInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstruction *) mPointer)->mRepeatedInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstructions  GGS_repeatInstruction::
reader_mRepeatBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_repeatInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_repeatInstruction *) mPointer)->mRepeatBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_repeatInstruction::actualTypeName (void) const {
 return "repeatInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_repeatInstruction * GGS_repeatInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_repeatInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@selectInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selectInstruction::
cPtr_selectInstruction (const GGS__list_syntaxInstructions & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mSelectBranchList (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_selectInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_selectInstruction * _p = dynamic_cast <const cPtr_selectInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mSelectBranchList._operator_isEqual (_p->mSelectBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selectInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @selectInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSelectBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_selectInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selectInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_selectInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selectInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "selectInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_selectInstruction * cPtr_selectInstruction::
_cloneObject (void) const {
  cPtr_selectInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_selectInstruction (mSelectBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_selectInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_selectInstruction::
_internalAppendValues (const GGS__list_syntaxInstructions & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_selectInstruction::
_internalPrependValues (const GGS__list_syntaxInstructions & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_selectInstruction::
_addAssign_operation (const GGS_selectInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_selectInstruction *) inElement.getPtr ())->mSelectBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_selectInstruction GGS__list_selectInstruction::
_operator_concat (const GGS__list_selectInstruction & inOperand) const {
  GGS__list_selectInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_selectInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS__list_syntaxInstructions  p_0 = p->mSelectBranchList ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_selectInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS__list_syntaxInstructions & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_selectInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mSelectBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_selectInstruction  GGS__list_selectInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_selectInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_selectInstruction  GGS__list_selectInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS__list_syntaxInstructions & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_selectInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_selectInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_selectInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_selectInstruction::
_addModel (const GGS_selectInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_selectInstruction::
method_first (C_Compiler & _inLexique,
              GGS_selectInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selectInstruction::
method_last (C_Compiler & _inLexique,
             GGS_selectInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selectInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_selectInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selectInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_selectInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selectInstruction::constructor_new (_inLexique,
       _p->mSelectBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@selectInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_selectInstruction GGS_selectInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_syntaxInstructions & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_selectInstruction result ;
  macroMyNew (result.mPointer, cPtr_selectInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstructions  GGS_selectInstruction::
reader_mSelectBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selectInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selectInstruction *) mPointer)->mSelectBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selectInstruction::actualTypeName (void) const {
 return "selectInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selectInstruction * GGS_selectInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_selectInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@parseDoInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_parseDoInstruction::
cPtr_parseDoInstruction (const GGS__list_syntaxInstructions & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mParseDoBranchList (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_parseDoInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_parseDoInstruction * _p = dynamic_cast <const cPtr_parseDoInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mParseDoBranchList._operator_isEqual (_p->mParseDoBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_parseDoInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @parseDoInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mParseDoBranchList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_parseDoInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_parseDoInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_parseDoInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_parseDoInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "parseDoInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_parseDoInstruction * cPtr_parseDoInstruction::
_cloneObject (void) const {
  cPtr_parseDoInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_parseDoInstruction (mParseDoBranchList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_parseDoInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_parseDoInstruction::
_internalAppendValues (const GGS__list_syntaxInstructions & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_parseDoInstruction::
_internalPrependValues (const GGS__list_syntaxInstructions & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_parseDoInstruction::
_addAssign_operation (const GGS_parseDoInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_parseDoInstruction *) inElement.getPtr ())->mParseDoBranchList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_parseDoInstruction GGS__list_parseDoInstruction::
_operator_concat (const GGS__list_parseDoInstruction & inOperand) const {
  GGS__list_parseDoInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_parseDoInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS__list_syntaxInstructions  p_0 = p->mParseDoBranchList ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_parseDoInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS__list_syntaxInstructions & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_parseDoInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mParseDoBranchList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_parseDoInstruction  GGS__list_parseDoInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_parseDoInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_parseDoInstruction  GGS__list_parseDoInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS__list_syntaxInstructions & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_parseDoInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_parseDoInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_parseDoInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_parseDoInstruction::
_addModel (const GGS_parseDoInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_parseDoInstruction::
method_first (C_Compiler & _inLexique,
              GGS_parseDoInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_parseDoInstruction::constructor_new (_inLexique,
       _p->mParseDoBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_parseDoInstruction::
method_last (C_Compiler & _inLexique,
             GGS_parseDoInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_parseDoInstruction::constructor_new (_inLexique,
       _p->mParseDoBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_parseDoInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_parseDoInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_parseDoInstruction::constructor_new (_inLexique,
       _p->mParseDoBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_parseDoInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_parseDoInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_parseDoInstruction::constructor_new (_inLexique,
       _p->mParseDoBranchList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@parseDoInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_parseDoInstruction GGS_parseDoInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_syntaxInstructions & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_parseDoInstruction result ;
  macroMyNew (result.mPointer, cPtr_parseDoInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_syntaxInstructions  GGS_parseDoInstruction::
reader_mParseDoBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_parseDoInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_parseDoInstruction *) mPointer)->mParseDoBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_parseDoInstruction::actualTypeName (void) const {
 return "parseDoInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_parseDoInstruction * GGS_parseDoInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_parseDoInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@blockInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_blockInstruction::
cPtr_blockInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameters & argument_2,
                                const GGS_syntaxInstructions & argument_3,
                                const GGS_actualParameters & argument_4
                                COMMA_LOCATION_ARGS) :
cPtr_syntaxInstruction (THERE),
mReceiverVariable (argument_0),
mBlockMethodName (argument_1),
mPrologActualParameterList (argument_2),
mInstructionList (argument_3),
mEpilogActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_blockInstruction::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_blockInstruction * _p = dynamic_cast <const cPtr_blockInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverVariable._operator_isEqual (_p->mReceiverVariable).boolValue ()
         && mBlockMethodName._operator_isEqual (_p->mBlockMethodName).boolValue ()
         && mPrologActualParameterList._operator_isEqual (_p->mPrologActualParameterList).boolValue ()
         && mInstructionList._operator_isEqual (_p->mInstructionList).boolValue ()
         && mEpilogActualParameterList._operator_isEqual (_p->mEpilogActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_blockInstruction::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @blockInstruction" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverVariable.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mBlockMethodName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPrologActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEpilogActualParameterList.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_blockInstruction::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_blockInstruction::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_blockInstruction::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_blockInstruction::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "blockInstruction" ;
  if (inLevel > 0) {
    result = cPtr_syntaxInstruction::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_blockInstruction * cPtr_blockInstruction::
_cloneObject (void) const {
  cPtr_blockInstruction * _p = NULL ;
  macroMyNew (_p, cPtr_blockInstruction (mReceiverVariable, mBlockMethodName, mPrologActualParameterList, mInstructionList, mEpilogActualParameterList COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_blockInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS__list_blockInstruction::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2,
                    const GGS_syntaxInstructions & argument_3,
                    const GGS_actualParameters & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_blockInstruction::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_actualParameters & argument_2,
                    const GGS_syntaxInstructions & argument_3,
                    const GGS_actualParameters & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS__list_blockInstruction::
_addAssign_operation (const GGS_blockInstruction & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_blockInstruction *) inElement.getPtr ())->mReceiverVariable,
                                ((cPtr_blockInstruction *) inElement.getPtr ())->mBlockMethodName,
                                ((cPtr_blockInstruction *) inElement.getPtr ())->mPrologActualParameterList,
                                ((cPtr_blockInstruction *) inElement.getPtr ())->mInstructionList,
                                ((cPtr_blockInstruction *) inElement.getPtr ())->mEpilogActualParameterList) ;
  }
}

//---------------------------------------------------------------------------*

GGS__list_blockInstruction GGS__list_blockInstruction::
_operator_concat (const GGS__list_blockInstruction & inOperand) const {
  GGS__list_blockInstruction result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_blockInstruction * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mReceiverVariable ;
          GGS_lstring  p_1 = p->mBlockMethodName ;
          GGS_actualParameters  p_2 = p->mPrologActualParameterList ;
          GGS_syntaxInstructions  p_3 = p->mInstructionList ;
          GGS_actualParameters  p_4 = p->mEpilogActualParameterList ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_blockInstruction::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_actualParameters & argument_2,
                     const GGS_syntaxInstructions & argument_3,
                     const GGS_actualParameters & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS__list_blockInstruction::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverVariable,
                                _p->mBlockMethodName,
                                _p->mPrologActualParameterList,
                                _p->mInstructionList,
                                _p->mEpilogActualParameterList) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS__list_blockInstruction  GGS__list_blockInstruction::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_blockInstruction result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_blockInstruction  GGS__list_blockInstruction::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_actualParameters & argument_2,
                           const GGS_syntaxInstructions & argument_3,
                           const GGS_actualParameters & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_blockInstruction result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_blockInstruction::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_blockInstruction", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS__list_blockInstruction::
_addModel (const GGS_blockInstruction & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_blockInstruction::
method_first (C_Compiler & _inLexique,
              GGS_blockInstruction & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_blockInstruction::constructor_new (_inLexique,
       _p->mReceiverVariable,
       _p->mBlockMethodName,
       _p->mPrologActualParameterList,
       _p->mInstructionList,
       _p->mEpilogActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_blockInstruction::
method_last (C_Compiler & _inLexique,
             GGS_blockInstruction & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_blockInstruction::constructor_new (_inLexique,
       _p->mReceiverVariable,
       _p->mBlockMethodName,
       _p->mPrologActualParameterList,
       _p->mInstructionList,
       _p->mEpilogActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_blockInstruction::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_blockInstruction & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_blockInstruction::constructor_new (_inLexique,
       _p->mReceiverVariable,
       _p->mBlockMethodName,
       _p->mPrologActualParameterList,
       _p->mInstructionList,
       _p->mEpilogActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_blockInstruction::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_blockInstruction & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_blockInstruction::constructor_new (_inLexique,
       _p->mReceiverVariable,
       _p->mBlockMethodName,
       _p->mPrologActualParameterList,
       _p->mInstructionList,
       _p->mEpilogActualParameterList) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@blockInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_blockInstruction GGS_blockInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameters & argument_2,
                 const GGS_syntaxInstructions & argument_3,
                 const GGS_actualParameters & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_blockInstruction result ;
  macroMyNew (result.mPointer, cPtr_blockInstruction (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_blockInstruction::
reader_mReceiverVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_blockInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_blockInstruction *) mPointer)->mReceiverVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_blockInstruction::
reader_mBlockMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_blockInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_blockInstruction *) mPointer)->mBlockMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_blockInstruction::
reader_mPrologActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_blockInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_blockInstruction *) mPointer)->mPrologActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructions  GGS_blockInstruction::
reader_mInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_syntaxInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_blockInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_blockInstruction *) mPointer)->mInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameters  GGS_blockInstruction::
reader_mEpilogActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameters   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_blockInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_blockInstruction *) mPointer)->mEpilogActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_blockInstruction::actualTypeName (void) const {
 return "blockInstruction" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_blockInstruction * GGS_blockInstruction::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_blockInstruction *) mPointer ;
  }
#endif

