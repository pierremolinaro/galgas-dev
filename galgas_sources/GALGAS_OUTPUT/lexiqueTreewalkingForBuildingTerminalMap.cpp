//---------------------------------------------------------------------------*
//                                                                           *
//           File 'lexiqueTreewalkingForBuildingTerminalMap.cpp'             *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 27th, 2007, at 16h5'11"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//#define TRACE_TREE_WALKING

//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "lexiqueTreewalkingForBuildingTerminalMap.h"
#include "lexiqueSemantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueTreewalkingForBuildingTerminalMap.gTreewalking", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Treewalking routine prototype declaration                  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexiqueComponentRoot (C_Compiler & _inLexique,
                                const cPtr_lexiqueComponentRoot * _currentObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) ;

static void
_treewalking_routine_lexicalAttribute (C_Compiler & _inLexique,
                                const cPtr_lexicalAttribute * _currentObject,
                                const GGS_stringset   var_cas_inAllowedLexicalTypeNameSet,
                                GGS_lexicalAttributeMap  & var_cas_ioLexicalAttributeMap) ;

static void
_treewalking_routine_terminalDeclaration (C_Compiler & _inLexique,
                                const cPtr_terminalDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

static void
_treewalking_routine_lexicalListDeclaration (C_Compiler & _inLexique,
                                const cPtr_lexicalListDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

static void
_treewalking_routine_lexicalListEntry (C_Compiler & _inLexique,
                                const cPtr_lexicalListEntry * _currentObject,
                                const GGS_stringlist   var_cas_inArgumentTypeList,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Treewalking routine type declaration                    *
//                                                                           *
//---------------------------------------------------------------------------*

typedef void
_treewalking_routine_lexiqueComponentRoot_type (C_Compiler & _inLexique,
                                const cPtr_lexiqueComponentRoot * _currentObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) ;

typedef void
_treewalking_routine_lexicalAttribute_type (C_Compiler & _inLexique,
                                const cPtr_lexicalAttribute * _currentObject,
                                const GGS_stringset   var_cas_inAllowedLexicalTypeNameSet,
                                GGS_lexicalAttributeMap  & var_cas_ioLexicalAttributeMap) ;

typedef void
_treewalking_routine_terminalDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_terminalDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

typedef void
_treewalking_routine_lexicalListDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_lexicalListDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

typedef void
_treewalking_routine_lexicalListEntry_type (C_Compiler & _inLexique,
                                const cPtr_lexicalListEntry * _currentObject,
                                const GGS_stringlist   var_cas_inArgumentTypeList,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Dispatcher tables                              *
//                                                                           *
//---------------------------------------------------------------------------*


static const uint32 _kSize_lexiqueMetamodel = 5 ;

static const CTreewalkingVirtualMethod _kDispatcherFor_lexiqueMetamodel [_kSize_lexiqueMetamodel] = {
  {0, (void *) _treewalking_routine_lexiqueComponentRoot}, // @lexiqueComponentRoot, defined in 'lexiqueMetamodel' metamodel
  {3, (void *) _treewalking_routine_lexicalAttribute}, // @lexicalAttribute, defined in 'lexiqueMetamodel' metamodel
  {5, (void *) _treewalking_routine_terminalDeclaration}, // @terminalDeclaration, defined in 'lexiqueMetamodel' metamodel
  {6, (void *) _treewalking_routine_lexicalListDeclaration}, // @lexicalListDeclaration, defined in 'lexiqueMetamodel' metamodel
  {7, (void *) _treewalking_routine_lexicalListEntry}, // @lexicalListEntry, defined in 'lexiqueMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static C_TreewalkingDispacher _gDispatcherTree ;

//---------------------------------------------------------------------------*
//                                                                           *
//        'lexiqueComponentRoot' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexiqueComponentRoot (C_Compiler & _inLexique,
                                const cPtr_lexiqueComponentRoot * _currentObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexiqueComponentRoot\n") ; fflush (stdout) ;
  #endif
  GGS_stringset  var_cas_allowedLexicalTypeNameSet ;
  var_cas_allowedLexicalTypeNameSet = GGS_stringset::constructor_emptySet (_inLexique COMMA_HERE) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lstring")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lchar")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "luint")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "luint64")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lsint")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lsint64")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "ldouble")) ;
  GGS_lexicalAttributeMap  var_cas_lexicalAttributeMap ;
  var_cas_lexicalAttributeMap = GGS_lexicalAttributeMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mLexicalAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_lexicalAttribute_type * _f = (_treewalking_routine_lexicalAttribute_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_lexicalAttribute *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_lexicalAttribute *) _ptr->ptr (), var_cas_allowedLexicalTypeNameSet, var_cas_lexicalAttributeMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
  var_cas_outTerminalMap = GGS_terminalMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mTerminalDeclarationList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_terminalDeclaration_type * _f = (_treewalking_routine_terminalDeclaration_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_terminalDeclaration *) _ptr->ptr (), var_cas_lexicalAttributeMap, var_cas_outTerminalMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mLexicalListDeclarationList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_lexicalListDeclaration_type * _f = (_treewalking_routine_lexicalListDeclaration_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_lexicalListDeclaration *) _ptr->ptr (), var_cas_lexicalAttributeMap, var_cas_outTerminalMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'lexicalAttribute' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexicalAttribute (C_Compiler & _inLexique,
                                const cPtr_lexicalAttribute * _currentObject,
                                const GGS_stringset   var_cas_inAllowedLexicalTypeNameSet,
                                GGS_lexicalAttributeMap  & var_cas_ioLexicalAttributeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexicalAttribute\n") ; fflush (stdout) ;
  #endif
  if ((var_cas_inAllowedLexicalTypeNameSet.reader_hasKey (_inLexique, _currentObject->mTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (53)) COMMA_SOURCE_FILE_AT_LINE (53))).isBuiltAndTrue ()) {
    var_cas_ioLexicalAttributeMap.modifier_insertKey (_inLexique, _currentObject->mName, _currentObject->mTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)) COMMA_SOURCE_FILE_AT_LINE (54)) ;
  }else{
    GGS_string var_cas_m ;
    var_cas_m = GGS_string (true, "") ;
    var_cas_m.writeString ("the @") ;
    var_cas_m._dotAssign_operation (_currentObject->mTypeName) ;
    var_cas_m.writeString (" type is not a valid lexical attribute type; are allowed:") ;
    GGS_bool var_cas_first ;
    var_cas_first = GGS_bool (true, true) ;
    const GGS_stringset _var_2996 = var_cas_inAllowedLexicalTypeNameSet ;
    const GGS_stringset::element_type * operand_2996 = _var_2996.firstObject () ;
    while ((operand_2996 != NULL)) {
      macroValidPointer (operand_2996) ;
      if ((var_cas_first).isBuiltAndTrue ()) {
        var_cas_first = GGS_bool (true, false) ;
      }else{
        var_cas_m.writeString (",") ;
      }
      var_cas_m.writeString (" @") ;
      var_cas_m._dotAssign_operation (operand_2996->mKey) ;
      operand_2996 = operand_2996->nextObject () ;
    }
    _currentObject->mTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (68)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         'terminalDeclaration' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_terminalDeclaration (C_Compiler & _inLexique,
                                const cPtr_terminalDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @terminalDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_stringlist  var_cas_argumentTypeList ;
  var_cas_argumentTypeList = GGS_stringlist::constructor_emptyList (_inLexique COMMA_HERE) ;
  const GGS_lstringlist _var_3472 = _currentObject->mSentAttributeList ;
  const GGS_lstringlist::element_type * operand_3472 = _var_3472.firstObject () ;
  while ((operand_3472 != NULL)) {
    macroValidPointer (operand_3472) ;
    GGS_string var_cas_attributeTypeName ;
    if (var_cas_inLexicalAttributeMap._isBuilt ()) {
      var_cas_inLexicalAttributeMap (HERE)->method_searchKey (_inLexique, operand_3472->mValue, var_cas_attributeTypeName COMMA_SOURCE_FILE_AT_LINE (80)) ;
    }
    var_cas_argumentTypeList._addAssign_operation (var_cas_attributeTypeName) ;
    operand_3472 = operand_3472->nextObject () ;
  }
  var_cas_ioTerminalMap.modifier_insertKey (_inLexique, _currentObject->mName, var_cas_argumentTypeList COMMA_SOURCE_FILE_AT_LINE (83)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       'lexicalListDeclaration' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexicalListDeclaration (C_Compiler & _inLexique,
                                const cPtr_lexicalListDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexicalListDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_stringlist  var_cas_argumentTypeList ;
  var_cas_argumentTypeList = GGS_stringlist::constructor_emptyList (_inLexique COMMA_HERE) ;
  const GGS_lstringlist _var_3999 = _currentObject->mSentAttributeList ;
  const GGS_lstringlist::element_type * operand_3999 = _var_3999.firstObject () ;
  while ((operand_3999 != NULL)) {
    macroValidPointer (operand_3999) ;
    GGS_string var_cas_attributeTypeName ;
    if (var_cas_inLexicalAttributeMap._isBuilt ()) {
      var_cas_inLexicalAttributeMap (HERE)->method_searchKey (_inLexique, operand_3999->mValue, var_cas_attributeTypeName COMMA_SOURCE_FILE_AT_LINE (95)) ;
    }
    var_cas_argumentTypeList._addAssign_operation (var_cas_attributeTypeName) ;
    operand_3999 = operand_3999->nextObject () ;
  }
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mEntryList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_lexicalListEntry_type * _f = (_treewalking_routine_lexicalListEntry_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_lexicalListEntry *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_lexicalListEntry *) _ptr->ptr (), var_cas_argumentTypeList, var_cas_ioTerminalMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'lexicalListEntry' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexicalListEntry (C_Compiler & _inLexique,
                                const cPtr_lexicalListEntry * _currentObject,
                                const GGS_stringlist   var_cas_inArgumentTypeList,
                                GGS_terminalMap  & var_cas_ioTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexicalListEntry\n") ; fflush (stdout) ;
  #endif
  var_cas_ioTerminalMap.modifier_insertKey (_inLexique, _currentObject->mTerminalSpelling, var_cas_inArgumentTypeList COMMA_SOURCE_FILE_AT_LINE (107)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Build Dispatcher Tree                            *
//                                                                           *
//---------------------------------------------------------------------------*

static void _build_dispacher_tree (void) {
  _gDispatcherTree.enterTable (_metamodel_index_for_lexiqueMetamodel (),
                                _kSize_lexiqueMetamodel,
                                _kDispatcherFor_lexiqueMetamodel
                                COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                               Root routine                                *
//                                                                           *
//---------------------------------------------------------------------------*

void
_walk_throught_lexiqueTreewalkingForBuildingTerminalMap (C_Compiler & _inLexique,
                                const GGS_lexiqueComponentRoot & _rootObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) {
  if (_rootObject._isBuilt ()) {
    if (! _gDispatcherTree.isInited ()) {
      _build_dispacher_tree () ;
    }
    _treewalking_routine_lexiqueComponentRoot_type * _f = (_treewalking_routine_lexiqueComponentRoot_type *) _gDispatcherTree.entry (_rootObject.getPtr () COMMA_HERE) ;
    (* _f) (_inLexique, _rootObject.getPtr (), var_cas_outTerminalMap) ;
  }else{
    var_cas_outTerminalMap._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

