//---------------------------------------------------------------------------*
//                                                                           *
//           File 'lexiqueTreewalkingForBuildingTerminalMap.cpp'             *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       june 7th, 2008, at 12h31'21"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//#define TRACE_TREE_WALKING

//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "lexiqueTreewalkingForBuildingTerminalMap.h"
#include "lexiqueSemantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueTreewalkingForBuildingTerminalMap.gTreewalking", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Treewalking routine prototype declaration                  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexiqueComponentRoot (C_Compiler & _inLexique,
                                const cPtr_lexiqueComponentRoot * _currentObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) ;

static void
_treewalking_routine_lexicalAttribute (C_Compiler & _inLexique,
                                const cPtr_lexicalAttribute * _currentObject,
                                const GGS_stringset   var_cas_inAllowedLexicalTypeNameSet,
                                GGS_lexicalAttributeMap  & var_cas_ioLexicalAttributeMap) ;

static void
_treewalking_routine_terminalDeclaration (C_Compiler & _inLexique,
                                const cPtr_terminalDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

static void
_treewalking_routine_lexicalListDeclaration (C_Compiler & _inLexique,
                                const cPtr_lexicalListDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

static void
_treewalking_routine_lexicalListEntry (C_Compiler & _inLexique,
                                const cPtr_lexicalListEntry * _currentObject,
                                const GGS_stringlist   var_cas_inArgumentTypeList,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Treewalking routine type declaration                    *
//                                                                           *
//---------------------------------------------------------------------------*

typedef void
_treewalking_routine_lexiqueComponentRoot_type (C_Compiler & _inLexique,
                                const cPtr_lexiqueComponentRoot * _currentObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) ;

typedef void
_treewalking_routine_lexicalAttribute_type (C_Compiler & _inLexique,
                                const cPtr_lexicalAttribute * _currentObject,
                                const GGS_stringset   var_cas_inAllowedLexicalTypeNameSet,
                                GGS_lexicalAttributeMap  & var_cas_ioLexicalAttributeMap) ;

typedef void
_treewalking_routine_terminalDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_terminalDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

typedef void
_treewalking_routine_lexicalListDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_lexicalListDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

typedef void
_treewalking_routine_lexicalListEntry_type (C_Compiler & _inLexique,
                                const cPtr_lexicalListEntry * _currentObject,
                                const GGS_stringlist   var_cas_inArgumentTypeList,
                                GGS_terminalMap  & var_cas_ioTerminalMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Dispatcher tables                              *
//                                                                           *
//---------------------------------------------------------------------------*


static const uint32 _kSize_lexiqueMetamodel = 5 ;

static const CTreewalkingVirtualMethod _kDispatcherFor_lexiqueMetamodel [_kSize_lexiqueMetamodel] = {
  {0, (void *) _treewalking_routine_lexiqueComponentRoot}, // @lexiqueComponentRoot, defined in 'lexiqueMetamodel' metamodel
  {5, (void *) _treewalking_routine_lexicalAttribute}, // @lexicalAttribute, defined in 'lexiqueMetamodel' metamodel
  {7, (void *) _treewalking_routine_terminalDeclaration}, // @terminalDeclaration, defined in 'lexiqueMetamodel' metamodel
  {8, (void *) _treewalking_routine_lexicalListDeclaration}, // @lexicalListDeclaration, defined in 'lexiqueMetamodel' metamodel
  {9, (void *) _treewalking_routine_lexicalListEntry}, // @lexicalListEntry, defined in 'lexiqueMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static C_TreewalkingDispacher _gDispatcherTree ;

//---------------------------------------------------------------------------*
//                                                                           *
//        'lexiqueComponentRoot' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexiqueComponentRoot (C_Compiler & _inLexique,
                                const cPtr_lexiqueComponentRoot * _currentObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexiqueComponentRoot\n") ; fflush (stdout) ;
  #endif
  GGS_stringset  var_cas_allowedLexicalTypeNameSet ;
  var_cas_allowedLexicalTypeNameSet = GGS_stringset ::constructor_emptySet (_inLexique COMMA_HERE) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lstring")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lchar")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "luint")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "luint64")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lsint")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lsint64")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "ldouble")) ;
  GGS_lexicalAttributeMap  var_cas_lexicalAttributeMap ;
  var_cas_lexicalAttributeMap = GGS_lexicalAttributeMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mLexicalAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_lexicalAttribute_type * _f = (_treewalking_routine_lexicalAttribute_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_lexicalAttribute *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_lexicalAttribute *) _ptr->ptr (), var_cas_allowedLexicalTypeNameSet, var_cas_lexicalAttributeMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
  var_cas_outTerminalMap = GGS_terminalMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mTerminalDeclarationList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_terminalDeclaration_type * _f = (_treewalking_routine_terminalDeclaration_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_terminalDeclaration *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_terminalDeclaration *) _ptr->ptr (), var_cas_lexicalAttributeMap, var_cas_outTerminalMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mLexicalListDeclarationList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_lexicalListDeclaration_type * _f = (_treewalking_routine_lexicalListDeclaration_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_lexicalListDeclaration *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_lexicalListDeclaration *) _ptr->ptr (), var_cas_lexicalAttributeMap, var_cas_outTerminalMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'lexicalAttribute' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexicalAttribute (C_Compiler & _inLexique,
                                const cPtr_lexicalAttribute * _currentObject,
                                const GGS_stringset   var_cas_inAllowedLexicalTypeNameSet,
                                GGS_lexicalAttributeMap  & var_cas_ioLexicalAttributeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexicalAttribute\n") ; fflush (stdout) ;
  #endif
  if ((var_cas_inAllowedLexicalTypeNameSet.reader_hasKey (_inLexique, _currentObject->mTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (53)) COMMA_SOURCE_FILE_AT_LINE (53))).isBuiltAndTrue ()) {
    var_cas_ioLexicalAttributeMap.modifier_insertKey (_inLexique, _currentObject->mName, _currentObject->mTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)) COMMA_SOURCE_FILE_AT_LINE (54)) ;
  }else{
    GGS_string var_cas_m ;
    var_cas_m = GGS_string (true, "") ;
    var_cas_m.writeString ("the @") ;
    var_cas_m._dotAssign_operation (_currentObject->mTypeName) ;
    var_cas_m.writeString (" type is not a valid lexical attribute type; are allowed:") ;
    GGS_bool var_cas_firstLoop ;
    var_cas_firstLoop = GGS_bool (true, true) ;
    {
      GGS_stringset::cEnumerator enumerator_2999 (var_cas_inAllowedLexicalTypeNameSet, true) ;
      const GGS_stringset::cElement * operand_2999 = NULL ;
      while (((operand_2999 = (GGS_stringset::cElement *) enumerator_2999.nextObject ()))) {
        macroValidPointer (operand_2999) ;
        if ((var_cas_firstLoop).isBuiltAndTrue ()) {
          var_cas_firstLoop = GGS_bool (true, false) ;
        }else{
          var_cas_m.writeString (",") ;
        }
        var_cas_m.writeString (" @") ;
        var_cas_m._dotAssign_operation (operand_2999->mKey) ;
      }
    }
    _currentObject->mTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (67)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         'terminalDeclaration' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_terminalDeclaration (C_Compiler & _inLexique,
                                const cPtr_terminalDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @terminalDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_stringlist  var_cas_argumentTypeList ;
  var_cas_argumentTypeList = GGS_stringlist ::constructor_emptyList (_inLexique COMMA_HERE) ;
  {
    GGS_lstringlist::cEnumerator enumerator_3484 (_currentObject->mSentAttributeList, true) ;
    const GGS_lstringlist::cElement * operand_3484 = NULL ;
    while (((operand_3484 = (GGS_lstringlist::cElement *) enumerator_3484.nextObject ()))) {
      macroValidPointer (operand_3484) ;
      GGS_string var_cas_attributeTypeName ;
      const GGS_lexicalAttributeMap  _temp_3591 = var_cas_inLexicalAttributeMap ;
      if (_temp_3591._isBuilt ()) {
        _temp_3591 (HERE)->method_searchKey (_inLexique, operand_3484->mValue, var_cas_attributeTypeName COMMA_SOURCE_FILE_AT_LINE (80)) ;
      }
      var_cas_argumentTypeList._addAssign_operation (var_cas_attributeTypeName) ;
    }
  }
  var_cas_ioTerminalMap.modifier_insertKey (_inLexique, _currentObject->mName, var_cas_argumentTypeList COMMA_SOURCE_FILE_AT_LINE (83)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       'lexicalListDeclaration' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexicalListDeclaration (C_Compiler & _inLexique,
                                const cPtr_lexicalListDeclaration * _currentObject,
                                const GGS_lexicalAttributeMap   var_cas_inLexicalAttributeMap,
                                GGS_terminalMap  & var_cas_ioTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexicalListDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_stringlist  var_cas_argumentTypeList ;
  var_cas_argumentTypeList = GGS_stringlist ::constructor_emptyList (_inLexique COMMA_HERE) ;
  {
    GGS_lstringlist::cEnumerator enumerator_4012 (_currentObject->mSentAttributeList, true) ;
    const GGS_lstringlist::cElement * operand_4012 = NULL ;
    while (((operand_4012 = (GGS_lstringlist::cElement *) enumerator_4012.nextObject ()))) {
      macroValidPointer (operand_4012) ;
      GGS_string var_cas_attributeTypeName ;
      const GGS_lexicalAttributeMap  _temp_4119 = var_cas_inLexicalAttributeMap ;
      if (_temp_4119._isBuilt ()) {
        _temp_4119 (HERE)->method_searchKey (_inLexique, operand_4012->mValue, var_cas_attributeTypeName COMMA_SOURCE_FILE_AT_LINE (95)) ;
      }
      var_cas_argumentTypeList._addAssign_operation (var_cas_attributeTypeName) ;
    }
  }
  macroValidPointer (_currentObject) ;
  { AC_galgas_entity_list::cEntityListElement * _ptr = _currentObject->mEntryList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_lexicalListEntry_type * _f = (_treewalking_routine_lexicalListEntry_type *) _gDispatcherTree.entry (_ptr->ptr () COMMA_HERE) ;
      MF_Assert (dynamic_cast <cPtr_lexicalListEntry *> (_ptr->ptr ()) != NULL, "Treewalking dispatch error", 0, 0) ;
      (* _f) (_inLexique, (cPtr_lexicalListEntry *) _ptr->ptr (), var_cas_argumentTypeList, var_cas_ioTerminalMap) ;
      _ptr = _ptr->internalNextItem () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'lexicalListEntry' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_lexicalListEntry (C_Compiler & _inLexique,
                                const cPtr_lexicalListEntry * _currentObject,
                                const GGS_stringlist   var_cas_inArgumentTypeList,
                                GGS_terminalMap  & var_cas_ioTerminalMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @lexicalListEntry\n") ; fflush (stdout) ;
  #endif
  var_cas_ioTerminalMap.modifier_insertKey (_inLexique, _currentObject->mTerminalSpelling, var_cas_inArgumentTypeList COMMA_SOURCE_FILE_AT_LINE (107)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Build Dispatcher Tree                            *
//                                                                           *
//---------------------------------------------------------------------------*

static void _build_dispacher_tree (void) {
  _gDispatcherTree.enterTable (_metamodel_index_for_lexiqueMetamodel (),
                                _kSize_lexiqueMetamodel,
                                _kDispatcherFor_lexiqueMetamodel
                                COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                               Root routine                                *
//                                                                           *
//---------------------------------------------------------------------------*

void
_walk_throught_lexiqueTreewalkingForBuildingTerminalMap (C_Compiler & _inLexique,
                                const GGS_lexiqueComponentRoot & _rootObject,
                                GGS_terminalMap  & var_cas_outTerminalMap) {
  if (_rootObject._isBuilt ()) {
    if (! _gDispatcherTree.isInited ()) {
      _build_dispacher_tree () ;
    }
    _treewalking_routine_lexiqueComponentRoot_type * _f = (_treewalking_routine_lexiqueComponentRoot_type *) _gDispatcherTree.entry (_rootObject.getPtr () COMMA_HERE) ;
    (* _f) (_inLexique, _rootObject.getPtr (), var_cas_outTerminalMap) ;
  }else{
    var_cas_outTerminalMap._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

