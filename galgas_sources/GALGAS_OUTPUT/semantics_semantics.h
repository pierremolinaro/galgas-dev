//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'semantics_semantics.h'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 6th, 2006, at 14h14'44"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef semantics_semantics_DEFINED
#define semantics_semantics_DEFINED

#include <string.h>

#include "galgas/C_GGS_Object.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldouble.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/GGS_luint64.h"
#include "galgas/GGS_lsint64.h"
#include "galgas/GGS_stringset.h"
#include "galgas/AC_galgas_map.h"
#include "galgas/C_Lexique.h"

// Include imported semantics
#include "common_semantics.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                          Class Predeclarations                            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCplusPlusName ;
class GGS_typeDirectName ;
class GGS_typeCppThisName ;
class GGS_typeCppInheritedName ;
class GGS_typeAutomaticName ;
class GGS_typeLocationAutomaticName ;
class GGS_typeOperandName ;
class GGS_typeKeyName ;
class GGS_typeNullName ;
class GGS_typeCplusPlusNameList ;
class GGS_typeExpression ;
class GGS_typeClassMessagesMap ;
class GGS_typeSemanticsTypesList ;
class GGS_typeVariablesMap ;
#include "cGalgasVariablesMap.h"
class GGS_L_assignedVariables ;
class GGS_typeCible ;
class GGS_typeListeCibles ;
class GGS_typeListeTypesEtNomsArgMethode ;
class GGS_typeInstruction ;
class GGS_typeInstructionList ;
class GGS_L_nameWithType ;
class GGS_typeTableMethodesAimplementer ;
#include "cTableMethodesAimplementer.h"
class GGS_typeExpressionList ;
class GGS_varToDropList ;
class GGS_typeErrorInstruction ;
class GGS_typeWarningInstruction ;
class GGS_typeMessageInstruction ;
class GGS_typeReaderCallInstruction ;
class GGS_typeModifierCallInstruction ;
class GGS_typeInstructionAppelMethodeListe ;
class GGS_typeInstructionDeclarationVarLocale ;
class GGS_typeMapBlockPrologueInstruction ;
class GGS_typeMapBlockEpilogueInstruction ;
class GGS_typeReaderCallInExpression ;
class GGS_typeAndOperation ;
class GGS_typeOrOperation ;
class GGS_typeXorOperation ;
class GGS_typeConcatOperation ;
class GGS_typeTrueBool ;
class GGS_typeFalseBool ;
class GGS_typeLiteralStringExpression ;
class GGS_typeLiteralUIntExpression ;
class GGS_typeLiteralSIntExpression ;
class GGS_typeLiteralUInt64Expression ;
class GGS_typeLiteralSInt64Expression ;
class GGS_typeLiteralCharExpression ;
class GGS_typeHereExpression ;
class GGS_typeConstructorExpression ;
class GGS_typeTestComplement ;
class GGS_typeBoolOption ;
class GGS_typeUIntOption ;
class GGS_typeStringOption ;
class GGS_typeVarInExpression ;
class GGS_typeJokerInExpression ;
class GGS_typeAddOperation ;
class GGS_typeSubOperation ;
class GGS_typeMultiplyOperation ;
class GGS_typeDivideOperation ;
class GGS_typeModuloOperation ;
class GGS_typeUnaryMinusOperation ;
class GGS_typeEqualTest ;
class GGS_typeNonEqualTest ;
class GGS_typeStrictInfTest ;
class GGS_typeInfOrEqualTest ;
class GGS_typeStrictSupTest ;
class GGS_typeSupOrEqualTest ;
class GGS_typeTextTableCall ;
class GGS_C_assignmentInstruction ;
class GGS_C_declarationInstructionWithAssignment ;
class GGS_C_while_instruction ;
class GGS_L_expression_instructionsList_list ;
class GGS_C_if_instruction ;
class GGS_typeTableRoutinesAimplementer ;
class GGS_typeTableAttributsSemantiques ;
class GGS_typeJoker ;
class GGS_typeEntiteDest ;
class GGS_M_nonTerminalSymbolForSyntax ;
class GGS_C_grammarInstruction ;
class GGS_typeAppendInstruction ;
class GGS_typeRemoveInstruction ;
class GGS_typeIncrementInstruction ;
class GGS_typeDecrementInstruction ;
class GGS_typeInstructionAppelActionExterne ;
class GGS_L_matchInstructionCasesList ;
class GGS_typeMatchInstruction ;
class GGS_foreachEnumerationList ;
class GGS_typeForeachInstruction ;
class GGS_typeSimpleExtractInstruction ;
class GGS_typeStructuredExtractCasesList ;
class GGS_typeStructuredExtractInstructionWithElse ;
class GGS_typeRoutineCallInstruction ;
class GGS_typeDropInstruction ;
class GGS_typeTableNomRoutinesDeclarees ;
class GGS_typeEntityToGenerate ;
class GGS_typeExternTypeToGenerate ;
class GGS_typeRoutineAengendrer ;
class GGS_C_listTypeToImplement ;
class GGS_typeDefinitionTableAimplementer ;
class GGS_C_mapToImplement ;
class GGS_typeDefClasseAbstraiteAimplementer ;
class GGS_typeDefClasseNonAbstraiteAimplementer ;
class GGS_typeEntiteActionExterne ;
class GGS_typeActionExterneAengendrer ;
class GGS_typeEntitiesToGenerateList ;
class GGS_typeEnumCstMessageStringMap ;
class GGS_enumGalgasType ;
class GGS_mapAsConstraintPropertyMap ;
class GGS_passMap ;
class GGS_sharedPropertyList ;
class GGS_callInstructionSharedPropertySignatureMap ;
class GGS_constrainedEntityPassMap ;
class GGS_constraintAllPropertiesMap ;
class GGS_indexMap ;
class GGS_constrainedEntityMap ;
class GGS_callInstruction ;

class cPtr_typeCplusPlusName ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCplusPlusName {
  protected : cPtr_typeCplusPlusName * mPointer ;
  public : GGS_typeCplusPlusName (void) ;
  public : GGS_typeCplusPlusName (const GGS_typeCplusPlusName &) ;
  public : virtual ~GGS_typeCplusPlusName (void) ;
  public : void operator = (const GGS_typeCplusPlusName &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeCplusPlusName & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeCplusPlusName * inSource) ;
  public : GGS_typeCplusPlusName (cPtr_typeCplusPlusName * inSource) ;
  public : inline cPtr_typeCplusPlusName * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeCplusPlusName * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeCplusPlusName * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@typeCplusPlusNameList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeCplusPlusNameList ;

class GGS_typeCplusPlusNameList {
  public : typedef elementOf_GGS_typeCplusPlusNameList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeCplusPlusNameList (void) ;
//--- Copy Constructor
  public : GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeCplusPlusNameList & inSource) ;
//--- Destructor
  public : ~GGS_typeCplusPlusNameList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeCplusPlusNameList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

class cPtr_typeExpression ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeExpression {
  protected : cPtr_typeExpression * mPointer ;
  public : GGS_typeExpression (void) ;
  public : GGS_typeExpression (const GGS_typeExpression &) ;
  public : virtual ~GGS_typeExpression (void) ;
  public : void operator = (const GGS_typeExpression &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeExpression & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeExpression * inSource) ;
  public : GGS_typeExpression (cPtr_typeExpression * inSource) ;
  public : inline cPtr_typeExpression * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeExpression * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeExpression * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map '@typeClassMessagesMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeClassMessagesMap ;

class GGS_typeClassMessagesMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeClassMessagesMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeClassMessagesMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeClassMessagesMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeClassMessagesMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_typeClassMessagesMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeClassMessagesMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeClassMessagesMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@typeSemanticsTypesList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeSemanticsTypesList ;

class GGS_typeSemanticsTypesList {
  public : typedef elementOf_GGS_typeSemanticsTypesList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeSemanticsTypesList (void) ;
//--- Copy Constructor
  public : GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeSemanticsTypesList & inSource) ;
//--- Destructor
  public : ~GGS_typeSemanticsTypesList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeSemanticsTypesList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeVariablesMap {
  public : GGS_AC_galgasType  mArgumentType ;
  public : GGS_typeCplusPlusName  mCplusPlusName ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeVariablesMap : public cGalgasVariablesMap <e_typeVariablesMap> {
//--- Get object pointer
  public : inline GGS_typeVariablesMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeVariablesMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- Handle 'emptyMap' constructor
  public : static GGS_typeVariablesMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- 'searchForReadOnlyAccess' search method
public : void method_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
public : void method_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
//--- 'searchForDestructiveReadAccess' search method
public : void method_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
public : void method_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
//--- 'searchForReadWriteAccess' search method
public : void method_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
public : void method_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
//--- 'searchForWriteAccess' search method
public : void method_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
public : void method_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertListOfEntitiesLocalVariable (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertListOfEntitiesLocalVariableGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertSingleEntityLocalVariable (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertSingleEntityLocalVariableGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertEntityAttributeLocalVariable (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertEntityAttributeLocalVariableGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertUnusedInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertUnusedInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertConstInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertConstInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertUsedConstInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertUsedConstInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertUnusedConstInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertUnusedConstInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertLocalVariable (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertLocalVariableGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertOutProperty (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertOutPropertyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertInOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertInOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertUsedInOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertUsedInOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertUnusedInOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
public : void method_insertUnusedInOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1 COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@L_assignedVariables'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_assignedVariables ;

class GGS_L_assignedVariables {
  public : typedef elementOf_GGS_L_assignedVariables element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_L_assignedVariables (void) ;
//--- Copy Constructor
  public : GGS_L_assignedVariables (const GGS_L_assignedVariables & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_L_assignedVariables & inSource) ;
//--- Destructor
  public : ~GGS_L_assignedVariables (void) ;

//--- Constructor 'emptyList'
  public : static GGS_L_assignedVariables constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

class cPtr_typeCible ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCible {
  protected : cPtr_typeCible * mPointer ;
  public : GGS_typeCible (void) ;
  public : GGS_typeCible (const GGS_typeCible &) ;
  public : virtual ~GGS_typeCible (void) ;
  public : void operator = (const GGS_typeCible &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeCible & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeCible * inSource) ;
  public : GGS_typeCible (cPtr_typeCible * inSource) ;
  public : inline cPtr_typeCible * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeCible * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeCible * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         list '@typeListeCibles'                           *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeCibles ;

class GGS_typeListeCibles {
  public : typedef elementOf_GGS_typeListeCibles element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeListeCibles (void) ;
//--- Copy Constructor
  public : GGS_typeListeCibles (const GGS_typeListeCibles & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeListeCibles & inSource) ;
//--- Destructor
  public : ~GGS_typeListeCibles (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeListeCibles constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeCible & argument_0) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeCible & argument_0) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  list '@typeListeTypesEtNomsArgMethode'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeTypesEtNomsArgMethode ;

class GGS_typeListeTypesEtNomsArgMethode {
  public : typedef elementOf_GGS_typeListeTypesEtNomsArgMethode element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeListeTypesEtNomsArgMethode (void) ;
//--- Copy Constructor
  public : GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeListeTypesEtNomsArgMethode & inSource) ;
//--- Destructor
  public : ~GGS_typeListeTypesEtNomsArgMethode (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeListeTypesEtNomsArgMethode constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

class cPtr_typeInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstruction {
  protected : cPtr_typeInstruction * mPointer ;
  public : GGS_typeInstruction (void) ;
  public : GGS_typeInstruction (const GGS_typeInstruction &) ;
  public : virtual ~GGS_typeInstruction (void) ;
  public : void operator = (const GGS_typeInstruction &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeInstruction & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeInstruction * inSource) ;
  public : GGS_typeInstruction (cPtr_typeInstruction * inSource) ;
  public : inline cPtr_typeInstruction * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeInstruction * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeInstruction * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       list '@typeInstructionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeInstructionList ;

class GGS_typeInstructionList {
  public : typedef elementOf_GGS_typeInstructionList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeInstructionList (void) ;
//--- Copy Constructor
  public : GGS_typeInstructionList (const GGS_typeInstructionList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeInstructionList & inSource) ;
//--- Destructor
  public : ~GGS_typeInstructionList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeInstructionList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeInstruction & argument_0) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeInstruction & argument_0) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          list '@L_nameWithType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_nameWithType ;

class GGS_L_nameWithType {
  public : typedef elementOf_GGS_L_nameWithType element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_L_nameWithType (void) ;
//--- Copy Constructor
  public : GGS_L_nameWithType (const GGS_L_nameWithType & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_L_nameWithType & inSource) ;
//--- Destructor
  public : ~GGS_L_nameWithType (void) ;

//--- Constructor 'emptyList'
  public : static GGS_L_nameWithType constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMethodesAimplementer {
  public : GGS_L_EXsignature  aListeTypesParametres ;
  public : GGS_typeListeTypesEtNomsArgMethode  aListeTypeEtNomsArguments ;
  public : GGS_typeInstructionList  mInstructionList ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTableMethodesAimplementer : public cTableMethodesAimplementer <e_typeTableMethodesAimplementer> {
//--- Get object pointer
  public : inline GGS_typeTableMethodesAimplementer * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableMethodesAimplementer * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- Handle 'emptyMap' constructor
  public : static GGS_typeTableMethodesAimplementer constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//---
public : void method_insertAbstract (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) ;
public : void method_insertAbstractGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) ;
//---
public : void method_insertNotAbstract (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) ;
public : void method_insertNotAbstractGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_EXsignature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionList &  inParameter2 COMMA_LOCATION_ARGS) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        list '@typeExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeExpressionList ;

class GGS_typeExpressionList {
  public : typedef elementOf_GGS_typeExpressionList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeExpressionList (void) ;
//--- Copy Constructor
  public : GGS_typeExpressionList (const GGS_typeExpressionList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeExpressionList & inSource) ;
//--- Destructor
  public : ~GGS_typeExpressionList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeExpressionList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeExpression & argument_0) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeExpression & argument_0) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          list '@varToDropList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_varToDropList ;

class GGS_varToDropList {
  public : typedef elementOf_GGS_varToDropList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_varToDropList (void) ;
//--- Copy Constructor
  public : GGS_varToDropList (const GGS_varToDropList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_varToDropList & inSource) ;
//--- Destructor
  public : ~GGS_varToDropList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_varToDropList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                list '@L_expression_instructionsList_list'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_expression_instructionsList_list ;

class GGS_L_expression_instructionsList_list {
  public : typedef elementOf_GGS_L_expression_instructionsList_list element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_L_expression_instructionsList_list (void) ;
//--- Copy Constructor
  public : GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_L_expression_instructionsList_list & inSource) ;
//--- Destructor
  public : ~GGS_L_expression_instructionsList_list (void) ;

//--- Constructor 'emptyList'
  public : static GGS_L_expression_instructionsList_list constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableRoutinesAimplementer'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableRoutinesAimplementer ;

class GGS_typeTableRoutinesAimplementer : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableRoutinesAimplementer element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableRoutinesAimplementer * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableRoutinesAimplementer * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableRoutinesAimplementer constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_typeTableRoutinesAimplementer constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableRoutinesAimplementer & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableRoutinesAimplementer reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableAttributsSemantiques'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableAttributsSemantiques ;

class GGS_typeTableAttributsSemantiques : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableAttributsSemantiques element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableAttributsSemantiques * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableAttributsSemantiques * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableAttributsSemantiques constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName &  inParameter0,
                                const GGS_AC_galgasType &  inParameter1 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_typeCplusPlusName & inParameter0,
                                  const GGS_AC_galgasType & inParameter1,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_typeCplusPlusName & outParameter0,
                                  GGS_AC_galgasType & outParameter1,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_typeTableAttributsSemantiques constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableAttributsSemantiques & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableAttributsSemantiques reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

void routine_buildMapWithLocalConstants (C_Lexique &,
                                GGS_L_nameWithType  ,
                                GGS_typeListeAttributsSemantiques  ,
                                GGS_typeVariablesMap  &,
                                GGS_location  ,
                                GGS_localConstantBuildStyleEnum ,
                                GGS_bool  COMMA_LOCATION_ARGS) ;

void routine_verifierCompatibiliteTypes (C_Lexique &,
                                const GGS_typeSemanticsTypesList  &,
                                const GGS_typeListeAttributsSemantiques  &,
                                const GGS_location  & COMMA_LOCATION_ARGS) ;

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique &,
                                const GGS_L_EXsignature  &,
                                const GGS_L_actualParametersSignature  &,
                                const GGS_location  &,
                                GGS_typeInstructionList  &,
                                GGS_typeExpressionList  & COMMA_LOCATION_ARGS) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@M_nonTerminalSymbolForSyntax'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_M_nonTerminalSymbolForSyntax ;

class GGS_M_nonTerminalSymbolForSyntax : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_M_nonTerminalSymbolForSyntax element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_M_nonTerminalSymbolForSyntax * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_M_nonTerminalSymbolForSyntax * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_M_nonTerminalSymbolForSyntax constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_M_nonterminalSymbolAlts &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_M_nonterminalSymbolAlts   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_M_nonterminalSymbolAlts & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_M_nonterminalSymbolAlts & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_M_nonTerminalSymbolForSyntax constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_M_nonTerminalSymbolForSyntax & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_M_nonTerminalSymbolForSyntax reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   list '@L_matchInstructionCasesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_matchInstructionCasesList ;

class GGS_L_matchInstructionCasesList {
  public : typedef elementOf_GGS_L_matchInstructionCasesList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_L_matchInstructionCasesList (void) ;
//--- Copy Constructor
  public : GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_L_matchInstructionCasesList & inSource) ;
//--- Destructor
  public : ~GGS_L_matchInstructionCasesList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_L_matchInstructionCasesList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionList & argument_2) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      list '@foreachEnumerationList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_foreachEnumerationList ;

class GGS_foreachEnumerationList {
  public : typedef elementOf_GGS_foreachEnumerationList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_foreachEnumerationList (void) ;
//--- Copy Constructor
  public : GGS_foreachEnumerationList (const GGS_foreachEnumerationList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_foreachEnumerationList & inSource) ;
//--- Destructor
  public : ~GGS_foreachEnumerationList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_foreachEnumerationList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  list '@typeStructuredExtractCasesList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeStructuredExtractCasesList ;

class GGS_typeStructuredExtractCasesList {
  public : typedef elementOf_GGS_typeStructuredExtractCasesList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeStructuredExtractCasesList (void) ;
//--- Copy Constructor
  public : GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeStructuredExtractCasesList & inSource) ;
//--- Destructor
  public : ~GGS_typeStructuredExtractCasesList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeStructuredExtractCasesList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionList & argument_2,
                                const GGS_bool& argument_3) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Map '@typeTableNomRoutinesDeclarees'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableNomRoutinesDeclarees ;

class GGS_typeTableNomRoutinesDeclarees : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeTableNomRoutinesDeclarees element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableNomRoutinesDeclarees * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeTableNomRoutinesDeclarees * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeTableNomRoutinesDeclarees constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_typeTableNomRoutinesDeclarees constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeTableNomRoutinesDeclarees & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeTableNomRoutinesDeclarees reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

class cPtr_typeEntityToGenerate ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntityToGenerate {
  protected : cPtr_typeEntityToGenerate * mPointer ;
  public : GGS_typeEntityToGenerate (void) ;
  public : GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate &) ;
  public : virtual ~GGS_typeEntityToGenerate (void) ;
  public : void operator = (const GGS_typeEntityToGenerate &) ;
  public : inline bool isBuilt (void) const { return mPointer != NULL ; }
  public : inline bool isEqualTo (const GGS_typeEntityToGenerate & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeEntityToGenerate * inSource) ;
  public : GGS_typeEntityToGenerate (cPtr_typeEntityToGenerate * inSource) ;
  public : inline cPtr_typeEntityToGenerate * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : cPtr_typeEntityToGenerate * operator () (LOCATION_ARGS) const ;
  #else
    public : inline cPtr_typeEntityToGenerate * operator () (LOCATION_ARGS) const { return mPointer ; }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    list '@typeEntitiesToGenerateList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeEntitiesToGenerateList ;

class GGS_typeEntitiesToGenerateList {
  public : typedef elementOf_GGS_typeEntitiesToGenerateList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_typeEntitiesToGenerateList (void) ;
//--- Copy Constructor
  public : GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_typeEntitiesToGenerateList & inSource) ;
//--- Destructor
  public : ~GGS_typeEntitiesToGenerateList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_typeEntitiesToGenerateList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_typeEntityToGenerate & argument_0) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_typeEntityToGenerate & argument_0) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

void routine_enterBuiltinTypes (C_Lexique &,
                                GGS_M_semanticsEntitiesForUse  & COMMA_LOCATION_ARGS) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Map '@typeEnumCstMessageStringMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeEnumCstMessageStringMap ;

class GGS_typeEnumCstMessageStringMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_typeEnumCstMessageStringMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeEnumCstMessageStringMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_typeEnumCstMessageStringMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_typeEnumCstMessageStringMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_typeEnumCstMessageStringMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_typeEnumCstMessageStringMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_typeEnumCstMessageStringMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

void routine_appendJokersIfNeeded (C_Lexique &,
                                GGS_typeCplusPlusNameList  &,
                                GGS_uint  ,
                                GGS_uint  ,
                                GGS_typeCplusPlusName   COMMA_LOCATION_ARGS) ;

void routine_generateSemanticsComponent (C_Lexique &,
                                GGS_lstring  &,
                                GGS_stringset  &,
                                GGS_string &,
                                GGS_typeEntitiesToGenerateList  &,
                                GGS_stringset  & COMMA_LOCATION_ARGS) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Map '@mapAsConstraintPropertyMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_mapAsConstraintPropertyMap ;

class GGS_mapAsConstraintPropertyMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_mapAsConstraintPropertyMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_mapAsConstraintPropertyMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_mapAsConstraintPropertyMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_mapAsConstraintPropertyMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0,
                                const GGS_lstring &  inParameter1,
                                const GGS_uint &  inParameter2,
                                const GGS_string&  inParameter3,
                                const GGS_bool&  inParameter4 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1,
                                GGS_uint   & outParameter2,
                                GGS_string  & outParameter3,
                                GGS_bool  & outParameter4 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  const GGS_lstring & inParameter1,
                                  const GGS_uint & inParameter2,
                                  const GGS_string& inParameter3,
                                  const GGS_bool& inParameter4,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_lstring & outParameter1,
                                  GGS_uint & outParameter2,
                                  GGS_string& outParameter3,
                                  GGS_bool& outParameter4,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_mapAsConstraintPropertyMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_mapAsConstraintPropertyMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_mapAsConstraintPropertyMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Map '@passMap'                               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_passMap ;

class GGS_passMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_passMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_passMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_passMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_passMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const ;
//--- 'searchKeyAndGetIndex' Search Method
  public : void method_searchKeyAndGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_passMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_passMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_passMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        list '@sharedPropertyList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_sharedPropertyList ;

class GGS_sharedPropertyList {
  public : typedef elementOf_GGS_sharedPropertyList element_type ;
//--- Embedded class for list root
  protected : class cRootList {
    public : element_type * mFirstItem ;
    public : element_type * mLastItem ;
    public : sint32 mListLength ;
    public : sint32 mCountReference ;
  //--- Default constructor
    public : cRootList (void) ;
  //--- Destructor
    public : ~cRootList (void) ;
  //--- No Copy
    private : cRootList (const cRootList &) ;
    private : void operator = (const cRootList &) ;
  } ;
//--- Private attribute
  private : cRootList * mRoot ;
//--- Default Constructor
  public : GGS_sharedPropertyList (void) ;
//--- Copy Constructor
  public : GGS_sharedPropertyList (const GGS_sharedPropertyList & inSource) ;
//--- Assignment Operator
  public : void operator = (const GGS_sharedPropertyList & inSource) ;
//--- Destructor
  public : ~GGS_sharedPropertyList (void) ;

//--- Constructor 'emptyList'
  public : static GGS_sharedPropertyList constructor_emptyList (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Function 'count'
  public : sint32 count (void) const ;
//--- Reader 'description'
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
//--- Get first object
  public : element_type * firstObject (void) const ;
//--- Handling '+=' GALGAS operator
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
//--- Internal Methods
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void insulateList (void) ;
//--- 'isBuilt' method
  public : inline bool isBuilt (void) const {
    return mRoot != NULL ;
  }
//--- Handling GALGAS 'drop' instruction
  public : void drop_operation (void) ;
//--- Handling GALGAS 'length' reader
  public : GGS_uint reader_length (C_Lexique & /* inLexique */
                                   COMMA_UNUSED_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Map '@callInstructionSharedPropertySignatureMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_callInstructionSharedPropertySignatureMap ;

class GGS_callInstructionSharedPropertySignatureMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_callInstructionSharedPropertySignatureMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_callInstructionSharedPropertySignatureMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_callInstructionSharedPropertySignatureMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_callInstructionSharedPropertySignatureMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_sharedPropertyList &  inParameter0,
                                const GGS_location &  inParameter1 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_sharedPropertyList   & outParameter0,
                                GGS_location   & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_sharedPropertyList & inParameter0,
                                  const GGS_location & inParameter1,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_sharedPropertyList & outParameter0,
                                  GGS_location & outParameter1,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_callInstructionSharedPropertySignatureMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_callInstructionSharedPropertySignatureMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_callInstructionSharedPropertySignatureMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Map '@constrainedEntityPassMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_constrainedEntityPassMap ;

class GGS_constrainedEntityPassMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_constrainedEntityPassMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_constrainedEntityPassMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_constrainedEntityPassMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_constrainedEntityPassMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeInstructionList &  inParameter0,
                                const GGS_sharedPropertyList &  inParameter1,
                                const GGS_stringset &  inParameter2,
                                const GGS_callInstructionSharedPropertySignatureMap &  inParameter3 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeInstructionList   & outParameter0,
                                GGS_sharedPropertyList   & outParameter1,
                                GGS_stringset   & outParameter2,
                                GGS_callInstructionSharedPropertySignatureMap   & outParameter3 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_typeInstructionList & inParameter0,
                                  const GGS_sharedPropertyList & inParameter1,
                                  const GGS_stringset & inParameter2,
                                  const GGS_callInstructionSharedPropertySignatureMap & inParameter3,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_typeInstructionList & outParameter0,
                                  GGS_sharedPropertyList & outParameter1,
                                  GGS_stringset & outParameter2,
                                  GGS_callInstructionSharedPropertySignatureMap & outParameter3,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_constrainedEntityPassMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_constrainedEntityPassMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_constrainedEntityPassMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Map '@constraintAllPropertiesMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_constraintAllPropertiesMap ;

class GGS_constraintAllPropertiesMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_constraintAllPropertiesMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_constraintAllPropertiesMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_constraintAllPropertiesMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_constraintAllPropertiesMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_constraintAllPropertiesMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_constraintAllPropertiesMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_constraintAllPropertiesMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                             Map '@indexMap'                               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_indexMap ;

class GGS_indexMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_indexMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_indexMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_indexMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_indexMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0,
                                const GGS_uint &  inParameter1 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_uint   & outParameter1 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  const GGS_uint & inParameter1,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_lstring & outParameter0,
                                  GGS_uint & outParameter1,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_indexMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_indexMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_indexMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map '@constrainedEntityMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_constrainedEntityMap ;

class GGS_constrainedEntityMap : public AC_galgas_map {
//--- Element Class
  public : typedef elementOf_GGS_constrainedEntityMap element_type ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) internalRootObject () ; }
  public : inline element_type * firstObject (void) const { return (element_type *) internalFirstObject () ; }
  public : inline element_type * lastObject (void) const { return (element_type *) internalLastObject () ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_constrainedEntityMap * operator () (UNUSED_LOCATION_ARGS) { return this ; }
  public : inline const GGS_constrainedEntityMap * operator () (UNUSED_LOCATION_ARGS) const { return this ; }
//--- 'emptyMap' constructor
  public : static GGS_constrainedEntityMap constructor_emptyMap (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void method_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_stringset &  inParameter0,
                                const GGS_constrainedEntityPassMap &  inParameter1,
                                const GGS_lstring &  inParameter2,
                                const GGS_entityPropertyMap &  inParameter3,
                                const GGS_stringset &  inParameter4,
                                const GGS_location &  inParameter5,
                                const GGS_mapAsConstraintPropertyMap &  inParameter6,
                                const GGS_mapAsConstraintPropertyMap &  inParameter7,
                                const GGS_constraintAllPropertiesMap &  inParameter8,
                                const GGS_indexMap &  inParameter9,
                                const GGS_indexMap &  inParameter10 COMMA_LOCATION_ARGS) ;
//--- 'searchKey' Search Method
  public : void method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_stringset   & outParameter0,
                                GGS_constrainedEntityPassMap   & outParameter1,
                                GGS_lstring   & outParameter2,
                                GGS_entityPropertyMap   & outParameter3,
                                GGS_stringset   & outParameter4,
                                GGS_location   & outParameter5,
                                GGS_mapAsConstraintPropertyMap   & outParameter6,
                                GGS_mapAsConstraintPropertyMap   & outParameter7,
                                GGS_constraintAllPropertiesMap   & outParameter8,
                                GGS_indexMap   & outParameter9,
                                GGS_indexMap   & outParameter10 COMMA_LOCATION_ARGS) const ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  const GGS_stringset & inParameter0,
                                  const GGS_constrainedEntityPassMap & inParameter1,
                                  const GGS_lstring & inParameter2,
                                  const GGS_entityPropertyMap & inParameter3,
                                  const GGS_stringset & inParameter4,
                                  const GGS_location & inParameter5,
                                  const GGS_mapAsConstraintPropertyMap & inParameter6,
                                  const GGS_mapAsConstraintPropertyMap & inParameter7,
                                  const GGS_constraintAllPropertiesMap & inParameter8,
                                  const GGS_indexMap & inParameter9,
                                  const GGS_indexMap & inParameter10,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessage,
                                  const GGS_lstring & inKey,
                                  GGS_stringset & outParameter0,
                                  GGS_constrainedEntityPassMap & outParameter1,
                                  GGS_lstring & outParameter2,
                                  GGS_entityPropertyMap & outParameter3,
                                  GGS_stringset & outParameter4,
                                  GGS_location & outParameter5,
                                  GGS_mapAsConstraintPropertyMap & outParameter6,
                                  GGS_mapAsConstraintPropertyMap & outParameter7,
                                  GGS_constraintAllPropertiesMap & outParameter8,
                                  GGS_indexMap & outParameter9,
                                  GGS_indexMap & outParameter10,
                                  GGS_luint * outIndex
                                  COMMA_LOCATION_ARGS) const ;
  public : GGS_string reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const ;
  public : static GGS_constrainedEntityMap constructor_mapWithMapToOverride (C_Lexique & inLexique,
                                            const GGS_constrainedEntityMap & inMapToOverride
                                            COMMA_LOCATION_ARGS) ;
  public : GGS_constrainedEntityMap reader_overriddenMap (C_Lexique & inLexique
                                            COMMA_LOCATION_ARGS) const ;
} ;

void routine_generate_constraints (C_Lexique &,
                                GGS_passMap  ,
                                GGS_entityToImplementMap  ,
                                GGS_mapEntityMap  ,
                                GGS_lstring  ,
                                GGS_lstring  ,
                                GGS_constrainedEntityMap  ,
                                GGS_stringset  ,
                                GGS_lstring   COMMA_LOCATION_ARGS) ;

void routine_displayConstraintDefinitionErrors (C_Lexique &,
                                GGS_stringset  ,
                                GGS_stringset   COMMA_LOCATION_ARGS) ;

void routine_displayConstraintDefinitionErrorsNoElse (C_Lexique &,
                                GGS_stringset  ,
                                GGS_stringset   COMMA_LOCATION_ARGS) ;

//---------------------------------------------------------------------------*


#include "include_typeCplusPlusName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDirectName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDirectName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDirectName * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDirectName * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDirectName(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeCppThisName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCppThisName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeCppThisName * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeCppThisName * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeCppThisName(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeCppInheritedName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCppInheritedName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeCppInheritedName * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeCppInheritedName * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeCppInheritedName(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeAutomaticName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAutomaticName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeAutomaticName * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeAutomaticName * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeAutomaticName(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLocationAutomaticName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLocationAutomaticName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLocationAutomaticName * constructor_new (C_Lexique & inLexique,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLocationAutomaticName * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLocationAutomaticName(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeOperandName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeOperandName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeOperandName * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeOperandName * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeOperandName(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeKeyName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeKeyName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeKeyName * constructor_new (C_Lexique & inLexique,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeKeyName * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeKeyName(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeNullName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeNullName {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeNullName * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeNullName * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeNullName(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@typeCplusPlusNameList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeCplusPlusNameList {
  private : elementOf_GGS_typeCplusPlusNameList * mNextItem ;
    public : GGS_typeCplusPlusName  mCppName ;
  public : elementOf_GGS_typeCplusPlusNameList (const GGS_typeCplusPlusName & ) ;

  public : inline elementOf_GGS_typeCplusPlusNameList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeCplusPlusNameList (const elementOf_GGS_typeCplusPlusNameList &) ;
  private : void operator = (const elementOf_GGS_typeCplusPlusNameList &) ;
  public : inline ~elementOf_GGS_typeCplusPlusNameList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeCplusPlusNameList ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of map '@typeClassMessagesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeClassMessagesMap {
  public : GGS_lstring  mMessage ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeClassMessagesMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeClassMessagesMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeClassMessagesMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeClassMessagesMap * nextObject (void) const { return (elementOf_GGS_typeClassMessagesMap *) mNextItem ; }
  public : inline elementOf_GGS_typeClassMessagesMap * infObject (void) const { return (elementOf_GGS_typeClassMessagesMap *) mInfPtr ; }
  public : inline elementOf_GGS_typeClassMessagesMap * supObject (void) const { return (elementOf_GGS_typeClassMessagesMap *) mSupPtr ; }
//--- Data member
  public : e_typeClassMessagesMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeSemanticsTypesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeSemanticsTypesList {
  private : elementOf_GGS_typeSemanticsTypesList * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_lstring  mGalgasVariableName ;
  public : elementOf_GGS_typeSemanticsTypesList (const GGS_AC_galgasType & ,
                                const GGS_lstring & ) ;

  public : inline elementOf_GGS_typeSemanticsTypesList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeSemanticsTypesList (const elementOf_GGS_typeSemanticsTypesList &) ;
  private : void operator = (const elementOf_GGS_typeSemanticsTypesList &) ;
  public : inline ~elementOf_GGS_typeSemanticsTypesList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeSemanticsTypesList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@L_assignedVariables'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_assignedVariables {
  private : elementOf_GGS_L_assignedVariables * mNextItem ;
    public : GGS_typeCplusPlusName  aNomVariableCible ;
    public : GGS_lstring  aNomAttributSource ;
  public : elementOf_GGS_L_assignedVariables (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ) ;

  public : inline elementOf_GGS_L_assignedVariables * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_L_assignedVariables (const elementOf_GGS_L_assignedVariables &) ;
  private : void operator = (const elementOf_GGS_L_assignedVariables &) ;
  public : inline ~elementOf_GGS_L_assignedVariables (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_L_assignedVariables ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeCible.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@typeListeCibles'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeCibles {
  private : elementOf_GGS_typeListeCibles * mNextItem ;
    public : GGS_typeCible  aCible ;
  public : elementOf_GGS_typeListeCibles (const GGS_typeCible & ) ;

  public : inline elementOf_GGS_typeListeCibles * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeCibles (const elementOf_GGS_typeListeCibles &) ;
  private : void operator = (const elementOf_GGS_typeListeCibles &) ;
  public : inline ~elementOf_GGS_typeListeCibles (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeCibles ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeListeTypesEtNomsArgMethode'              *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeListeTypesEtNomsArgMethode {
  private : elementOf_GGS_typeListeTypesEtNomsArgMethode * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_formalArgumentPassingMode mFormalArgumentPassingMode ;
    public : GGS_typeCplusPlusName  mCppName ;
    public : GGS_bool mModeIn ;
  public : elementOf_GGS_typeListeTypesEtNomsArgMethode (const GGS_AC_galgasType & ,
                                const GGS_formalArgumentPassingMode& ,
                                const GGS_typeCplusPlusName & ,
                                const GGS_bool& ) ;

  public : inline elementOf_GGS_typeListeTypesEtNomsArgMethode * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeListeTypesEtNomsArgMethode (const elementOf_GGS_typeListeTypesEtNomsArgMethode &) ;
  private : void operator = (const elementOf_GGS_typeListeTypesEtNomsArgMethode &) ;
  public : inline ~elementOf_GGS_typeListeTypesEtNomsArgMethode (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeListeTypesEtNomsArgMethode ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeInstructionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeInstructionList {
  private : elementOf_GGS_typeInstructionList * mNextItem ;
    public : GGS_typeInstruction  mInstruction ;
  public : elementOf_GGS_typeInstructionList (const GGS_typeInstruction & ) ;

  public : inline elementOf_GGS_typeInstructionList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeInstructionList (const elementOf_GGS_typeInstructionList &) ;
  private : void operator = (const elementOf_GGS_typeInstructionList &) ;
  public : inline ~elementOf_GGS_typeInstructionList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeInstructionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@L_nameWithType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_nameWithType {
  private : elementOf_GGS_L_nameWithType * mNextItem ;
    public : GGS_lstring  mType ;
    public : GGS_lstring  mName ;
  public : elementOf_GGS_L_nameWithType (const GGS_lstring & ,
                                const GGS_lstring & ) ;

  public : inline elementOf_GGS_L_nameWithType * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_L_nameWithType (const elementOf_GGS_L_nameWithType &) ;
  private : void operator = (const elementOf_GGS_L_nameWithType &) ;
  public : inline ~elementOf_GGS_L_nameWithType (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_L_nameWithType ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeExpressionList {
  private : elementOf_GGS_typeExpressionList * mNextItem ;
    public : GGS_typeExpression  mExpression ;
  public : elementOf_GGS_typeExpressionList (const GGS_typeExpression & ) ;

  public : inline elementOf_GGS_typeExpressionList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeExpressionList (const elementOf_GGS_typeExpressionList &) ;
  private : void operator = (const elementOf_GGS_typeExpressionList &) ;
  public : inline ~elementOf_GGS_typeExpressionList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeExpressionList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@varToDropList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_varToDropList {
  private : elementOf_GGS_varToDropList * mNextItem ;
    public : GGS_typeCplusPlusName  mVarToDrop ;
  public : elementOf_GGS_varToDropList (const GGS_typeCplusPlusName & ) ;

  public : inline elementOf_GGS_varToDropList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_varToDropList (const elementOf_GGS_varToDropList &) ;
  private : void operator = (const elementOf_GGS_varToDropList &) ;
  public : inline ~elementOf_GGS_varToDropList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_varToDropList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeErrorInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeErrorInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeErrorInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeErrorInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2,
                                const GGS_varToDropList & argument_3 COMMA_LOCATION_ARGS) {
      return new cPtr_typeErrorInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeWarningInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeWarningInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeWarningInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeWarningInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeWarningInstruction(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeMessageInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMessageInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeMessageInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeMessageInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeMessageInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeReaderCallInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeReaderCallInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeReaderCallInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeReaderCallInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeReaderCallInstruction(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeModifierCallInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeModifierCallInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeModifierCallInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeModifierCallInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeModifierCallInstruction(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionAppelMethodeListe.h"

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionAppelMethodeListe {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionAppelMethodeListe * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionAppelMethodeListe * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionAppelMethodeListe(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionDeclarationVarLocale.h"

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionDeclarationVarLocale {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionDeclarationVarLocale * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionDeclarationVarLocale * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionDeclarationVarLocale(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeMapBlockPrologueInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMapBlockPrologueInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeMapBlockPrologueInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeMapBlockPrologueInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeMapBlockPrologueInstruction(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeMapBlockEpilogueInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMapBlockEpilogueInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeMapBlockEpilogueInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeMapBlockEpilogueInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeMapBlockEpilogueInstruction(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeReaderCallInExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeReaderCallInExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeReaderCallInExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_location & argument_3 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeReaderCallInExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_location & argument_3 COMMA_LOCATION_ARGS) {
      return new cPtr_typeReaderCallInExpression(argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeAndOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAndOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeAndOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeAndOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeAndOperation(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeOrOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeOrOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeOrOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeOrOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeOrOperation(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeXorOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeXorOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeXorOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeXorOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeXorOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeXorOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeXorOperation(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeConcatOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConcatOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeConcatOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeConcatOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeConcatOperation(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeTrueBool.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTrueBool {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeTrueBool * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeTrueBool * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeTrueBool(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeFalseBool.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeFalseBool {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeFalseBool * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeFalseBool * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeFalseBool(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLiteralStringExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralStringExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLiteralStringExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLiteralStringExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLiteralStringExpression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLiteralUIntExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralUIntExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLiteralUIntExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLiteralUIntExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLiteralUIntExpression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLiteralSIntExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralSIntExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLiteralSIntExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_lsint & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLiteralSIntExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lsint & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLiteralSIntExpression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralUInt64Expression'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLiteralUInt64Expression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralUInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralUInt64Expression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLiteralUInt64Expression * constructor_new (C_Lexique & inLexique,
                                const GGS_luint64 & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLiteralUInt64Expression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint64 & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLiteralUInt64Expression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralSInt64Expression'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLiteralSInt64Expression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralSInt64Expression'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralSInt64Expression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLiteralSInt64Expression * constructor_new (C_Lexique & inLexique,
                                const GGS_lsint64 & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLiteralSInt64Expression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lsint64 & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLiteralSInt64Expression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeLiteralCharExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralCharExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeLiteralCharExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeLiteralCharExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeLiteralCharExpression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeHereExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeHereExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeHereExpression * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeHereExpression * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeHereExpression(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeConstructorExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConstructorExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeConstructorExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeConstructorExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeConstructorExpression(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeTestComplement.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTestComplement {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeTestComplement * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeTestComplement * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeTestComplement(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeBoolOption.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeBoolOption {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeBoolOption * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeBoolOption * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeBoolOption(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeUIntOption.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeUIntOption {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeUIntOption * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeUIntOption * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeUIntOption(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeStringOption'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeStringOption.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStringOption'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStringOption {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeStringOption * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeStringOption * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeStringOption(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeVarInExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeVarInExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeVarInExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeVarInExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeVarInExpression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeJokerInExpression.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeJokerInExpression {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeJokerInExpression * constructor_new (C_Lexique & inLexique,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeJokerInExpression * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeJokerInExpression(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAddOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeAddOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAddOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAddOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeAddOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeAddOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeAddOperation(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeSubOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeSubOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeSubOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeSubOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeSubOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeSubOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeSubOperation(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMultiplyOperation'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeMultiplyOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMultiplyOperation'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMultiplyOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeMultiplyOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeMultiplyOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeMultiplyOperation(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDivideOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDivideOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDivideOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDivideOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDivideOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDivideOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDivideOperation(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeModuloOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeModuloOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeModuloOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeModuloOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeModuloOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeModuloOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeModuloOperation(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeUnaryMinusOperation'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeUnaryMinusOperation.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeUnaryMinusOperation'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeUnaryMinusOperation {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeUnaryMinusOperation * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeUnaryMinusOperation * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeUnaryMinusOperation(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeEqualTest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEqualTest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeEqualTest * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeEqualTest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeEqualTest(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeNonEqualTest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeNonEqualTest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeNonEqualTest * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeNonEqualTest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeNonEqualTest(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeStrictInfTest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStrictInfTest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeStrictInfTest * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeStrictInfTest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeStrictInfTest(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInfOrEqualTest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInfOrEqualTest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInfOrEqualTest * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInfOrEqualTest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInfOrEqualTest(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeStrictSupTest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStrictSupTest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeStrictSupTest * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeStrictSupTest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeStrictSupTest(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeSupOrEqualTest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeSupOrEqualTest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeSupOrEqualTest * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeSupOrEqualTest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeSupOrEqualTest(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeTextTableCall.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTextTableCall {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeTextTableCall * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeTextTableCall * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeTextTableCall(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_assignmentInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_assignmentInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_assignmentInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_assignmentInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_C_assignmentInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_declarationInstructionWithAssignment.h"

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_declarationInstructionWithAssignment {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_declarationInstructionWithAssignment * constructor_new (C_Lexique & inLexique,
                                const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_declarationInstructionWithAssignment * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_C_declarationInstructionWithAssignment(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_while_instruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_while_instruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_C_while_instruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_while_instruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_while_instruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_while_instruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionList & argument_1,
                                const GGS_typeExpression & argument_2,
                                const GGS_typeInstructionList & argument_3,
                                const GGS_location & argument_4 COMMA_LOCATION_ARGS) {
      return new cPtr_C_while_instruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@L_expression_instructionsList_list'            *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_expression_instructionsList_list {
  private : elementOf_GGS_L_expression_instructionsList_list * mNextItem ;
    public : GGS_typeExpression  mIFexpression ;
    public : GGS_typeInstructionList  mInstructionList ;
  public : elementOf_GGS_L_expression_instructionsList_list (const GGS_typeExpression & ,
                                const GGS_typeInstructionList & ) ;

  public : inline elementOf_GGS_L_expression_instructionsList_list * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_L_expression_instructionsList_list (const elementOf_GGS_L_expression_instructionsList_list &) ;
  private : void operator = (const elementOf_GGS_L_expression_instructionsList_list &) ;
  public : inline ~elementOf_GGS_L_expression_instructionsList_list (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_L_expression_instructionsList_list ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_if_instruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_if_instruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_if_instruction * constructor_new (C_Lexique & inLexique,
                                const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_if_instruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionList & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_C_if_instruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of map '@typeTableRoutinesAimplementer'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableRoutinesAimplementer {
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableRoutinesAimplementer : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableRoutinesAimplementer (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableRoutinesAimplementer & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableRoutinesAimplementer * nextObject (void) const { return (elementOf_GGS_typeTableRoutinesAimplementer *) mNextItem ; }
  public : inline elementOf_GGS_typeTableRoutinesAimplementer * infObject (void) const { return (elementOf_GGS_typeTableRoutinesAimplementer *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableRoutinesAimplementer * supObject (void) const { return (elementOf_GGS_typeTableRoutinesAimplementer *) mSupPtr ; }
//--- Data member
  public : e_typeTableRoutinesAimplementer mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of map '@typeTableAttributsSemantiques'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableAttributsSemantiques {
  public : GGS_typeCplusPlusName  aNomCppAttribut ;
  public : GGS_AC_galgasType  mAttributType ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableAttributsSemantiques : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableAttributsSemantiques (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableAttributsSemantiques & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableAttributsSemantiques * nextObject (void) const { return (elementOf_GGS_typeTableAttributsSemantiques *) mNextItem ; }
  public : inline elementOf_GGS_typeTableAttributsSemantiques * infObject (void) const { return (elementOf_GGS_typeTableAttributsSemantiques *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableAttributsSemantiques * supObject (void) const { return (elementOf_GGS_typeTableAttributsSemantiques *) mSupPtr ; }
//--- Data member
  public : e_typeTableAttributsSemantiques mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeJoker.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeJoker {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeJoker * constructor_new (C_Lexique & inLexique COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeJoker * constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
      return new cPtr_typeJoker(THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeEntiteDest.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteDest {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeEntiteDest * constructor_new (C_Lexique & inLexique,
                                const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeEntiteDest * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeEntiteDest(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of map '@M_nonTerminalSymbolForSyntax'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_M_nonTerminalSymbolForSyntax {
  public : GGS_M_nonterminalSymbolAlts  mAltParametersMap ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_M_nonTerminalSymbolForSyntax : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_M_nonTerminalSymbolForSyntax (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_M_nonTerminalSymbolForSyntax & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_M_nonTerminalSymbolForSyntax * nextObject (void) const { return (elementOf_GGS_M_nonTerminalSymbolForSyntax *) mNextItem ; }
  public : inline elementOf_GGS_M_nonTerminalSymbolForSyntax * infObject (void) const { return (elementOf_GGS_M_nonTerminalSymbolForSyntax *) mInfPtr ; }
  public : inline elementOf_GGS_M_nonTerminalSymbolForSyntax * supObject (void) const { return (elementOf_GGS_M_nonTerminalSymbolForSyntax *) mSupPtr ; }
//--- Data member
  public : e_M_nonTerminalSymbolForSyntax mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_grammarInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_grammarInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_grammarInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_grammarInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3 COMMA_LOCATION_ARGS) {
      return new cPtr_C_grammarInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeAppendInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAppendInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeAppendInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeAppendInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeAppendInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRemoveInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeRemoveInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRemoveInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeRemoveInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeRemoveInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeRemoveInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeRemoveInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeIncrementInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeIncrementInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeIncrementInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeIncrementInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeIncrementInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDecrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDecrementInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDecrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDecrementInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDecrementInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDecrementInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDecrementInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeInstructionAppelActionExterne.h"

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionAppelActionExterne {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeInstructionAppelActionExterne * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeInstructionAppelActionExterne * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_EXsignature & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeInstructionAppelActionExterne(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@L_matchInstructionCasesList'               *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_L_matchInstructionCasesList {
  private : elementOf_GGS_L_matchInstructionCasesList * mNextItem ;
    public : GGS_lstring  mCase1_name ;
    public : GGS_lstring  mCase2_name ;
    public : GGS_typeInstructionList  mInstructionList ;
  public : elementOf_GGS_L_matchInstructionCasesList (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_typeInstructionList & ) ;

  public : inline elementOf_GGS_L_matchInstructionCasesList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_L_matchInstructionCasesList (const elementOf_GGS_L_matchInstructionCasesList &) ;
  private : void operator = (const elementOf_GGS_L_matchInstructionCasesList &) ;
  public : inline ~elementOf_GGS_L_matchInstructionCasesList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_L_matchInstructionCasesList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeMatchInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMatchInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeMatchInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeMatchInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionList & argument_9 COMMA_LOCATION_ARGS) {
      return new cPtr_typeMatchInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@foreachEnumerationList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_foreachEnumerationList {
  private : elementOf_GGS_foreachEnumerationList * mNextItem ;
    public : GGS_typeCplusPlusName  mCppEnumeratedVariableName ;
    public : GGS_location  mLocationOffset ;
    public : GGS_string mCppTypeName ;
  public : elementOf_GGS_foreachEnumerationList (const GGS_typeCplusPlusName & ,
                                const GGS_location & ,
                                const GGS_string& ) ;

  public : inline elementOf_GGS_foreachEnumerationList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_foreachEnumerationList (const elementOf_GGS_foreachEnumerationList &) ;
  private : void operator = (const elementOf_GGS_foreachEnumerationList &) ;
  public : inline ~elementOf_GGS_foreachEnumerationList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_foreachEnumerationList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeForeachInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeForeachInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeForeachInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeForeachInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeForeachInstruction(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeSimpleExtractInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeSimpleExtractInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeSimpleExtractInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeSimpleExtractInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4 COMMA_LOCATION_ARGS) {
      return new cPtr_typeSimpleExtractInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@typeStructuredExtractCasesList'              *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeStructuredExtractCasesList {
  private : elementOf_GGS_typeStructuredExtractCasesList * mNextItem ;
    public : GGS_lstring  mClassName ;
    public : GGS_location  mResultVarID ;
    public : GGS_typeInstructionList  mInstructionList ;
    public : GGS_bool mNoUsedParameter ;
  public : elementOf_GGS_typeStructuredExtractCasesList (const GGS_lstring & ,
                                const GGS_location & ,
                                const GGS_typeInstructionList & ,
                                const GGS_bool& ) ;

  public : inline elementOf_GGS_typeStructuredExtractCasesList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeStructuredExtractCasesList (const elementOf_GGS_typeStructuredExtractCasesList &) ;
  private : void operator = (const elementOf_GGS_typeStructuredExtractCasesList &) ;
  public : inline ~elementOf_GGS_typeStructuredExtractCasesList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeStructuredExtractCasesList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeStructuredExtractInstructionWithElse.h"

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStructuredExtractInstructionWithElse {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeStructuredExtractInstructionWithElse * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeStructuredExtractInstructionWithElse * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeStructuredExtractInstructionWithElse(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeRoutineCallInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeRoutineCallInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeRoutineCallInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeRoutineCallInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeRoutineCallInstruction(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDropInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDropInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDropInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDropInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeCplusPlusName & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDropInstruction(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of map '@typeTableNomRoutinesDeclarees'               *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableNomRoutinesDeclarees {
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeTableNomRoutinesDeclarees : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeTableNomRoutinesDeclarees (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeTableNomRoutinesDeclarees & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeTableNomRoutinesDeclarees * nextObject (void) const { return (elementOf_GGS_typeTableNomRoutinesDeclarees *) mNextItem ; }
  public : inline elementOf_GGS_typeTableNomRoutinesDeclarees * infObject (void) const { return (elementOf_GGS_typeTableNomRoutinesDeclarees *) mInfPtr ; }
  public : inline elementOf_GGS_typeTableNomRoutinesDeclarees * supObject (void) const { return (elementOf_GGS_typeTableNomRoutinesDeclarees *) mSupPtr ; }
//--- Data member
  public : e_typeTableNomRoutinesDeclarees mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*


#include "include_typeEntityToGenerate.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeExternTypeToGenerate.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeExternTypeToGenerate {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeExternTypeToGenerate * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeExternTypeToGenerate * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeExternTypeToGenerate(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeRoutineAengendrer.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeRoutineAengendrer {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeRoutineAengendrer * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeRoutineAengendrer * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionList & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_typeRoutineAengendrer(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_listTypeToImplement.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_listTypeToImplement {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_listTypeToImplement * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_listTypeToImplement * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_C_listTypeToImplement(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDefinitionTableAimplementer.h"

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefinitionTableAimplementer {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDefinitionTableAimplementer * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDefinitionTableAimplementer * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4,
                                const GGS_insertOrSearchMethodList & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDefinitionTableAimplementer(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_C_mapToImplement.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_mapToImplement {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_C_mapToImplement * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_C_mapToImplement * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_insertOrSearchMethodList & argument_3,
                                const GGS_insertOrSearchMethodList & argument_4 COMMA_LOCATION_ARGS) {
      return new cPtr_C_mapToImplement(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDefClasseAbstraiteAimplementer.h"

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefClasseAbstraiteAimplementer {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDefClasseAbstraiteAimplementer * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDefClasseAbstraiteAimplementer * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDefClasseAbstraiteAimplementer(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeDefClasseNonAbstraiteAimplementer.h"

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefClasseNonAbstraiteAimplementer {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeDefClasseNonAbstraiteAimplementer * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeDefClasseNonAbstraiteAimplementer * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7 COMMA_LOCATION_ARGS) {
      return new cPtr_typeDefClasseNonAbstraiteAimplementer(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeEntiteActionExterne.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteActionExterne {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeEntiteActionExterne * constructor_new (C_Lexique & inLexique,
                                const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeEntiteActionExterne * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_L_EXsignature & argument_0 COMMA_LOCATION_ARGS) {
      return new cPtr_typeEntiteActionExterne(argument_0 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_typeActionExterneAengendrer.h"

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeActionExterneAengendrer {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_typeActionExterneAengendrer * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_typeActionExterneAengendrer * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_L_EXsignature & argument_1 COMMA_LOCATION_ARGS) {
      return new cPtr_typeActionExterneAengendrer(argument_0,
                                argument_1 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@typeEntitiesToGenerateList'                *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_typeEntitiesToGenerateList {
  private : elementOf_GGS_typeEntitiesToGenerateList * mNextItem ;
    public : GGS_typeEntityToGenerate  mEntityToGenerate ;
  public : elementOf_GGS_typeEntitiesToGenerateList (const GGS_typeEntityToGenerate & ) ;

  public : inline elementOf_GGS_typeEntitiesToGenerateList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_typeEntitiesToGenerateList (const elementOf_GGS_typeEntitiesToGenerateList &) ;
  private : void operator = (const elementOf_GGS_typeEntitiesToGenerateList &) ;
  public : inline ~elementOf_GGS_typeEntitiesToGenerateList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_typeEntitiesToGenerateList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of map '@typeEnumCstMessageStringMap'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeEnumCstMessageStringMap {
  public : GGS_lstring  mMessageString ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_typeEnumCstMessageStringMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_typeEnumCstMessageStringMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_typeEnumCstMessageStringMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_typeEnumCstMessageStringMap * nextObject (void) const { return (elementOf_GGS_typeEnumCstMessageStringMap *) mNextItem ; }
  public : inline elementOf_GGS_typeEnumCstMessageStringMap * infObject (void) const { return (elementOf_GGS_typeEnumCstMessageStringMap *) mInfPtr ; }
  public : inline elementOf_GGS_typeEnumCstMessageStringMap * supObject (void) const { return (elementOf_GGS_typeEnumCstMessageStringMap *) mSupPtr ; }
//--- Data member
  public : e_typeEnumCstMessageStringMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_enumGalgasType.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_enumGalgasType {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_enumGalgasType * constructor_new (C_Lexique & inLexique,
                                const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_enumGalgasType * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_lstring & argument_0,
                                const GGS_enumConstantMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2 COMMA_LOCATION_ARGS) {
      return new cPtr_enumGalgasType(argument_0,
                                argument_1,
                                argument_2 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of map '@mapAsConstraintPropertyMap'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_mapAsConstraintPropertyMap {
  public : GGS_lstring  mMapTypeName ;
  public : GGS_lstring  mElementTypeName ;
  public : GGS_uint  mPassIndex ;
  public : GGS_string mPassName ;
  public : GGS_bool mIsShared ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_mapAsConstraintPropertyMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_mapAsConstraintPropertyMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_mapAsConstraintPropertyMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_mapAsConstraintPropertyMap * nextObject (void) const { return (elementOf_GGS_mapAsConstraintPropertyMap *) mNextItem ; }
  public : inline elementOf_GGS_mapAsConstraintPropertyMap * infObject (void) const { return (elementOf_GGS_mapAsConstraintPropertyMap *) mInfPtr ; }
  public : inline elementOf_GGS_mapAsConstraintPropertyMap * supObject (void) const { return (elementOf_GGS_mapAsConstraintPropertyMap *) mSupPtr ; }
//--- Data member
  public : e_mapAsConstraintPropertyMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        Element of map '@passMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

class e_passMap {
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_passMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_passMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_passMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_passMap * nextObject (void) const { return (elementOf_GGS_passMap *) mNextItem ; }
  public : inline elementOf_GGS_passMap * infObject (void) const { return (elementOf_GGS_passMap *) mInfPtr ; }
  public : inline elementOf_GGS_passMap * supObject (void) const { return (elementOf_GGS_passMap *) mSupPtr ; }
//--- Data member
  public : e_passMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@sharedPropertyList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class elementOf_GGS_sharedPropertyList {
  private : elementOf_GGS_sharedPropertyList * mNextItem ;
    public : GGS_lstring  mSharedPropertyTypeName ;
    public : GGS_lstring  mSharedPropertyName ;
  public : elementOf_GGS_sharedPropertyList (const GGS_lstring & ,
                                const GGS_lstring & ) ;

  public : inline elementOf_GGS_sharedPropertyList * nextObject (void) const { return mNextItem ; }
  private : elementOf_GGS_sharedPropertyList (const elementOf_GGS_sharedPropertyList &) ;
  private : void operator = (const elementOf_GGS_sharedPropertyList &) ;
  public : inline ~elementOf_GGS_sharedPropertyList (void) {}
  public : void appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
  friend class GGS_sharedPropertyList ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of map '@callInstructionSharedPropertySignatureMap'         *
//                                                                           *
//---------------------------------------------------------------------------*

class e_callInstructionSharedPropertySignatureMap {
  public : GGS_sharedPropertyList  mSignature ;
  public : GGS_location  mSignatureLocation ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_callInstructionSharedPropertySignatureMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_callInstructionSharedPropertySignatureMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_callInstructionSharedPropertySignatureMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_callInstructionSharedPropertySignatureMap * nextObject (void) const { return (elementOf_GGS_callInstructionSharedPropertySignatureMap *) mNextItem ; }
  public : inline elementOf_GGS_callInstructionSharedPropertySignatureMap * infObject (void) const { return (elementOf_GGS_callInstructionSharedPropertySignatureMap *) mInfPtr ; }
  public : inline elementOf_GGS_callInstructionSharedPropertySignatureMap * supObject (void) const { return (elementOf_GGS_callInstructionSharedPropertySignatureMap *) mSupPtr ; }
//--- Data member
  public : e_callInstructionSharedPropertySignatureMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of map '@constrainedEntityPassMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_constrainedEntityPassMap {
  public : GGS_typeInstructionList  mInstructionList ;
  public : GGS_sharedPropertyList  mSharedPropertyList ;
  public : GGS_stringset  mConstraintPropertyDefinitionSet ;
  public : GGS_callInstructionSharedPropertySignatureMap  mCallInstructionSharedPropertySignatureMap ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_constrainedEntityPassMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_constrainedEntityPassMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_constrainedEntityPassMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_constrainedEntityPassMap * nextObject (void) const { return (elementOf_GGS_constrainedEntityPassMap *) mNextItem ; }
  public : inline elementOf_GGS_constrainedEntityPassMap * infObject (void) const { return (elementOf_GGS_constrainedEntityPassMap *) mInfPtr ; }
  public : inline elementOf_GGS_constrainedEntityPassMap * supObject (void) const { return (elementOf_GGS_constrainedEntityPassMap *) mSupPtr ; }
//--- Data member
  public : e_constrainedEntityPassMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of map '@constraintAllPropertiesMap'                *
//                                                                           *
//---------------------------------------------------------------------------*

class e_constraintAllPropertiesMap {
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_constraintAllPropertiesMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_constraintAllPropertiesMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_constraintAllPropertiesMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_constraintAllPropertiesMap * nextObject (void) const { return (elementOf_GGS_constraintAllPropertiesMap *) mNextItem ; }
  public : inline elementOf_GGS_constraintAllPropertiesMap * infObject (void) const { return (elementOf_GGS_constraintAllPropertiesMap *) mInfPtr ; }
  public : inline elementOf_GGS_constraintAllPropertiesMap * supObject (void) const { return (elementOf_GGS_constraintAllPropertiesMap *) mSupPtr ; }
//--- Data member
  public : e_constraintAllPropertiesMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        Element of map '@indexMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class e_indexMap {
  public : GGS_lstring  mMapTypeName ;
  public : GGS_uint  mPassIndex ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_indexMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_indexMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_indexMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_indexMap * nextObject (void) const { return (elementOf_GGS_indexMap *) mNextItem ; }
  public : inline elementOf_GGS_indexMap * infObject (void) const { return (elementOf_GGS_indexMap *) mInfPtr ; }
  public : inline elementOf_GGS_indexMap * supObject (void) const { return (elementOf_GGS_indexMap *) mSupPtr ; }
//--- Data member
  public : e_indexMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of map '@constrainedEntityMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_constrainedEntityMap {
  public : GGS_stringset  mPassesDefinedByInheritanceTreeRootEntity ;
  public : GGS_constrainedEntityPassMap  mConstrainedEntityPassMap ;
  public : GGS_lstring  mSuperEntityName ;
  public : GGS_entityPropertyMap  mEntityPropertiesMap ;
  public : GGS_stringset  mDescendantEntitySet ;
  public : GGS_location  mEndOfConstraintLocation ;
  public : GGS_mapAsConstraintPropertyMap  mMapAsConstraintPropertyCurrentMap ;
  public : GGS_mapAsConstraintPropertyMap  mAllMapsAsConstraintPropertyMap ;
  public : GGS_constraintAllPropertiesMap  mConstraintAllPropertiesMap ;
  public : GGS_indexMap  mCurrentIndexMap ;
  public : GGS_indexMap  mInheritedIndexMap ;
} ;

//---------------------------------------------------------------------------*

class elementOf_GGS_constrainedEntityMap : public AC_galgas_map_element {
//--- Constructor
  public : elementOf_GGS_constrainedEntityMap (const GGS_lstring & inKey,
                                     const sint32 inIndex,
                                     const e_constrainedEntityMap & inInfo) ;
//--- Get pointers
  public : inline elementOf_GGS_constrainedEntityMap * nextObject (void) const { return (elementOf_GGS_constrainedEntityMap *) mNextItem ; }
  public : inline elementOf_GGS_constrainedEntityMap * infObject (void) const { return (elementOf_GGS_constrainedEntityMap *) mInfPtr ; }
  public : inline elementOf_GGS_constrainedEntityMap * supObject (void) const { return (elementOf_GGS_constrainedEntityMap *) mSupPtr ; }
//--- Data member
  public : e_constrainedEntityMap mInfo ;
//--- Method for 'description' reader
  public : void appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'callInstruction'                           *
//                                                                           *
//---------------------------------------------------------------------------*


#include "include_callInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_callInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_callInstruction {
  #ifndef DO_NOT_GENERATE_CHECKINGS
    public : static cPtr_callInstruction * constructor_new (C_Lexique & inLexique,
                                const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_metamodelPropertyKind& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_L_lstringList & argument_4 COMMA_LOCATION_ARGS) ;
  #else
    public : inline static cPtr_callInstruction * constructor_new (C_Lexique & /* inLexique */,
                                const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_metamodelPropertyKind& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_L_lstringList & argument_4 COMMA_LOCATION_ARGS) {
      return new cPtr_callInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*

#endif
