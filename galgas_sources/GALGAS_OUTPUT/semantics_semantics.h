//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'semantics_semantics.h'                        *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                     october 27th, 2005, at 17h54'29"                      *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#ifndef semantics_semantics_DEFINED
#define semantics_semantics_DEFINED

#include <string.h>

// Include predefined semantics types definition *
#include "galgas/C_GGS_Object.h"
#include "galgas/AC_galgas_io.h"
#include "galgas/GGS_location.h"
#include "galgas/GGS_lbool.h"
#include "galgas/GGS_lchar.h"
#include "galgas/GGS_lstring.h"
#include "galgas/GGS_ldouble.h"
#include "galgas/GGS_luint.h"
#include "galgas/GGS_lsint.h"
#include "galgas/GGS_stringset.h"
#include "galgas/AC_galgas_map.h"
// Include scanner definition *
#include "galgas/C_Lexique.h"
// Include imported semantics *
#include "common_semantics.h"

//---------------------------------------------------------------------------*
//                                                                           *
//   Include directives generated by extern types, methods or attributes     *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cGalgasVariablesMap.h"
#include "cTableMethodesAimplementer.h"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

class cPtr_typeCplusPlusName ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCplusPlusName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCplusPlusName {
  protected : cPtr_typeCplusPlusName * mPointer ;
  public : GGS_typeCplusPlusName (void) ;
  public : GGS_typeCplusPlusName (const GGS_typeCplusPlusName &) ;
  public : virtual ~GGS_typeCplusPlusName (void) ;
  public : void operator = (const GGS_typeCplusPlusName &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_typeCplusPlusName & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeCplusPlusName * inSource) ;
  public : GGS_typeCplusPlusName (cPtr_typeCplusPlusName * inSource) ;
  public : inline cPtr_typeCplusPlusName * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_typeCplusPlusName * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class list 'typeCplusPlusNameList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCplusPlusNameList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeCplusPlusName  mCppName ;
    public : element_type (const GGS_typeCplusPlusName & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeCplusPlusNameList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeCplusPlusNameList (void) ; // Default Constructor
  public : GGS_typeCplusPlusNameList (const GGS_typeCplusPlusNameList &) ; // Copy constructor
  public : void operator = (const GGS_typeCplusPlusNameList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeCplusPlusNameList (void) ;

//--- Constructor 'new'
  public : static GGS_typeCplusPlusNameList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0) ;
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_typeExpression ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeExpression {
  protected : cPtr_typeExpression * mPointer ;
  public : GGS_typeExpression (void) ;
  public : GGS_typeExpression (const GGS_typeExpression &) ;
  public : virtual ~GGS_typeExpression (void) ;
  public : void operator = (const GGS_typeExpression &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_typeExpression & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeExpression * inSource) ;
  public : GGS_typeExpression (cPtr_typeExpression * inSource) ;
  public : inline cPtr_typeExpression * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_typeExpression * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               DECLARATIONS FOR MAP 'typeClassMessagesMap'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeClassMessagesMap {
  public : GGS_lstring  mMessage ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeClassMessagesMap : public AC_galgas_map {
//------------------------ Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeClassMessagesMap & inInfo) ;
  //--- Get pointers
    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : e_typeClassMessagesMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }
  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeClassMessagesMap * operator () (void) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeClassMessagesMap constructor_empty (void) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0) ;
  public : void methode_insertKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_lstring &  inParameter0) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0) ;
  public : void methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                               GGS_lstring & outParameter0,
                                  GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'typeSemanticsTypesList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeSemanticsTypesList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_lstring  mGalgasVariableName ;
    public : element_type (const GGS_AC_galgasType & ,
                                const GGS_lstring & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeSemanticsTypesList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeSemanticsTypesList (void) ; // Default Constructor
  public : GGS_typeSemanticsTypesList (const GGS_typeSemanticsTypesList &) ; // Copy constructor
  public : void operator = (const GGS_typeSemanticsTypesList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeSemanticsTypesList (void) ;

//--- Constructor 'new'
  public : static GGS_typeSemanticsTypesList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_lstring & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map element 'e_typeVariablesMap'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeVariablesMap {
  public : GGS_AC_galgasType  mArgumentType ;
  public : GGS_typeCplusPlusName  mCplusPlusName ;
  public : bool isBuilt (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          map 'typeVariablesMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeVariablesMap : public cGalgasVariablesMap <e_typeVariablesMap> {
//--- Get object pointer
  public : inline GGS_typeVariablesMap * operator () (void) { return this ; }
//--- Handle 'empty' constructor
  public : static GGS_typeVariablesMap constructor_empty (void) ;
//---
public : void methode_searchForReadOnlyAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
public : void methode_searchForReadOnlyAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
//---
public : void methode_searchForDestructiveReadAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
public : void methode_searchForDestructiveReadAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
//---
public : void methode_searchForReadWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
public : void methode_searchForReadWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
//---
public : void methode_searchForWriteAccess (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
public : void methode_searchForWriteAccessGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_AC_galgasType   & outParameter0,
                                GGS_typeCplusPlusName   & outParameter1) ;
//---
public : void methode_insertInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertConstInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertConstInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertUsedConstInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertUsedConstInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertUnusedConstInArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertUnusedConstInArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertLocalVariable (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertLocalVariableGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertInOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertInOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
//---
public : void methode_insertUnusedInOutArgument (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
public : void methode_insertUnusedInOutArgumentGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_AC_galgasType &  inParameter0,
                                const GGS_typeCplusPlusName &  inParameter1) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'L_assignedVariables'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_assignedVariables {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeCplusPlusName  aNomVariableCible ;
    public : GGS_lstring  aNomAttributSource ;
    public : element_type (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_assignedVariables ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_assignedVariables (void) ; // Default Constructor
  public : GGS_L_assignedVariables (const GGS_L_assignedVariables &) ; // Copy constructor
  public : void operator = (const GGS_L_assignedVariables &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_assignedVariables (void) ;

//--- Constructor 'new'
  public : static GGS_L_assignedVariables constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_typeCible ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeCible'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCible {
  protected : cPtr_typeCible * mPointer ;
  public : GGS_typeCible (void) ;
  public : GGS_typeCible (const GGS_typeCible &) ;
  public : virtual ~GGS_typeCible (void) ;
  public : void operator = (const GGS_typeCible &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_typeCible & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeCible * inSource) ;
  public : GGS_typeCible (cPtr_typeCible * inSource) ;
  public : inline cPtr_typeCible * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_typeCible * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class list 'typeListeCibles'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeListeCibles {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeCible  aCible ;
    public : element_type (const GGS_typeCible & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeListeCibles ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeCibles (void) ; // Default Constructor
  public : GGS_typeListeCibles (const GGS_typeListeCibles &) ; // Copy constructor
  public : void operator = (const GGS_typeListeCibles &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeCibles (void) ;

//--- Constructor 'new'
  public : static GGS_typeListeCibles constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeCible & argument_0) ;
  protected : void internalAppendItem (const GGS_typeCible & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class list 'typeListeTypesEtNomsArgMethode'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeListeTypesEtNomsArgMethode {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_AC_galgasType  mType ;
    public : GGS_formalArgumentPassingMode mFormalArgumentPassingMode ;
    public : GGS_typeCplusPlusName  mCppName ;
    public : GGS_bool aModeIn ;
    public : element_type (const GGS_AC_galgasType & ,
                                const GGS_formalArgumentPassingMode& ,
                                const GGS_typeCplusPlusName & ,
                                const GGS_bool& ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeListeTypesEtNomsArgMethode ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeListeTypesEtNomsArgMethode (void) ; // Default Constructor
  public : GGS_typeListeTypesEtNomsArgMethode (const GGS_typeListeTypesEtNomsArgMethode &) ; // Copy constructor
  public : void operator = (const GGS_typeListeTypesEtNomsArgMethode &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeListeTypesEtNomsArgMethode (void) ;

//--- Constructor 'new'
  public : static GGS_typeListeTypesEtNomsArgMethode constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) ;
  protected : void internalAppendItem (const GGS_AC_galgasType & argument_0,
                                const GGS_formalArgumentPassingMode& argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_bool& argument_3) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

class cPtr_typeInstruction ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstruction {
  protected : cPtr_typeInstruction * mPointer ;
  public : GGS_typeInstruction (void) ;
  public : GGS_typeInstruction (const GGS_typeInstruction &) ;
  public : virtual ~GGS_typeInstruction (void) ;
  public : void operator = (const GGS_typeInstruction &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_typeInstruction & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeInstruction * inSource) ;
  public : GGS_typeInstruction (cPtr_typeInstruction * inSource) ;
  public : inline cPtr_typeInstruction * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_typeInstruction * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class list 'typeInstructionsList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionsList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeInstruction  aInstruction ;
    public : element_type (const GGS_typeInstruction & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeInstructionsList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeInstructionsList (void) ; // Default Constructor
  public : GGS_typeInstructionsList (const GGS_typeInstructionsList &) ; // Copy constructor
  public : void operator = (const GGS_typeInstructionsList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeInstructionsList (void) ;

//--- Constructor 'new'
  public : static GGS_typeInstructionsList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeInstruction & argument_0) ;
  protected : void internalAppendItem (const GGS_typeInstruction & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class list 'L_nameWithType'                         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_nameWithType {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  mType ;
    public : GGS_lstring  mName ;
    public : element_type (const GGS_lstring & ,
                                const GGS_lstring & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_nameWithType ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_nameWithType (void) ; // Default Constructor
  public : GGS_L_nameWithType (const GGS_L_nameWithType &) ; // Copy constructor
  public : void operator = (const GGS_L_nameWithType &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_nameWithType (void) ;

//--- Constructor 'new'
  public : static GGS_L_nameWithType constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           class map element 'e_typeTableMethodesAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableMethodesAimplementer {
  public : GGS_L_signature  aListeTypesParametres ;
  public : GGS_typeListeTypesEtNomsArgMethode  aListeTypeEtNomsArguments ;
  public : GGS_typeInstructionsList  mInstructionsList ;
  public : bool isBuilt (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   map 'typeTableMethodesAimplementer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTableMethodesAimplementer : public cTableMethodesAimplementer <e_typeTableMethodesAimplementer> {
//--- Get object pointer
  public : inline GGS_typeTableMethodesAimplementer * operator () (void) { return this ; }
//--- Handle 'empty' constructor
  public : static GGS_typeTableMethodesAimplementer constructor_empty (void) ;
//---
public : void methode_insertAbstract (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) ;
public : void methode_insertAbstractGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) ;
//---
public : void methode_insertNotAbstract (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) ;
public : void methode_insertNotAbstractGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_L_signature &  inParameter0,
                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter1,
                                const GGS_typeInstructionsList &  inParameter2) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'typeExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeExpressionList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeExpression  mExpression ;
    public : element_type (const GGS_typeExpression & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeExpressionList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeExpressionList (void) ; // Default Constructor
  public : GGS_typeExpressionList (const GGS_typeExpressionList &) ; // Copy constructor
  public : void operator = (const GGS_typeExpressionList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeExpressionList (void) ;

//--- Constructor 'new'
  public : static GGS_typeExpressionList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeExpression & argument_0) ;
  protected : void internalAppendItem (const GGS_typeExpression & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class list 'L_expression_instructionsList_list'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_expression_instructionsList_list {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeExpression  mIFexpression ;
    public : GGS_typeInstructionsList  mInstructionsList ;
    public : element_type (const GGS_typeExpression & ,
                                const GGS_typeInstructionsList & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_expression_instructionsList_list ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_expression_instructionsList_list (void) ; // Default Constructor
  public : GGS_L_expression_instructionsList_list (const GGS_L_expression_instructionsList_list &) ; // Copy constructor
  public : void operator = (const GGS_L_expression_instructionsList_list &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_expression_instructionsList_list (void) ;

//--- Constructor 'new'
  public : static GGS_L_expression_instructionsList_list constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) ;
  protected : void internalAppendItem (const GGS_typeExpression & argument_0,
                                const GGS_typeInstructionsList & argument_1) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           DECLARATIONS FOR MAP 'typeTableRoutinesAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableRoutinesAimplementer {
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableRoutinesAimplementer : public AC_galgas_map {
//------------------------ Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableRoutinesAimplementer & inInfo) ;
  //--- Get pointers
    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : e_typeTableRoutinesAimplementer mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }
  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableRoutinesAimplementer * operator () (void) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableRoutinesAimplementer constructor_empty (void) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) ;
  public : void methode_insertKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           DECLARATIONS FOR MAP 'typeTableAttributsSemantiques'            *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableAttributsSemantiques {
  public : GGS_typeCplusPlusName  aNomCppAttribut ;
  public : GGS_AC_galgasType  mAttributType ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableAttributsSemantiques : public AC_galgas_map {
//------------------------ Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableAttributsSemantiques & inInfo) ;
  //--- Get pointers
    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : e_typeTableAttributsSemantiques mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }
  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableAttributsSemantiques * operator () (void) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableAttributsSemantiques constructor_empty (void) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeCplusPlusName &  inParameter0,
                                const GGS_AC_galgasType &  inParameter1) ;
  public : void methode_insertKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeCplusPlusName &  inParameter0,
                                const GGS_AC_galgasType &  inParameter1) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1) ;
  public : void methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeCplusPlusName   & outParameter0,
                                GGS_AC_galgasType   & outParameter1) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  const GGS_typeCplusPlusName & inParameter0,
                                  const GGS_AC_galgasType & inParameter1,
                                  GGS_luint * outIndex) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                               GGS_typeCplusPlusName & outParameter0,
                               GGS_AC_galgasType & outParameter1,
                                  GGS_luint * outIndex) ;
} ;

void routine_buildMapWithLocalConstants (C_Lexique &,
                                GGS_L_nameWithType  ,
                                GGS_typeListeAttributsSemantiques  ,
                                GGS_typeVariablesMap  &,
                                GGS_location  ,
                                GGS_localConstantBuildStyleEnum ,
                                GGS_bool ) ;

void routine_checkAssignmentTypesCompatibility (C_Lexique &,
                                GGS_AC_galgasType  ,
                                GGS_AC_galgasType  ,
                                GGS_location  ) ;

void routine_verifierCompatibiliteTypes (C_Lexique &,
                                GGS_typeSemanticsTypesList  ,
                                GGS_typeListeAttributsSemantiques  ,
                                const GGS_location  &) ;

void routine_verifierCompatibiliteArgEffectifsSignature (C_Lexique &,
                                GGS_L_signature  ,
                                GGS_L_actualParametersSignature  ,
                                const GGS_location  &,
                                GGS_typeInstructionsList  &,
                                GGS_typeExpressionList  &) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'L_matchInstructionCasesList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_L_matchInstructionCasesList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  mCase1_name ;
    public : GGS_lstring  mCase2_name ;
    public : GGS_typeInstructionsList  mInstructionsList ;
    public : element_type (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_typeInstructionsList & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_L_matchInstructionCasesList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_L_matchInstructionCasesList (void) ; // Default Constructor
  public : GGS_L_matchInstructionCasesList (const GGS_L_matchInstructionCasesList &) ; // Copy constructor
  public : void operator = (const GGS_L_matchInstructionCasesList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_L_matchInstructionCasesList (void) ;

//--- Constructor 'new'
  public : static GGS_L_matchInstructionCasesList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeInstructionsList & argument_2) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'foreachEnumerationList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_foreachEnumerationList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeCplusPlusName  mCppEnumeratedVariableName ;
    public : GGS_location  mLocationOffset ;
    public : GGS_string mCppTypeName ;
    public : element_type (const GGS_typeCplusPlusName & ,
                                const GGS_location & ,
                                const GGS_string& ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_foreachEnumerationList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_foreachEnumerationList (void) ; // Default Constructor
  public : GGS_foreachEnumerationList (const GGS_foreachEnumerationList &) ; // Copy constructor
  public : void operator = (const GGS_foreachEnumerationList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_foreachEnumerationList (void) ;

//--- Constructor 'new'
  public : static GGS_foreachEnumerationList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) ;
  protected : void internalAppendItem (const GGS_typeCplusPlusName & argument_0,
                                const GGS_location & argument_1,
                                const GGS_string& argument_2) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class list 'typeStructuredExtractCasesList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStructuredExtractCasesList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_lstring  mClassName ;
    public : GGS_location  mResultVarID ;
    public : GGS_typeInstructionsList  mInstructionsList ;
    public : GGS_bool mNoUsedParameter ;
    public : element_type (const GGS_lstring & ,
                                const GGS_location & ,
                                const GGS_typeInstructionsList & ,
                                const GGS_bool& ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeStructuredExtractCasesList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeStructuredExtractCasesList (void) ; // Default Constructor
  public : GGS_typeStructuredExtractCasesList (const GGS_typeStructuredExtractCasesList &) ; // Copy constructor
  public : void operator = (const GGS_typeStructuredExtractCasesList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeStructuredExtractCasesList (void) ;

//--- Constructor 'new'
  public : static GGS_typeStructuredExtractCasesList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) ;
  protected : void internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeInstructionsList & argument_2,
                                const GGS_bool& argument_3) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           DECLARATIONS FOR MAP 'typeTableNomRoutinesDeclarees'            *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeTableNomRoutinesDeclarees {
} ;

//---------------------------------------------------------------------------*

class GGS_typeTableNomRoutinesDeclarees : public AC_galgas_map {
//------------------------ Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeTableNomRoutinesDeclarees & inInfo) ;
  //--- Get pointers
    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : e_typeTableNomRoutinesDeclarees mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }
  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeTableNomRoutinesDeclarees * operator () (void) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeTableNomRoutinesDeclarees constructor_empty (void) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) ;
  public : void methode_insertKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex) ;
} ;

class cPtr_typeEntityToGenerate ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntityToGenerate'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntityToGenerate {
  protected : cPtr_typeEntityToGenerate * mPointer ;
  public : GGS_typeEntityToGenerate (void) ;
  public : GGS_typeEntityToGenerate (const GGS_typeEntityToGenerate &) ;
  public : virtual ~GGS_typeEntityToGenerate (void) ;
  public : void operator = (const GGS_typeEntityToGenerate &) ;
  public : bool isBuilt (void) const ;
  public : inline bool isEqualTo (const GGS_typeEntityToGenerate & operand_) const {
    return mPointer == operand_.mPointer ;
  }
  public : void operator = (cPtr_typeEntityToGenerate * inSource) ;
  public : GGS_typeEntityToGenerate (cPtr_typeEntityToGenerate * inSource) ;
  public : inline cPtr_typeEntityToGenerate * getPtr (void) const {
    return mPointer ;
  }
  public : void drop_operation (void) ;
  public : cPtr_typeEntityToGenerate * operator () (void) const ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     DECLARATIONS FOR MAP 'stateMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class e_stateMap {
} ;

//---------------------------------------------------------------------------*

class GGS_stateMap : public AC_galgas_map {
//------------------------ Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_stateMap & inInfo) ;
  //--- Get pointers
    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : e_stateMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }
  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_stateMap * operator () (void) { return this ; }
//--- 'empty' constructor
  public : static GGS_stateMap constructor_empty (void) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) ;
  public : void methode_insertKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey) ;
  public : void methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  GGS_luint * outIndex) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'typeEntitiesToGenerateList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntitiesToGenerateList {
  public : class element_type {
    private : element_type * mNextItem ;
    public : GGS_typeEntityToGenerate  mEntityToGenerate ;
    public : element_type (const GGS_typeEntityToGenerate & ) ;

    public : inline element_type * nextObject (void) const { return mNextItem ; }
    private : element_type (const element_type &) ;
    private : void operator = (const element_type &) ;
    public : ~element_type (void) {}
    friend class GGS_typeEntitiesToGenerateList ;
  } ;

  private : element_type * mFirstItem ;
  private : element_type * mLastItem ;
  private : element_type * mCurrentItemPtr ;
  private : sint32 mCurrentItemIndex ;
  private : sint32 mListLength ;
  public : inline sint32 count (void) const {
    return mListLength ;
  }
  private : sint32 * mCountReference ;
  public : GGS_typeEntitiesToGenerateList (void) ; // Default Constructor
  public : GGS_typeEntitiesToGenerateList (const GGS_typeEntitiesToGenerateList &) ; // Copy constructor
  public : void operator = (const GGS_typeEntitiesToGenerateList &) ; // Assignment operator
//--- Virtual destructor
  public : virtual ~GGS_typeEntitiesToGenerateList (void) ;

//--- Constructor 'new'
  public : static GGS_typeEntitiesToGenerateList constructor_empty (void) ;
//--- Get first item
  public : inline element_type * firstObject (void) const { return mFirstItem ; }
  public : void addAssign_operation (const GGS_typeEntityToGenerate & argument_0) ;
  protected : void internalAppendItem (const GGS_typeEntityToGenerate & argument_0) ;
  public : void insulateList (void) ;
  public : void emptyList (void) ;
  public : inline bool isBuilt (void) const {
    return mCountReference != NULL ;
  }
  public : void drop_operation (void) ;
  public : inline GGS_uint reader_length (void)  const {
    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;
  }
} ;

void routine_enterBuiltinTypes (C_Lexique &,
                                GGS_M_semanticsEntitiesForUse  &) ;

//---------------------------------------------------------------------------*
//                                                                           *
//            DECLARATIONS FOR MAP 'typeEnumCstMessageStringMap'             *
//                                                                           *
//---------------------------------------------------------------------------*

class e_typeEnumCstMessageStringMap {
  public : GGS_lstring  mMessageString ;
} ;

//---------------------------------------------------------------------------*

class GGS_typeEnumCstMessageStringMap : public AC_galgas_map {
//------------------------ Internal class for an element
  public : class element_type : public AC_galgas_map_element {
  //--- Constructor
    public : element_type (const GGS_lstring & inKey,
                           const sint32 inIndex,
                           const e_typeEnumCstMessageStringMap & inInfo) ;
  //--- Get pointers
    public : inline element_type * nextObject (void) const { return (element_type *) mNextItem ; }
    public : inline element_type * infObject (void) const { return (element_type *) mInfPtr ; }
    public : inline element_type * supObject (void) const { return (element_type *) mSupPtr ; }
  //--- Data members
    public : e_typeEnumCstMessageStringMap mInfo ;
  } ;
//--- Get pointers
  public : inline element_type * rootObject (void) const { return (element_type *) mRoot ; }
  public : inline element_type * firstObject (void) const { return (element_type *) mFirstItem ; }
  public : inline element_type * lastObject (void) const { return (element_type *) mLastItem ; }
//--- Create a new element
  protected : virtual AC_galgas_map_element * new_element (const GGS_lstring & inKey, void * inInfo) ;
//--- Get object pointer (for method call)
  public : inline GGS_typeEnumCstMessageStringMap * operator () (void) { return this ; }
//--- 'empty' constructor
  public : static GGS_typeEnumCstMessageStringMap constructor_empty (void) ;
//--- Method used for duplicate a map
  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;
//--- 'insertKey' Insert Method
  public : void methode_insertKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0) ;
  public : void methode_insertKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_lstring &  inParameter0) ;
//--- 'searchKey' Search Method
  public : void methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0) ;
  public : void methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0) ;
//--- Internal method for inserting an element
  protected : void insertElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                                  const GGS_lstring & inParameter0,
                                  GGS_luint * outIndex) ;
//--- Internal method for searching for an element
  protected : void searchElement (C_Lexique & inLexique,
                                  const char * inErrorMessagesArray [],
                                  const GGS_lstring & inKey,
                               GGS_lstring & outParameter0,
                                  GGS_luint * outIndex) ;
} ;

void appendJokersIfNeeded (C_Lexique &,
                                GGS_typeCplusPlusNameList  &,
                                GGS_uint  ,
                                GGS_uint  ,
                                GGS_typeCplusPlusName  ) ;

#include "include_typeCplusPlusName.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeDirectName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeDirectName

#define macroInheritFrom_typeDirectName

class cPtr_typeDirectName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeDirectName
  public : cPtr_typeDirectName (const GGS_lstring & ) ;
  public : GGS_lstring  mName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeDirectName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDirectName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeDirectName * constructor_new (const GGS_lstring & argument_0) ;
  #else
    public : inline static cPtr_typeDirectName * constructor_new (const GGS_lstring & argument_0) {
      return new cPtr_typeDirectName(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCppThisName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeCppThisName

#define macroInheritFrom_typeCppThisName

class cPtr_typeCppThisName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeCppThisName
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeCppThisName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCppThisName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeCppThisName * constructor_new () ;
  #else
    public : inline static cPtr_typeCppThisName * constructor_new () {
      return new cPtr_typeCppThisName() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeCppInheritedName'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeCppInheritedName

#define macroInheritFrom_typeCppInheritedName

class cPtr_typeCppInheritedName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeCppInheritedName
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeCppInheritedName'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeCppInheritedName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeCppInheritedName * constructor_new () ;
  #else
    public : inline static cPtr_typeCppInheritedName * constructor_new () {
      return new cPtr_typeCppInheritedName() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAutomaticName'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeAutomaticName

#define macroInheritFrom_typeAutomaticName

class cPtr_typeAutomaticName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeAutomaticName
  public : cPtr_typeAutomaticName (const GGS_lstring & ) ;
  public : GGS_lstring  mName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAutomaticName'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAutomaticName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeAutomaticName * constructor_new (const GGS_lstring & argument_0) ;
  #else
    public : inline static cPtr_typeAutomaticName * constructor_new (const GGS_lstring & argument_0) {
      return new cPtr_typeAutomaticName(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLocationAutomaticName'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeLocationAutomaticName

#define macroInheritFrom_typeLocationAutomaticName

class cPtr_typeLocationAutomaticName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeLocationAutomaticName
  public : cPtr_typeLocationAutomaticName (const GGS_location & ) ;
  public : GGS_location  mLocation ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLocationAutomaticName'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLocationAutomaticName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeLocationAutomaticName * constructor_new (const GGS_location & argument_0) ;
  #else
    public : inline static cPtr_typeLocationAutomaticName * constructor_new (const GGS_location & argument_0) {
      return new cPtr_typeLocationAutomaticName(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOperandName'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeOperandName

#define macroInheritFrom_typeOperandName

class cPtr_typeOperandName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeOperandName
  public : cPtr_typeOperandName (const GGS_lstring & ,
                                const GGS_location & ,
                                const GGS_bool& ) ;
  public : GGS_lstring  mName ;
  public : GGS_location  mLocationOffset ;
  public : GGS_bool mFieldKind ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOperandName'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeOperandName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeOperandName * constructor_new (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2) ;
  #else
    public : inline static cPtr_typeOperandName * constructor_new (const GGS_lstring & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2) {
      return new cPtr_typeOperandName(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeKeyName'                             *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeKeyName

#define macroInheritFrom_typeKeyName

class cPtr_typeKeyName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeKeyName
  public : cPtr_typeKeyName (const GGS_location & ) ;
  public : GGS_location  mLocationOffset ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeKeyName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeKeyName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeKeyName * constructor_new (const GGS_location & argument_0) ;
  #else
    public : inline static cPtr_typeKeyName * constructor_new (const GGS_location & argument_0) {
      return new cPtr_typeKeyName(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeNullName'                            *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeNullName

#define macroInheritFrom_typeNullName

class cPtr_typeNullName : public cPtr_typeCplusPlusName {
  private : typedef cPtr_typeCplusPlusName inherited ;
  macroInheritFrom_typeCplusPlusName
  macro_typeNullName
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeNullName'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeNullName {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeNullName * constructor_new () ;
  #else
    public : inline static cPtr_typeNullName * constructor_new () {
      return new cPtr_typeNullName() ;
    }
  #endif
} ;

#include "include_typeExpression.h"

#include "include_typeCible.h"

#include "include_typeInstruction.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeErrorInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeErrorInstruction

#define macroInheritFrom_typeErrorInstruction

class cPtr_typeErrorInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeErrorInstruction
  public : cPtr_typeErrorInstruction (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mErrorLocationExpression ;
  public : GGS_typeExpression  mErrorMessageExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeErrorInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeErrorInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeErrorInstruction * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeErrorInstruction * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeErrorInstruction(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeWarningInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeWarningInstruction

#define macroInheritFrom_typeWarningInstruction

class cPtr_typeWarningInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeWarningInstruction
  public : cPtr_typeWarningInstruction (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mWarningLocationExpression ;
  public : GGS_typeExpression  mWarningMessageExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeWarningInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeWarningInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeWarningInstruction * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeWarningInstruction * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeWarningInstruction(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeMessageInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeMessageInstruction

#define macroInheritFrom_typeMessageInstruction

class cPtr_typeMessageInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeMessageInstruction
  public : cPtr_typeMessageInstruction (const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mMessageExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeMessageInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMessageInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeMessageInstruction * constructor_new (const GGS_typeExpression & argument_0) ;
  #else
    public : inline static cPtr_typeMessageInstruction * constructor_new (const GGS_typeExpression & argument_0) {
      return new cPtr_typeMessageInstruction(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeReaderCallInstruction

#define macroInheritFrom_typeReaderCallInstruction

class cPtr_typeReaderCallInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeReaderCallInstruction
  public : cPtr_typeReaderCallInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_typeCplusPlusName  aNomCppVariable ;
  public : GGS_lstring  aNomMethodeSimple ;
  public : GGS_typeExpressionList  mExpressionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeReaderCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeReaderCallInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeReaderCallInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) ;
  #else
    public : inline static cPtr_typeReaderCallInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
      return new cPtr_typeReaderCallInstruction(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeModifierCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeModifierCallInstruction

#define macroInheritFrom_typeModifierCallInstruction

class cPtr_typeModifierCallInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeModifierCallInstruction
  public : cPtr_typeModifierCallInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_typeCplusPlusName  aNomCppVariable ;
  public : GGS_lstring  aNomMethodeSimple ;
  public : GGS_typeExpressionList  mExpressionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeModifierCallInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeModifierCallInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeModifierCallInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) ;
  #else
    public : inline static cPtr_typeModifierCallInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
      return new cPtr_typeModifierCallInstruction(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeInstructionAppelMethodeListe'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeInstructionAppelMethodeListe

#define macroInheritFrom_typeInstructionAppelMethodeListe

class cPtr_typeInstructionAppelMethodeListe : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeInstructionAppelMethodeListe
  public : cPtr_typeInstructionAppelMethodeListe (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_typeCplusPlusNameList & ) ;
  public : GGS_typeCplusPlusName  aNomCppAttribut ;
  public : GGS_lstring  aMethodeDeListe ;
  public : GGS_typeCplusPlusNameList  aListeNomsCppArguments ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelMethodeListe'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionAppelMethodeListe {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeInstructionAppelMethodeListe * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2) ;
  #else
    public : inline static cPtr_typeInstructionAppelMethodeListe * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusNameList & argument_2) {
      return new cPtr_typeInstructionAppelMethodeListe(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeInstructionDeclarationVarLocale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeInstructionDeclarationVarLocale

#define macroInheritFrom_typeInstructionDeclarationVarLocale

class cPtr_typeInstructionDeclarationVarLocale : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeInstructionDeclarationVarLocale
  public : cPtr_typeInstructionDeclarationVarLocale (const GGS_typeCplusPlusName & ,
                                const GGS_AC_galgasType & ) ;
  public : GGS_typeCplusPlusName  aNomCppVariable ;
  public : GGS_AC_galgasType  aTypeVariable ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeInstructionDeclarationVarLocale'           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionDeclarationVarLocale {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeInstructionDeclarationVarLocale * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1) ;
  #else
    public : inline static cPtr_typeInstructionDeclarationVarLocale * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_AC_galgasType & argument_1) {
      return new cPtr_typeInstructionDeclarationVarLocale(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockPrologueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeMapBlockPrologueInstruction

#define macroInheritFrom_typeMapBlockPrologueInstruction

class cPtr_typeMapBlockPrologueInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeMapBlockPrologueInstruction
  public : cPtr_typeMapBlockPrologueInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_typeCplusPlusName  aNomVariableTable ;
  public : GGS_lstring  aNomMethodeBloc ;
  public : GGS_typeExpressionList  mPrologueExpressionList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockPrologueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMapBlockPrologueInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeMapBlockPrologueInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) ;
  #else
    public : inline static cPtr_typeMapBlockPrologueInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
      return new cPtr_typeMapBlockPrologueInstruction(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeMapBlockEpilogueInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeMapBlockEpilogueInstruction

#define macroInheritFrom_typeMapBlockEpilogueInstruction

class cPtr_typeMapBlockEpilogueInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeMapBlockEpilogueInstruction
  public : cPtr_typeMapBlockEpilogueInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_typeCplusPlusName  aNomVariableTable ;
  public : GGS_lstring  aNomMethodeBloc ;
  public : GGS_typeExpressionList  mEpilogueExpressionList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeMapBlockEpilogueInstruction'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMapBlockEpilogueInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeMapBlockEpilogueInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) ;
  #else
    public : inline static cPtr_typeMapBlockEpilogueInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
      return new cPtr_typeMapBlockEpilogueInstruction(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeReaderCallInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeReaderCallInExpression

#define macroInheritFrom_typeReaderCallInExpression

class cPtr_typeReaderCallInExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeReaderCallInExpression
  public : cPtr_typeReaderCallInExpression (const GGS_typeExpression & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_typeExpression  mExpressionValue ;
  public : GGS_lstring  mReaderName ;
  public : GGS_typeExpressionList  mExpressionList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeReaderCallInExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeReaderCallInExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeReaderCallInExpression * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) ;
  #else
    public : inline static cPtr_typeReaderCallInExpression * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
      return new cPtr_typeReaderCallInExpression(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeAndOperation'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeAndOperation

#define macroInheritFrom_typeAndOperation

class cPtr_typeAndOperation : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeAndOperation
  public : cPtr_typeAndOperation (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAndOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAndOperation {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeAndOperation * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeAndOperation * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeAndOperation(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeOrOperation'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeOrOperation

#define macroInheritFrom_typeOrOperation

class cPtr_typeOrOperation : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeOrOperation
  public : cPtr_typeOrOperation (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeOrOperation'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeOrOperation {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeOrOperation * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeOrOperation * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeOrOperation(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConcatOperation'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeConcatOperation

#define macroInheritFrom_typeConcatOperation

class cPtr_typeConcatOperation : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeConcatOperation
  public : cPtr_typeConcatOperation (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConcatOperation'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConcatOperation {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeConcatOperation * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeConcatOperation * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeConcatOperation(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeTrueBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeTrueBool

#define macroInheritFrom_typeTrueBool

class cPtr_typeTrueBool : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeTrueBool
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeTrueBool'                       *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTrueBool {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeTrueBool * constructor_new () ;
  #else
    public : inline static cPtr_typeTrueBool * constructor_new () {
      return new cPtr_typeTrueBool() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFalseBool'                            *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeFalseBool

#define macroInheritFrom_typeFalseBool

class cPtr_typeFalseBool : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeFalseBool
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFalseBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeFalseBool {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeFalseBool * constructor_new () ;
  #else
    public : inline static cPtr_typeFalseBool * constructor_new () {
      return new cPtr_typeFalseBool() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeLiteralStringExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeLiteralStringExpression

#define macroInheritFrom_typeLiteralStringExpression

class cPtr_typeLiteralStringExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeLiteralStringExpression
  public : cPtr_typeLiteralStringExpression (const GGS_lstring & ) ;
  public : GGS_lstring  mLiteralString ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLiteralStringExpression'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralStringExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeLiteralStringExpression * constructor_new (const GGS_lstring & argument_0) ;
  #else
    public : inline static cPtr_typeLiteralStringExpression * constructor_new (const GGS_lstring & argument_0) {
      return new cPtr_typeLiteralStringExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralUIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeLiteralUIntExpression

#define macroInheritFrom_typeLiteralUIntExpression

class cPtr_typeLiteralUIntExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeLiteralUIntExpression
  public : cPtr_typeLiteralUIntExpression (const GGS_luint & ) ;
  public : GGS_luint  mLiteralInt ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralUIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralUIntExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeLiteralUIntExpression * constructor_new (const GGS_luint & argument_0) ;
  #else
    public : inline static cPtr_typeLiteralUIntExpression * constructor_new (const GGS_luint & argument_0) {
      return new cPtr_typeLiteralUIntExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralSIntExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeLiteralSIntExpression

#define macroInheritFrom_typeLiteralSIntExpression

class cPtr_typeLiteralSIntExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeLiteralSIntExpression
  public : cPtr_typeLiteralSIntExpression (const GGS_lsint & ) ;
  public : GGS_lsint  mLiteralInt ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralSIntExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralSIntExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeLiteralSIntExpression * constructor_new (const GGS_lsint & argument_0) ;
  #else
    public : inline static cPtr_typeLiteralSIntExpression * constructor_new (const GGS_lsint & argument_0) {
      return new cPtr_typeLiteralSIntExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeLiteralCharExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeLiteralCharExpression

#define macroInheritFrom_typeLiteralCharExpression

class cPtr_typeLiteralCharExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeLiteralCharExpression
  public : cPtr_typeLiteralCharExpression (const GGS_lchar & ) ;
  public : GGS_lchar  mLiteralChar ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLiteralCharExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeLiteralCharExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeLiteralCharExpression * constructor_new (const GGS_lchar & argument_0) ;
  #else
    public : inline static cPtr_typeLiteralCharExpression * constructor_new (const GGS_lchar & argument_0) {
      return new cPtr_typeLiteralCharExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeHereExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeHereExpression

#define macroInheritFrom_typeHereExpression

class cPtr_typeHereExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeHereExpression
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeHereExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeHereExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeHereExpression * constructor_new () ;
  #else
    public : inline static cPtr_typeHereExpression * constructor_new () {
      return new cPtr_typeHereExpression() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeConstructorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeConstructorExpression

#define macroInheritFrom_typeConstructorExpression

class cPtr_typeConstructorExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeConstructorExpression
  public : cPtr_typeConstructorExpression (const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_lstring  mClassName ;
  public : GGS_lstring  mClassMethodName ;
  public : GGS_typeExpressionList  mExpressionList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeConstructorExpression'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeConstructorExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeConstructorExpression * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) ;
  #else
    public : inline static cPtr_typeConstructorExpression * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2) {
      return new cPtr_typeConstructorExpression(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTestComplement'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeTestComplement

#define macroInheritFrom_typeTestComplement

class cPtr_typeTestComplement : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeTestComplement
  public : cPtr_typeTestComplement (const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mTest ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeTestComplement'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTestComplement {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeTestComplement * constructor_new (const GGS_typeExpression & argument_0) ;
  #else
    public : inline static cPtr_typeTestComplement * constructor_new (const GGS_typeExpression & argument_0) {
      return new cPtr_typeTestComplement(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeBoolOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeBoolOption

#define macroInheritFrom_typeBoolOption

class cPtr_typeBoolOption : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeBoolOption
  public : cPtr_typeBoolOption (const GGS_lstring & ,
                                const GGS_lstring & ) ;
  public : GGS_lstring  mOptionComponentName ;
  public : GGS_lstring  mOptionName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeBoolOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeBoolOption {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeBoolOption * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  #else
    public : inline static cPtr_typeBoolOption * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
      return new cPtr_typeBoolOption(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeUIntOption'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeUIntOption

#define macroInheritFrom_typeUIntOption

class cPtr_typeUIntOption : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeUIntOption
  public : cPtr_typeUIntOption (const GGS_lstring & ,
                                const GGS_lstring & ) ;
  public : GGS_lstring  mOptionComponentName ;
  public : GGS_lstring  mOptionName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUIntOption'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeUIntOption {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeUIntOption * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  #else
    public : inline static cPtr_typeUIntOption * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
      return new cPtr_typeUIntOption(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeVarInExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeVarInExpression

#define macroInheritFrom_typeVarInExpression

class cPtr_typeVarInExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeVarInExpression
  public : cPtr_typeVarInExpression (const GGS_typeCplusPlusName & ) ;
  public : GGS_typeCplusPlusName  mCppVarName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeVarInExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeVarInExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeVarInExpression * constructor_new (const GGS_typeCplusPlusName & argument_0) ;
  #else
    public : inline static cPtr_typeVarInExpression * constructor_new (const GGS_typeCplusPlusName & argument_0) {
      return new cPtr_typeVarInExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeJokerInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeJokerInExpression

#define macroInheritFrom_typeJokerInExpression

class cPtr_typeJokerInExpression : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeJokerInExpression
  public : cPtr_typeJokerInExpression (const GGS_location & ) ;
  public : GGS_location  mLocation ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeJokerInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeJokerInExpression {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeJokerInExpression * constructor_new (const GGS_location & argument_0) ;
  #else
    public : inline static cPtr_typeJokerInExpression * constructor_new (const GGS_location & argument_0) {
      return new cPtr_typeJokerInExpression(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEqualTest'                            *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeEqualTest

#define macroInheritFrom_typeEqualTest

class cPtr_typeEqualTest : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeEqualTest
  public : cPtr_typeEqualTest (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeEqualTest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEqualTest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeEqualTest(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeNonEqualTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeNonEqualTest

#define macroInheritFrom_typeNonEqualTest

class cPtr_typeNonEqualTest : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeNonEqualTest
  public : cPtr_typeNonEqualTest (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeNonEqualTest'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeNonEqualTest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeNonEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeNonEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeNonEqualTest(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictInfTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeStrictInfTest

#define macroInheritFrom_typeStrictInfTest

class cPtr_typeStrictInfTest : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeStrictInfTest
  public : cPtr_typeStrictInfTest (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictInfTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStrictInfTest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeStrictInfTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeStrictInfTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeStrictInfTest(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeInfOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeInfOrEqualTest

#define macroInheritFrom_typeInfOrEqualTest

class cPtr_typeInfOrEqualTest : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeInfOrEqualTest
  public : cPtr_typeInfOrEqualTest (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeInfOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInfOrEqualTest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeInfOrEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeInfOrEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeInfOrEqualTest(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeStrictSupTest'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeStrictSupTest

#define macroInheritFrom_typeStrictSupTest

class cPtr_typeStrictSupTest : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeStrictSupTest
  public : cPtr_typeStrictSupTest (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeStrictSupTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStrictSupTest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeStrictSupTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeStrictSupTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeStrictSupTest(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeSupOrEqualTest'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeSupOrEqualTest

#define macroInheritFrom_typeSupOrEqualTest

class cPtr_typeSupOrEqualTest : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeSupOrEqualTest
  public : cPtr_typeSupOrEqualTest (const GGS_typeExpression & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeExpression  mLeftExpression ;
  public : GGS_typeExpression  mRightExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeSupOrEqualTest'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeSupOrEqualTest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeSupOrEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_typeSupOrEqualTest * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_typeSupOrEqualTest(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeTextTableCall'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeTextTableCall

#define macroInheritFrom_typeTextTableCall

class cPtr_typeTextTableCall : public cPtr_typeExpression {
  private : typedef cPtr_typeExpression inherited ;
  macroInheritFrom_typeExpression
  macro_typeTextTableCall
  public : cPtr_typeTextTableCall (const GGS_typeExpression & ,
                                const GGS_lstring & ,
                                const GGS_typeCplusPlusName & ) ;
  public : GGS_typeExpression  mExpression ;
  public : GGS_lstring  aNomMethodeTest ;
  public : GGS_typeCplusPlusName  aNomCppClef ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeTextTableCall'                    *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeTextTableCall {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeTextTableCall * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2) ;
  #else
    public : inline static cPtr_typeTextTableCall * constructor_new (const GGS_typeExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeCplusPlusName & argument_2) {
      return new cPtr_typeTextTableCall(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'C_assignmentInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_assignmentInstruction

#define macroInheritFrom_C_assignmentInstruction

class cPtr_C_assignmentInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_C_assignmentInstruction
  public : cPtr_C_assignmentInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_typeExpression & ) ;
  public : GGS_typeCplusPlusName  mTargetVarCppName ;
  public : GGS_typeExpression  mSourceExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_C_assignmentInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_assignmentInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_assignmentInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1) ;
  #else
    public : inline static cPtr_C_assignmentInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpression & argument_1) {
      return new cPtr_C_assignmentInstruction(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'C_declarationInstructionWithAssignment'               *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_declarationInstructionWithAssignment

#define macroInheritFrom_C_declarationInstructionWithAssignment

class cPtr_C_declarationInstructionWithAssignment : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_C_declarationInstructionWithAssignment
  public : cPtr_C_declarationInstructionWithAssignment (const GGS_AC_galgasType & ,
                                const GGS_typeCplusPlusName & ,
                                const GGS_typeExpression & ) ;
  public : GGS_AC_galgasType  mVariableType ;
  public : GGS_typeCplusPlusName  mTargetVarCppName ;
  public : GGS_typeExpression  mSourceExpression ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_C_declarationInstructionWithAssignment'          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_declarationInstructionWithAssignment {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_declarationInstructionWithAssignment * constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2) ;
  #else
    public : inline static cPtr_C_declarationInstructionWithAssignment * constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_typeExpression & argument_2) {
      return new cPtr_C_declarationInstructionWithAssignment(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_if_instruction'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_if_instruction

#define macroInheritFrom_C_if_instruction

class cPtr_C_if_instruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_C_if_instruction
  public : cPtr_C_if_instruction (const GGS_L_expression_instructionsList_list & ,
                                const GGS_typeInstructionsList & ) ;
  public : GGS_L_expression_instructionsList_list  mIFbranchesList ;
  public : GGS_typeInstructionsList  mElseInstructionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_if_instruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_if_instruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_if_instruction * constructor_new (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionsList & argument_1) ;
  #else
    public : inline static cPtr_C_if_instruction * constructor_new (const GGS_L_expression_instructionsList_list & argument_0,
                                const GGS_typeInstructionsList & argument_1) {
      return new cPtr_C_if_instruction(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'typeJoker'                              *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeJoker

#define macroInheritFrom_typeJoker

class cPtr_typeJoker : public cPtr_typeCible {
  private : typedef cPtr_typeCible inherited ;
  macroInheritFrom_typeCible
  macro_typeJoker
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_verifierType (C_Lexique &,
                                GGS_AC_galgasType  ,
                                GGS_lstring & ,
                                GGS_L_assignedVariables & ,
                                GGS_typeCplusPlusNameList & ) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       GALGAS class 'GGS_typeJoker'                        *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeJoker {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeJoker * constructor_new () ;
  #else
    public : inline static cPtr_typeJoker * constructor_new () {
      return new cPtr_typeJoker() ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeEntiteDest'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeEntiteDest

#define macroInheritFrom_typeEntiteDest

class cPtr_typeEntiteDest : public cPtr_typeCible {
  private : typedef cPtr_typeCible inherited ;
  macroInheritFrom_typeCible
  macro_typeEntiteDest
  public : cPtr_typeEntiteDest (const GGS_AC_galgasType & ,
                                const GGS_typeCplusPlusName & ,
                                const GGS_location & ) ;
  public : GGS_AC_galgasType  aTypeVarDest ;
  public : GGS_typeCplusPlusName  mCppName ;
  public : GGS_location  aPositionVariableCible ;
  public : virtual bool isBuilt (void) const ;

  public : virtual void methode_verifierType (C_Lexique &,
                                GGS_AC_galgasType  ,
                                GGS_lstring & ,
                                GGS_L_assignedVariables & ,
                                GGS_typeCplusPlusNameList & ) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeEntiteDest'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteDest {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeEntiteDest * constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2) ;
  #else
    public : inline static cPtr_typeEntiteDest * constructor_new (const GGS_AC_galgasType & argument_0,
                                const GGS_typeCplusPlusName & argument_1,
                                const GGS_location & argument_2) {
      return new cPtr_typeEntiteDest(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeEntiteNonTerminal'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeEntiteNonTerminal

#define macroInheritFrom_typeEntiteNonTerminal

class cPtr_typeEntiteNonTerminal : public cPtr_AC_semanticsEntity {
  private : typedef cPtr_AC_semanticsEntity inherited ;
  macroInheritFrom_AC_semanticsEntity
  macro_typeEntiteNonTerminal
  public : cPtr_typeEntiteNonTerminal (const GGS_M_nonterminalSymbolAlts & ) ;
  public : GGS_M_nonterminalSymbolAlts  mAltParametersMap ;
  public : virtual bool isBuilt (void) const ;

  public : virtual const char * message_messageTypeEntite (void) const ;
  public : static const char * static_string_message_messageTypeEntite (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEntiteNonTerminal'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteNonTerminal {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeEntiteNonTerminal * constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) ;
  #else
    public : inline static cPtr_typeEntiteNonTerminal * constructor_new (const GGS_M_nonterminalSymbolAlts & argument_0) {
      return new cPtr_typeEntiteNonTerminal(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'C_grammarInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_grammarInstruction

#define macroInheritFrom_C_grammarInstruction

class cPtr_C_grammarInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_C_grammarInstruction
  public : cPtr_C_grammarInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_typeExpressionList & ,
                                const GGS_lstring & ) ;
  public : GGS_typeCplusPlusName  mSourceFileCppName ;
  public : GGS_lstring  mGrammarName ;
  public : GGS_typeExpressionList  mExpressionsList ;
  public : GGS_lstring  mAltSymbol ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_grammarInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_grammarInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_grammarInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3) ;
  #else
    public : inline static cPtr_C_grammarInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeExpressionList & argument_2,
                                const GGS_lstring & argument_3) {
      return new cPtr_C_grammarInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeAppendInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeAppendInstruction

#define macroInheritFrom_typeAppendInstruction

class cPtr_typeAppendInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeAppendInstruction
  public : cPtr_typeAppendInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_typeCplusPlusName  mTargetVarCppName ;
  public : GGS_typeExpressionList  mSourceExpressions ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeAppendInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAppendInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeAppendInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1) ;
  #else
    public : inline static cPtr_typeAppendInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1) {
      return new cPtr_typeAppendInstruction(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeIncrementInstruction'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeIncrementInstruction

#define macroInheritFrom_typeIncrementInstruction

class cPtr_typeIncrementInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeIncrementInstruction
  public : cPtr_typeIncrementInstruction (const GGS_typeCplusPlusName & ) ;
  public : GGS_typeCplusPlusName  mTargetVarCppName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeIncrementInstruction'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeIncrementInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeIncrementInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0) ;
  #else
    public : inline static cPtr_typeIncrementInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0) {
      return new cPtr_typeIncrementInstruction(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'typeAppendInstructionWithAssignment'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeAppendInstructionWithAssignment

#define macroInheritFrom_typeAppendInstructionWithAssignment

class cPtr_typeAppendInstructionWithAssignment : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeAppendInstructionWithAssignment
  public : cPtr_typeAppendInstructionWithAssignment (const GGS_typeCplusPlusName & ,
                                const GGS_typeExpressionList & ,
                                const GGS_typeCplusPlusName & ) ;
  public : GGS_typeCplusPlusName  mTargetVarCppName ;
  public : GGS_typeExpressionList  mSourceExpressions ;
  public : GGS_typeCplusPlusName  m_luint_TargetVarCppName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeAppendInstructionWithAssignment'           *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeAppendInstructionWithAssignment {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeAppendInstructionWithAssignment * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2) ;
  #else
    public : inline static cPtr_typeAppendInstructionWithAssignment * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_typeCplusPlusName & argument_2) {
      return new cPtr_typeAppendInstructionWithAssignment(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionAppelActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeInstructionAppelActionExterne

#define macroInheritFrom_typeInstructionAppelActionExterne

class cPtr_typeInstructionAppelActionExterne : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeInstructionAppelActionExterne
  public : cPtr_typeInstructionAppelActionExterne (const GGS_lstring & ,
                                const GGS_typeExpressionList & ,
                                const GGS_L_signature & ) ;
  public : GGS_lstring  aNomAction ;
  public : GGS_typeExpressionList  mExpressionsList ;
  public : GGS_L_signature  aListeTypesParametresFormels ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionAppelActionExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeInstructionAppelActionExterne {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeInstructionAppelActionExterne * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_signature & argument_2) ;
  #else
    public : inline static cPtr_typeInstructionAppelActionExterne * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1,
                                const GGS_L_signature & argument_2) {
      return new cPtr_typeInstructionAppelActionExterne(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeMatchInstruction'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeMatchInstruction

#define macroInheritFrom_typeMatchInstruction

class cPtr_typeMatchInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeMatchInstruction
  public : cPtr_typeMatchInstruction (const GGS_location & ,
                                const GGS_location & ,
                                const GGS_typeCplusPlusName & ,
                                const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_lstring & ,
                                const GGS_bool& ,
                                const GGS_bool& ,
                                const GGS_L_matchInstructionCasesList & ,
                                const GGS_typeInstructionsList & ) ;
  public : GGS_location  aIndicatif1 ;
  public : GGS_location  aIndicatif2 ;
  public : GGS_typeCplusPlusName  aNomCppVariable1 ;
  public : GGS_typeCplusPlusName  aNomCppVariable2 ;
  public : GGS_lstring  aNomTypeBase1 ;
  public : GGS_lstring  aNomTypeBase2 ;
  public : GGS_bool mOperand1_isEnumeration ;
  public : GGS_bool mOperand2_isEnumeration ;
  public : GGS_L_matchInstructionCasesList  aListeCas ;
  public : GGS_typeInstructionsList  mElseInstructionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeMatchInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeMatchInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeMatchInstruction * constructor_new (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionsList & argument_9) ;
  #else
    public : inline static cPtr_typeMatchInstruction * constructor_new (const GGS_location & argument_0,
                                const GGS_location & argument_1,
                                const GGS_typeCplusPlusName & argument_2,
                                const GGS_typeCplusPlusName & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_bool& argument_6,
                                const GGS_bool& argument_7,
                                const GGS_L_matchInstructionCasesList & argument_8,
                                const GGS_typeInstructionsList & argument_9) {
      return new cPtr_typeMatchInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeForeachInstruction'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeForeachInstruction

#define macroInheritFrom_typeForeachInstruction

class cPtr_typeForeachInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeForeachInstruction
  public : cPtr_typeForeachInstruction (const GGS_foreachEnumerationList & ,
                                const GGS_typeExpression & ,
                                const GGS_typeInstructionsList & ) ;
  public : GGS_foreachEnumerationList  mForeachEnumerationList ;
  public : GGS_typeExpression  mWhileExpression ;
  public : GGS_typeInstructionsList  mInstructionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeForeachInstruction'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeForeachInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeForeachInstruction * constructor_new (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionsList & argument_2) ;
  #else
    public : inline static cPtr_typeForeachInstruction * constructor_new (const GGS_foreachEnumerationList & argument_0,
                                const GGS_typeExpression & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
      return new cPtr_typeForeachInstruction(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeSimpleExtractInstruction'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeSimpleExtractInstruction

#define macroInheritFrom_typeSimpleExtractInstruction

class cPtr_typeSimpleExtractInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeSimpleExtractInstruction
  public : cPtr_typeSimpleExtractInstruction (const GGS_typeCplusPlusName & ,
                                const GGS_lstring & ,
                                const GGS_L_assignedVariables & ,
                                const GGS_typeExpression & ,
                                const GGS_lstring & ) ;
  public : GGS_typeCplusPlusName  aNomVariable ;
  public : GGS_lstring  aNomClasse ;
  public : GGS_L_assignedVariables  aListeAffectationParametresEffectifs ;
  public : GGS_typeExpression  mErrorLocationExpression ;
  public : GGS_lstring  aNomMessage ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeSimpleExtractInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeSimpleExtractInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeSimpleExtractInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4) ;
  #else
    public : inline static cPtr_typeSimpleExtractInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_assignedVariables & argument_2,
                                const GGS_typeExpression & argument_3,
                                const GGS_lstring & argument_4) {
      return new cPtr_typeSimpleExtractInstruction(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'typeStructuredExtractInstructionWithElse'              *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeStructuredExtractInstructionWithElse

#define macroInheritFrom_typeStructuredExtractInstructionWithElse

class cPtr_typeStructuredExtractInstructionWithElse : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeStructuredExtractInstructionWithElse
  public : cPtr_typeStructuredExtractInstructionWithElse (const GGS_typeCplusPlusName & ,
                                const GGS_typeStructuredExtractCasesList & ,
                                const GGS_typeInstructionsList & ) ;
  public : GGS_typeCplusPlusName  mVariableName ;
  public : GGS_typeStructuredExtractCasesList  mCasesList ;
  public : GGS_typeInstructionsList  mElseInstructionList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_typeStructuredExtractInstructionWithElse'         *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeStructuredExtractInstructionWithElse {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeStructuredExtractInstructionWithElse * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionsList & argument_2) ;
  #else
    public : inline static cPtr_typeStructuredExtractInstructionWithElse * constructor_new (const GGS_typeCplusPlusName & argument_0,
                                const GGS_typeStructuredExtractCasesList & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
      return new cPtr_typeStructuredExtractInstructionWithElse(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'typeRoutineCallInstruction'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeRoutineCallInstruction

#define macroInheritFrom_typeRoutineCallInstruction

class cPtr_typeRoutineCallInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeRoutineCallInstruction
  public : cPtr_typeRoutineCallInstruction (const GGS_lstring & ,
                                const GGS_typeExpressionList & ) ;
  public : GGS_lstring  aNomRoutine ;
  public : GGS_typeExpressionList  mExpressionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeRoutineCallInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeRoutineCallInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeRoutineCallInstruction * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1) ;
  #else
    public : inline static cPtr_typeRoutineCallInstruction * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeExpressionList & argument_1) {
      return new cPtr_typeRoutineCallInstruction(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeDropInstruction'                         *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeDropInstruction

#define macroInheritFrom_typeDropInstruction

class cPtr_typeDropInstruction : public cPtr_typeInstruction {
  private : typedef cPtr_typeInstruction inherited ;
  macroInheritFrom_typeInstruction
  macro_typeDropInstruction
  public : cPtr_typeDropInstruction (const GGS_typeCplusPlusName & ) ;
  public : GGS_typeCplusPlusName  aVariableConsommee ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDropInstruction {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeDropInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0) ;
  #else
    public : inline static cPtr_typeDropInstruction * constructor_new (const GGS_typeCplusPlusName & argument_0) {
      return new cPtr_typeDropInstruction(argument_0) ;
    }
  #endif
} ;

#include "include_typeEntityToGenerate.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeExternTypeToGenerate'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeExternTypeToGenerate

#define macroInheritFrom_typeExternTypeToGenerate

class cPtr_typeExternTypeToGenerate : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_typeExternTypeToGenerate
  public : cPtr_typeExternTypeToGenerate (const GGS_lstring & ,
                                const GGS_lstring & ) ;
  public : GGS_lstring  mName ;
  public : GGS_lstring  mCppClassName ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeExternTypeToGenerate'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeExternTypeToGenerate {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeExternTypeToGenerate * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) ;
  #else
    public : inline static cPtr_typeExternTypeToGenerate * constructor_new (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
      return new cPtr_typeExternTypeToGenerate(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeRoutineAengendrer'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeRoutineAengendrer

#define macroInheritFrom_typeRoutineAengendrer

class cPtr_typeRoutineAengendrer : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_typeRoutineAengendrer
  public : cPtr_typeRoutineAengendrer (const GGS_lstring & ,
                                const GGS_typeListeTypesEtNomsArgMethode & ,
                                const GGS_typeInstructionsList & ) ;
  public : GGS_lstring  aNomRoutine ;
  public : GGS_typeListeTypesEtNomsArgMethode  aListeTypeEtNomsArguments ;
  public : GGS_typeInstructionsList  mInstructionsList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeRoutineAengendrer'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeRoutineAengendrer {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeRoutineAengendrer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionsList & argument_2) ;
  #else
    public : inline static cPtr_typeRoutineAengendrer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeTypesEtNomsArgMethode & argument_1,
                                const GGS_typeInstructionsList & argument_2) {
      return new cPtr_typeRoutineAengendrer(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'C_listTypeToImplement'                        *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_listTypeToImplement

#define macroInheritFrom_C_listTypeToImplement

class cPtr_C_listTypeToImplement : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_C_listTypeToImplement
  public : cPtr_C_listTypeToImplement (const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_L_nameWithType & ) ;
  public : GGS_lstring  aNomListe ;
  public : GGS_typeListeAttributsSemantiques  mNonExternAttributesList ;
  public : GGS_L_nameWithType  mExternAttributesList ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_C_listTypeToImplement'                  *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_listTypeToImplement {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_listTypeToImplement * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2) ;
  #else
    public : inline static cPtr_C_listTypeToImplement * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2) {
      return new cPtr_C_listTypeToImplement(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'typeDefinitionTableAimplementer'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeDefinitionTableAimplementer

#define macroInheritFrom_typeDefinitionTableAimplementer

class cPtr_typeDefinitionTableAimplementer : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_typeDefinitionTableAimplementer
  public : cPtr_typeDefinitionTableAimplementer (const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_L_nameWithType & ,
                                const GGS_lstring & ,
                                const GGS_typeTableMethodesInsererChercher & ,
                                const GGS_typeTableMethodesInsererChercher & ,
                                const GGS_typeTableBlocsDeTable & ) ;
  public : GGS_lstring  aNomTable ;
  public : GGS_typeListeAttributsSemantiques  mNonExternAttributesList ;
  public : GGS_L_nameWithType  mExternAttributesList ;
  public : GGS_lstring  aNomClasseGenerique ;
  public : GGS_typeTableMethodesInsererChercher  aTableMethodesInserer ;
  public : GGS_typeTableMethodesInsererChercher  aTableMethodesChercher ;
  public : GGS_typeTableBlocsDeTable  aTableMethodesSurcharger ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeDefinitionTableAimplementer'             *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefinitionTableAimplementer {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeDefinitionTableAimplementer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6) ;
  #else
    public : inline static cPtr_typeDefinitionTableAimplementer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_L_nameWithType & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5,
                                const GGS_typeTableBlocsDeTable & argument_6) {
      return new cPtr_typeDefinitionTableAimplementer(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'C_mapToImplement'                          *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_C_mapToImplement

#define macroInheritFrom_C_mapToImplement

class cPtr_C_mapToImplement : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_C_mapToImplement
  public : cPtr_C_mapToImplement (const GGS_stateMap & ,
                                const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_L_nameWithType & ,
                                const GGS_typeTableMethodesInsererChercher & ,
                                const GGS_typeTableMethodesInsererChercher & ) ;
  public : GGS_stateMap  mStateMap ;
  public : GGS_lstring  aNomTable ;
  public : GGS_typeListeAttributsSemantiques  mNonExternAttributesList ;
  public : GGS_L_nameWithType  mExternAttributesList ;
  public : GGS_typeTableMethodesInsererChercher  aTableMethodesInserer ;
  public : GGS_typeTableMethodesInsererChercher  aTableMethodesChercher ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_C_mapToImplement'                     *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_C_mapToImplement {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_C_mapToImplement * constructor_new (const GGS_stateMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_L_nameWithType & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5) ;
  #else
    public : inline static cPtr_C_mapToImplement * constructor_new (const GGS_stateMap & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_typeListeAttributsSemantiques & argument_2,
                                const GGS_L_nameWithType & argument_3,
                                const GGS_typeTableMethodesInsererChercher & argument_4,
                                const GGS_typeTableMethodesInsererChercher & argument_5) {
      return new cPtr_C_mapToImplement(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeDefClasseAbstraiteAimplementer'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeDefClasseAbstraiteAimplementer

#define macroInheritFrom_typeDefClasseAbstraiteAimplementer

class cPtr_typeDefClasseAbstraiteAimplementer : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_typeDefClasseAbstraiteAimplementer
  public : cPtr_typeDefClasseAbstraiteAimplementer (const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_typeTableMethodes & ,
                                const GGS_bool& ,
                                const GGS_typeTableMethodesAimplementer & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_L_nameWithType & ,
                                const GGS_typeSuperClassesMap & ,
                                const GGS_typeClassMessagesMap & ) ;
  public : GGS_lstring  aNomClasse ;
  public : GGS_typeListeAttributsSemantiques  aListeTousAttributsNonExternes ;
  public : GGS_typeTableMethodes  aTableToutesMethodes ;
  public : GGS_bool mGenerateIncludeHeader ;
  public : GGS_typeTableMethodesAimplementer  mMethodsMap ;
  public : GGS_typeListeAttributsSemantiques  aListeAttributsCourants ;
  public : GGS_L_nameWithType  aListeExternesCourants ;
  public : GGS_typeSuperClassesMap  mAncestorClassesMap ;
  public : GGS_typeClassMessagesMap  mMessagesMap ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeDefClasseAbstraiteAimplementer'            *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefClasseAbstraiteAimplementer {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeDefClasseAbstraiteAimplementer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_L_nameWithType & argument_6,
                                const GGS_typeSuperClassesMap & argument_7,
                                const GGS_typeClassMessagesMap & argument_8) ;
  #else
    public : inline static cPtr_typeDefClasseAbstraiteAimplementer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_typeTableMethodesAimplementer & argument_4,
                                const GGS_typeListeAttributsSemantiques & argument_5,
                                const GGS_L_nameWithType & argument_6,
                                const GGS_typeSuperClassesMap & argument_7,
                                const GGS_typeClassMessagesMap & argument_8) {
      return new cPtr_typeDefClasseAbstraiteAimplementer(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'typeDefClasseNonAbstraiteAimplementer'                *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeDefClasseNonAbstraiteAimplementer

#define macroInheritFrom_typeDefClasseNonAbstraiteAimplementer

class cPtr_typeDefClasseNonAbstraiteAimplementer : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_typeDefClasseNonAbstraiteAimplementer
  public : cPtr_typeDefClasseNonAbstraiteAimplementer (const GGS_lstring & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_typeTableMethodes & ,
                                const GGS_typeTableMethodesAimplementer & ,
                                const GGS_typeListeAttributsSemantiques & ,
                                const GGS_L_nameWithType & ,
                                const GGS_typeSuperClassesMap & ,
                                const GGS_typeClassMessagesMap & ,
                                const GGS_bool& ) ;
  public : GGS_lstring  aNomClasse ;
  public : GGS_typeListeAttributsSemantiques  aListeTousAttributsNonExternes ;
  public : GGS_typeTableMethodes  aTableToutesMethodes ;
  public : GGS_typeTableMethodesAimplementer  mMethodsMap ;
  public : GGS_typeListeAttributsSemantiques  aListeAttributsCourants ;
  public : GGS_L_nameWithType  aListeExternesCourants ;
  public : GGS_typeSuperClassesMap  mAncestorClassesMap ;
  public : GGS_typeClassMessagesMap  mMessagesMap ;
  public : GGS_bool mGenerateIncludeHeader ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_typeDefClasseNonAbstraiteAimplementer'          *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeDefClasseNonAbstraiteAimplementer {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeDefClasseNonAbstraiteAimplementer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_bool& argument_8) ;
  #else
    public : inline static cPtr_typeDefClasseNonAbstraiteAimplementer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeAttributsSemantiques & argument_1,
                                const GGS_typeTableMethodes & argument_2,
                                const GGS_typeTableMethodesAimplementer & argument_3,
                                const GGS_typeListeAttributsSemantiques & argument_4,
                                const GGS_L_nameWithType & argument_5,
                                const GGS_typeSuperClassesMap & argument_6,
                                const GGS_typeClassMessagesMap & argument_7,
                                const GGS_bool& argument_8) {
      return new cPtr_typeDefClasseNonAbstraiteAimplementer(argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeEntiteActionExterne'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeEntiteActionExterne

#define macroInheritFrom_typeEntiteActionExterne

class cPtr_typeEntiteActionExterne : public cPtr_AC_semanticsEntity {
  private : typedef cPtr_AC_semanticsEntity inherited ;
  macroInheritFrom_AC_semanticsEntity
  macro_typeEntiteActionExterne
  public : cPtr_typeEntiteActionExterne (const GGS_L_signature & ) ;
  public : GGS_L_signature  aSignature ;
  public : virtual bool isBuilt (void) const ;

  public : virtual const char * message_messageTypeEntite (void) const ;
  public : static const char * static_string_message_messageTypeEntite (void) ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeEntiteActionExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeEntiteActionExterne {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeEntiteActionExterne * constructor_new (const GGS_L_signature & argument_0) ;
  #else
    public : inline static cPtr_typeEntiteActionExterne * constructor_new (const GGS_L_signature & argument_0) {
      return new cPtr_typeEntiteActionExterne(argument_0) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeActionExterneAengendrer'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_typeActionExterneAengendrer

#define macroInheritFrom_typeActionExterneAengendrer

class cPtr_typeActionExterneAengendrer : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_typeActionExterneAengendrer
  public : cPtr_typeActionExterneAengendrer (const GGS_lstring & ,
                                const GGS_L_signature & ) ;
  public : GGS_lstring  aNomAction ;
  public : GGS_L_signature  aSignature ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeActionExterneAengendrer'               *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_typeActionExterneAengendrer {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_typeActionExterneAengendrer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_L_signature & argument_1) ;
  #else
    public : inline static cPtr_typeActionExterneAengendrer * constructor_new (const GGS_lstring & argument_0,
                                const GGS_L_signature & argument_1) {
      return new cPtr_typeActionExterneAengendrer(argument_0,
                                argument_1) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'enumGalgasType'                           *
//                                                                           *
//---------------------------------------------------------------------------*

#define macro_enumGalgasType

#define macroInheritFrom_enumGalgasType

class cPtr_enumGalgasType : public cPtr_typeEntityToGenerate {
  private : typedef cPtr_typeEntityToGenerate inherited ;
  macroInheritFrom_typeEntityToGenerate
  macro_enumGalgasType
  public : cPtr_enumGalgasType (const GGS_lstring & ,
                                const GGS_typeEnumConstantesMap & ,
                                const GGS_typeEnumMessageMap & ) ;
  public : GGS_lstring  mEnumTypeName ;
  public : GGS_typeEnumConstantesMap  mConstantMap ;
  public : GGS_typeEnumMessageMap  mEnumMessageMap ;
  public : virtual bool isBuilt (void) const ;

} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_enumGalgasType'                      *
//                                                                           *
//---------------------------------------------------------------------------*

class GGS_enumGalgasType {
  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
    public : static cPtr_enumGalgasType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) ;
  #else
    public : inline static cPtr_enumGalgasType * constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeEnumConstantesMap & argument_1,
                                const GGS_typeEnumMessageMap & argument_2) {
      return new cPtr_enumGalgasType(argument_0,
                                argument_1,
                                argument_2) ;
    }
  #endif
} ;

//---------------------------------------------------------------------------*

#endif
