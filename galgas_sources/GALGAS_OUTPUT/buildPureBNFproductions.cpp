//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'buildPureBNFproductions.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     october 12th, 2009, at 21h24'44"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "buildPureBNFproductions.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "buildPureBNFproductions.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@syntaxRuleListForGrammar'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_syntaxRuleListForGrammar::
elementOf_GGS_syntaxRuleListForGrammar (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_syntaxInstructionList & argument_2
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mSyntaxComponentName (argument_0),
mLeftNonTerminal (argument_1),
mSyntaxInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_syntaxRuleListForGrammar::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_syntaxRuleListForGrammar * ptr = dynamic_cast <const elementOf_GGS_syntaxRuleListForGrammar *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSyntaxComponentName.operator_isEqual (ptr->mSyntaxComponentName).boolValue ()
         && mLeftNonTerminal.operator_isEqual (ptr->mLeftNonTerminal).boolValue ()
         && mSyntaxInstructionList.operator_isEqual (ptr->mSyntaxInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_syntaxRuleListForGrammar::
appendForDescription (C_Compiler & inLexique,
                          C_String & ioString,
                          const PMSInt32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxComponentName.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftNonTerminal.reader_description  (inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSyntaxInstructionList.reader_description  (inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@syntaxRuleListForGrammar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
_internalAppendValues (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_syntaxInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
_internalPrependValues (const GGS_string& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_syntaxInstructionList & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_syntaxInstructionList & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleListForGrammar GGS_syntaxRuleListForGrammar::
operator_concat (const GGS_syntaxRuleListForGrammar & inOperand) const {
  GGS_syntaxRuleListForGrammar result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
dotAssign_operation (const GGS_syntaxRuleListForGrammar inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        _insulateList () ;
        elementOf_GGS_syntaxRuleListForGrammar * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mSyntaxComponentName ;
          GGS_lstring  p_1 = p->mLeftNonTerminal ;
          GGS_syntaxInstructionList  p_2 = p->mSyntaxInstructionList ;
          _internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_syntaxInstructionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
_insulateList (void) {
  if (_shared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      _internalAppendValues (ptr->mSyntaxComponentName,
                                ptr->mLeftNonTerminal,
                                ptr->mSyntaxInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleListForGrammar  GGS_syntaxRuleListForGrammar::
constructor_emptyList (void) {
  GGS_syntaxRuleListForGrammar result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleListForGrammar  GGS_syntaxRuleListForGrammar::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_syntaxInstructionList & argument_2) {
  GGS_syntaxRuleListForGrammar result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
internalSubListWithRange (GGS_syntaxRuleListForGrammar & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSyntaxComponentName, ptr->mLeftNonTerminal, ptr->mSyntaxInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleListForGrammar GGS_syntaxRuleListForGrammar::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_syntaxRuleListForGrammar result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxRuleListForGrammar GGS_syntaxRuleListForGrammar::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_syntaxRuleListForGrammar result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxRuleListForGrammar::
reader_description (C_Compiler & inLexique
                    COMMA_LOCATION_ARGS,
                    const PMSInt32 inIndentation) const {
  return _description (inLexique, "@syntaxRuleListForGrammar", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_lstring & _out_1,
              GGS_syntaxInstructionList & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mLeftNonTerminal ;
    _out_2 = ptr->mSyntaxInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_lstring & _out_1,
             GGS_syntaxInstructionList & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mLeftNonTerminal ;
    _out_2 = ptr->mSyntaxInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_lstring & _out_1,
                 GGS_syntaxInstructionList & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mLeftNonTerminal ;
    _out_2 = ptr->mSyntaxInstructionList ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_lstring & _out_1,
                GGS_syntaxInstructionList & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSyntaxComponentName ;
    _out_1 = ptr->mLeftNonTerminal ;
    _out_2 = ptr->mSyntaxInstructionList ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_syntaxRuleListForGrammar::
reader_mSyntaxComponentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxComponentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_syntaxRuleListForGrammar::
reader_mLeftNonTerminalAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLeftNonTerminal ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionList  GGS_syntaxRuleListForGrammar::
reader_mSyntaxInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_syntaxInstructionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSyntaxInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
modifier_setMSyntaxComponentNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxComponentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
modifier_setMLeftNonTerminalAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLeftNonTerminal = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_syntaxRuleListForGrammar::
modifier_setMSyntaxInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_syntaxInstructionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSyntaxInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_syntaxRuleListForGrammar::cEnumerator::_mSyntaxComponentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxComponentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_syntaxRuleListForGrammar::cEnumerator::_mLeftNonTerminal (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLeftNonTerminal ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_syntaxInstructionList  & GGS_syntaxRuleListForGrammar::cEnumerator::_mSyntaxInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSyntaxInstructionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@syntaxInstruction.buildPureSyntaxInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction> gDispatchTableForMethod__syntaxInstruction__buildPureSyntaxInstruction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction (typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__syntaxInstruction__buildPureSyntaxInstruction.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction
findCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__syntaxInstruction__buildPureSyntaxInstruction.count ()) {
    result = gDispatchTableForMethod__syntaxInstruction__buildPureSyntaxInstruction (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction (superClassPtr) ;
      gDispatchTableForMethod__syntaxInstruction__buildPureSyntaxInstruction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "buildPureSyntaxInstructionList"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildPureSyntaxInstructionList (C_Compiler & inLexique,
                                const GGS_string  var_cas_inSyntaxComponent,
                                const GGS_syntaxInstructionList   var_cas_inSyntaxInstructionList,
                                GGS_syntaxInstructionList  & var_cas_outPureSyntaxInstructionList,
                                GGS_syntaxRuleListForGrammar  & var_cas_ioPureSyntaxRuleListForGrammar,
                                GGS_stringlist  & var_cas_ioAddedNonTerminalList,
                                GGS_uint  & var_cas_ioAddedRuleIndex COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildPureSyntaxInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_outPureSyntaxInstructionList = GGS_syntaxInstructionList ::constructor_emptyList () ;
  {
    GGS_syntaxInstructionList::cEnumerator enumerator_2855 (var_cas_inSyntaxInstructionList, true) ;
    const GGS_syntaxInstructionList::cElement * operand_2855 = NULL ;
    while (((operand_2855 = enumerator_2855.nextObject ()))) {
      macroValidPointer (operand_2855) ;
      const GGS_syntaxInstruction  temp_2903 = operand_2855->mInstruction ;
      if (temp_2903.isBuilt ()) {
        typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction method = findCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction (temp_2903.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_2903 (HERE), var_cas_inSyntaxComponent, var_cas_ioPureSyntaxRuleListForGrammar, var_cas_outPureSyntaxInstructionList, var_cas_ioAddedNonTerminalList, var_cas_ioAddedRuleIndex COMMA_SOURCE_FILE_AT_LINE (58)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildPureSyntaxInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticInstruction.buildPureSyntaxInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticInstruction__buildPureSyntaxInstruction (C_Compiler & inLexique,
                                const cPtr_semanticInstruction * operand_3398,
                                const GGS_string  /* var_cas_inSyntaxComponent */,
                                GGS_syntaxRuleListForGrammar  & /* var_cas_ioPureSyntaxRuleListForGrammar */,
                                GGS_syntaxInstructionList  & /* var_cas_ioPureSyntaxInstructionList */,
                                GGS_stringlist  & /* var_cas_ioAddedNonTerminalList */,
                                GGS_uint  & /* var_cas_ioAddedRuleIndex */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3398 != NULL) {
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("internal error (use debug tool)") COMMA_SOURCE_FILE_AT_LINE (80)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@nonterminalCallInstruction.buildPureSyntaxInstruction'  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__nonterminalCallInstruction__buildPureSyntaxInstruction (C_Compiler &,
                                const cPtr_nonterminalCallInstruction * operand_3862,
                                const GGS_string  /* var_cas_inSyntaxComponent */,
                                GGS_syntaxRuleListForGrammar  & /* var_cas_ioPureSyntaxRuleListForGrammar */,
                                GGS_syntaxInstructionList  & var_cas_ioPureSyntaxInstructionList,
                                GGS_stringlist  & /* var_cas_ioAddedNonTerminalList */,
                                GGS_uint  & /* var_cas_ioAddedRuleIndex */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3862 != NULL) {
    var_cas_ioPureSyntaxInstructionList.addAssign_operation (operand_3862) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@terminalCheckInstruction.buildPureSyntaxInstruction'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__terminalCheckInstruction__buildPureSyntaxInstruction (C_Compiler &,
                                const cPtr_terminalCheckInstruction * operand_4307,
                                const GGS_string  /* var_cas_inSyntaxComponent */,
                                GGS_syntaxRuleListForGrammar  & /* var_cas_ioPureSyntaxRuleListForGrammar */,
                                GGS_syntaxInstructionList  & var_cas_ioPureSyntaxInstructionList,
                                GGS_stringlist  & /* var_cas_ioAddedNonTerminalList */,
                                GGS_uint  & /* var_cas_ioAddedRuleIndex */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4307 != NULL) {
    var_cas_ioPureSyntaxInstructionList.addAssign_operation (operand_4307) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@repeatInstruction.buildPureSyntaxInstruction'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__repeatInstruction__buildPureSyntaxInstruction (C_Compiler & inLexique,
                                const cPtr_repeatInstruction * operand_4745,
                                const GGS_string  var_cas_inSyntaxComponent,
                                GGS_syntaxRuleListForGrammar  & var_cas_ioPureSyntaxRuleListForGrammar,
                                GGS_syntaxInstructionList  & var_cas_ioPureSyntaxInstructionList,
                                GGS_stringlist  & var_cas_ioAddedNonTerminalList,
                                GGS_uint  & var_cas_ioAddedRuleIndex
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4745 != NULL) {
    GGS_string var_cas_addedNonTerminalString = (((GGS_string ("select_repeat_")).operator_concat (var_cas_inSyntaxComponent)).operator_concat (GGS_string ("_"))).operator_concat (var_cas_ioAddedRuleIndex.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (130))) ;
    var_cas_ioAddedRuleIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (131)) ;
    GGS_lstring  var_cas_selectRepeatAddedNonTerminal = GGS_lstring ::constructor_new (inLexique, var_cas_addedNonTerminalString, operand_4745->mRepeatInstructionLocation COMMA_HERE) ;
    var_cas_ioAddedNonTerminalList.addAssign_operation (var_cas_addedNonTerminalString) ;
    GGS_syntaxInstructionList  var_cas_repeatedPureInstructionList ;
    ::routine_buildPureSyntaxInstructionList (inLexique,  var_cas_inSyntaxComponent,  operand_4745->mRepeatedInstructionList,  var_cas_repeatedPureInstructionList,  var_cas_ioPureSyntaxRuleListForGrammar,  var_cas_ioAddedNonTerminalList,  var_cas_ioAddedRuleIndex COMMA_SOURCE_FILE_AT_LINE (139)) ;
    var_cas_ioPureSyntaxInstructionList.dotAssign_operation (var_cas_repeatedPureInstructionList) ;
    var_cas_ioPureSyntaxInstructionList.addAssign_operation (GGS_nonterminalCallInstruction ::constructor_new (inLexique, var_cas_selectRepeatAddedNonTerminal, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE), GGS_actualParameterList ::constructor_emptyList () COMMA_HERE)) ;
    var_cas_ioPureSyntaxRuleListForGrammar.addAssign_operation (var_cas_inSyntaxComponent, var_cas_selectRepeatAddedNonTerminal, GGS_syntaxInstructionList ::constructor_emptyList ()) ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_6670 (operand_4745->mRepeatBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_6670 = NULL ;
      while (((operand_6670 = enumerator_6670.nextObject ()))) {
        macroValidPointer (operand_6670) ;
        GGS_syntaxInstructionList  var_cas_pureInstructionList ;
        ::routine_buildPureSyntaxInstructionList (inLexique,  var_cas_inSyntaxComponent,  operand_6670->mSyntaxInstructionList,  var_cas_pureInstructionList,  var_cas_ioPureSyntaxRuleListForGrammar,  var_cas_ioAddedNonTerminalList,  var_cas_ioAddedRuleIndex COMMA_SOURCE_FILE_AT_LINE (163)) ;
        var_cas_pureInstructionList.dotAssign_operation (var_cas_repeatedPureInstructionList) ;
        var_cas_pureInstructionList.addAssign_operation (GGS_nonterminalCallInstruction ::constructor_new (inLexique, var_cas_selectRepeatAddedNonTerminal, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE), GGS_actualParameterList ::constructor_emptyList () COMMA_HERE)) ;
        var_cas_ioPureSyntaxRuleListForGrammar.addAssign_operation (var_cas_inSyntaxComponent, var_cas_selectRepeatAddedNonTerminal, var_cas_pureInstructionList) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@selectInstruction.buildPureSyntaxInstruction'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__selectInstruction__buildPureSyntaxInstruction (C_Compiler & inLexique,
                                const cPtr_selectInstruction * operand_7488,
                                const GGS_string  var_cas_inSyntaxComponent,
                                GGS_syntaxRuleListForGrammar  & var_cas_ioPureSyntaxRuleListForGrammar,
                                GGS_syntaxInstructionList  & var_cas_ioPureSyntaxInstructionList,
                                GGS_stringlist  & var_cas_ioAddedNonTerminalList,
                                GGS_uint  & var_cas_ioAddedRuleIndex
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7488 != NULL) {
    GGS_string var_cas_addedNonTerminalString = (((GGS_string ("select_")).operator_concat (var_cas_inSyntaxComponent)).operator_concat (GGS_string ("_"))).operator_concat (var_cas_ioAddedRuleIndex.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (194))) ;
    var_cas_ioAddedRuleIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (195)) ;
    GGS_lstring  var_cas_selectAddedNonTerminal = GGS_lstring ::constructor_new (inLexique, var_cas_addedNonTerminalString, operand_7488->mSelectInstructionLocation COMMA_HERE) ;
    var_cas_ioAddedNonTerminalList.addAssign_operation (var_cas_addedNonTerminalString) ;
    var_cas_ioPureSyntaxInstructionList.addAssign_operation (GGS_nonterminalCallInstruction ::constructor_new (inLexique, var_cas_selectAddedNonTerminal, GGS_lstring ::constructor_new (inLexique, GGS_string (""), GGS_location (inLexique) COMMA_HERE), GGS_actualParameterList ::constructor_emptyList () COMMA_HERE)) ;
    {
      GGS_listOfSyntaxInstructionList::cEnumerator enumerator_8195 (operand_7488->mSelectBranchList, true) ;
      const GGS_listOfSyntaxInstructionList::cElement * operand_8195 = NULL ;
      while (((operand_8195 = enumerator_8195.nextObject ()))) {
        macroValidPointer (operand_8195) ;
        GGS_syntaxInstructionList  var_cas_pureSyntaxInstructionList ;
        ::routine_buildPureSyntaxInstructionList (inLexique,  var_cas_inSyntaxComponent,  operand_8195->mSyntaxInstructionList,  var_cas_pureSyntaxInstructionList,  var_cas_ioPureSyntaxRuleListForGrammar,  var_cas_ioAddedNonTerminalList,  var_cas_ioAddedRuleIndex COMMA_SOURCE_FILE_AT_LINE (208)) ;
        var_cas_ioPureSyntaxRuleListForGrammar.addAssign_operation (var_cas_inSyntaxComponent, var_cas_selectAddedNonTerminal, var_cas_pureSyntaxInstructionList) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@parseDoInstruction.buildPureSyntaxInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__parseDoInstruction__buildPureSyntaxInstruction (C_Compiler & inLexique,
                                const cPtr_parseDoInstruction * operand_8782,
                                const GGS_string  /* var_cas_inSyntaxComponent */,
                                GGS_syntaxRuleListForGrammar  & /* var_cas_ioPureSyntaxRuleListForGrammar */,
                                GGS_syntaxInstructionList  & /* var_cas_ioPureSyntaxInstructionList */,
                                GGS_stringlist  & /* var_cas_ioAddedNonTerminalList */,
                                GGS_uint  & /* var_cas_ioAddedRuleIndex */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8782 != NULL) {
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("internal error (use debug tool)") COMMA_SOURCE_FILE_AT_LINE (234)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@blockInstruction.buildPureSyntaxInstruction'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__blockInstruction__buildPureSyntaxInstruction (C_Compiler & inLexique,
                                const cPtr_blockInstruction * operand_9236,
                                const GGS_string  /* var_cas_inSyntaxComponent */,
                                GGS_syntaxRuleListForGrammar  & /* var_cas_ioPureSyntaxRuleListForGrammar */,
                                GGS_syntaxInstructionList  & /* var_cas_ioPureSyntaxInstructionList */,
                                GGS_stringlist  & /* var_cas_ioAddedNonTerminalList */,
                                GGS_uint  & /* var_cas_ioAddedRuleIndex */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9236 != NULL) {
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("internal error (use debug tool)") COMMA_SOURCE_FILE_AT_LINE (246)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_buildPureBNFproductions (void) {
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__semanticInstruction__buildPureSyntaxInstruction, gClassInfoFor__semanticInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__nonterminalCallInstruction__buildPureSyntaxInstruction, gClassInfoFor__nonterminalCallInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__terminalCheckInstruction__buildPureSyntaxInstruction, gClassInfoFor__terminalCheckInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__repeatInstruction__buildPureSyntaxInstruction, gClassInfoFor__repeatInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__selectInstruction__buildPureSyntaxInstruction, gClassInfoFor__selectInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__parseDoInstruction__buildPureSyntaxInstruction, gClassInfoFor__parseDoInstruction.slotID ()) ;
 enterCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction ((typeCategoryMethod__syntaxInstruction__buildPureSyntaxInstruction) category_method__blockInstruction__buildPureSyntaxInstruction, gClassInfoFor__blockInstruction.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_buildPureBNFproductions (prologueRoutineFor_buildPureBNFproductions,
                                   NULL) ;

//---------------------------------------------------------------------------*

