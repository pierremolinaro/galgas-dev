//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'buildTypeMapForSemantics.cpp'                     *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 7th, 2007, at 17h44'3"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//#define TRACE_TREE_WALKING

//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "buildTypeMapForSemantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "buildTypeMapForSemantics.gTreewalking", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Treewalking routine prototype declaration                  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticsComponentRoot (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                GGS_location   var_cas_inEndOfSourceFile,
                                GGS_typeMap  & var_cas_outTypeMap) ;

static void
_treewalking_routine_semanticDeclaration (C_Compiler & _inLexique,
                                const cPtr_semanticDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_classDeclaration (C_Compiler & _inLexique,
                                const cPtr_classDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_listDeclaration (C_Compiler & _inLexique,
                                const cPtr_listDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

static void
_treewalking_routine_attributeInCollection (C_Compiler & _inLexique,
                                const cPtr_attributeInCollection * _currentObject,
                                GGS_attributeList  & var_cas_ioAttributeList,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Treewalking routine type declaration                    *
//                                                                           *
//---------------------------------------------------------------------------*

typedef void
_treewalking_routine_semanticsComponentRoot_type (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                GGS_location   var_cas_inEndOfSourceFile,
                                GGS_typeMap  & var_cas_outTypeMap) ;

typedef void
_treewalking_routine_semanticDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_semanticDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_classDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_classDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_listDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_listDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

typedef void
_treewalking_routine_attributeInCollection_type (C_Compiler & _inLexique,
                                const cPtr_attributeInCollection * _currentObject,
                                GGS_attributeList  & var_cas_ioAttributeList,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Dispatcher tables                              *
//                                                                           *
//---------------------------------------------------------------------------*


static const uint32 _kSize_instructionMetamodel = 1 ;

static const CTreewalkingVirtualMethod _kDispatcherFor_instructionMetamodel [_kSize_instructionMetamodel] = {
  {3, (void *) _treewalking_routine_semanticDeclaration}, // @semanticDeclaration, defined in 'instructionMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static const uint32 _kSize_semanticsMetamodel = 4 ;

static const CTreewalkingVirtualMethod _kDispatcherFor_semanticsMetamodel [_kSize_semanticsMetamodel] = {
  {0, (void *) _treewalking_routine_semanticsComponentRoot}, // @semanticsComponentRoot, defined in 'semanticsMetamodel' metamodel
  {1, (void *) _treewalking_routine_attributeInCollection}, // @attributeInCollection, defined in 'semanticsMetamodel' metamodel
  {10, (void *) _treewalking_routine_listDeclaration}, // @listDeclaration, defined in 'semanticsMetamodel' metamodel
  {5, (void *) _treewalking_routine_classDeclaration}, // @classDeclaration, defined in 'semanticsMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static C_TreewalkingDispacher _gDispatcherTree ;

//---------------------------------------------------------------------------*
//                                                                           *
//       'semanticsComponentRoot' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticsComponentRoot (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                GGS_location   var_cas_inEndOfSourceFile,
                                GGS_typeMap  & var_cas_outTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @semanticsComponentRoot\n") ; fflush (stdout) ;
  #endif
  var_cas_outTypeMap = GGS_typeMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE), GGS_stringGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (32)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE), GGS_charGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (33)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE), GGS_boolGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (34)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE), GGS_uintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (35)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE), GGS_sintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (36)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint64"), GGS_location (_inLexique) COMMA_HERE), GGS_uint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (37)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint64"), GGS_location (_inLexique) COMMA_HERE), GGS_sint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (38)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE), GGS_doubleGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (39)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE), GGS_lstringGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (40)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE), GGS_lcharGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (41)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE), GGS_lboolGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (42)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE), GGS_luintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (43)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE), GGS_lsintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (44)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint64"), GGS_location (_inLexique) COMMA_HERE), GGS_luint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (45)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint64"), GGS_location (_inLexique) COMMA_HERE), GGS_lsint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (46)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE), GGS_ldoubleGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (47)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "binaryset"), GGS_location (_inLexique) COMMA_HERE), GGS_binarysetGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (48)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE), GGS_stringsetGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (49)) ;
  macroValidPointer (_currentObject) ;
  { GGS_semanticDeclarationList::element_type * _ptr = _currentObject->mSemanticDeclarationList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_semanticDeclaration_type * _f = (_treewalking_routine_semanticDeclaration_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_outTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  _inLexique.printMessage ((var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (53)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (53)))._operator_concat (GGS_string (true, " unresolved indexes\n")) COMMA_SOURCE_FILE_AT_LINE (53)) ;
  if (((var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_m ;
    var_cas_m = (var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (55)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (55)))._operator_concat (GGS_string (true, " type")) ;
    if (((var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (56)))._operator_isEqual (GGS_uint (true, 1U))).isBuiltAndTrue ()) {
      var_cas_m = GGS_string (true, "1 type is not defined:") ;
    }else{
      var_cas_m = (var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (59)))._operator_concat (GGS_string (true, " types are not defined:")) ;
    }
    const GGS_stringlist _var_3972 = var_cas_outTypeMap.reader_unsolvedIndexKeyStringList (_inLexique COMMA_SOURCE_FILE_AT_LINE (61)) ;
    GGS_stringlist::element_type * operand_3972 = _var_3972.firstObject () ;
    while ((operand_3972 != NULL)) {
      macroValidPointer (operand_3972) ;
      var_cas_m.writeString ("\n  - @") ;
      var_cas_m._dotAssign_operation (operand_3972->mValue) ;
      operand_3972 = operand_3972->nextObject () ;
    }
    var_cas_inEndOfSourceFile.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (64)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         'semanticDeclaration' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticDeclaration (C_Compiler &,
                                const cPtr_semanticDeclaration * /* _currentObject */,
                                GGS_typeMap  & /* var_cas_ioTypeMap */) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @semanticDeclaration\n") ; fflush (stdout) ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'classDeclaration' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_classDeclaration (C_Compiler & _inLexique,
                                const cPtr_classDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @classDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_typeMapIndex  var_cas_superClassIndex ;
  if (((_currentObject->mSuperClassName.ggs_string ().reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (78)))._operator_isEqual (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    var_cas_superClassIndex = GGS_typeMapIndex::constructor_null (_inLexique COMMA_HERE) ;
  }else{
    GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, _currentObject->mSuperClassName, var_cas_ioTypeMap, var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (81)) ;
  }
  GGS_attributeList  var_cas_attributeList ;
  var_cas_attributeList = GGS_attributeList::constructor_emptyList (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { GGS_attributeInCollectionList::element_type * _ptr = _currentObject->mAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_attributeInCollection_type * _f = (_treewalking_routine_attributeInCollection_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_attributeList, var_cas_ioTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_classGalgasType::constructor_new (_inLexique, _currentObject->mIsAbstract, _currentObject->mClassTypeName, var_cas_superClassIndex, var_cas_attributeList COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mClassTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (93)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           'listDeclaration' treewalking routine implementation            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_listDeclaration (C_Compiler & _inLexique,
                                const cPtr_listDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @listDeclaration\n") ; fflush (stdout) ;
  #endif
  GGS_attributeList  var_cas_attributeList ;
  var_cas_attributeList = GGS_attributeList::constructor_emptyList (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { GGS_attributeInCollectionList::element_type * _ptr = _currentObject->mAttributeList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_attributeInCollection_type * _f = (_treewalking_routine_attributeInCollection_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_attributeList, var_cas_ioTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  GGS_ACGalgasType  var_cas_t ;
  var_cas_t = GGS_listGalgasType::constructor_new (_inLexique, _currentObject->mListTypeName, var_cas_attributeList COMMA_HERE) ;
  var_cas_ioTypeMap.modifier_insertKey (_inLexique, _currentObject->mListTypeName, var_cas_t COMMA_SOURCE_FILE_AT_LINE (107)) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        'attributeInCollection' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_attributeInCollection (C_Compiler & _inLexique,
                                const cPtr_attributeInCollection * _currentObject,
                                GGS_attributeList  & var_cas_ioAttributeList,
                                GGS_typeMap  & var_cas_ioTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @attributeInCollection\n") ; fflush (stdout) ;
  #endif
  GGS_typeMapIndex  var_cas_index ;
  GGS_typeMapIndex::class_method_makeRegularIndex (_inLexique, _currentObject->mAttributeTypeName, var_cas_ioTypeMap, var_cas_index COMMA_SOURCE_FILE_AT_LINE (117)) ;
  var_cas_ioAttributeList._addAssign_operation (var_cas_index, _currentObject->mAttributeName) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Build Dispatcher Tree                            *
//                                                                           *
//---------------------------------------------------------------------------*

static void _build_dispacher_tree (void) {
  _gDispatcherTree.enterTable (_metamodel_index_for_instructionMetamodel (),
                                _kSize_instructionMetamodel,
                                _kDispatcherFor_instructionMetamodel
                                COMMA_HERE) ;
  _gDispatcherTree.enterTable (_metamodel_index_for_semanticsMetamodel (),
                                _kSize_semanticsMetamodel,
                                _kDispatcherFor_semanticsMetamodel
                                COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                               Root routine                                *
//                                                                           *
//---------------------------------------------------------------------------*

void
_walk_throught_buildTypeMapForSemantics (C_Compiler & _inLexique,
                                const GGS_semanticsComponentRoot & _rootObject,
                                GGS_location   var_cas_inEndOfSourceFile,
                                GGS_typeMap  & var_cas_outTypeMap) {
  if (_rootObject._isBuilt ()) {
    if (! _gDispatcherTree.isInited ()) {
      _build_dispacher_tree () ;
    }
    _treewalking_routine_semanticsComponentRoot_type * _f = (_treewalking_routine_semanticsComponentRoot_type *) _gDispatcherTree.entry (_rootObject.getPtr () COMMA_HERE) ;
    (* _f) (_inLexique, _rootObject.getPtr (), var_cas_inEndOfSourceFile, var_cas_outTypeMap) ;
  }else{
    var_cas_outTypeMap._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

