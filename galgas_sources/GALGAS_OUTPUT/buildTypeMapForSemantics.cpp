//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'buildTypeMapForSemantics.cpp'                     *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 6th, 2007, at 16h38'43"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//#define TRACE_TREE_WALKING

//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "buildTypeMapForSemantics.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "buildTypeMapForSemantics.gTreewalking", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Treewalking routine prototype declaration                  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticsComponentRoot (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                GGS_typeMap  & var_cas_outTypeMap) ;

static void
_treewalking_routine_semanticDeclaration (C_Compiler & _inLexique,
                                const cPtr_semanticDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Treewalking routine type declaration                    *
//                                                                           *
//---------------------------------------------------------------------------*

typedef void
_treewalking_routine_semanticsComponentRoot_type (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                GGS_typeMap  & var_cas_outTypeMap) ;

typedef void
_treewalking_routine_semanticDeclaration_type (C_Compiler & _inLexique,
                                const cPtr_semanticDeclaration * _currentObject,
                                GGS_typeMap  & var_cas_ioTypeMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Dispatcher tables                              *
//                                                                           *
//---------------------------------------------------------------------------*

static const uint32 _kSize_instructionMetamodel = 6 ;

static void * _kDispatcherFor_instructionMetamodel [_kSize_instructionMetamodel] = {
  NULL, // #0
  NULL, // #1
  NULL, // #2
  (void *) _treewalking_routine_semanticDeclaration, // #3 @semanticDeclaration, defined in 'instructionMetamodel' metamodel
  (void *) _treewalking_routine_semanticDeclaration, // #4 @routineDeclaration, defined in 'instructionMetamodel' metamodel
  (void *) _treewalking_routine_semanticDeclaration, // #5 @actionDeclaration, defined in 'instructionMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static const uint32 _kSize_semanticsMetamodel = 17 ;

static void * _kDispatcherFor_semanticsMetamodel [_kSize_semanticsMetamodel] = {
  (void *) _treewalking_routine_semanticsComponentRoot, // #0 @semanticsComponentRoot, defined in 'semanticsMetamodel' metamodel
  NULL, // #1
  NULL, // #2
  NULL, // #3
  NULL, // #4
  NULL, // #5
  NULL, // #6
  NULL, // #7
  NULL, // #8
  NULL, // #9
  (void *) _treewalking_routine_semanticDeclaration, // #10 @listDeclaration, defined in 'semanticsMetamodel' metamodel
  NULL, // #11
  (void *) _treewalking_routine_semanticDeclaration, // #12 @sortedListDeclaration, defined in 'semanticsMetamodel' metamodel
  (void *) _treewalking_routine_semanticDeclaration, // #13 @enumDeclaration, defined in 'semanticsMetamodel' metamodel
  (void *) _treewalking_routine_semanticDeclaration, // #2 @mapDeclaration, defined in 'semanticsMetamodel' metamodel
  (void *) _treewalking_routine_semanticDeclaration, // #4 @mapindexDeclaration, defined in 'semanticsMetamodel' metamodel
  (void *) _treewalking_routine_semanticDeclaration, // #5 @classDeclaration, defined in 'semanticsMetamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static C_TreewalkingDispacher _gDispatcherTree ;

//---------------------------------------------------------------------------*
//                                                                           *
//       'semanticsComponentRoot' treewalking routine implementation         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticsComponentRoot (C_Compiler & _inLexique,
                                const cPtr_semanticsComponentRoot * _currentObject,
                                GGS_typeMap  & var_cas_outTypeMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @semanticsComponentRoot\n") ; fflush (stdout) ;
  #endif
  var_cas_outTypeMap = GGS_typeMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "string"), GGS_location (_inLexique) COMMA_HERE), GGS_stringGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (29)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "char"), GGS_location (_inLexique) COMMA_HERE), GGS_charGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (30)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "bool"), GGS_location (_inLexique) COMMA_HERE), GGS_boolGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (31)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint"), GGS_location (_inLexique) COMMA_HERE), GGS_uintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (32)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint"), GGS_location (_inLexique) COMMA_HERE), GGS_sintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (33)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "uint64"), GGS_location (_inLexique) COMMA_HERE), GGS_uint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (34)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "sint64"), GGS_location (_inLexique) COMMA_HERE), GGS_sint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (35)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "double"), GGS_location (_inLexique) COMMA_HERE), GGS_doubleGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (36)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lstring"), GGS_location (_inLexique) COMMA_HERE), GGS_lstringGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (37)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lchar"), GGS_location (_inLexique) COMMA_HERE), GGS_lcharGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (38)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lbool"), GGS_location (_inLexique) COMMA_HERE), GGS_lboolGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (39)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint"), GGS_location (_inLexique) COMMA_HERE), GGS_luintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (40)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint"), GGS_location (_inLexique) COMMA_HERE), GGS_lsintGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (41)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "luint64"), GGS_location (_inLexique) COMMA_HERE), GGS_luint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (42)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "lsint64"), GGS_location (_inLexique) COMMA_HERE), GGS_lsint64GalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (43)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "ldouble"), GGS_location (_inLexique) COMMA_HERE), GGS_ldoubleGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (44)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "binaryset"), GGS_location (_inLexique) COMMA_HERE), GGS_binarysetGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (45)) ;
  var_cas_outTypeMap.modifier_insertKey (_inLexique, GGS_lstring::constructor_new (_inLexique, GGS_string (true, "stringset"), GGS_location (_inLexique) COMMA_HERE), GGS_stringsetGalgasType::constructor_new (_inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (46)) ;
  macroValidPointer (_currentObject) ;
  { GGS_semanticDeclarationList::element_type * _ptr = _currentObject->mSemanticDeclarationList.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_semanticDeclaration_type * _f = (_treewalking_routine_semanticDeclaration_type *) _gDispatcherTree.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_outTypeMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
  if (((var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (50)))._operator_strictSup (GGS_uint (true, 0U))).isBuiltAndTrue ()) {
    GGS_string var_cas_m ;
    var_cas_m = (var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (51)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (51)))._operator_concat (GGS_string (true, " type")) ;
    if (((var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (52)))._operator_isEqual (GGS_uint (true, 1U))).isBuiltAndTrue ()) {
      var_cas_m = GGS_string (true, "1 type is not defined: ") ;
    }else{
      var_cas_m = (var_cas_outTypeMap.reader_unsolvedIndexCount (_inLexique COMMA_SOURCE_FILE_AT_LINE (55)).reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (55)))._operator_concat (GGS_string (true, " types are not defined: ")) ;
    }
    GGS_bool var_cas_first ;
    var_cas_first = GGS_bool (true, true) ;
    const GGS_stringlist _var_3888 = var_cas_outTypeMap.reader_unsolvedIndexKeyStringList (_inLexique COMMA_SOURCE_FILE_AT_LINE (58)) ;
    GGS_stringlist::element_type * operand_3888 = _var_3888.firstObject () ;
    while ((operand_3888 != NULL)) {
      macroValidPointer (operand_3888) ;
      if ((var_cas_first).isBuiltAndTrue ()) {
        var_cas_first = GGS_bool (true, false) ;
      }else{
        var_cas_m.writeString (", ") ;
      }
      var_cas_m.writeString ("@") ;
      var_cas_m._dotAssign_operation (operand_3888->mValue) ;
      operand_3888 = operand_3888->nextObject () ;
    }
    GGS_location (_inLexique).reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (66)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         'semanticDeclaration' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_semanticDeclaration (C_Compiler &,
                                const cPtr_semanticDeclaration * /* _currentObject */,
                                GGS_typeMap  & /* var_cas_ioTypeMap */) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @semanticDeclaration\n") ; fflush (stdout) ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Build Dispatcher Tree                            *
//                                                                           *
//---------------------------------------------------------------------------*

static void _build_dispacher_tree (void) {
  _gDispatcherTree.enterTable (_metamodel_index_for_instructionMetamodel (),
                                _kSize_instructionMetamodel,
                                _kDispatcherFor_instructionMetamodel
                                COMMA_HERE) ;
  _gDispatcherTree.enterTable (_metamodel_index_for_semanticsMetamodel (),
                                _kSize_semanticsMetamodel,
                                _kDispatcherFor_semanticsMetamodel
                                COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                               Root routine                                *
//                                                                           *
//---------------------------------------------------------------------------*

void
_walk_throught_buildTypeMapForSemantics (C_Compiler & _inLexique,
                                const GGS_semanticsComponentRoot & _rootObject,
                                GGS_typeMap  & var_cas_outTypeMap) {
  if (_rootObject._isBuilt ()) {
    if (! _gDispatcherTree.isInited ()) {
      _build_dispacher_tree () ;
    }
    _treewalking_routine_semanticsComponentRoot_type * _f = (_treewalking_routine_semanticsComponentRoot_type *) _gDispatcherTree.entry (_rootObject.getPtr () COMMA_HERE) ;
    (* _f) (_inLexique, _rootObject.getPtr (), var_cas_outTypeMap) ;
  }else{
    var_cas_outTypeMap._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

