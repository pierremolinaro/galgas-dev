//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'buildSemanticContext.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 12th, 2010, at 19h36'32"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "buildSemanticContext.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "buildSemanticContext.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_predefinedTypeAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_predefinedTypeAST::
cPtr_predefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mPredefinedTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_predefinedTypeAST * GGS_predefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_predefinedTypeAST) ;
    return (cPtr_predefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_predefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@predefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_predefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_predefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_predefinedTypeAST (& typeid (cPtr_predefinedTypeAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_predefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__predefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_predefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_predefinedTypeAST ("predefinedTypeAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST::
GGS_predefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST::
GGS_predefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_predefinedTypeAST GGS_predefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_predefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_predefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_predefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_predefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_predefinedTypeAST::
reader_mPredefinedTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_predefinedTypeAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_predefinedTypeAST *) mPointer)->mPredefinedTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_predefinedTypeAST::actualTypeName (void) const {
  return "predefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__predefinedTypeAST ("predefinedTypeAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_predefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_predefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_predefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_predefinedTypeAST GGS_predefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_predefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_predefinedTypeAST * p = dynamic_cast <const GGS_predefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_predefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_predefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_predefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_binarysetPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_binarysetPredefinedTypeAST::
cPtr_binarysetPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_binarysetPredefinedTypeAST * GGS_binarysetPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_binarysetPredefinedTypeAST) ;
    return (cPtr_binarysetPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_binarysetPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_binarysetPredefinedTypeAST * ptr = dynamic_cast <const cPtr_binarysetPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_binarysetPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@binarysetPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_binarysetPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_binarysetPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_binarysetPredefinedTypeAST (& typeid (cPtr_binarysetPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_binarysetPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__binarysetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_binarysetPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_binarysetPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_binarysetPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_binarysetPredefinedTypeAST ("binarysetPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST::
GGS_binarysetPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST::
GGS_binarysetPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_binarysetPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_binarysetPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_binarysetPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_binarysetPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_binarysetPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_binarysetPredefinedTypeAST::actualTypeName (void) const {
  return "binarysetPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__binarysetPredefinedTypeAST ("binarysetPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_binarysetPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_binarysetPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_binarysetPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_binarysetPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_binarysetPredefinedTypeAST GGS_binarysetPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_binarysetPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_binarysetPredefinedTypeAST * p = dynamic_cast <const GGS_binarysetPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_binarysetPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_binarysetPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_binarysetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_boolPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_boolPredefinedTypeAST::
cPtr_boolPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_boolPredefinedTypeAST * GGS_boolPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_boolPredefinedTypeAST) ;
    return (cPtr_boolPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_boolPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_boolPredefinedTypeAST * ptr = dynamic_cast <const cPtr_boolPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_boolPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@boolPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_boolPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_boolPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_boolPredefinedTypeAST (& typeid (cPtr_boolPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_boolPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__boolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_boolPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_boolPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_boolPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_boolPredefinedTypeAST ("boolPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST::
GGS_boolPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST::
GGS_boolPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_boolPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_boolPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_boolPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_boolPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_boolPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_boolPredefinedTypeAST::actualTypeName (void) const {
  return "boolPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__boolPredefinedTypeAST ("boolPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_boolPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_boolPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_boolPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_boolPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_boolPredefinedTypeAST GGS_boolPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_boolPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_boolPredefinedTypeAST * p = dynamic_cast <const GGS_boolPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_boolPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_boolPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_boolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_uintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uintPredefinedTypeAST::
cPtr_uintPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uintPredefinedTypeAST * GGS_uintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uintPredefinedTypeAST) ;
    return (cPtr_uintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_uintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uintPredefinedTypeAST (& typeid (cPtr_uintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__uintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uintPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_uintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uintPredefinedTypeAST ("uintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST::
GGS_uintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST::
GGS_uintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_uintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_uintPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uintPredefinedTypeAST::actualTypeName (void) const {
  return "uintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uintPredefinedTypeAST ("uintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_uintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_uintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uintPredefinedTypeAST GGS_uintPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uintPredefinedTypeAST * p = dynamic_cast <const GGS_uintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_uint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_uint64PredefinedTypeAST::
cPtr_uint64PredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_uint64PredefinedTypeAST * GGS_uint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_uint64PredefinedTypeAST) ;
    return (cPtr_uint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_uint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_uint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_uint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_uint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@uint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_uint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_uint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_uint64PredefinedTypeAST (& typeid (cPtr_uint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_uint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__uint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_uint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_uint64PredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_uint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_uint64PredefinedTypeAST ("uint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST::
GGS_uint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST::
GGS_uint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_uint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_uint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_uint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_uint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_uint64PredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_uint64PredefinedTypeAST::actualTypeName (void) const {
  return "uint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__uint64PredefinedTypeAST ("uint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_uint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_uint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_uint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_uint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint64PredefinedTypeAST GGS_uint64PredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_uint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_uint64PredefinedTypeAST * p = dynamic_cast <const GGS_uint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_uint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_uint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_uint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_sintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sintPredefinedTypeAST::
cPtr_sintPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sintPredefinedTypeAST * GGS_sintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sintPredefinedTypeAST) ;
    return (cPtr_sintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_sintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sintPredefinedTypeAST (& typeid (cPtr_sintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__sintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sintPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_sintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sintPredefinedTypeAST ("sintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST::
GGS_sintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST::
GGS_sintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_sintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_sintPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sintPredefinedTypeAST::actualTypeName (void) const {
  return "sintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sintPredefinedTypeAST ("sintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_sintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_sintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sintPredefinedTypeAST GGS_sintPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sintPredefinedTypeAST * p = dynamic_cast <const GGS_sintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_sint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sint64PredefinedTypeAST::
cPtr_sint64PredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sint64PredefinedTypeAST * GGS_sint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sint64PredefinedTypeAST) ;
    return (cPtr_sint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_sint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sint64PredefinedTypeAST (& typeid (cPtr_sint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__sint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sint64PredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_sint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sint64PredefinedTypeAST ("sint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST::
GGS_sint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST::
GGS_sint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_sint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_sint64PredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sint64PredefinedTypeAST::actualTypeName (void) const {
  return "sint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sint64PredefinedTypeAST ("sint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_sint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_sint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sint64PredefinedTypeAST GGS_sint64PredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sint64PredefinedTypeAST * p = dynamic_cast <const GGS_sint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_charPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_charPredefinedTypeAST::
cPtr_charPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_charPredefinedTypeAST * GGS_charPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_charPredefinedTypeAST) ;
    return (cPtr_charPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_charPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_charPredefinedTypeAST * ptr = dynamic_cast <const cPtr_charPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_charPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@charPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_charPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_charPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_charPredefinedTypeAST (& typeid (cPtr_charPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_charPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__charPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_charPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_charPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_charPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_charPredefinedTypeAST ("charPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST::
GGS_charPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST::
GGS_charPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_charPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_charPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_charPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_charPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_charPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_charPredefinedTypeAST::actualTypeName (void) const {
  return "charPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__charPredefinedTypeAST ("charPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_charPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_charPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_charPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_charPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_charPredefinedTypeAST GGS_charPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_charPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_charPredefinedTypeAST * p = dynamic_cast <const GGS_charPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_charPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_charPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_charPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_doublePredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_doublePredefinedTypeAST::
cPtr_doublePredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_doublePredefinedTypeAST * GGS_doublePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_doublePredefinedTypeAST) ;
    return (cPtr_doublePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_doublePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_doublePredefinedTypeAST * ptr = dynamic_cast <const cPtr_doublePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_doublePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@doublePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_doublePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_doublePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_doublePredefinedTypeAST (& typeid (cPtr_doublePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_doublePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__doublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_doublePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_doublePredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_doublePredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_doublePredefinedTypeAST ("doublePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST::
GGS_doublePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST::
GGS_doublePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_doublePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_doublePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_doublePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_doublePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_doublePredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_doublePredefinedTypeAST::actualTypeName (void) const {
  return "doublePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__doublePredefinedTypeAST ("doublePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_doublePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_doublePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_doublePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_doublePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_doublePredefinedTypeAST GGS_doublePredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_doublePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_doublePredefinedTypeAST * p = dynamic_cast <const GGS_doublePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_doublePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_doublePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_doublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_stringPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringPredefinedTypeAST::
cPtr_stringPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringPredefinedTypeAST * GGS_stringPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_stringPredefinedTypeAST) ;
    return (cPtr_stringPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_stringPredefinedTypeAST * ptr = dynamic_cast <const cPtr_stringPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_stringPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@stringPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringPredefinedTypeAST (& typeid (cPtr_stringPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__stringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_stringPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_stringPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_stringPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringPredefinedTypeAST ("stringPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST::
GGS_stringPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST::
GGS_stringPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_stringPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_stringPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringPredefinedTypeAST::actualTypeName (void) const {
  return "stringPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringPredefinedTypeAST ("stringPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_stringPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_stringPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringPredefinedTypeAST GGS_stringPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringPredefinedTypeAST * p = dynamic_cast <const GGS_stringPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lboolPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lboolPredefinedTypeAST::
cPtr_lboolPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lboolPredefinedTypeAST * GGS_lboolPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lboolPredefinedTypeAST) ;
    return (cPtr_lboolPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lboolPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lboolPredefinedTypeAST * ptr = dynamic_cast <const cPtr_lboolPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lboolPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lboolPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lboolPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lboolPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lboolPredefinedTypeAST (& typeid (cPtr_lboolPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lboolPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__lboolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lboolPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lboolPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lboolPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lboolPredefinedTypeAST ("lboolPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_lboolPredefinedTypeAST::
GGS_lboolPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lboolPredefinedTypeAST::
GGS_lboolPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lboolPredefinedTypeAST GGS_lboolPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lboolPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lboolPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_lboolPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lboolPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lboolPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lboolPredefinedTypeAST GGS_lboolPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lboolPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_lboolPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lboolPredefinedTypeAST::actualTypeName (void) const {
  return "lboolPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lboolPredefinedTypeAST ("lboolPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_lboolPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lboolPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lboolPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_lboolPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lboolPredefinedTypeAST GGS_lboolPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lboolPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lboolPredefinedTypeAST * p = dynamic_cast <const GGS_lboolPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lboolPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lboolPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lboolPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_luintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luintPredefinedTypeAST::
cPtr_luintPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luintPredefinedTypeAST * GGS_luintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_luintPredefinedTypeAST) ;
    return (cPtr_luintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_luintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_luintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_luintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@luintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luintPredefinedTypeAST (& typeid (cPtr_luintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_luintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__luintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_luintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_luintPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_luintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_luintPredefinedTypeAST ("luintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_luintPredefinedTypeAST::
GGS_luintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luintPredefinedTypeAST::
GGS_luintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_luintPredefinedTypeAST GGS_luintPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_luintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_luintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luintPredefinedTypeAST GGS_luintPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_luintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_luintPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luintPredefinedTypeAST::actualTypeName (void) const {
  return "luintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__luintPredefinedTypeAST ("luintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_luintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_luintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_luintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_luintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luintPredefinedTypeAST GGS_luintPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_luintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_luintPredefinedTypeAST * p = dynamic_cast <const GGS_luintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_luintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_luintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_luintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_luint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_luint64PredefinedTypeAST::
cPtr_luint64PredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_luint64PredefinedTypeAST * GGS_luint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_luint64PredefinedTypeAST) ;
    return (cPtr_luint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_luint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_luint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_luint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_luint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@luint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_luint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_luint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_luint64PredefinedTypeAST (& typeid (cPtr_luint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_luint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__luint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_luint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_luint64PredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_luint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_luint64PredefinedTypeAST ("luint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_luint64PredefinedTypeAST::
GGS_luint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_luint64PredefinedTypeAST::
GGS_luint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_luint64PredefinedTypeAST GGS_luint64PredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_luint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_luint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_luint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_luint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_luint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64PredefinedTypeAST GGS_luint64PredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_luint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_luint64PredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_luint64PredefinedTypeAST::actualTypeName (void) const {
  return "luint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__luint64PredefinedTypeAST ("luint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_luint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_luint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_luint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_luint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64PredefinedTypeAST GGS_luint64PredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_luint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_luint64PredefinedTypeAST * p = dynamic_cast <const GGS_luint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_luint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_luint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_luint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lsintPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsintPredefinedTypeAST::
cPtr_lsintPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsintPredefinedTypeAST * GGS_lsintPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lsintPredefinedTypeAST) ;
    return (cPtr_lsintPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsintPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lsintPredefinedTypeAST * ptr = dynamic_cast <const cPtr_lsintPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lsintPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lsintPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsintPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsintPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsintPredefinedTypeAST (& typeid (cPtr_lsintPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lsintPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__lsintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lsintPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lsintPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lsintPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lsintPredefinedTypeAST ("lsintPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_lsintPredefinedTypeAST::
GGS_lsintPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsintPredefinedTypeAST::
GGS_lsintPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lsintPredefinedTypeAST GGS_lsintPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsintPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsintPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_lsintPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lsintPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsintPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsintPredefinedTypeAST GGS_lsintPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lsintPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_lsintPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsintPredefinedTypeAST::actualTypeName (void) const {
  return "lsintPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lsintPredefinedTypeAST ("lsintPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_lsintPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lsintPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lsintPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_lsintPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsintPredefinedTypeAST GGS_lsintPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lsintPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lsintPredefinedTypeAST * p = dynamic_cast <const GGS_lsintPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lsintPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lsintPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lsintPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lsint64PredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lsint64PredefinedTypeAST::
cPtr_lsint64PredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lsint64PredefinedTypeAST * GGS_lsint64PredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lsint64PredefinedTypeAST) ;
    return (cPtr_lsint64PredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lsint64PredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lsint64PredefinedTypeAST * ptr = dynamic_cast <const cPtr_lsint64PredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lsint64PredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lsint64PredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lsint64PredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lsint64PredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lsint64PredefinedTypeAST (& typeid (cPtr_lsint64PredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lsint64PredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__lsint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lsint64PredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lsint64PredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lsint64PredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lsint64PredefinedTypeAST ("lsint64PredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_lsint64PredefinedTypeAST::
GGS_lsint64PredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lsint64PredefinedTypeAST::
GGS_lsint64PredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lsint64PredefinedTypeAST GGS_lsint64PredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lsint64PredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lsint64PredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_lsint64PredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lsint64PredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lsint64PredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64PredefinedTypeAST GGS_lsint64PredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lsint64PredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_lsint64PredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lsint64PredefinedTypeAST::actualTypeName (void) const {
  return "lsint64PredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lsint64PredefinedTypeAST ("lsint64PredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_lsint64PredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lsint64PredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lsint64PredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_lsint64PredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64PredefinedTypeAST GGS_lsint64PredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lsint64PredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lsint64PredefinedTypeAST * p = dynamic_cast <const GGS_lsint64PredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lsint64PredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lsint64PredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lsint64PredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_lcharPredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lcharPredefinedTypeAST::
cPtr_lcharPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lcharPredefinedTypeAST * GGS_lcharPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lcharPredefinedTypeAST) ;
    return (cPtr_lcharPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lcharPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lcharPredefinedTypeAST * ptr = dynamic_cast <const cPtr_lcharPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lcharPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lcharPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lcharPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lcharPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lcharPredefinedTypeAST (& typeid (cPtr_lcharPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lcharPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__lcharPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lcharPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lcharPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lcharPredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lcharPredefinedTypeAST ("lcharPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_lcharPredefinedTypeAST::
GGS_lcharPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lcharPredefinedTypeAST::
GGS_lcharPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lcharPredefinedTypeAST GGS_lcharPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lcharPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lcharPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_lcharPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lcharPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lcharPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lcharPredefinedTypeAST GGS_lcharPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lcharPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_lcharPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lcharPredefinedTypeAST::actualTypeName (void) const {
  return "lcharPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lcharPredefinedTypeAST ("lcharPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_lcharPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lcharPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lcharPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_lcharPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lcharPredefinedTypeAST GGS_lcharPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lcharPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lcharPredefinedTypeAST * p = dynamic_cast <const GGS_lcharPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lcharPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lcharPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lcharPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_ldoublePredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ldoublePredefinedTypeAST::
cPtr_ldoublePredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ldoublePredefinedTypeAST * GGS_ldoublePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ldoublePredefinedTypeAST) ;
    return (cPtr_ldoublePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ldoublePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ldoublePredefinedTypeAST * ptr = dynamic_cast <const cPtr_ldoublePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ldoublePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ldoublePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ldoublePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ldoublePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ldoublePredefinedTypeAST (& typeid (cPtr_ldoublePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ldoublePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__ldoublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ldoublePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ldoublePredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_ldoublePredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ldoublePredefinedTypeAST ("ldoublePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_ldoublePredefinedTypeAST::
GGS_ldoublePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ldoublePredefinedTypeAST::
GGS_ldoublePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ldoublePredefinedTypeAST GGS_ldoublePredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ldoublePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ldoublePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_ldoublePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ldoublePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ldoublePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldoublePredefinedTypeAST GGS_ldoublePredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_ldoublePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_ldoublePredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ldoublePredefinedTypeAST::actualTypeName (void) const {
  return "ldoublePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ldoublePredefinedTypeAST ("ldoublePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_ldoublePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ldoublePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ldoublePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_ldoublePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldoublePredefinedTypeAST GGS_ldoublePredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ldoublePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ldoublePredefinedTypeAST * p = dynamic_cast <const GGS_ldoublePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ldoublePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ldoublePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ldoublePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lstringPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lstringPredefinedTypeAST::
cPtr_lstringPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lstringPredefinedTypeAST * GGS_lstringPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lstringPredefinedTypeAST) ;
    return (cPtr_lstringPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lstringPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lstringPredefinedTypeAST * ptr = dynamic_cast <const cPtr_lstringPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lstringPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lstringPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lstringPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lstringPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lstringPredefinedTypeAST (& typeid (cPtr_lstringPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lstringPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__lstringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lstringPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lstringPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lstringPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lstringPredefinedTypeAST ("lstringPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_lstringPredefinedTypeAST::
GGS_lstringPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lstringPredefinedTypeAST::
GGS_lstringPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lstringPredefinedTypeAST GGS_lstringPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lstringPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lstringPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_lstringPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lstringPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lstringPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringPredefinedTypeAST GGS_lstringPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_lstringPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_lstringPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lstringPredefinedTypeAST::actualTypeName (void) const {
  return "lstringPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lstringPredefinedTypeAST ("lstringPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_lstringPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lstringPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lstringPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_lstringPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringPredefinedTypeAST GGS_lstringPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lstringPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lstringPredefinedTypeAST * p = dynamic_cast <const GGS_lstringPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lstringPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lstringPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lstringPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_locationPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_locationPredefinedTypeAST::
cPtr_locationPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_locationPredefinedTypeAST * GGS_locationPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_locationPredefinedTypeAST) ;
    return (cPtr_locationPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_locationPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_locationPredefinedTypeAST * ptr = dynamic_cast <const cPtr_locationPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_locationPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@locationPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_locationPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_locationPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_locationPredefinedTypeAST (& typeid (cPtr_locationPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_locationPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__locationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_locationPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_locationPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_locationPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_locationPredefinedTypeAST ("locationPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST::
GGS_locationPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST::
GGS_locationPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_locationPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_locationPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_locationPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_locationPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_locationPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_locationPredefinedTypeAST::actualTypeName (void) const {
  return "locationPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__locationPredefinedTypeAST ("locationPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_locationPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_locationPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_locationPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_locationPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_locationPredefinedTypeAST GGS_locationPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_locationPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_locationPredefinedTypeAST * p = dynamic_cast <const GGS_locationPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_locationPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_locationPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_locationPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_stringsetPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_stringsetPredefinedTypeAST::
cPtr_stringsetPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_stringsetPredefinedTypeAST * GGS_stringsetPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_stringsetPredefinedTypeAST) ;
    return (cPtr_stringsetPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_stringsetPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_stringsetPredefinedTypeAST * ptr = dynamic_cast <const cPtr_stringsetPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_stringsetPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@stringsetPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_stringsetPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_stringsetPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_stringsetPredefinedTypeAST (& typeid (cPtr_stringsetPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_stringsetPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__stringsetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_stringsetPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_stringsetPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_stringsetPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_stringsetPredefinedTypeAST ("stringsetPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST::
GGS_stringsetPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST::
GGS_stringsetPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_stringsetPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_stringsetPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_stringsetPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_stringsetPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_stringsetPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_stringsetPredefinedTypeAST::actualTypeName (void) const {
  return "stringsetPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__stringsetPredefinedTypeAST ("stringsetPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_stringsetPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_stringsetPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_stringsetPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_stringsetPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringsetPredefinedTypeAST GGS_stringsetPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_stringsetPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_stringsetPredefinedTypeAST * p = dynamic_cast <const GGS_stringsetPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_stringsetPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_stringsetPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_stringsetPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_objectPredefinedTypeAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_objectPredefinedTypeAST::
cPtr_objectPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_objectPredefinedTypeAST * GGS_objectPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_objectPredefinedTypeAST) ;
    return (cPtr_objectPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_objectPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_objectPredefinedTypeAST * ptr = dynamic_cast <const cPtr_objectPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_objectPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@objectPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_objectPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_objectPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_objectPredefinedTypeAST (& typeid (cPtr_objectPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_objectPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__objectPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_objectPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_objectPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_objectPredefinedTypeAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_objectPredefinedTypeAST ("objectPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST::
GGS_objectPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST::
GGS_objectPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_objectPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_objectPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_objectPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_objectPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_objectPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_objectPredefinedTypeAST::actualTypeName (void) const {
  return "objectPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__objectPredefinedTypeAST ("objectPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_objectPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_objectPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_objectPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_objectPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_objectPredefinedTypeAST GGS_objectPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_objectPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_objectPredefinedTypeAST * p = dynamic_cast <const GGS_objectPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_objectPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_objectPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_objectPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_functionPredefinedTypeAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionPredefinedTypeAST::
cPtr_functionPredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionPredefinedTypeAST * GGS_functionPredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionPredefinedTypeAST) ;
    return (cPtr_functionPredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionPredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionPredefinedTypeAST * ptr = dynamic_cast <const cPtr_functionPredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionPredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionPredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionPredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionPredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionPredefinedTypeAST (& typeid (cPtr_functionPredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionPredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionPredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionPredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_functionPredefinedTypeAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionPredefinedTypeAST ("functionPredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST::
GGS_functionPredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST::
GGS_functionPredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionPredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionPredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionPredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionPredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_functionPredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionPredefinedTypeAST::actualTypeName (void) const {
  return "functionPredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionPredefinedTypeAST ("functionPredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_functionPredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionPredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionPredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_functionPredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionPredefinedTypeAST GGS_functionPredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionPredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionPredefinedTypeAST * p = dynamic_cast <const GGS_functionPredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionPredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionPredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionPredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typePredefinedTypeAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typePredefinedTypeAST::
cPtr_typePredefinedTypeAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_predefinedTypeAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typePredefinedTypeAST * GGS_typePredefinedTypeAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typePredefinedTypeAST) ;
    return (cPtr_typePredefinedTypeAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typePredefinedTypeAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typePredefinedTypeAST * ptr = dynamic_cast <const cPtr_typePredefinedTypeAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mPredefinedTypeName.operator_isEqual (ptr->mPredefinedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typePredefinedTypeAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typePredefinedTypeAST:"
           << mPredefinedTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typePredefinedTypeAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typePredefinedTypeAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typePredefinedTypeAST (& typeid (cPtr_typePredefinedTypeAST), & typeid (cPtr_predefinedTypeAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typePredefinedTypeAST::galgasRTTI (void) const {
  return & gClassInfoFor__typePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typePredefinedTypeAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typePredefinedTypeAST (mPredefinedTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typePredefinedTypeAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typePredefinedTypeAST ("typePredefinedTypeAST", true, & kTypeDescriptor_GGS_predefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST::
GGS_typePredefinedTypeAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST::
GGS_typePredefinedTypeAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typePredefinedTypeAST *> (inPointer) != NULL)
      : (typeid (cPtr_typePredefinedTypeAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typePredefinedTypeAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typePredefinedTypeAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  macroMyNew (result.mPointer, cPtr_typePredefinedTypeAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typePredefinedTypeAST::actualTypeName (void) const {
  return "typePredefinedTypeAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typePredefinedTypeAST ("typePredefinedTypeAST", gClassInfoFor__predefinedTypeAST, & kTypeDescriptor_GGS_typePredefinedTypeAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typePredefinedTypeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typePredefinedTypeAST * p = NULL ;
    macroMyNew (p, GGS_typePredefinedTypeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typePredefinedTypeAST GGS_typePredefinedTypeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typePredefinedTypeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typePredefinedTypeAST * p = dynamic_cast <const GGS_typePredefinedTypeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typePredefinedTypeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typePredefinedTypeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typePredefinedTypeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "appendPredefinedListTypeAST"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendPredefinedListTypeAST (C_Compiler & inLexique,
                                GGS_semanticDeclarationListAST  & var_cas_ioDeclarationListASTs,
                                const GGS_string  var_cas_inElementTypeName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendPredefinedListTypeAST at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_attributeInCollectionListAST  var_cas_attributeList = GGS_attributeInCollectionListAST ::constructor_emptyList () ;
  var_cas_attributeList.addAssign_operation (GGS_lstring ::constructor_new (inLexique, var_cas_inElementTypeName, GGS_location (inLexique) COMMA_HERE), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_listDeclarationAST ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, (var_cas_inElementTypeName).operator_concat (GGS_string ("list")), GGS_location (inLexique) COMMA_HERE), var_cas_attributeList COMMA_HERE)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendPredefinedListTypeAST\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "appendPredefinedTypesASTs"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendPredefinedTypesASTs (C_Compiler & inLexique,
                                GGS_semanticDeclarationListAST  & var_cas_ioDeclarationListASTs COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendPredefinedTypesASTs at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_boolPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("bool") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_uintPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("uint") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_uint64PredefinedTypeAST ::constructor_new (inLexique, GGS_string ("uint64") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_sintPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("sint") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_sint64PredefinedTypeAST ::constructor_new (inLexique, GGS_string ("sint64") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_charPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("char") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_doublePredefinedTypeAST ::constructor_new (inLexique, GGS_string ("double") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_stringPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("string") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_lboolPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("lbool") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_luintPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("luint") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_luint64PredefinedTypeAST ::constructor_new (inLexique, GGS_string ("luint64") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_lsintPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("lsint") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_lsint64PredefinedTypeAST ::constructor_new (inLexique, GGS_string ("lsint64") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_lcharPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("lchar") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_ldoublePredefinedTypeAST ::constructor_new (inLexique, GGS_string ("ldouble") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_lstringPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("lstring") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_locationPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("location") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_stringsetPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("stringset") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_objectPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("object") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_functionPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("function") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_typePredefinedTypeAST ::constructor_new (inLexique, GGS_string ("type") COMMA_HERE)) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_binarysetPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("binaryset") COMMA_HERE)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("uint") COMMA_SOURCE_FILE_AT_LINE (131)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("uint64") COMMA_SOURCE_FILE_AT_LINE (132)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("sint") COMMA_SOURCE_FILE_AT_LINE (133)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("sint64") COMMA_SOURCE_FILE_AT_LINE (134)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("object") COMMA_SOURCE_FILE_AT_LINE (135)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("function") COMMA_SOURCE_FILE_AT_LINE (136)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("string") COMMA_SOURCE_FILE_AT_LINE (137)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("lstring") COMMA_SOURCE_FILE_AT_LINE (138)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendPredefinedTypesASTs\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineMap ("routineMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_routineMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineMap * p = NULL ;
    macroMyNew (p, GGS_routineMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineMap * p = dynamic_cast <const GGS_routineMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionMap ("functionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultTypeIndex.operator_isEqual (ptr->mInfo.mResultTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_unifiedTypeMapIndex & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultTypeIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_unifiedTypeMapIndex   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_unifiedTypeMapIndex   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_unifiedTypeMapIndex & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_functionMap::cEnumerator::_mResultTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultTypeIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_functionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionMap * p = NULL ;
    macroMyNew (p, GGS_functionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionMap * p = dynamic_cast <const GGS_functionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mTemplateSignature (),
mFilewrapperTemplatePath () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateMap ("filewrapperTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperTemplateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTemplateSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplatePath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTemplateSignature.operator_isEqual (ptr->mInfo.mTemplateSignature)).boolValue ()
           && (mInfo.mFilewrapperTemplatePath.operator_isEqual (ptr->mInfo.mFilewrapperTemplatePath)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperTemplateMap info  ;
    info.mTemplateSignature = inParameter0 ;
    info.mFilewrapperTemplatePath = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mTemplateSignature ;
    outParameter1 = node->mInfo.mFilewrapperTemplatePath ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_filewrapperTemplateMap::cEnumerator::_mTemplateSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateMap::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateMap * p = dynamic_cast <const GGS_filewrapperTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_filewrapperMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperMap::e_filewrapperMap (void) :
mFilewrapperPath (),
mFilewrapperExtensionList (),
mFilewrapperTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@filewrapperMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperMap ("filewrapperMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperMap::
elementOf_GGS_filewrapperMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperPath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperExtensionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplateMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFilewrapperPath.operator_isEqual (ptr->mInfo.mFilewrapperPath)).boolValue ()
           && (mInfo.mFilewrapperExtensionList.operator_isEqual (ptr->mInfo.mFilewrapperExtensionList)).boolValue ()
           && (mInfo.mFilewrapperTemplateMap.operator_isEqual (ptr->mInfo.mFilewrapperTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isNotEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_lstringlist & inParameter1,
                const GGS_filewrapperTemplateMap & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperMap info  ;
    info.mFilewrapperPath = inParameter0 ;
    info.mFilewrapperExtensionList = inParameter1 ;
    info.mFilewrapperTemplateMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstringlist   & outParameter1,
               GGS_filewrapperTemplateMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFilewrapperPath ;
    outParameter1 = node->mInfo.mFilewrapperExtensionList ;
    outParameter2 = node->mInfo.mFilewrapperTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstringlist   & outParameter1,
                                GGS_filewrapperTemplateMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstringlist & inParameter1,
                                const GGS_filewrapperTemplateMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperMap::cEnumerator::_mFilewrapperPath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperPath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_filewrapperMap::cEnumerator::_mFilewrapperExtensionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperExtensionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperMap * p = dynamic_cast <const GGS_filewrapperMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperMap ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_descendantClassListMap ("descendantClassListMap", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_unifiedTypeMapIndexList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_descendantClassListMap::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_descendantClassListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_descendantClassListMap::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
constructor_emptyMap (void) {
  GGS_descendantClassListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_descendantClassListMap::
_typeNameForDescriptionReader (void) const {
  return "@descendantClassListMap" ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
operator_concat (const GGS_descendantClassListMap & inOperand) const {
  GGS_descendantClassListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
dotAssign_operation (const GGS_descendantClassListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_unifiedTypeMapIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_unifiedTypeMapIndex & inAttribute0) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_unifiedTypeMapIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_descendantClassListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_unifiedTypeMapIndexList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_descendantClassListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_descendantClassListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cEnumerator::
cEnumerator (const GGS_descendantClassListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_unifiedTypeMapIndexList & GGS_descendantClassListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_descendantClassListMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_descendantClassListMap * p = NULL ;
    macroMyNew (p, GGS_descendantClassListMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_descendantClassListMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_descendantClassListMap * p = dynamic_cast <const GGS_descendantClassListMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_descendantClassListMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_descendantClassListMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_descendantClassListMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mDescendantClassListMap (),
mFilewrapperMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mDescendantClassListMap.drop () ;
  mFilewrapperMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mDescendantClassListMap.isBuilt ()
    && mFilewrapperMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isEqual (inOperand.mTypeMap)
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mDescendantClassListMap.operator_isEqual (inOperand.mDescendantClassListMap))
    .operator_and (mFilewrapperMap.operator_isEqual (inOperand.mFilewrapperMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isNotEqual (inOperand.mTypeMap)
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mDescendantClassListMap.operator_isNotEqual (inOperand.mDescendantClassListMap))
    .operator_or (mFilewrapperMap.operator_isNotEqual (inOperand.mFilewrapperMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_unifiedTypeMap & argument_0,
                 const GGS_routineMap & argument_1,
                 const GGS_functionMap & argument_2,
                 const GGS_descendantClassListMap& argument_3,
                 const GGS_filewrapperMap & argument_4) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  result.mRoutineMap = argument_1 ;
  result.mFunctionMap = argument_2 ;
  result.mDescendantClassListMap = argument_3 ;
  result.mFilewrapperMap = argument_4 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDescendantClassListMap " ;
    _s << mDescendantClassListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrapperMap " ;
    _s << mFilewrapperMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@collectedTypeMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMap ("collectedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_collectedTypeMap::
elementOf_GGS_collectedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_collectedTypeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_collectedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_collectedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_collectedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_collectedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isNotEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_collectedTypeMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_collectedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_collectedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @collectedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMap * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMap * p = dynamic_cast <const GGS_collectedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    map index '@collectedTypeMapIndex'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMapIndex ("collectedTypeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isNotEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @collectedTypeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_collectedTypeMap & ioMap,
                               GGS_collectedTypeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMapIndex * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMapIndex * p = dynamic_cast <const GGS_collectedTypeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMapIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "collectAttributeTypes"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_collectAttributeTypes (C_Compiler & inLexique,
                                const GGS_attributeInCollectionListAST   var_cas_inAttributeList,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_collectAttributeTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_attributeInCollectionListAST::cEnumerator enumerator_11034 (var_cas_inAttributeList, true) ;
    const GGS_attributeInCollectionListAST::cElement * operand_11034 = NULL ;
    while (((operand_11034 = enumerator_11034.nextObject ()))) {
      macroValidPointer (operand_11034) ;
      GGS_collectedTypeMapIndex  var_cas_attributeTypeIndex ;
      GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_11034->mAttributeTypeName, var_cas_ioCollectedTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (234)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_collectAttributeTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@semanticDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__collectType (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_11347,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11347 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@semanticDeclarationAST.collectType'   *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__collectType> gDispatchTableForMethod__semanticDeclarationAST__collectType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__collectType (typeCategoryMethod__semanticDeclarationAST__collectType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__collectType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__collectType
findCategoryMethod__semanticDeclarationAST__collectType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__collectType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__collectType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__collectType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__collectType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__collectType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@predefinedTypeAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__collectType (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_11537,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11537 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_11537->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (250)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@mapDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_11800,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11800 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_11800->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (258)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_11800->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (259)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@mapindexDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_12102,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12102 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12102->mMapIndexTypeName COMMA_SOURCE_FILE_AT_LINE (267)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@enumDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_12342,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12342 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12342->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (275)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@sortedListDeclarationAST.collectType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_12584,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12584 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12584->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (283)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_12584->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (284)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@structDeclarationAST.collectType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_12891,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12891 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12891->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (292)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_12891->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (293)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_13192,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13192 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13192->mListTypeName COMMA_SOURCE_FILE_AT_LINE (301)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_13192->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (302)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@classDeclarationAST.collectType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_13492,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13492 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13492->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (310)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_13492->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (311)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@listmapDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_13795,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13795 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13795->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (319)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@semanticDeclarationAST.enterType'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterType> gDispatchTableForMethod__semanticDeclarationAST__enterType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterType (typeCategoryMethod__semanticDeclarationAST__enterType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterType
findCategoryMethod__semanticDeclarationAST__enterType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@uintPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__uintPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_uintPredefinedTypeAST * operand_14525,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14525 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_constructorMapFor_uint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (339)) ;
    ::routine_readerMapFor_uint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (340)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_14525->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (341)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@uint64PredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__uint64PredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_uint64PredefinedTypeAST * operand_15343,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15343 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_constructorMapFor_uint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (363)) ;
    ::routine_readerMapFor_uint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (364)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_15343->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (365)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@sintPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sintPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_sintPredefinedTypeAST * operand_16141,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16141 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_constructorMapFor_sint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (387)) ;
    ::routine_readerMapFor_sint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (388)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_16141->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (389)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@sint64PredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sint64PredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_sint64PredefinedTypeAST * operand_16937,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16937 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_constructorMapFor_sint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (411)) ;
    ::routine_readerMapFor_sint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (412)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_16937->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (413)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@charPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__charPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_charPredefinedTypeAST * operand_17735,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17735 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_constructorMapFor_char (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (435)) ;
    ::routine_readerMapFor_char (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (436)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_17735->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (437)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@doublePredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__doublePredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_doublePredefinedTypeAST * operand_18531,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_18531 != NULL) {
    GGS_readerMap  var_cas_readerMap ;
    ::routine_readerMapFor_double (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (458)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_18531->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (459)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@stringPredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_stringPredefinedTypeAST * operand_19234,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_19234 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_string (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (484)) ;
    ::routine_readerMapFor_string (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (485)) ;
    ::routine_modifierMapFor_string (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (486)) ;
    ::routine_instanceMethodMapFor_string (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (487)) ;
    ::routine_classMethodMapFor_string (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_classMethodMap COMMA_SOURCE_FILE_AT_LINE (488)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_19234->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (489)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@lboolPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lboolPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_lboolPredefinedTypeAST * operand_20324,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_20324 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_lbool (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (514)) ;
    ::routine_readerMapFor_lbool (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (515)) ;
    ::routine_modifierMapFor_lbool (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (516)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_20324->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (517)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@luintPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__luintPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_luintPredefinedTypeAST * operand_21281,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_21281 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_luint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (542)) ;
    ::routine_readerMapFor_luint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (543)) ;
    ::routine_modifierMapFor_luint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (544)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_21281->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (545)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@luint64PredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__luint64PredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_luint64PredefinedTypeAST * operand_22240,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22240 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_luint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (570)) ;
    ::routine_readerMapFor_luint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (571)) ;
    ::routine_modifierMapFor_luint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (572)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_22240->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (573)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@lsintPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lsintPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_lsintPredefinedTypeAST * operand_23203,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23203 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_lsint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (598)) ;
    ::routine_readerMapFor_lsint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (599)) ;
    ::routine_modifierMapFor_lsint (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (600)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_23203->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (601)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@lsint64PredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lsint64PredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_lsint64PredefinedTypeAST * operand_24162,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24162 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_lsint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (626)) ;
    ::routine_readerMapFor_lsint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (627)) ;
    ::routine_modifierMapFor_lsint64 (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (628)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_24162->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (629)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@lcharPredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lcharPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_lcharPredefinedTypeAST * operand_25125,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25125 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_lchar (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (654)) ;
    ::routine_readerMapFor_lchar (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (655)) ;
    ::routine_modifierMapFor_lchar (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (656)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_25125->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (657)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@ldoublePredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__ldoublePredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_ldoublePredefinedTypeAST * operand_26084,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26084 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_ldouble (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (682)) ;
    ::routine_readerMapFor_ldouble (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (683)) ;
    ::routine_modifierMapFor_ldouble (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (684)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_26084->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (685)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@lstringPredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lstringPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_lstringPredefinedTypeAST * operand_27049,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_27049 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_lstring (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (710)) ;
    ::routine_readerMapFor_lstring (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (711)) ;
    ::routine_modifierMapFor_lstring (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (712)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_27049->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (713)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@locationPredefinedTypeAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__locationPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_locationPredefinedTypeAST * operand_28015,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_28015 != NULL) {
    GGS_readerMap  var_cas_readerMap ;
    ::routine_readerMapFor_location (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (734)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_28015->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (735)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@stringsetPredefinedTypeAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringsetPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_stringsetPredefinedTypeAST * operand_28723,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_28723 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_data (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (760)) ;
    ::routine_readerMapFor_data (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (761)) ;
    ::routine_modifierMapFor_data (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (762)) ;
    ::routine_instanceMethodMapFor_data (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (763)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_28723->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (764)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@objectPredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__objectPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_objectPredefinedTypeAST * operand_29744,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_29744 != NULL) {
    GGS_readerMap  var_cas_readerMap ;
    ::routine_readerMapFor_object (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (785)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_29744->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (786)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@functionPredefinedTypeAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__functionPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_functionPredefinedTypeAST * operand_30449,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_30449 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    ::routine_constructorMapFor_function (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (811)) ;
    ::routine_readerMapFor_function (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (812)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_30449->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (813)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@typePredefinedTypeAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__typePredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_typePredefinedTypeAST * operand_31356,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_31356 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_constructorMapFor_type (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (836)) ;
    ::routine_readerMapFor_type (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (837)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_31356->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (838)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@binarysetPredefinedTypeAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__binarysetPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_binarysetPredefinedTypeAST * operand_32186,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_32186 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_constructorMapFor_binaryset (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (861)) ;
    ::routine_readerMapFor_binaryset (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (862)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_32186->mPredefinedTypeName, GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (863)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@mapDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_33017,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_33017 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndex  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (890)) ;
    GGS_unifiedTypeMapIndex  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (893)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentMapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_33017->mMapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (896)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_33017->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (898)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (898)) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (900)) ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_insertMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    GGS_formalParameterSignature  var_cas_removeMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_34574 (operand_33017->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_34574 = NULL ;
      while (((operand_34574 = enumerator_34574.nextObject ()))) {
        macroValidPointer (operand_34574) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_34574->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (909)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_34574->mAttributeName) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_34574->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (911))) ;
        var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_35168 (operand_33017->mInsertMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_35168 = NULL ;
      while (((operand_35168 = enumerator_35168.nextObject ()))) {
        macroValidPointer (operand_35168) ;
        const GGS_bool cond_35323 = var_cas_modifierMap.reader_hasKey (operand_35168->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (917))) ;
        if (cond_35323.isBuiltAndTrue ()) {
          operand_35168->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_35168->mMethodName)).operator_concat (GGS_string ("' insert method is already declared")) COMMA_SOURCE_FILE_AT_LINE (919)) ;
        }else if (cond_35323.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_35168->mMethodName, var_cas_insertMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (920)) ;
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_35531 (operand_33017->mRemoveMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_35531 = NULL ;
      while (((operand_35531 = enumerator_35531.nextObject ()))) {
        macroValidPointer (operand_35531) ;
        const GGS_bool cond_35722 = var_cas_modifierMap.reader_hasKey (operand_35531->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (929))) ;
        if (cond_35722.isBuiltAndTrue ()) {
          operand_35531->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_35531->mMethodName)).operator_concat (GGS_string ("' method is already declared as an insert modifier or a remove modifier")) COMMA_SOURCE_FILE_AT_LINE (931)) ;
        }else if (cond_35722.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_35531->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (932)) ;
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_35928 (operand_33017->mSearchMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_35928 = NULL ;
      while (((operand_35928 = enumerator_35928.nextObject ()))) {
        macroValidPointer (operand_35928) ;
        var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, operand_35928->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (941)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_36127 (operand_33017->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_36127 = NULL ;
      while (((operand_36127 = enumerator_36127.nextObject ()))) {
        macroValidPointer (operand_36127) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_36127->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (949))).operator_concat (GGS_string ("ForKey")), operand_36127->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (949)) COMMA_HERE) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_36127->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (951)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_unifiedTypeMapIndexList ::constructor_listWithValue (var_cas_stringTypeIndex), GGS_bool (true), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (952)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_36691 (operand_33017->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_36691 = NULL ;
      while (((operand_36691 = enumerator_36691.nextObject ()))) {
        macroValidPointer (operand_36691) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_36691->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")), operand_36691->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (963)) COMMA_HERE) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_36691->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (965)) ;
        GGS_formalParameterSignature  var_cas_accessorFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, var_cas_accessorFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (969)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_33017->mMapTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapType (inLexique COMMA_HERE), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumerationDescriptor COMMA_SOURCE_FILE_AT_LINE (976)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@mapindexDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_37898,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_37898 != NULL) {
    GGS_typedAttributeList  var_cas_mapTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_bool automatic_var_38193_0 ;
    GGS_unifiedTypeMapIndex  automatic_var_38193_1 ;
    GGS_constructorMap  automatic_var_38193_2 ;
    GGS_readerMap  automatic_var_38193_3 ;
    GGS_modifierMap  automatic_var_38193_4 ;
    GGS_instanceMethodMap  automatic_var_38193_5 ;
    GGS_classMethodMap  automatic_var_38193_6 ;
    GGS_enumerationDescriptorList  automatic_var_38193_7 ;
    const GGS_unifiedTypeMap  temp_38100 = var_cas_ioSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (999)) ;
    if (temp_38100.isBuilt ()) {
      temp_38100 (HERE)->method_searchKey (inLexique, operand_37898->mAssociatedMapTypeName, automatic_var_38193_0, automatic_var_38193_1, var_cas_typeKindEnum, var_cas_mapTypedAttributeList, automatic_var_38193_2, automatic_var_38193_3, automatic_var_38193_4, automatic_var_38193_5, automatic_var_38193_6, automatic_var_38193_7 COMMA_SOURCE_FILE_AT_LINE (999)) ;
    }
    const GGS_bool cond_38410 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_mapType (inLexique COMMA_HERE)) ;
    if (cond_38410.isBuiltAndTrue ()) {
      operand_37898->mAssociatedMapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_37898->mAssociatedMapTypeName)).operator_concat (GGS_string (" should be a map type")) COMMA_SOURCE_FILE_AT_LINE (1008)) ;
      var_cas_mapTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndex  var_cas_associatedMapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_37898->mAssociatedMapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_associatedMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (1018)) ;
    GGS_unifiedTypeMapIndex  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1021)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1024)) ;
    GGS_unifiedTypeMapIndex  var_cas_mapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_37898->mMapIndexTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_mapTypeIndex COMMA_SOURCE_FILE_AT_LINE (1027)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_argList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_argList.addAssign_operation (var_cas_associatedMapTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_HERE)) ;
    var_cas_argList.addAssign_operation (var_cas_currentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
    var_cas_classMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("makeRegularIndex"), GGS_location (inLexique) COMMA_HERE), var_cas_argList, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1033)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("null"),  operand_37898->mMapIndexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1039)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1039)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isSolved"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1041)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isNull"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1042)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_40282 (var_cas_mapTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_40282 = NULL ;
      while (((operand_40282 = enumerator_40282.nextObject ()))) {
        macroValidPointer (operand_40282) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_40282->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1045))).operator_concat (GGS_string ("ForKey")), operand_40282->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1045)) COMMA_HERE) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_bool (true), operand_40282->mAttributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (1046)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_37898->mMapIndexTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_HERE), var_cas_mapTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1056)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@enumDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_41117,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_41117 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_41117->mEnumTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1084)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_41601 (operand_41117->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_41601 = NULL ;
      while (((operand_41601 = enumerator_41601.nextObject ()))) {
        macroValidPointer (operand_41601) ;
        ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  operand_41601->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1087)),  operand_41117->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1087)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1087)) ;
      }
    }
    {
      GGS_enumMessageListAST::cEnumerator enumerator_41792 (operand_41117->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_41792 = NULL ;
      while (((operand_41792 = enumerator_41792.nextObject ()))) {
        macroValidPointer (operand_41792) ;
        ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_41792->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1091)),  GGS_string ("string"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1091)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_41117->mEnumTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_HERE), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1094)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@filewrapperDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_42471,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_42471 != NULL) {
    GGS_filewrapperTemplateMap  var_cas_filewrapperTemplateMap = GGS_filewrapperTemplateMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    {
      GGS_filewrapperTemplateListAST::cEnumerator enumerator_42609 (operand_42471->mFilewrapperTemplateList, true) ;
      const GGS_filewrapperTemplateListAST::cElement * operand_42609 = NULL ;
      while (((operand_42609 = enumerator_42609.nextObject ()))) {
        macroValidPointer (operand_42609) ;
        GGS_unifiedTypeMapIndexList  var_cas_templateSignature = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
        {
          GGS_formalInputParameterListAST::cEnumerator enumerator_42727 (operand_42609->mFilewrapperTemplateFormalInputParameters, true) ;
          const GGS_formalInputParameterListAST::cElement * operand_42727 = NULL ;
          while (((operand_42727 = enumerator_42727.nextObject ()))) {
            macroValidPointer (operand_42727) ;
            GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
            GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_42727->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1119)) ;
            var_cas_templateSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
          }
        }
        var_cas_filewrapperTemplateMap.modifier_insertKey (inLexique, operand_42609->mFilewrapperTemplateName, var_cas_templateSignature, operand_42609->mFilewrapperTemplatePath COMMA_SOURCE_FILE_AT_LINE (1122)) ;
      }
    }
    var_cas_ioSemanticContext.mFilewrapperMap.modifier_insertKey (inLexique, operand_42471->mFilewrapperName, operand_42471->mFilewrapperPath, operand_42471->mFilewrapperExtensionList, var_cas_filewrapperTemplateMap COMMA_SOURCE_FILE_AT_LINE (1128)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@sortedListDeclarationAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_43424,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_43424 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1142)) ;
    GGS_unifiedTypeMapIndex  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_43424->mSortedListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1145)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_44097 (operand_43424->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_44097 = NULL ;
      while (((operand_44097 = enumerator_44097.nextObject ()))) {
        macroValidPointer (operand_44097) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_44097->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1153)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_44097->mAttributeName) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_44097->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1155))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_modifierFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptySortedList"),  operand_43424->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1161)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1161)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1164)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popGreatest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1167)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popSmallest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1172)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("greatest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1179)) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("smallest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1184)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_43424->mSortedListTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_sortedListType (inLexique COMMA_HERE), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumerationDescriptor COMMA_SOURCE_FILE_AT_LINE (1190)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@structDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_46057,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_46057 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_structTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46057->mStructTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1212)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_46483 (operand_46057->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_46483 = NULL ;
      while (((operand_46483 = enumerator_46483.nextObject ()))) {
        macroValidPointer (operand_46483) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46483->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1219)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_46483->mAttributeTypeName) ;
      }
    }
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_HERE), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1223)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_46997 (operand_46057->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_46997 = NULL ;
      while (((operand_46997 = enumerator_46997.nextObject ()))) {
        macroValidPointer (operand_46997) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46997->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1233)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, operand_46997->mAttributeName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_bool (false), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (1234)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_46057->mStructTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_structType (inLexique COMMA_HERE), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1248)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@listDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_48009,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_48009 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_48153 (operand_48009->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_48153 = NULL ;
      while (((operand_48153 = enumerator_48153.nextObject ()))) {
        macroValidPointer (operand_48153) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_48153->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1272)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_48153->mAttributeName) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1277)) ;
    GGS_unifiedTypeMapIndex  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_48009->mListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1280)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_48991 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_48991 = NULL ;
      while (((operand_48991 = enumerator_48991.nextObject ()))) {
        macroValidPointer (operand_48991) ;
        var_cas_enumerationDescriptor.addAssign_operation (operand_48991->mAttributeTypeIndex, operand_48991->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1286))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (operand_48991->mAttributeTypeIndex) ;
        var_cas_modifierFormalArgumentList.addAssign_operation (operand_48991->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyList"),  operand_48009->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1292)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1292)) ;
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("listWithValue"), GGS_location (inLexique) COMMA_HERE), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1293)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1301)) ;
    ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListFromIndex"),  GGS_string ("uint"),  operand_48009->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1302)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1302)) ;
    ::routine_enterBaseReaderWith2Arguments (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListWithRange"),  GGS_string ("uint"),  GGS_string ("uint"),  operand_48009->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1303)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1303)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_50033 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_50033 = NULL ;
      while (((operand_50033 = enumerator_50033.nextObject ()))) {
        macroValidPointer (operand_50033) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, (operand_50033->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1306))).operator_concat (GGS_string ("AtIndex")), operand_50033->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1306)) COMMA_HERE), GGS_unifiedTypeMapIndexList ::constructor_listWithValue (var_cas_uintType), GGS_bool (false), operand_50033->mAttributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (1305)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popFirst"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1316)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popLast"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1321)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_50642 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_50642 = NULL ;
      while (((operand_50642 = enumerator_50642.nextObject ()))) {
        macroValidPointer (operand_50642) ;
        GGS_formalParameterSignature  var_cas_setterFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_setterFormalArgumentList.addAssign_operation (operand_50642->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_setterFormalArgumentList.addAssign_operation (var_cas_uintType, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_50642->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("AtIndex")), operand_50642->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1331)) COMMA_HERE), var_cas_setterFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1330)) ;
      }
    }
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("first"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1338)) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("last"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1343)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_48009->mListTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_listType (inLexique COMMA_HERE), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumerationDescriptor COMMA_SOURCE_FILE_AT_LINE (1349)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@classDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_51952,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_51952 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1370)) ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndex  var_cas_superClassIndex ;
    const GGS_bool cond_52366 = (operand_51952->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1375))).operator_isEqual (GGS_string ("")) ;
    if (cond_52366.isBuiltAndTrue ()) {
      var_cas_superClassIndex = GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE) ;
    }else if (cond_52366.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_51952->mSuperClassName, var_cas_ioSemanticContext.mTypeMap, var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (1378)) ;
    }
    GGS_unifiedTypeMapIndex  var_cas_classIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_51952->mClassTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1382)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    const GGS_bool cond_53234 = (operand_51952->mIsAbstract).operator_not () ;
    if (cond_53234.isBuiltAndTrue ()) {
      GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
      {
        GGS_attributeInCollectionListAST::cEnumerator enumerator_52841 (operand_51952->mAttributeList, true) ;
        const GGS_attributeInCollectionListAST::cElement * operand_52841 = NULL ;
        while (((operand_52841 = enumerator_52841.nextObject ()))) {
          macroValidPointer (operand_52841) ;
          GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
          GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_52841->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1389)) ;
          var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        }
      }
      var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_HERE), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1392)) ;
    }
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_51952->mClassTypeName, (operand_51952->mIsAbstract).operator_not (), var_cas_superClassIndex, GGS_typeKindEnum::constructor_classType (inLexique COMMA_HERE), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1406)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@externRoutineDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_53936,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_53936 != NULL) {
    GGS_formalParameterSignature  var_cas_routineSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_54123 (operand_53936->mFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_54123 = NULL ;
      while (((operand_54123 = enumerator_54123.nextObject ()))) {
        macroValidPointer (operand_54123) ;
        GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_54123->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1430)) ;
        var_cas_routineSignature.addAssign_operation (var_cas_parameterTypeIndex, operand_54123->mFormalParameterPassingMode) ;
      }
    }
    var_cas_ioSemanticContext.mRoutineMap.modifier_insertKey (inLexique, operand_53936->mRoutineName, var_cas_routineSignature COMMA_SOURCE_FILE_AT_LINE (1434)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@externFunctionDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_54647,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_54647 != NULL) {
    GGS_unifiedTypeMapIndexList  var_cas_functionSignature = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_54835 (operand_54647->mFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_54835 = NULL ;
      while (((operand_54835 = enumerator_54835.nextObject ()))) {
        macroValidPointer (operand_54835) ;
        GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_54835->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1446)) ;
        var_cas_functionSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_54647->mResultTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1451)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_54647->mFunctionName, var_cas_functionSignature, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1453)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@lazyFunctionDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lazyFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_lazyFunctionDeclarationAST * operand_55515,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_55515 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_55515->mResultTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1463)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_55515->mFunctionName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1465)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listmapDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_56017,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_56017 != NULL) {
    GGS_typedAttributeList  var_cas_listTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_bool automatic_var_56316_0 ;
    GGS_unifiedTypeMapIndex  automatic_var_56316_1 ;
    GGS_constructorMap  automatic_var_56316_2 ;
    GGS_readerMap  automatic_var_56316_3 ;
    GGS_modifierMap  automatic_var_56316_4 ;
    GGS_instanceMethodMap  automatic_var_56316_5 ;
    GGS_classMethodMap  automatic_var_56316_6 ;
    GGS_enumerationDescriptorList  automatic_var_56316_7 ;
    const GGS_unifiedTypeMap  temp_56221 = var_cas_ioSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1476)) ;
    if (temp_56221.isBuilt ()) {
      temp_56221 (HERE)->method_searchKey (inLexique, operand_56017->mAssociatedListTypeName, automatic_var_56316_0, automatic_var_56316_1, var_cas_typeKindEnum, var_cas_listTypedAttributeList, automatic_var_56316_2, automatic_var_56316_3, automatic_var_56316_4, automatic_var_56316_5, automatic_var_56316_6, automatic_var_56316_7 COMMA_SOURCE_FILE_AT_LINE (1476)) ;
    }
    const GGS_bool cond_56544 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_mapType (inLexique COMMA_HERE)) ;
    if (cond_56544.isBuiltAndTrue ()) {
      operand_56017->mAssociatedListTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '@")).operator_concat (operand_56017->mAssociatedListTypeName)).operator_concat (GGS_string ("' type should be a list type")) COMMA_SOURCE_FILE_AT_LINE (1485)) ;
      var_cas_listTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndex  var_cas_associatedListTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_56017->mAssociatedListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_associatedListTypeIndex COMMA_SOURCE_FILE_AT_LINE (1495)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_56017->mListmapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1498)) ;
    GGS_unifiedTypeMapIndex  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1501)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1503)) ;
    GGS_enumerationDescriptorList  var_cas_enumeratorDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_stringTypeIndex, GGS_string ("key")) ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_associatedListTypeIndex, GGS_string ("value")) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_56017->mListmapTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_HERE), var_cas_listTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumeratorDescriptor COMMA_SOURCE_FILE_AT_LINE (1509)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@partiallyOrderedSemanticDeclarationListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
elementOf_GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2):
mDependanceString (argument_0),
mTypeString (argument_1),
mSemanticDeclaration (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDependanceString.operator_isEqual (ptr->mDependanceString).boolValue ()
         && mTypeString.operator_isEqual (ptr->mTypeString).boolValue ()
         && mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * operand = (const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *) inOperand ;
  PMSInt32 result = mDependanceString.genericObjectCompare (operand->mDependanceString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDependanceString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Sorted list '@partiallyOrderedSemanticDeclarationListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ("partiallyOrderedSemanticDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::GGS_partiallyOrderedSemanticDeclarationListAST (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::
GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_partiallyOrderedSemanticDeclarationListAST & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isNotEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_semanticDeclarationAST & argument_2) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::
operator_concat (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  GGS_partiallyOrderedSemanticDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
dotAssign_operation (const GGS_partiallyOrderedSemanticDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDependanceString ;
          GGS_string p_1 = p->mTypeString ;
          GGS_semanticDeclarationAST  p_2 = p->mSemanticDeclaration ;
          internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDependanceString,
                                ptr->mTypeString,
                                ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_emptySortedList (void) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_semanticDeclarationAST & argument_2) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_partiallyOrderedSemanticDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@partiallyOrderedSemanticDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_smallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_greatest (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_semanticDeclarationAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_semanticDeclarationAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mDependanceString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDependanceString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mTypeString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_partiallyOrderedSemanticDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_partiallyOrderedSemanticDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_partiallyOrderedSemanticDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_partiallyOrderedSemanticDeclarationListAST * p = dynamic_cast <const GGS_partiallyOrderedSemanticDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_partiallyOrderedSemanticDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_58766,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & /* var_cas_ioPartiallyOrderedDeclarationList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_58766 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.enterOrderedDeclaration'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration> gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration
findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_59009,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_59009 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_59009->mPredefinedTypeName, operand_59009) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_59319,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_59319 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_59319->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1558)), operand_59319->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1558)), operand_59319) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_59654,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_59654 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_59654->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1566)), operand_59654) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_59968,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_59968 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_59968->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1574)), operand_59968) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_60282,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_60282 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_60282->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1582)), operand_60282) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.enterOrderedDeclaration'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_60600,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_60600 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_60600->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1590)), operand_60600) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_60921,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_60921 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_60921->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1598)), operand_60921->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1598)), operand_60921) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapindexDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_61270,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_61270 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_61270->mAssociatedMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1606)), operand_61270->mMapIndexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1606)), operand_61270) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSemanticContext"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSemanticContext (C_Compiler & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inSemanticDeclarationList,
                                const GGS_location   var_cas_inEndOfSourceFile,
                                GGS_semanticContext & var_cas_outSemanticContext COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSemanticContext at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_semanticDeclarationListAST  var_cas_semanticDeclarationList = var_cas_inSemanticDeclarationList ;
  ::routine_appendPredefinedTypesASTs (inLexique,  var_cas_semanticDeclarationList COMMA_SOURCE_FILE_AT_LINE (1622)) ;
  GGS_collectedTypeMap  var_cas_collectedTypeMap = GGS_collectedTypeMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_62370 (var_cas_semanticDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_62370 = NULL ;
    while (((operand_62370 = enumerator_62370.nextObject ()))) {
      macroValidPointer (operand_62370) ;
      const GGS_semanticDeclarationAST  temp_62411 = operand_62370->mSemanticDeclaration ;
      if (temp_62411.isBuilt ()) {
        typeCategoryMethod__semanticDeclarationAST__collectType method = findCategoryMethod__semanticDeclarationAST__collectType (temp_62411.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_62411 (HERE), var_cas_collectedTypeMap COMMA_SOURCE_FILE_AT_LINE (1626)) ;
        }
      }
    }
  }
  GGS_stringlist  var_cas_undefinedClasses = var_cas_collectedTypeMap.reader_unsolvedIndexKeyStringList (inLexique COMMA_SOURCE_FILE_AT_LINE (1629)) ;
  const GGS_bool cond_62814 = (var_cas_undefinedClasses.reader_length ()).operator_isEqual (GGS_uint (1U)) ;
  if (cond_62814.isBuiltAndTrue ()) {
    GGS_string var_cas_errorMessage = GGS_string ("there is 1 undefined type:") ;
    {
      GGS_stringlist::cEnumerator enumerator_62698 (var_cas_undefinedClasses, true) ;
      const GGS_stringlist::cElement * operand_62698 = NULL ;
      while (((operand_62698 = enumerator_62698.nextObject ()))) {
        macroValidPointer (operand_62698) ;
        var_cas_errorMessage.appendCString ("\n"
          "-  @") ;
        var_cas_errorMessage.dotAssign_operation (operand_62698->mValue) ;
      }
    }
    var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1636)) ;
  }else if (cond_62814.isBuiltAndFalse ()) {
    const GGS_bool cond_63094 = (var_cas_undefinedClasses.reader_length ()).operator_strictSup (GGS_uint (1U)) ;
    if (cond_63094.isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage = ((GGS_string ("there are ")).operator_concat (var_cas_undefinedClasses.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1637)))).operator_concat (GGS_string (" undefined types:")) ;
      {
        GGS_stringlist::cEnumerator enumerator_62980 (var_cas_undefinedClasses, true) ;
        const GGS_stringlist::cElement * operand_62980 = NULL ;
        while (((operand_62980 = enumerator_62980.nextObject ()))) {
          macroValidPointer (operand_62980) ;
          var_cas_errorMessage.appendCString ("\n"
            "-  @") ;
          var_cas_errorMessage.dotAssign_operation (operand_62980->mValue) ;
        }
      }
      var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1642)) ;
    }
  }
  GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
  const GGS_bool cond_63592 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_63592.isBuiltAndTrue ()) {
    {
      GGS_semanticDeclarationListAST::cEnumerator enumerator_63463 (var_cas_semanticDeclarationList, true) ;
      const GGS_semanticDeclarationListAST::cElement * operand_63463 = NULL ;
      while (((operand_63463 = enumerator_63463.nextObject ()))) {
        macroValidPointer (operand_63463) ;
        const GGS_semanticDeclarationAST  temp_63518 = operand_63463->mSemanticDeclaration ;
        if (temp_63518.isBuilt ()) {
          typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration method = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (temp_63518.galgasObjectRunTimeInfo ()) ;
          if (method != NULL) {
            method (inLexique, temp_63518 (HERE), var_cas_partiallyOrderedSemanticDeclarationListAST COMMA_SOURCE_FILE_AT_LINE (1650)) ;
          }
        }
      }
    }
  }
  GGS_semanticDeclarationListAST  var_cas_orderedSemanticDeclarationListAST = GGS_semanticDeclarationListAST ::constructor_emptyList () ;
  GGS_stringset  var_cas_alreadyDefinedTypes = GGS_stringset ::constructor_emptySet () ;
  var_cas_alreadyDefinedTypes.addAssign_operation (GGS_string ("")) ;
  GGS_bool var_cas_progress = GGS_bool (true) ;
  GGS_uint _variant_64548 = var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length () ;
  GGS_bool _condition_64548 (_variant_64548.isBuilt (), true) ;
  while (_condition_64548.isBuiltAndTrue ()) {
    _condition_64548 = ((var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U))).operator_and (var_cas_progress) ;
    if (_condition_64548.isBuiltAndTrue ()) {
      if (_variant_64548.uintValue () == 0) {
        inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1672)) ;
        _condition_64548 = GGS_bool (false) ;
      }else{
        _variant_64548.decrement_operation (inLexique COMMA_HERE) ;
        var_cas_progress = GGS_bool (false) ;
        const GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_r = var_cas_partiallyOrderedSemanticDeclarationListAST ;
        var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
        {
          GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_64181 (var_cas_r, true) ;
          const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_64181 = NULL ;
          while (((operand_64181 = enumerator_64181.nextObject ()))) {
            macroValidPointer (operand_64181) ;
            const GGS_bool cond_64399 = var_cas_alreadyDefinedTypes.reader_hasKey (operand_64181->mDependanceString) ;
            if (cond_64399.isBuiltAndTrue ()) {
              var_cas_orderedSemanticDeclarationListAST.addAssign_operation (operand_64181->mSemanticDeclaration) ;
              var_cas_alreadyDefinedTypes.addAssign_operation (operand_64181->mTypeString) ;
              var_cas_progress = GGS_bool (true) ;
            }else if (cond_64399.isBuiltAndFalse ()) {
              var_cas_partiallyOrderedSemanticDeclarationListAST.addAssign_operation (operand_64181->mDependanceString, operand_64181->mTypeString, operand_64181->mSemanticDeclaration) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_64953 = (var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
  if (cond_64953.isBuiltAndTrue ()) {
    GGS_string var_cas_s = GGS_string ("inheritance circularities involving the ") ;
    {
      GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_64827 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
      const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_64827 = enumerator_64827.nextObject () ;
      if ((operand_64827 != NULL)) {
        bool _foreach_loop_64827 ;
        do{
          macroValidPointer (operand_64827) ;
          var_cas_s.appendCString ("@") ;
          var_cas_s.dotAssign_operation (operand_64827->mTypeString) ;
          operand_64827 = enumerator_64827.nextObject () ;
          _foreach_loop_64827 = ((operand_64827 != NULL)) ;
          if (_foreach_loop_64827) {
            var_cas_s.appendCString (", ") ;
          }
        }while (_foreach_loop_64827) ;
      }
    }
    var_cas_s.appendCString (" classes") ;
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_s COMMA_SOURCE_FILE_AT_LINE (1683)) ;
  }
  var_cas_outSemanticContext = GGS_semanticContext::constructor_new (GGS_unifiedTypeMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_routineMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_functionMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_descendantClassListMap::constructor_emptyMap (), GGS_filewrapperMap ::constructor_emptyMap (inLexique COMMA_HERE)) ;
  const GGS_bool cond_65412 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_65412.isBuiltAndTrue ()) {
    {
      GGS_semanticDeclarationListAST::cEnumerator enumerator_65323 (var_cas_orderedSemanticDeclarationListAST, true) ;
      const GGS_semanticDeclarationListAST::cElement * operand_65323 = NULL ;
      while (((operand_65323 = enumerator_65323.nextObject ()))) {
        macroValidPointer (operand_65323) ;
        const GGS_semanticDeclarationAST  temp_65364 = operand_65323->mSemanticDeclaration ;
        if (temp_65364.isBuilt ()) {
          typeCategoryMethod__semanticDeclarationAST__enterType method = findCategoryMethod__semanticDeclarationAST__enterType (temp_65364.galgasObjectRunTimeInfo ()) ;
          if (method != NULL) {
            method (inLexique, temp_65364 (HERE), var_cas_outSemanticContext COMMA_SOURCE_FILE_AT_LINE (1695)) ;
          }
        }
      }
    }
  }
  const GGS_bool cond_65787 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_65787.isBuiltAndTrue ()) {
    {
      GGS_unifiedTypeMap::cEnumerator enumerator_65651 (var_cas_outSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1703)), true) ;
      const GGS_unifiedTypeMap::cElement * operand_65651 = NULL ;
      while (((operand_65651 = enumerator_65651.nextObject ()))) {
        macroValidPointer (operand_65651) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSemanticContext\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_buildSemanticContext (void) {
  enterCategoryMethod__semanticDeclarationAST__collectType (category_method__semanticDeclarationAST__collectType, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__predefinedTypeAST__collectType, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__mapDeclarationAST__collectType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__mapindexDeclarationAST__collectType, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__enumDeclarationAST__collectType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__sortedListDeclarationAST__collectType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__structDeclarationAST__collectType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__listDeclarationAST__collectType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__classDeclarationAST__collectType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__listmapDeclarationAST__collectType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__uintPredefinedTypeAST__enterType, gClassInfoFor__uintPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__uint64PredefinedTypeAST__enterType, gClassInfoFor__uint64PredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__sintPredefinedTypeAST__enterType, gClassInfoFor__sintPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__sint64PredefinedTypeAST__enterType, gClassInfoFor__sint64PredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__charPredefinedTypeAST__enterType, gClassInfoFor__charPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__doublePredefinedTypeAST__enterType, gClassInfoFor__doublePredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__stringPredefinedTypeAST__enterType, gClassInfoFor__stringPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lboolPredefinedTypeAST__enterType, gClassInfoFor__lboolPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__luintPredefinedTypeAST__enterType, gClassInfoFor__luintPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__luint64PredefinedTypeAST__enterType, gClassInfoFor__luint64PredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lsintPredefinedTypeAST__enterType, gClassInfoFor__lsintPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lsint64PredefinedTypeAST__enterType, gClassInfoFor__lsint64PredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lcharPredefinedTypeAST__enterType, gClassInfoFor__lcharPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__ldoublePredefinedTypeAST__enterType, gClassInfoFor__ldoublePredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lstringPredefinedTypeAST__enterType, gClassInfoFor__lstringPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__locationPredefinedTypeAST__enterType, gClassInfoFor__locationPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__stringsetPredefinedTypeAST__enterType, gClassInfoFor__stringsetPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__objectPredefinedTypeAST__enterType, gClassInfoFor__objectPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__functionPredefinedTypeAST__enterType, gClassInfoFor__functionPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__typePredefinedTypeAST__enterType, gClassInfoFor__typePredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__binarysetPredefinedTypeAST__enterType, gClassInfoFor__binarysetPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapDeclarationAST__enterType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapindexDeclarationAST__enterType, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__enumDeclarationAST__enterType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__filewrapperDeclarationAST__enterType, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__sortedListDeclarationAST__enterType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__structDeclarationAST__enterType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listDeclarationAST__enterType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__classDeclarationAST__enterType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externRoutineDeclarationAST__enterType, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externFunctionDeclarationAST__enterType, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lazyFunctionDeclarationAST__enterType, gClassInfoFor__lazyFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listmapDeclarationAST__enterType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (category_method__semanticDeclarationAST__enterOrderedDeclaration, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__predefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__classDeclarationAST__enterOrderedDeclaration, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__structDeclarationAST__enterOrderedDeclaration, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__enumDeclarationAST__enterOrderedDeclaration, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__sortedListDeclarationAST__enterOrderedDeclaration, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listmapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapindexDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_buildSemanticContext (void) {
  gDispatchTableForMethod__semanticDeclarationAST__collectType.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterType.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_buildSemanticContext (prologueRoutineFor_buildSemanticContext, epilogueRoutineFor_buildSemanticContext) ;

//---------------------------------------------------------------------------*

