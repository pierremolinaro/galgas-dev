//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'buildSemanticContext.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 11th, 2010, at 19h55'8"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "buildSemanticContext.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "buildSemanticContext.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of routine "addTypeList"                   *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addTypeList (C_Compiler & inLexique,
                                const GGS_typedAttributeList   var_cas_inTypedAttributeList,
                                const GGS_lstring   var_cas_inListTypeName,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addTypeList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapIndex  var_cas_uintType ;
  GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_ioUnifiedTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (42)) ;
  GGS_unifiedTypeMapIndex  var_cas_listTypeIndex ;
  GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, var_cas_inListTypeName, var_cas_ioUnifiedTypeMap, var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (45)) ;
  GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
  GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
  GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
  {
    GGS_typedAttributeList::cEnumerator enumerator_2846 (var_cas_inTypedAttributeList, true) ;
    const GGS_typedAttributeList::cElement * operand_2846 = NULL ;
    while (((operand_2846 = enumerator_2846.nextObject ()))) {
      macroValidPointer (operand_2846) ;
      var_cas_enumerationDescriptor.addAssign_operation (operand_2846->mEnumeratedType, operand_2846->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (51))) ;
      var_cas_constructorAttributeTypeList.addAssign_operation (operand_2846->mEnumeratedType) ;
      var_cas_modifierFormalArgumentList.addAssign_operation (operand_2846->mEnumeratedType, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
    }
  }
  GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("emptyList"),  var_cas_inListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (57)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (57)) ;
  var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("listWithValue"), GGS_location (inLexique) COMMA_HERE), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (58)) ;
  GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (66)) ;
  ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("subListFromIndex"),  GGS_string ("uint"),  var_cas_inListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (67)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (67)) ;
  ::routine_enterBaseReaderWith2Arguments (inLexique,  var_cas_readerMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("subListWithRange"),  GGS_string ("uint"),  GGS_string ("uint"),  var_cas_inListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (68)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (68)) ;
  {
    GGS_typedAttributeList::cEnumerator enumerator_3841 (var_cas_inTypedAttributeList, true) ;
    const GGS_typedAttributeList::cElement * operand_3841 = NULL ;
    while (((operand_3841 = enumerator_3841.nextObject ()))) {
      macroValidPointer (operand_3841) ;
      var_cas_readerMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, (operand_3841->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (71))).operator_concat (GGS_string ("AtIndex")), operand_3841->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (71)) COMMA_HERE), GGS_unifiedTypeMapIndexList ::constructor_listWithValue (var_cas_uintType), GGS_bool (false), operand_3841->mEnumeratedType, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (70)) ;
    }
  }
  GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popFirst"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (81)) ;
  var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popLast"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (86)) ;
  {
    GGS_typedAttributeList::cEnumerator enumerator_4430 (var_cas_inTypedAttributeList, true) ;
    const GGS_typedAttributeList::cElement * operand_4430 = NULL ;
    while (((operand_4430 = enumerator_4430.nextObject ()))) {
      macroValidPointer (operand_4430) ;
      GGS_formalParameterSignature  var_cas_setterFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
      var_cas_setterFormalArgumentList.addAssign_operation (operand_4430->mEnumeratedType, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
      var_cas_setterFormalArgumentList.addAssign_operation (var_cas_uintType, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
      var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_4430->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("AtIndex")), operand_4430->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (96)) COMMA_HERE), var_cas_setterFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (95)) ;
    }
  }
  GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("first"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (103)) ;
  var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("last"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (108)) ;
  var_cas_ioUnifiedTypeMap.modifier_insertKey (inLexique, var_cas_inListTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_listType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumerationDescriptor COMMA_SOURCE_FILE_AT_LINE (114)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addTypeList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "addPredefinedTypeList"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_addPredefinedTypeList (C_Compiler & inLexique,
                                const GGS_string  var_cas_inElementTypeName,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_addPredefinedTypeList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_lstring  var_cas_listTypeName = GGS_lstring ::constructor_new (inLexique, (var_cas_inElementTypeName).operator_concat (GGS_string ("list")), GGS_location (inLexique) COMMA_HERE) ;
  GGS_unifiedTypeMapIndex  var_cas_t ;
  GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inElementTypeName, GGS_location (inLexique) COMMA_HERE), var_cas_ioUnifiedTypeMap, var_cas_t COMMA_SOURCE_FILE_AT_LINE (137)) ;
  GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
  var_cas_typedAttributeList.addAssign_operation (var_cas_t, GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_HERE)) ;
  ::routine_addTypeList (inLexique,  var_cas_typedAttributeList,  var_cas_listTypeName,  var_cas_ioUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (142)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_addPredefinedTypeList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Implementation of function "predefinedTypeMap"               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_unifiedTypeMap  function_predefinedTypeMap (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER function_predefinedTypeMap at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMap  var_cas_outUnifiedTypeMap ;
  var_cas_outUnifiedTypeMap = GGS_unifiedTypeMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  GGS_constructorMap  var_cas_constructorMap ;
  GGS_readerMap  var_cas_readerMap ;
  GGS_modifierMap  var_cas_modifierMap ;
  GGS_instanceMethodMap  var_cas_instanceMethodMap ;
  GGS_classMethodMap  var_cas_classMethodMap ;
  ::routine_constructorMapFor_char (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (161)) ;
  ::routine_readerMapFor_char (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (162)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("char"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (163)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_readerMapFor_bool (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (178)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (179)) ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_uint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (193)) ;
  ::routine_readerMapFor_uint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (194)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (195)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_sint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (210)) ;
  ::routine_readerMapFor_sint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (211)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (212)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_sint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (227)) ;
  ::routine_readerMapFor_sint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (228)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint64"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (229)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_uint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (244)) ;
  ::routine_readerMapFor_uint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (245)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (246)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_readerMapFor_double (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (261)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("double"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (262)) ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_data (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (276)) ;
  ::routine_readerMapFor_data (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (277)) ;
  ::routine_modifierMapFor_data (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (278)) ;
  ::routine_instanceMethodMapFor_data (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (279)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("data"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (280)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  var_cas_instanceMethodMap.drop () ;
  ::routine_constructorMapFor_type (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (297)) ;
  ::routine_readerMapFor_type (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (298)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("type"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (299)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_stringset (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (314)) ;
  ::routine_readerMapFor_stringset (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (315)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("stringset"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (316)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_binaryset (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (331)) ;
  ::routine_readerMapFor_binaryset (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (332)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("binaryset"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (333)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_string (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (348)) ;
  ::routine_readerMapFor_string (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (349)) ;
  ::routine_modifierMapFor_string (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (350)) ;
  ::routine_instanceMethodMapFor_string (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (351)) ;
  ::routine_classMethodMapFor_string (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_classMethodMap COMMA_SOURCE_FILE_AT_LINE (352)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (353)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  var_cas_instanceMethodMap.drop () ;
  var_cas_classMethodMap.drop () ;
  ::routine_constructorMapFor_function (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (371)) ;
  ::routine_readerMapFor_function (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (372)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("function"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (373)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  ::routine_readerMapFor_object (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (388)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("object"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (389)) ;
  var_cas_readerMap.drop () ;
  ::routine_readerMapFor_location (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (403)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_readerMap, GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (404)) ;
  var_cas_readerMap.drop () ;
  ::routine_constructorMapFor_lstring (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (418)) ;
  ::routine_readerMapFor_lstring (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (419)) ;
  ::routine_modifierMapFor_lstring (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (420)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (421)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_lchar (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (437)) ;
  ::routine_readerMapFor_lchar (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (438)) ;
  ::routine_modifierMapFor_lchar (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (439)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lchar"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (440)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_lbool (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (456)) ;
  ::routine_readerMapFor_lbool (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (457)) ;
  ::routine_modifierMapFor_lbool (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (458)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lbool"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (459)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_ldouble (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (475)) ;
  ::routine_readerMapFor_ldouble (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (476)) ;
  ::routine_modifierMapFor_ldouble (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (477)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("ldouble"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (478)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_luint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (494)) ;
  ::routine_readerMapFor_luint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (495)) ;
  ::routine_modifierMapFor_luint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (496)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (497)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_luint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (513)) ;
  ::routine_readerMapFor_luint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (514)) ;
  ::routine_modifierMapFor_luint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (515)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("luint64"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (516)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_lsint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (532)) ;
  ::routine_readerMapFor_lsint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (533)) ;
  ::routine_modifierMapFor_lsint (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (534)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (535)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_constructorMapFor_lsint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (551)) ;
  ::routine_readerMapFor_lsint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (552)) ;
  ::routine_modifierMapFor_lsint64 (inLexique,  var_cas_outUnifiedTypeMap,  var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (553)) ;
  var_cas_outUnifiedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lsint64"), GGS_location (inLexique) COMMA_HERE), GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (554)) ;
  var_cas_constructorMap.drop () ;
  var_cas_readerMap.drop () ;
  var_cas_modifierMap.drop () ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("lstring"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (570)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("string"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (572)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("type"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (574)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("uint64"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (576)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("luint"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (578)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("uint"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (580)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("function"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (582)) ;
  ::routine_addPredefinedTypeList (inLexique,  GGS_string ("object"),  var_cas_outUnifiedTypeMap COMMA_SOURCE_FILE_AT_LINE (584)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE function_predefinedTypeMap\n") ;
  #endif
  return var_cas_outUnifiedTypeMap ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_predefinedTypeMap (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_unifiedTypeMap  result = function_predefinedTypeMap (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_predefinedTypeMap ("predefinedTypeMap",
                              functionForGenericCall_predefinedTypeMap,
                              & kTypeDescriptor_GGS_unifiedTypeMap ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineMap ("routineMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_routineMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineMap * p = NULL ;
    macroMyNew (p, GGS_routineMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineMap * p = dynamic_cast <const GGS_routineMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionMap ("functionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultTypeIndex.operator_isEqual (ptr->mInfo.mResultTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_unifiedTypeMapIndex & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultTypeIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_unifiedTypeMapIndex   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_unifiedTypeMapIndex   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_unifiedTypeMapIndex & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_functionMap::cEnumerator::_mResultTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultTypeIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_functionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionMap * p = NULL ;
    macroMyNew (p, GGS_functionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionMap * p = dynamic_cast <const GGS_functionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mTemplateSignature (),
mFilewrapperTemplatePath () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateMap ("filewrapperTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperTemplateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTemplateSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplatePath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTemplateSignature.operator_isEqual (ptr->mInfo.mTemplateSignature)).boolValue ()
           && (mInfo.mFilewrapperTemplatePath.operator_isEqual (ptr->mInfo.mFilewrapperTemplatePath)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperTemplateMap info  ;
    info.mTemplateSignature = inParameter0 ;
    info.mFilewrapperTemplatePath = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mTemplateSignature ;
    outParameter1 = node->mInfo.mFilewrapperTemplatePath ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_filewrapperTemplateMap::cEnumerator::_mTemplateSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateMap::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateMap * p = dynamic_cast <const GGS_filewrapperTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_filewrapperMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperMap::e_filewrapperMap (void) :
mFilewrapperPath (),
mFilewrapperExtensionList (),
mFilewrapperTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@filewrapperMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperMap ("filewrapperMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperMap::
elementOf_GGS_filewrapperMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperPath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperExtensionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplateMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFilewrapperPath.operator_isEqual (ptr->mInfo.mFilewrapperPath)).boolValue ()
           && (mInfo.mFilewrapperExtensionList.operator_isEqual (ptr->mInfo.mFilewrapperExtensionList)).boolValue ()
           && (mInfo.mFilewrapperTemplateMap.operator_isEqual (ptr->mInfo.mFilewrapperTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isNotEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_lstringlist & inParameter1,
                const GGS_filewrapperTemplateMap & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperMap info  ;
    info.mFilewrapperPath = inParameter0 ;
    info.mFilewrapperExtensionList = inParameter1 ;
    info.mFilewrapperTemplateMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstringlist   & outParameter1,
               GGS_filewrapperTemplateMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFilewrapperPath ;
    outParameter1 = node->mInfo.mFilewrapperExtensionList ;
    outParameter2 = node->mInfo.mFilewrapperTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstringlist   & outParameter1,
                                GGS_filewrapperTemplateMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstringlist & inParameter1,
                                const GGS_filewrapperTemplateMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperMap::cEnumerator::_mFilewrapperPath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperPath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_filewrapperMap::cEnumerator::_mFilewrapperExtensionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperExtensionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperMap * p = dynamic_cast <const GGS_filewrapperMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperMap ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_descendantClassListMap ("descendantClassListMap", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_unifiedTypeMapIndexList::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_descendantClassListMap::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_descendantClassListMap::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_descendantClassListMap::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
constructor_emptyMap (void) {
  GGS_descendantClassListMap result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_descendantClassListMap::
_typeNameForDescriptionReader (void) const {
  return "@descendantClassListMap" ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::
operator_concat (const GGS_descendantClassListMap & inOperand) const {
  GGS_descendantClassListMap result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
dotAssign_operation (const GGS_descendantClassListMap inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_unifiedTypeMapIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_descendantClassListMap::
addAssign_operation (const GGS_string & inKey,
                      const GGS_unifiedTypeMapIndex & inAttribute0) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_unifiedTypeMapIndexList & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_unifiedTypeMapIndexList GGS_descendantClassListMap::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_unifiedTypeMapIndexList result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_unifiedTypeMapIndexList::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_descendantClassListMap::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_descendantClassListMap::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap::cEnumerator::
cEnumerator (const GGS_descendantClassListMap & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_unifiedTypeMapIndexList & GGS_descendantClassListMap::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_descendantClassListMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_descendantClassListMap * p = NULL ;
    macroMyNew (p, GGS_descendantClassListMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descendantClassListMap GGS_descendantClassListMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_descendantClassListMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_descendantClassListMap * p = dynamic_cast <const GGS_descendantClassListMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_descendantClassListMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_descendantClassListMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_descendantClassListMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mDescendantClassListMap (),
mFilewrapperMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mDescendantClassListMap.drop () ;
  mFilewrapperMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mDescendantClassListMap.isBuilt ()
    && mFilewrapperMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isEqual (inOperand.mTypeMap)
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mDescendantClassListMap.operator_isEqual (inOperand.mDescendantClassListMap))
    .operator_and (mFilewrapperMap.operator_isEqual (inOperand.mFilewrapperMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isNotEqual (inOperand.mTypeMap)
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mDescendantClassListMap.operator_isNotEqual (inOperand.mDescendantClassListMap))
    .operator_or (mFilewrapperMap.operator_isNotEqual (inOperand.mFilewrapperMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_unifiedTypeMap & argument_0,
                 const GGS_routineMap & argument_1,
                 const GGS_functionMap & argument_2,
                 const GGS_descendantClassListMap& argument_3,
                 const GGS_filewrapperMap & argument_4) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  result.mRoutineMap = argument_1 ;
  result.mFunctionMap = argument_2 ;
  result.mDescendantClassListMap = argument_3 ;
  result.mFilewrapperMap = argument_4 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mDescendantClassListMap " ;
    _s << mDescendantClassListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrapperMap " ;
    _s << mFilewrapperMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_collectedTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_collectedTypeMap::e_collectedTypeMap (void) :
mDeclarationAbstractSyntaxTree () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@collectedTypeMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMap ("collectedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_collectedTypeMap::
elementOf_GGS_collectedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_collectedTypeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_collectedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDeclarationAbstractSyntaxTree.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_collectedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_collectedTypeMap * ptr = dynamic_cast <const elementOf_GGS_collectedTypeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mDeclarationAbstractSyntaxTree.operator_isEqual (ptr->mInfo.mDeclarationAbstractSyntaxTree)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_collectedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_collectedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isNotEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_semanticDeclarationAST & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_collectedTypeMap info  ;
    info.mDeclarationAbstractSyntaxTree = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_semanticDeclarationAST   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mDeclarationAbstractSyntaxTree ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_semanticDeclarationAST   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_semanticDeclarationAST & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_collectedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_collectedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @collectedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_collectedTypeMap::cEnumerator::_mDeclarationAbstractSyntaxTree (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDeclarationAbstractSyntaxTree ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMap * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMap * p = dynamic_cast <const GGS_collectedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@semanticDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__collectType (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_24741,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24741 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@semanticDeclarationAST.collectType'   *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__collectType> gDispatchTableForMethod__semanticDeclarationAST__collectType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__collectType (typeCategoryMethod__semanticDeclarationAST__collectType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__collectType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__collectType
findCategoryMethod__semanticDeclarationAST__collectType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__collectType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__collectType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__collectType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__collectType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__collectType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@mapDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_24931,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24931 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_24931->mMapTypeName, operand_24931 COMMA_SOURCE_FILE_AT_LINE (681)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@mapindexDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_25187,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25187 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25187->mMapIndexTypeName, operand_25187 COMMA_SOURCE_FILE_AT_LINE (692)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@enumDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_25444,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25444 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25444->mEnumTypeName, operand_25444 COMMA_SOURCE_FILE_AT_LINE (703)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@sortedListDeclarationAST.collectType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_25703,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25703 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25703->mSortedListTypeName, operand_25703 COMMA_SOURCE_FILE_AT_LINE (714)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@structDeclarationAST.collectType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_25964,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25964 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25964->mStructTypeName, operand_25964 COMMA_SOURCE_FILE_AT_LINE (725)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_26219,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26219 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_26219->mListTypeName, operand_26219 COMMA_SOURCE_FILE_AT_LINE (736)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@classDeclarationAST.collectType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_26473,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26473 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_26473->mClassTypeName, operand_26473 COMMA_SOURCE_FILE_AT_LINE (747)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@listmapDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_26730,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26730 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_26730->mListmapTypeName, operand_26730 COMMA_SOURCE_FILE_AT_LINE (758)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@semanticDeclarationAST.enterType'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterType> gDispatchTableForMethod__semanticDeclarationAST__enterType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterType (typeCategoryMethod__semanticDeclarationAST__enterType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterType
findCategoryMethod__semanticDeclarationAST__enterType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@mapDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_27514,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_27514 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndex  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (788)) ;
    GGS_unifiedTypeMapIndex  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (791)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentMapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_27514->mMapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (794)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_27514->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (796)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (796)) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (798)) ;
    GGS_formalParameterSignature  var_cas_insertMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    GGS_formalParameterSignature  var_cas_removeMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_29064 (operand_27514->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_29064 = NULL ;
      while (((operand_29064 = enumerator_29064.nextObject ()))) {
        macroValidPointer (operand_29064) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_29064->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (806)) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_29064->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (807))) ;
        var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_29594 (operand_27514->mInsertMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_29594 = NULL ;
      while (((operand_29594 = enumerator_29594.nextObject ()))) {
        macroValidPointer (operand_29594) ;
        const GGS_bool cond_29749 = var_cas_modifierMap.reader_hasKey (operand_29594->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (813))) ;
        if (cond_29749.isBuiltAndTrue ()) {
          operand_29594->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_29594->mMethodName)).operator_concat (GGS_string ("' insert method is already declared")) COMMA_SOURCE_FILE_AT_LINE (815)) ;
        }else if (cond_29749.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertKey (inLexique, operand_29594->mMethodName, var_cas_insertMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (816)) ;
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_29951 (operand_27514->mRemoveMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_29951 = NULL ;
      while (((operand_29951 = enumerator_29951.nextObject ()))) {
        macroValidPointer (operand_29951) ;
        const GGS_bool cond_30142 = var_cas_modifierMap.reader_hasKey (operand_29951->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (825))) ;
        if (cond_30142.isBuiltAndTrue ()) {
          operand_29951->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_29951->mMethodName)).operator_concat (GGS_string ("' method is already declared as an insert modifier or a remove modifier")) COMMA_SOURCE_FILE_AT_LINE (827)) ;
        }else if (cond_30142.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertKey (inLexique, operand_29951->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (828)) ;
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_30342 (operand_27514->mSearchMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_30342 = NULL ;
      while (((operand_30342 = enumerator_30342.nextObject ()))) {
        macroValidPointer (operand_30342) ;
        var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_30342->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (837)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_30535 (operand_27514->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_30535 = NULL ;
      while (((operand_30535 = enumerator_30535.nextObject ()))) {
        macroValidPointer (operand_30535) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_30535->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (845))).operator_concat (GGS_string ("ForKey")), operand_30535->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (845)) COMMA_HERE) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_30535->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (847)) ;
        var_cas_readerMap.modifier_insertKey (inLexique, var_cas_accessorName, GGS_unifiedTypeMapIndexList ::constructor_listWithValue (var_cas_stringTypeIndex), GGS_bool (true), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (848)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_31093 (operand_27514->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_31093 = NULL ;
      while (((operand_31093 = enumerator_31093.nextObject ()))) {
        macroValidPointer (operand_31093) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_31093->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")), operand_31093->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (859)) COMMA_HERE) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_31093->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (861)) ;
        GGS_formalParameterSignature  var_cas_accessorFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
        var_cas_modifierMap.modifier_insertKey (inLexique, var_cas_accessorName, var_cas_accessorFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (865)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_27514->mMapTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumerationDescriptor COMMA_SOURCE_FILE_AT_LINE (872)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@mapindexDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_32270,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   var_cas_inCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_32270 != NULL) {
    GGS_semanticDeclarationAST  var_cas_ast ;
    const GGS_collectedTypeMap  temp_32458 = var_cas_inCollectedTypeMap ;
    if (temp_32458.isBuilt ()) {
      temp_32458 (HERE)->method_searchKey (inLexique, operand_32270->mAssociatedMapTypeName, var_cas_ast COMMA_SOURCE_FILE_AT_LINE (894)) ;
    }
    GGS_attributeInCollectionListAST  var_cas_mapAttributeList ;
    { const GGS_semanticDeclarationAST _var_32774 = var_cas_ast ; // CAST instruction
      if (_var_32774.getPtr () != NULL) {
        macroValidPointer (_var_32774.getPtr ()) ;
        if (typeid (cPtr_mapDeclarationAST) == typeid (* (_var_32774.getPtr ()))) {
          const GGS_mapDeclarationAST var_cas_mapAST (_var_32774.getPtr ()) ;
          var_cas_mapAttributeList = var_cas_mapAST.reader_mAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (898)) ;
        }else{
          operand_32270->mAssociatedMapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '@")).operator_concat (operand_32270->mAssociatedMapTypeName)).operator_concat (GGS_string ("' should be a map type")) COMMA_SOURCE_FILE_AT_LINE (901)) ;
          var_cas_mapAttributeList.drop () ;
        }
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndex  var_cas_associatedMapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_32270->mAssociatedMapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_associatedMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (910)) ;
    GGS_unifiedTypeMapIndex  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (913)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (916)) ;
    GGS_unifiedTypeMapIndex  var_cas_mapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_32270->mMapIndexTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_mapTypeIndex COMMA_SOURCE_FILE_AT_LINE (919)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_argList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_argList.addAssign_operation (var_cas_associatedMapTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_HERE)) ;
    var_cas_argList.addAssign_operation (var_cas_currentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
    var_cas_classMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("makeRegularIndex"), GGS_location (inLexique) COMMA_HERE), var_cas_argList, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (925)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("null"),  operand_32270->mMapIndexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (931)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (931)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isSolved"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (933)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isNull"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (934)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_34637 (var_cas_mapAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_34637 = NULL ;
      while (((operand_34637 = enumerator_34637.nextObject ()))) {
        macroValidPointer (operand_34637) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_34637->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (937))).operator_concat (GGS_string ("ForKey")), operand_34637->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (937)) COMMA_HERE) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_34637->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (939)) ;
        var_cas_readerMap.modifier_insertKey (inLexique, var_cas_accessorName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_bool (true), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (940)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_32270->mMapIndexTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (950)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@enumDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_35599,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_35599 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_35599->mEnumTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (978)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_36131 (operand_35599->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_36131 = NULL ;
      while (((operand_36131 = enumerator_36131.nextObject ()))) {
        macroValidPointer (operand_36131) ;
        ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  operand_36131->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (981)),  operand_35599->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (981)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (981)) ;
      }
    }
    {
      GGS_enumMessageListAST::cEnumerator enumerator_36322 (operand_35599->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_36322 = NULL ;
      while (((operand_36322 = enumerator_36322.nextObject ()))) {
        macroValidPointer (operand_36322) ;
        ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_36322->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (985)),  GGS_string ("string"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (985)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_35599->mEnumTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (988)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@filewrapperDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_36964,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_36964 != NULL) {
    GGS_filewrapperTemplateMap  var_cas_filewrapperTemplateMap = GGS_filewrapperTemplateMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    {
      GGS_filewrapperTemplateListAST::cEnumerator enumerator_37150 (operand_36964->mFilewrapperTemplateList, true) ;
      const GGS_filewrapperTemplateListAST::cElement * operand_37150 = NULL ;
      while (((operand_37150 = enumerator_37150.nextObject ()))) {
        macroValidPointer (operand_37150) ;
        GGS_unifiedTypeMapIndexList  var_cas_templateSignature = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
        {
          GGS_formalInputParameterListAST::cEnumerator enumerator_37268 (operand_37150->mFilewrapperTemplateFormalInputParameters, true) ;
          const GGS_formalInputParameterListAST::cElement * operand_37268 = NULL ;
          while (((operand_37268 = enumerator_37268.nextObject ()))) {
            macroValidPointer (operand_37268) ;
            GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
            GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_37268->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1013)) ;
            var_cas_templateSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
          }
        }
        var_cas_filewrapperTemplateMap.modifier_insertKey (inLexique, operand_37150->mFilewrapperTemplateName, var_cas_templateSignature, operand_37150->mFilewrapperTemplatePath COMMA_SOURCE_FILE_AT_LINE (1016)) ;
      }
    }
    var_cas_ioSemanticContext.mFilewrapperMap.modifier_insertKey (inLexique, operand_36964->mFilewrapperName, operand_36964->mFilewrapperPath, operand_36964->mFilewrapperExtensionList, var_cas_filewrapperTemplateMap COMMA_SOURCE_FILE_AT_LINE (1022)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@sortedListDeclarationAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_37965,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_37965 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1037)) ;
    GGS_unifiedTypeMapIndex  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_37965->mSortedListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1040)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_38631 (operand_37965->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_38631 = NULL ;
      while (((operand_38631 = enumerator_38631.nextObject ()))) {
        macroValidPointer (operand_38631) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_38631->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1047)) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_38631->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1048))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_modifierFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_HERE)) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptySortedList"),  operand_37965->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1054)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1054)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1057)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popGreatest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1060)) ;
    var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popSmallest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1065)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("greatest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1072)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("smallest"), GGS_location (inLexique) COMMA_HERE), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1077)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_37965->mSortedListTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_sortedListType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumerationDescriptor COMMA_SOURCE_FILE_AT_LINE (1083)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@structDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_40479,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_40479 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_structTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_40479->mStructTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1105)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_40898 (operand_40479->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_40898 = NULL ;
      while (((operand_40898 = enumerator_40898.nextObject ()))) {
        macroValidPointer (operand_40898) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_40898->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1111)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
      }
    }
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_HERE), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1114)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_41344 (operand_40479->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_41344 = NULL ;
      while (((operand_41344 = enumerator_41344.nextObject ()))) {
        macroValidPointer (operand_41344) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_41344->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1124)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, operand_41344->mAttributeName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_bool (false), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_HERE), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (1125)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_40479->mStructTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_structType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1139)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@listDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_42332,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_42332 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_42524 (operand_42332->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_42524 = NULL ;
      while (((operand_42524 = enumerator_42524.nextObject ()))) {
        macroValidPointer (operand_42524) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_42524->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1163)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_42524->mAttributeName) ;
      }
    }
    ::routine_addTypeList (inLexique,  var_cas_typedAttributeList,  operand_42332->mListTypeName,  var_cas_ioSemanticContext.mTypeMap COMMA_SOURCE_FILE_AT_LINE (1166)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@classDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_43002,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_43002 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1180)) ;
    GGS_unifiedTypeMapIndex  var_cas_superClassIndex ;
    const GGS_bool cond_43404 = (operand_43002->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1183))).operator_isEqual (GGS_string ("")) ;
    if (cond_43404.isBuiltAndTrue ()) {
      var_cas_superClassIndex = GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE) ;
    }else if (cond_43404.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_43002->mSuperClassName, var_cas_ioSemanticContext.mTypeMap, var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (1186)) ;
    }
    GGS_unifiedTypeMapIndex  var_cas_classIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_43002->mClassTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1190)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    const GGS_bool cond_44272 = (operand_43002->mIsAbstract).operator_not () ;
    if (cond_44272.isBuiltAndTrue ()) {
      GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
      {
        GGS_attributeInCollectionListAST::cEnumerator enumerator_43879 (operand_43002->mAttributeList, true) ;
        const GGS_attributeInCollectionListAST::cElement * operand_43879 = NULL ;
        while (((operand_43879 = enumerator_43879.nextObject ()))) {
          macroValidPointer (operand_43879) ;
          GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
          GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_43879->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1197)) ;
          var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        }
      }
      var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_HERE), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1200)) ;
    }
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_43002->mClassTypeName, (operand_43002->mIsAbstract).operator_not (), var_cas_superClassIndex, GGS_typeKindEnum::constructor_classType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_enumerationDescriptorList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1214)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@externRoutineDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_44950,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_44950 != NULL) {
    GGS_formalParameterSignature  var_cas_routineSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_45185 (operand_44950->mFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_45185 = NULL ;
      while (((operand_45185 = enumerator_45185.nextObject ()))) {
        macroValidPointer (operand_45185) ;
        GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_45185->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1238)) ;
        var_cas_routineSignature.addAssign_operation (var_cas_parameterTypeIndex, operand_45185->mFormalParameterPassingMode) ;
      }
    }
    var_cas_ioSemanticContext.mRoutineMap.modifier_insertKey (inLexique, operand_44950->mRoutineName, var_cas_routineSignature COMMA_SOURCE_FILE_AT_LINE (1242)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@externFunctionDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_45709,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_45709 != NULL) {
    GGS_unifiedTypeMapIndexList  var_cas_functionSignature = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_45945 (operand_45709->mFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_45945 = NULL ;
      while (((operand_45945 = enumerator_45945.nextObject ()))) {
        macroValidPointer (operand_45945) ;
        GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_45945->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1255)) ;
        var_cas_functionSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_45709->mResultTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1260)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_45709->mFunctionName, var_cas_functionSignature, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1262)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@lazyFunctionDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lazyFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_lazyFunctionDeclarationAST * operand_46625,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   /* var_cas_inCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_46625 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46625->mResultTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1273)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_46625->mFunctionName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1275)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listmapDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_47175,
                                GGS_semanticContext & var_cas_ioSemanticContext,
                                const GGS_collectedTypeMap   var_cas_inCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_47175 != NULL) {
    GGS_semanticDeclarationAST  var_cas_ast ;
    const GGS_collectedTypeMap  temp_47367 = var_cas_inCollectedTypeMap ;
    if (temp_47367.isBuilt ()) {
      temp_47367 (HERE)->method_searchKey (inLexique, operand_47175->mAssociatedListTypeName, var_cas_ast COMMA_SOURCE_FILE_AT_LINE (1286)) ;
    }
    GGS_attributeInCollectionListAST  var_cas_listAttributeList ;
    { const GGS_semanticDeclarationAST _var_47698 = var_cas_ast ; // CAST instruction
      if (_var_47698.getPtr () != NULL) {
        macroValidPointer (_var_47698.getPtr ()) ;
        if (typeid (cPtr_listDeclarationAST) == typeid (* (_var_47698.getPtr ()))) {
          const GGS_listDeclarationAST var_cas_listAST (_var_47698.getPtr ()) ;
          var_cas_listAttributeList = var_cas_listAST.reader_mAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1290)) ;
        }else{
          operand_47175->mAssociatedListTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '@")).operator_concat (operand_47175->mAssociatedListTypeName)).operator_concat (GGS_string ("' type should be a list type")) COMMA_SOURCE_FILE_AT_LINE (1293)) ;
          var_cas_listAttributeList.drop () ;
        }
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    GGS_unifiedTypeMapIndex  var_cas_associatedListTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_47175->mAssociatedListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_associatedListTypeIndex COMMA_SOURCE_FILE_AT_LINE (1302)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_47175->mListmapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1305)) ;
    GGS_unifiedTypeMapIndex  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1308)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1310)) ;
    GGS_enumerationDescriptorList  var_cas_enumeratorDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_stringTypeIndex, GGS_string ("key")) ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_associatedListTypeIndex, GGS_string ("value")) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_47175->mListmapTypeName, GGS_bool (true), GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_HERE), GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_HERE), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_HERE), var_cas_enumeratorDescriptor COMMA_SOURCE_FILE_AT_LINE (1316)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSemanticContext"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSemanticContext (C_Compiler & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inSemanticDeclarationList,
                                const GGS_location   var_cas_inEndOfSourceFile,
                                GGS_semanticContext & var_cas_outSemanticContext COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSemanticContext at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMap  var_cas_typeMap = function_predefinedTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1342)) ;
  var_cas_outSemanticContext = GGS_semanticContext::constructor_new (var_cas_typeMap, GGS_routineMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_functionMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_descendantClassListMap::constructor_emptyMap (), GGS_filewrapperMap ::constructor_emptyMap (inLexique COMMA_HERE)) ;
  GGS_collectedTypeMap  var_cas_collectedTypeMap = GGS_collectedTypeMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_50142 (var_cas_inSemanticDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_50142 = NULL ;
    while (((operand_50142 = enumerator_50142.nextObject ()))) {
      macroValidPointer (operand_50142) ;
      const GGS_semanticDeclarationAST  temp_50183 = operand_50142->mSemanticDeclaration ;
      if (temp_50183.isBuilt ()) {
        typeCategoryMethod__semanticDeclarationAST__collectType method = findCategoryMethod__semanticDeclarationAST__collectType (temp_50183.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_50183 (HERE), var_cas_collectedTypeMap COMMA_SOURCE_FILE_AT_LINE (1354)) ;
        }
      }
    }
  }
  const GGS_bool cond_50436 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_50436.isBuiltAndTrue ()) {
    {
      GGS_semanticDeclarationListAST::cEnumerator enumerator_50329 (var_cas_inSemanticDeclarationList, true) ;
      const GGS_semanticDeclarationListAST::cElement * operand_50329 = NULL ;
      while (((operand_50329 = enumerator_50329.nextObject ()))) {
        macroValidPointer (operand_50329) ;
        const GGS_semanticDeclarationAST  temp_50370 = operand_50329->mSemanticDeclaration ;
        if (temp_50370.isBuilt ()) {
          typeCategoryMethod__semanticDeclarationAST__enterType method = findCategoryMethod__semanticDeclarationAST__enterType (temp_50370.galgasObjectRunTimeInfo ()) ;
          if (method != NULL) {
            method (inLexique, temp_50370 (HERE), var_cas_outSemanticContext, var_cas_collectedTypeMap COMMA_SOURCE_FILE_AT_LINE (1359)) ;
          }
        }
      }
    }
  }
  const GGS_bool cond_51172 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_51172.isBuiltAndTrue ()) {
    GGS_stringlist  var_cas_undefinedClasses = var_cas_outSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1364)).reader_unsolvedIndexKeyStringList (inLexique COMMA_SOURCE_FILE_AT_LINE (1364)) ;
    const GGS_bool cond_50869 = (var_cas_undefinedClasses.reader_length ()).operator_isEqual (GGS_uint (1U)) ;
    if (cond_50869.isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage = GGS_string ("there is 1 undefined type:") ;
      {
        GGS_stringlist::cEnumerator enumerator_50745 (var_cas_undefinedClasses, true) ;
        const GGS_stringlist::cElement * operand_50745 = NULL ;
        while (((operand_50745 = enumerator_50745.nextObject ()))) {
          macroValidPointer (operand_50745) ;
          var_cas_errorMessage.appendCString ("\n"
            "-  @") ;
          var_cas_errorMessage.dotAssign_operation (operand_50745->mValue) ;
        }
      }
      var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1371)) ;
    }else if (cond_50869.isBuiltAndFalse ()) {
      const GGS_bool cond_51161 = (var_cas_undefinedClasses.reader_length ()).operator_strictSup (GGS_uint (1U)) ;
      if (cond_51161.isBuiltAndTrue ()) {
        GGS_string var_cas_errorMessage = ((GGS_string ("there are ")).operator_concat (var_cas_undefinedClasses.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1372)))).operator_concat (GGS_string (" undefined types:")) ;
        {
          GGS_stringlist::cEnumerator enumerator_51039 (var_cas_undefinedClasses, true) ;
          const GGS_stringlist::cElement * operand_51039 = NULL ;
          while (((operand_51039 = enumerator_51039.nextObject ()))) {
            macroValidPointer (operand_51039) ;
            var_cas_errorMessage.appendCString ("\n"
              "-  @") ;
            var_cas_errorMessage.dotAssign_operation (operand_51039->mValue) ;
          }
        }
        var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1377)) ;
      }
    }
  }
  const GGS_bool cond_51547 = (GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U)) ;
  if (cond_51547.isBuiltAndTrue ()) {
    {
      GGS_unifiedTypeMap::cEnumerator enumerator_51411 (var_cas_outSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1384)), true) ;
      const GGS_unifiedTypeMap::cElement * operand_51411 = NULL ;
      while (((operand_51411 = enumerator_51411.nextObject ()))) {
        macroValidPointer (operand_51411) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSemanticContext\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_buildSemanticContext (void) {
  enterCategoryMethod__semanticDeclarationAST__collectType (category_method__semanticDeclarationAST__collectType, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__mapDeclarationAST__collectType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__mapindexDeclarationAST__collectType, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__enumDeclarationAST__collectType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__sortedListDeclarationAST__collectType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__structDeclarationAST__collectType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__listDeclarationAST__collectType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__classDeclarationAST__collectType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__listmapDeclarationAST__collectType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapDeclarationAST__enterType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapindexDeclarationAST__enterType, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__enumDeclarationAST__enterType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__filewrapperDeclarationAST__enterType, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__sortedListDeclarationAST__enterType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__structDeclarationAST__enterType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listDeclarationAST__enterType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__classDeclarationAST__enterType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externRoutineDeclarationAST__enterType, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externFunctionDeclarationAST__enterType, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lazyFunctionDeclarationAST__enterType, gClassInfoFor__lazyFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listmapDeclarationAST__enterType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_buildSemanticContext (void) {
  gDispatchTableForMethod__semanticDeclarationAST__collectType.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterType.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_buildSemanticContext (prologueRoutineFor_buildSemanticContext, epilogueRoutineFor_buildSemanticContext) ;

//---------------------------------------------------------------------------*

