//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'grammar_semantics.cpp'                        *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                     february 2nd, 2005, at 19h33'46"                      *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "files/C_text_file_write.h"
#include "grammar_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//             Class element of list 'typeListeAttributsAxiome'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::element_type::
element_type (const GGS_lstring & argument_0) {
  mNextItem = (element_type *) NULL ;
  aAttributAxiome = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class list 'typeListeAttributsAxiome'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome
::GGS_typeListeAttributsAxiome (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::~GGS_typeListeAttributsAxiome (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::operator = (const GGS_typeListeAttributsAxiome & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aAttributAxiome) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome  GGS_typeListeAttributsAxiome::
constructor_empty (void) {
  GGS_typeListeAttributsAxiome result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class element of list 'typeListeChaines'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeChaines::element_type::
element_type (const GGS_lstring & argument_0) {
  mNextItem = (element_type *) NULL ;
  attributChaine = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class list 'typeListeChaines'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeChaines
::GGS_typeListeChaines (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeChaines::~GGS_typeListeChaines (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeChaines::GGS_typeListeChaines (const GGS_typeListeChaines & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::operator = (const GGS_typeListeChaines & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributChaine) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeChaines  GGS_typeListeChaines::
constructor_empty (void) {
  GGS_typeListeChaines result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Class element of list 'L_grammarDescriptorForProgram'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::element_type::
element_type (const GGS_lstring & argument_0,
                                const GGS_L_signature_ForGrammarComponent & argument_1,
                                const GGS_typeListeAttributsAxiome & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  mNextItem = (element_type *) NULL ;
  mGrammarName = argument_0 ;
  mStartSymbolSignature = argument_1 ;
  mStartSymbolAttributesList = argument_2 ;
  mIncludeHeader = argument_3 ;
  mLexiqueClassName = argument_4 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'L_grammarDescriptorForProgram'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram
::GGS_L_grammarDescriptorForProgram (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::~GGS_L_grammarDescriptorForProgram (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::operator = (const GGS_L_grammarDescriptorForProgram & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_L_signature_ForGrammarComponent & argument_1,
                                const GGS_typeListeAttributsAxiome & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_L_signature_ForGrammarComponent & argument_1,
                                const GGS_typeListeAttributsAxiome & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()
                 && argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mGrammarName,
                                p->mStartSymbolSignature,
                                p->mStartSymbolAttributesList,
                                p->mIncludeHeader,
                                p->mLexiqueClassName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_empty (void) {
  GGS_L_grammarDescriptorForProgram result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

