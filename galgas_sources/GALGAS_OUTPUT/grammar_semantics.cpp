//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'grammar_semantics.cpp'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     january 10th, 2006, at 14h16'59"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "grammar_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@typeListeAttributsAxiome'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeAttributsAxiome::
elementOf_GGS_typeListeAttributsAxiome (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_typeListeAttributsAxiome *) NULL ;
  aAttributAxiome = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeListeAttributsAxiome'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome
::GGS_typeListeAttributsAxiome (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::~GGS_typeListeAttributsAxiome (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome::GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::operator = (const GGS_typeListeAttributsAxiome & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aAttributAxiome) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeAttributsAxiome  GGS_typeListeAttributsAxiome::
constructor_empty (void) {
  GGS_typeListeAttributsAxiome result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeAttributsAxiome
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeChaines'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeChaines::
elementOf_GGS_typeListeChaines (const GGS_lstring & argument_0) {
  mNextItem = (elementOf_GGS_typeListeChaines *) NULL ;
  attributChaine = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeChaines'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeChaines
::GGS_typeListeChaines (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeChaines::~GGS_typeListeChaines (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeChaines::GGS_typeListeChaines (const GGS_typeListeChaines & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::operator = (const GGS_typeListeChaines & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines::
internalAppendItem (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines::
addAssign_operation (const GGS_lstring & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributChaine) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeChaines  GGS_typeListeChaines::
constructor_empty (void) {
  GGS_typeListeChaines result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeChaines
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@L_grammarDescriptorForProgram'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_L_grammarDescriptorForProgram::
elementOf_GGS_L_grammarDescriptorForProgram (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4) {
  mNextItem = (elementOf_GGS_L_grammarDescriptorForProgram *) NULL ;
  mGrammarPostfix = argument_0 ;
  mGrammarName = argument_1 ;
  mStartSymbolSignature = argument_2 ;
  mStartSymbolAttributesList = argument_3 ;
  mLexiqueClassName = argument_4 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@L_grammarDescriptorForProgram'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram
::GGS_L_grammarDescriptorForProgram (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::~GGS_L_grammarDescriptorForProgram (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram::GGS_L_grammarDescriptorForProgram (const GGS_L_grammarDescriptorForProgram & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::operator = (const GGS_L_grammarDescriptorForProgram & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
internalAppendItem (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_L_signature & argument_2,
                                const GGS_typeListeAttributsAxiome & argument_3,
                                const GGS_lstring & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mGrammarPostfix,
                                p->mGrammarName,
                                p->mStartSymbolSignature,
                                p->mStartSymbolAttributesList,
                                p->mLexiqueClassName) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_L_grammarDescriptorForProgram  GGS_L_grammarDescriptorForProgram::
constructor_empty (void) {
  GGS_L_grammarDescriptorForProgram result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_L_grammarDescriptorForProgram
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

