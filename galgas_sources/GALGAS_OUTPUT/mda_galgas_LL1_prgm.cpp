//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'mda_galgas_LL1_prgm.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 7th, 2007, at 19h54'34"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include "utilities/F_DisplayException.h"
#include "utilities/MF_MemoryControl.h"
#include "generic_arraies/TC_UniqueArray.h"
#include "command_line_interface/F_Analyze_CLI_Options.h"
#include "command_line_interface/mainForLIBPM.h"
#include "utilities/MF_MemoryControl.h"

#ifdef TARGET_API_MAC_CARBON
  #include <SIOUX.H>
#endif

#ifdef COMPILE_FOR_WIN32
  #ifdef __MWERKS__
    #include <WINSIOUX.H>
  #endif
#endif

#include <typeinfo>

//---------------------------------------------------------------------------*

#include "buildTypeMapForSemantics.h"
#include "galgas_LL1_grammar.h"
#include "grammarLL1grammar.h"
#include "guiLL1grammar.h"
#include "lexiqueLL1grammar.h"
#include "lexiqueSemantics.h"
#include "lexiqueTreewalkingForBuildingTerminalMap.h"
#include "mda_galgas_LL1_prgm.h"
#include "mda_galgas_LL1_routines.h"
#include "metamodelLL1grammar.h"
#include "optionHeaderGeneration.h"
#include "optionImplementationGeneration.h"
#include "optionLL1grammar.h"
#include "optionSemantics.h"
#include "optionTreewalkingForBuildingOptionMap.h"
#include "programSLRgrammar.h"
#include "projectLL1grammar.h"
#include "semanticsSLRgrammar.h"
#include "semanticsSemantics.h"
#include "semantics_semantics.h"
#include "syntaxSLRgrammar.h"
#include "treewalkingSLRgrammar.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "mda_galgas_LL1_prgm.gProgram", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              C_options_for_mda_galgas_LL1_prgm  CONSTRUCTOR               *
//                                                                           *
//---------------------------------------------------------------------------*

C_options_for_mda_galgas_LL1_prgm::
C_options_for_mda_galgas_LL1_prgm (const bool inAcceptsDebugOption)
:mBuiltinOptions (inAcceptsDebugOption) {
  add (& mBuiltinOptions) ;
  add (& mGalgasOptions) ;
  add (& mOptions_galgas_cli_options) ;
}

int mainForLIBPM  (const int argc, const char * argv []) {
  bool verboseOptionOn = true ;
  sint16 returnCode = 0 ; // No error
  {
  //--- Input/output parameters
    C_options_for_mda_galgas_LL1_prgm options (false) ;
    C_galgas_io_parameters IOparameters  (& options) ;
    #ifndef DO_NOT_GENERATE_CHECKINGS
      IOparameters.mCompilerVersion = "version GALGAS_BETA_VERSION (LL(1) grammar)" " [debug]" ;
    #else
      IOparameters.mCompilerVersion = "version GALGAS_BETA_VERSION (LL(1) grammar)" ;
    #endif
    IOparameters.mMaxErrorCount = 100 ;
    IOparameters.mMaxWarningCount = 100 ;
    const char * extensions [] = {"ggs", "gOption", "gMetamodel", "gLexique", "gSemantics", "gSyntax", "gGrammar", "gGui", "gProgram", "gTreewalking", "gProject", NULL} ;
    const char * helpMessages [] = {"a '.ggs' GALGAS source file", "a GALGAS option source file", "a GALGAS metamodel source file", "a GALGAS lexique source file", "a GALGAS semantics source file", "a GALGAS syntax source file", "a GALGAS grammar source file", "a GALGAS GUI source file", "a GALGAS program source file", "a GALGAS treewalking source file", "a GALGAS project source file", NULL} ;
    TC_UniqueArray <C_String> sourceFilesArray ;
  //--- Analyze Command Line Options
    F_Analyze_CLI_Options (argc, argv,
                           "version GALGAS_BETA_VERSION (LL(1) grammar)",
                           options,
                           sourceFilesArray,
                           extensions,
                           helpMessages,
                           IOparameters.mCocoaOutput) ;
  //--- Build galgas io object
    C_galgas_io * galgasIOptr = NULL ;
    macroMyNew (galgasIOptr, C_galgas_io (IOparameters, C_galgas_io::kTerminalOutputKind COMMA_HERE)) ;
  //--- Common lexique object
    C_Compiler * _commonLexique = NULL ;
    macroMyNew (_commonLexique, C_Compiler (galgasIOptr COMMA_HERE)) ;
  //--- Ask Save On Close ? (Carbon and Windows SIOUX Only)
    #ifdef SIOUX_IS_IMPLEMENTED
      SIOUXSettings.asktosaveonclose = options.boolOptionValueFromKeys ("generic_cli_options",
                                                                        ASK_TO_SAVE_ON_CLOSE,
                                                                        false) ;
    #endif
  //--- Enable 64 bit alloc debug ? Only if compiled in 64 bit and in debug mode
    #ifndef DO_NOT_GENERATE_CHECKINGS
      #ifdef __LP64__
        if (options.boolOptionValueFromKeys ("generic_cli_options",
                                             "enable_allocation_debugging",
                                             false)) {
          enableAllocDebugFor64BitTool () ;
        }
      #endif
    #endif
    try{
      verboseOptionOn = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                                         "verbose_output",
                                                         false) ;
      mda_galgas_LL1_prgm_prologue (options, sourceFilesArray) ;
      for (sint32 i=0 ; i<sourceFilesArray.count () ; i++) {
        const C_String fileExtension = sourceFilesArray (i COMMA_HERE).pathExtension () ;
        sint16 r = 0 ;
        if (fileExtension.compare ("ggs") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          if (var_cas_inSourceFile._isBuilt ()) {
            ::routine_fixFileGenerationStartDirectory (_inLexique,  var_cas_inSourceFile COMMA_SOURCE_FILE_AT_LINE (64)) ;
          }
          GGS_M_lexiqueComponents  var_cas_lexiqueMapForUse ;
          var_cas_lexiqueMapForUse = GGS_M_lexiqueComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_semanticsComponents  var_cas_semanticsComponentsMap ;
          var_cas_semanticsComponentsMap = GGS_M_semanticsComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_syntaxComponents  var_cas_syntaxComponentsMap ;
          var_cas_syntaxComponentsMap = GGS_M_syntaxComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_grammarComponents  var_cas_grammarComponentsMap ;
          var_cas_grammarComponentsMap = GGS_M_grammarComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_optionComponents  var_cas_optionComponentsMap ;
          var_cas_optionComponentsMap = GGS_M_optionComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_metamodelsComponents  var_cas_metamodelComponentMap ;
          var_cas_metamodelComponentMap = GGS_M_metamodelsComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_treewalkingComponents  var_cas_treewalkingComponentMap ;
          var_cas_treewalkingComponentMap = GGS_M_treewalkingComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              galgas_LL1_grammar grammar_ ;
              try{
                grammar_.startParsing_ (*scanner_,
                                          var_cas_lexiqueMapForUse,
                                          var_cas_semanticsComponentsMap,
                                          var_cas_syntaxComponentsMap,
                                          var_cas_grammarComponentsMap,
                                          var_cas_optionComponentsMap,
                                          var_cas_metamodelComponentMap,
                                          var_cas_treewalkingComponentMap) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (72)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (72)) ;
            }
          }
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gOption") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (89)) ;
          ::routine_compileOptionComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (90)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gMetamodel") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (99)) ;
          ::routine_compileMetamodelComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (100)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gLexique") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (109)) ;
          ::routine_compileLexiqueComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (110)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gSemantics") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (119)) ;
          ::routine_compileSemanticsComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (120)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gSyntax") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (129)) ;
          ::routine_compileSyntaxComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (130)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gGrammar") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (139)) ;
          ::routine_compileGrammarComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (140)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gGui") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (149)) ;
          ::routine_compileGuiComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (150)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gProgram") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (159)) ;
          ::routine_compileProgramComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (160)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gTreewalking") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (169)) ;
          ::routine_compileTreewalkingComponentLL1 (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (170)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gProject") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_outputDirectory ;
          ::routine_getOutputDirectory (_inLexique,  var_cas_inSourceFile,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (180)) ;
          GGS_lstringlist  var_cas_fileList ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              projectLL1grammar grammar_ ;
              try{
                grammar_.startParsing_ (*scanner_,
                                          var_cas_fileList) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (186)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (186)) ;
            }
          }
          const GGS_lstringlist _var_8006 = var_cas_fileList ;
          GGS_lstringlist::element_type * operand_8006 = _var_8006.firstObject () ;
          while ((operand_8006 != NULL)) {
            macroValidPointer (operand_8006) ;
            _inLexique.printMessage (((GGS_string (true, "----- Compiling '"))._operator_concat (operand_8006->mValue))._operator_concat (GGS_string (true, "'\n")) COMMA_SOURCE_FILE_AT_LINE (189)) ;
            GGS_string var_cas_extension ;
            var_cas_extension = operand_8006->mValue.ggs_string ().reader_pathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (190)) ;
            GGS_lstring  var_cas_fullFilePath ;
            var_cas_fullFilePath = GGS_lstring::constructor_new (_inLexique, ((var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (192)))._operator_concat (GGS_string (true, "/")))._operator_concat (operand_8006->mValue.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (192))), operand_8006->mValue.reader_location (_inLexique COMMA_SOURCE_FILE_AT_LINE (193)) COMMA_HERE) ;
            if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gTreewalking"))).isBuiltAndTrue ()) {
              ::routine_compileTreewalkingComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (196)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gSemantics"))).isBuiltAndTrue ()) {
              ::routine_compileSemanticsComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (198)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gLexique"))).isBuiltAndTrue ()) {
              ::routine_compileLexiqueComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (200)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gSyntax"))).isBuiltAndTrue ()) {
              ::routine_compileSyntaxComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (202)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gMetamodel"))).isBuiltAndTrue ()) {
              ::routine_compileMetamodelComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (204)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gOption"))).isBuiltAndTrue ()) {
              ::routine_compileOptionComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (206)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gGrammar"))).isBuiltAndTrue ()) {
              ::routine_compileGrammarComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (208)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gProgram"))).isBuiltAndTrue ()) {
              ::routine_compileProgramComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (210)) ;
            }else if (((var_cas_extension)._operator_isEqual (GGS_string (true, "gGui"))).isBuiltAndTrue ()) {
              ::routine_compileGuiComponentLL1 (_inLexique,  var_cas_fullFilePath,  var_cas_outputDirectory COMMA_SOURCE_FILE_AT_LINE (212)) ;
            }else{
              operand_8006->mValue.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "unhandled extension") COMMA_SOURCE_FILE_AT_LINE (215)) ;
            }
            operand_8006 = operand_8006->nextObject () ;
          }
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else{
          printf ("*** Error: unhandled extension for file '%s' ***\n", sourceFilesArray (i COMMA_HERE).cString ()) ;
          r = 1 ;
        }
        if (r != 0) {
          returnCode = r ;
        }
      }
    //--- Error or warnings ?
      if (_commonLexique->totalErrorCount () > 0) {
        returnCode = 1 ; // Error code
      }else if (_commonLexique->totalWarningCount () > 0) {
        const bool warningsAreTreatedAsError
            = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                               "treat_warnings_as_error",
                                               false) ;
        if (warningsAreTreatedAsError) {
          returnCode = 1 ; // Error code
          if (verboseOptionOn) {
            printf ("** Note: warnings are treated as errors. **\n") ;
          }
        }
      }
    //--- Epilogue
      mda_galgas_LL1_prgm_epilogue (options) ;
    }catch (const M_STD_NAMESPACE exception & e) {
      F_default_display_exception (e) ;
      returnCode = 1 ; // Error code
    }catch (...) {
      F_default_display_unknown_exception () ;
      returnCode = 2 ; // Error code
    }
    macroDetachPointer (galgasIOptr, C_galgas_io) ;
    macroDetachPointer (_commonLexique, C_Compiler) ;
    C_TreewalkingDispacher::releaseAllTables () ;
  }
  #ifndef DO_NOT_GENERATE_CHECKINGS
    C_GGS_Object::checkAllObjectsHaveBeenReleased () ;
  #endif
  if (verboseOptionOn) {
    #ifndef DO_NOT_GENERATE_CHECKINGS
      const uint64 maxUsedMemorySize = getMaxUsedMemorySize () ;
      const uint64 oneMegaByte = 1 << 20 ;
      const uint64 megaBytes = maxUsedMemorySize / oneMegaByte ;
      const uint64 fraction = ((maxUsedMemorySize % oneMegaByte) * 1000) / oneMegaByte ;
      co << getCreatedDynamicObjectsTotalCount ()
         << " C++ objects have been created ("
         << megaBytes << "." << widthWithZeroFill (3) << fraction
         << " MB).\n" ;
      deactivateMemoryControl () ;
      if ((getAllocationBalance () != 0) && (returnCode == 0)) {
        display_pointers () ;
      }
    #endif
  }
  return returnCode ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    P R O L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

void
mda_galgas_LL1_prgm_prologue (const C_options_for_mda_galgas_LL1_prgm & /* inOptions */,
                     const TC_UniqueArray <C_String> & /* inSourceFilesArray */) {
// ADD YOUR CODE HERE
}
//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    E P I L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

void mda_galgas_LL1_prgm_epilogue (const C_options_for_mda_galgas_LL1_prgm & /* inOptions */) {
// ADD YOUR CODE HERE
}

//--- END OF USER ZONE 2


