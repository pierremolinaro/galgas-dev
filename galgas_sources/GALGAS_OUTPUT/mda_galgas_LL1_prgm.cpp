//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'mda_galgas_LL1_prgm.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       may 17th, 2007, at 17h32'28"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include "utilities/F_DisplayException.h"
#include "utilities/MF_MemoryControl.h"
#include "generic_arraies/TC_UniqueArray.h"
#include "command_line_interface/F_Analyze_CLI_Options.h"
#include "command_line_interface/mainForLIBPM.h"
#include "utilities/MF_MemoryControl.h"

#ifdef TARGET_API_MAC_CARBON
  #include <SIOUX.H>
#endif

#ifdef COMPILE_FOR_WIN32
  #ifdef __MWERKS__
    #include <WINSIOUX.H>
  #endif
#endif

//---------------------------------------------------------------------------*

#include "galgas_LL1_grammar.h"
#include "lexiqueLL1grammar.h"
#include "lexiqueTreewalkingForBuildingTerminalMap.h"
#include "mda_galgas_LL1_prgm.h"
#include "metamodelLL1grammar.h"
#include "optionHeaderGeneration.h"
#include "optionImplementationGeneration.h"
#include "optionLL1grammar.h"
#include "optionTreewalkingForBuildingOptionMap.h"
#include "semanticsSLRgrammar.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "mda_galgas_LL1_prgm.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              C_options_for_mda_galgas_LL1_prgm  CONSTRUCTOR               *
//                                                                           *
//---------------------------------------------------------------------------*

C_options_for_mda_galgas_LL1_prgm::
C_options_for_mda_galgas_LL1_prgm (const bool inAcceptsDebugOption)
:mBuiltinOptions (inAcceptsDebugOption) {
  add (& mBuiltinOptions) ;
  add (& mGalgasOptions) ;
  add (& mOptions_galgas_cli_options) ;
}

int mainForLIBPM  (const int argc, const char * argv []) {
  bool verboseOptionOn = true ;
  sint16 returnCode = 0 ; // No error
  {
  //--- Input/output parameters
    C_options_for_mda_galgas_LL1_prgm options (true) ;
    C_galgas_io_parameters IOparameters  (& options) ;
    #ifndef DO_NOT_GENERATE_CHECKINGS
      IOparameters.mCompilerVersion = "version GALGAS_BETA_VERSION (LL(1) grammar)" " [debug]" ;
    #else
      IOparameters.mCompilerVersion = "version GALGAS_BETA_VERSION (LL(1) grammar)" ;
    #endif
    IOparameters.mMaxErrorCount = 100 ;
    IOparameters.mMaxWarningCount = 100 ;
    const char * extensions [] = {"ggs", "gOption", "gMetamodel", "gLexique", "gSemantics", NULL} ;
    const char * helpMessages [] = {"a '.ggs' GALGAS source file", "a GALGAS option source file", "a GALGAS metamodel source file", "a GALGAS lexique source file", "a GALGAS semantics source file", NULL} ;
    TC_UniqueArray <C_String> sourceFilesArray ;
  //--- Analyze Command Line Options
    F_Analyze_CLI_Options (argc, argv,
                           "version GALGAS_BETA_VERSION (LL(1) grammar)",
                           options,
                           sourceFilesArray,
                           extensions,
                           helpMessages,
                           IOparameters.mCocoaOutput) ;
  //--- Build galgas io object
    C_galgas_io * galgasIOptr = NULL ;
    macroMyNew (galgasIOptr, C_galgas_io (IOparameters, C_galgas_io::kTerminalOutputKind COMMA_HERE)) ;
  //--- Common lexique object
    C_Compiler * _commonLexique = NULL ;
    macroMyNew (_commonLexique, C_Compiler (galgasIOptr COMMA_HERE)) ;
  //--- Ask Save On Close ? (Carbon and Windows SIOUX Only)
    #ifdef SIOUX_IS_IMPLEMENTED
      SIOUXSettings.asktosaveonclose = options.boolOptionValueFromKeys ("generic_cli_options",
                                                                        ASK_TO_SAVE_ON_CLOSE,
                                                                        false) ;
    #endif
  //--- Enable 64 bit alloc debug ? Only if compiled in 64 bit and in debug mode
    #ifndef DO_NOT_GENERATE_CHECKINGS
      #ifdef __LP64__
        if (options.boolOptionValueFromKeys ("generic_cli_options",
                                             "enable_allocation_debugging",
                                             false)) {
          enableAllocDebugFor64BitTool () ;
        }
      #endif
    #endif
    try{
      verboseOptionOn = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                                         "verbose_output",
                                                         false) ;
      mda_galgas_LL1_prgm_prologue (options, sourceFilesArray) ;
      for (sint32 i=0 ; i<sourceFilesArray.count () ; i++) {
        const C_String fileExtension = sourceFilesArray (i COMMA_HERE).pathExtension () ;
        sint16 r = 0 ;
        if (fileExtension.compare ("ggs") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          if (var_cas_inSourceFile._isBuilt ()) {
            ::routine_fixFileGenerationStartDirectory (_inLexique,  var_cas_inSourceFile COMMA_SOURCE_FILE_AT_LINE (45)) ;
          }
          GGS_M_lexiqueComponents  var_cas_lexiqueMapForUse ;
          var_cas_lexiqueMapForUse = GGS_M_lexiqueComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_semanticsComponents  var_cas_semanticsComponentsMap ;
          var_cas_semanticsComponentsMap = GGS_M_semanticsComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_syntaxComponents  var_cas_syntaxComponentsMap ;
          var_cas_syntaxComponentsMap = GGS_M_syntaxComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_grammarComponents  var_cas_grammarComponentsMap ;
          var_cas_grammarComponentsMap = GGS_M_grammarComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_optionComponents  var_cas_optionComponentsMap ;
          var_cas_optionComponentsMap = GGS_M_optionComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_metamodelsComponents  var_cas_metamodelComponentMap ;
          var_cas_metamodelComponentMap = GGS_M_metamodelsComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          GGS_M_treewalkingComponents  var_cas_treewalkingComponentMap ;
          var_cas_treewalkingComponentMap = GGS_M_treewalkingComponents::constructor_emptyMap (_inLexique COMMA_HERE) ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              galgas_LL1_grammar grammar_ ;
              try{
                grammar_.startParsing_ (*scanner_,
                                          var_cas_lexiqueMapForUse,
                                          var_cas_semanticsComponentsMap,
                                          var_cas_syntaxComponentsMap,
                                          var_cas_grammarComponentsMap,
                                          var_cas_optionComponentsMap,
                                          var_cas_metamodelComponentMap,
                                          var_cas_treewalkingComponentMap) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (54)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (54)) ;
            }
          }
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gOption") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_startDirectory ;
          var_cas_startDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (69)) ;
          var_cas_startDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
          GGS_optionComponentRoot  var_cas_optionComponentRoot ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              optionLL1grammar grammar_ ;
              try{
                var_cas_optionComponentRoot = grammar_.startParsing_ (*scanner_) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (73)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (73)) ;
            }
          }
          GGS_commandLineOptionMap  var_cas_boolOptionMap ;
          GGS_commandLineOptionMap  var_cas_uintOptionMap ;
          GGS_commandLineOptionMap  var_cas_stringOptionMap ;
          _walk_throught_optionTreewalkingForBuildingOptionMap (_inLexique, var_cas_optionComponentRoot, var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap) ;
          _walk_throught_optionHeaderGeneration (_inLexique, var_cas_optionComponentRoot, var_cas_startDirectory, var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (86)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap) ;
          _walk_throught_optionImplementationGeneration (_inLexique, var_cas_optionComponentRoot, var_cas_startDirectory, var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (93)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (93)), var_cas_boolOptionMap, var_cas_uintOptionMap, var_cas_stringOptionMap) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gMetamodel") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_startDirectory ;
          var_cas_startDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (104)) ;
          var_cas_startDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
          GGS_metamodelComponentRoot  var_cas_metamodelComponentRoot ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              metamodelLL1grammar grammar_ ;
              try{
                var_cas_metamodelComponentRoot = grammar_.startParsing_ (*scanner_) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (108)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (108)) ;
            }
          }
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gLexique") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_startDirectory ;
          var_cas_startDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (115)) ;
          var_cas_startDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
          GGS_lexiqueComponentRoot  var_cas_lexiqueComponentRoot ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              lexiqueLL1grammar grammar_ ;
              try{
                var_cas_lexiqueComponentRoot = grammar_.startParsing_ (*scanner_) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (119)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (119)) ;
            }
          }
          GGS_terminalMap  var_cas_terminalMap ;
          _walk_throught_lexiqueTreewalkingForBuildingTerminalMap (_inLexique, var_cas_lexiqueComponentRoot, var_cas_terminalMap) ;
          _inLexique.printMessage (C_String ("LOGGING terminalMap: ") + var_cas_terminalMap.reader_description (_inLexique COMMA_HERE) + "\n" COMMA_SOURCE_FILE_AT_LINE (125)) ;
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else if (fileExtension.compare ("gSemantics") == 0) {
          C_Compiler & _inLexique = * _commonLexique ;
          const GGS_string _source (true, sourceFilesArray (i COMMA_HERE)) ;
          const GGS_location _here (_inLexique) ;
          const GGS_lstring var_cas_inSourceFile (GGS_lstring::constructor_new (_inLexique, _source, _here COMMA_HERE)) ;
          GGS_string var_cas_startDirectory ;
          var_cas_startDirectory = var_cas_inSourceFile.ggs_string ().reader_stringByDeletingLastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (132)) ;
          var_cas_startDirectory.writeString ("/GALGAS_OUTPUT_TEMP") ;
          GGS_semanticsComponentRoot  var_cas_semanticsComponentRoot ;
          { galgas_scanner * scanner_ = NULL ;
            const C_String sourceFileName = var_cas_inSourceFile.isAbsolutePath ()
              ? var_cas_inSourceFile.string ()
              : _inLexique.sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent (var_cas_inSourceFile) ;
            if (sourceFileName.fileExists ()) {
              macroMyNew (scanner_, galgas_scanner (_inLexique.ioParametersPtr (), sourceFileName COMMA_HERE)) ;
              scanner_->mPerformGeneration = _inLexique.mPerformGeneration ;
              semanticsSLRgrammar grammar_ ;
              try{
                var_cas_semanticsComponentRoot = grammar_.startParsing_ (*scanner_) ;
              }catch (const C_TextReadException & inFileReadError) {
                var_cas_inSourceFile.signalSemanticError (_inLexique, inFileReadError.what () COMMA_SOURCE_FILE_AT_LINE (136)) ;
              }
              macroDetachPointer (scanner_, galgas_scanner) ;
            }else{
              C_String message ;
              message << "The '" << sourceFileName << "' file does not exist" ;
              var_cas_inSourceFile.signalSemanticError (_inLexique, message.cString () COMMA_SOURCE_FILE_AT_LINE (136)) ;
            }
          }
          if (verboseOptionOn || ((_inLexique.totalErrorCount () + _inLexique.totalWarningCount ()) > 0)) {
            co << "Analysis of '" << sourceFilesArray (i COMMA_HERE).lastPathComponent () << "' completed. " ;
            switch (_commonLexique->totalErrorCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "No error, " ;
              }
              break ;
            case 1 :
              co << "1 error, " ;
              returnCode = 1 ; // Error code
              break ;
            default :
              co << _commonLexique->totalErrorCount () << " errors, " ;
              returnCode = 1 ; // Error code
              break ;
            }
            switch (_commonLexique->totalWarningCount ()) {
            case 0 :
              if (verboseOptionOn) {
                co << "no warning" ;
              }
              break ;
            case 1 :
              co << "1 warning" ;
              break ;
            default :
              co << _commonLexique->totalWarningCount () << " warnings" ;
              break ;
            }
            if (verboseOptionOn || ((_commonLexique->totalErrorCount () + _commonLexique->totalWarningCount ()) > 0)) {
              co << ".\n" ;
            }
          }
        }else{
          printf ("*** Error: unhandled extension for file '%s' ***\n", sourceFilesArray (i COMMA_HERE).cString ()) ;
          r = 1 ;
        }
        if (r != 0) {
          returnCode = r ;
        }
      }
    //--- Error or warnings ?
      if (_commonLexique->totalErrorCount () > 0) {
        returnCode = 1 ; // Error code
      }else if (_commonLexique->totalWarningCount () > 0) {
        const bool warningsAreTreatedAsError
            = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                               "treat_warnings_as_error",
                                               false) ;
        if (warningsAreTreatedAsError) {
          returnCode = 1 ; // Error code
          if (verboseOptionOn) {
            printf ("** Note: warnings are treated as errors. **\n") ;
          }
        }
      }
    //--- Epilogue
      mda_galgas_LL1_prgm_epilogue (options) ;
    }catch (const M_STD_NAMESPACE exception & e) {
      F_default_display_exception (e) ;
      returnCode = 1 ; // Error code
    }catch (...) {
      F_default_display_unknown_exception () ;
      returnCode = 2 ; // Error code
    }
    macroDetachPointer (galgasIOptr, C_galgas_io) ;
    macroDetachPointer (_commonLexique, C_Compiler) ;
    C_TreewalkingDispacher::releaseAllTables () ;
  }
  #ifndef DO_NOT_GENERATE_CHECKINGS
    C_GGS_Object::checkAllObjectsHaveBeenReleased () ;
  #endif
  if (verboseOptionOn) {
    #ifndef DO_NOT_GENERATE_CHECKINGS
      const uint64 maxUsedMemorySize = getMaxUsedMemorySize () ;
      const uint64 oneMegaByte = 1 << 20 ;
      const uint64 megaBytes = maxUsedMemorySize / oneMegaByte ;
      const uint64 fraction = ((maxUsedMemorySize % oneMegaByte) * 1000) / oneMegaByte ;
      co << getCreatedDynamicObjectsTotalCount ()
         << " C++ objects have been created ("
         << megaBytes << "." << widthWithZeroFill (3) << fraction
         << " MB).\n" ;
      deactivateMemoryControl () ;
      if ((getAllocationBalance () != 0) && (returnCode == 0)) {
        display_pointers () ;
      }
    #endif
  }
  return returnCode ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    P R O L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

void
mda_galgas_LL1_prgm_prologue (const C_options_for_mda_galgas_LL1_prgm & /* inOptions */,
                     const TC_UniqueArray <C_String> & /* inSourceFilesArray */) {
// ADD YOUR CODE HERE
}
//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    E P I L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

void mda_galgas_LL1_prgm_epilogue (const C_options_for_mda_galgas_LL1_prgm & /* inOptions */) {
// ADD YOUR CODE HERE
}

//--- END OF USER ZONE 2


