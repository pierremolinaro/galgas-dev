//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'expressionMetamodel.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      june 28th, 2007, at 15h26'45"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "expressionMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "expressionMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("expressionMetamodel", 40) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_expressionMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@semanticExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpression::
cPtr_semanticExpression (LOCATION_ARGS) :
cPtr_entity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticExpression::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticExpression" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_semanticExpression * cPtr_semanticExpression::
_cloneObject (void) const {
  cPtr_semanticExpression * _p = NULL ;
  macroMyNew (_p, cPtr_semanticExpression (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_semanticExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_semanticExpression::
_addAssign_operation (const GGS_semanticExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticExpression GGS__list_semanticExpression::
_operator_concat (const GGS__list_semanticExpression & inOperand) const {
  GGS__list_semanticExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_semanticExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_semanticExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_semanticExpression  GGS__list_semanticExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticExpression  GGS__list_semanticExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_semanticExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_semanticExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_semanticExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
_addModel (const GGS_semanticExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
method_first (C_Compiler & _inLexique,
              GGS_semanticExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
method_last (C_Compiler & _inLexique,
             GGS_semanticExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_semanticExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@semanticExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_semanticExpression::actualTypeName (void) const {
 return "semanticExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpression * GGS_semanticExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@outExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outExpressionList::
cPtr_outExpressionList (const GGS__list_semanticExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_entity (THERE),
mExpression (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_outExpressionList::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_outExpressionList * _p = dynamic_cast <const cPtr_outExpressionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && mEndOfExpressionLocation._operator_isEqual (_p->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outExpressionList::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @outExpressionList" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_outExpressionList::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outExpressionList::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_outExpressionList::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outExpressionList::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "outExpressionList" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_outExpressionList * cPtr_outExpressionList::
_cloneObject (void) const {
  cPtr_outExpressionList * _p = NULL ;
  macroMyNew (_p, cPtr_outExpressionList (mExpression, mEndOfExpressionLocation COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_outExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
_internalAppendValues (const GGS__list_semanticExpression & argument_0,
                    const GGS_location & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
_internalPrependValues (const GGS__list_semanticExpression & argument_0,
                    const GGS_location & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_outExpressionList::
_addAssign_operation (const GGS_outExpressionList & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_outExpressionList GGS__list_outExpressionList::
_operator_concat (const GGS__list_outExpressionList & inOperand) const {
  GGS__list_outExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_outExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_outExpressionList & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression,
                                _p->mEndOfExpressionLocation) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_outExpressionList  GGS__list_outExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_outExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_outExpressionList  GGS__list_outExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_outExpressionList & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_outExpressionList result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_outExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_outExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
_addModel (const GGS_outExpressionList & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_outExpressionList & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_outExpressionList & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_outExpressionList & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_outExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_outExpressionList & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@outExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_outExpressionList GGS_outExpressionList::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS__list_semanticExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outExpressionList result ;
  macroMyNew (result.mPointer, cPtr_outExpressionList (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_semanticExpression  GGS_outExpressionList::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS__list_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outExpressionList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outExpressionList *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_outExpressionList::
reader_mEndOfExpressionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outExpressionList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outExpressionList *) mPointer)->mEndOfExpressionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outExpressionList::actualTypeName (void) const {
 return "outExpressionList" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outExpressionList * GGS_outExpressionList::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_outExpressionList *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@variableExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_variableExpression::
cPtr_variableExpression (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mVariableName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_variableExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_variableExpression * _p = dynamic_cast <const cPtr_variableExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableName._operator_isEqual (_p->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_variableExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @variableExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_variableExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_variableExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_variableExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_variableExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "variableExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_variableExpression * cPtr_variableExpression::
_cloneObject (void) const {
  cPtr_variableExpression * _p = NULL ;
  macroMyNew (_p, cPtr_variableExpression (mVariableName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_variableExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
_internalAppendValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
_internalPrependValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_variableExpression::
_addAssign_operation (const GGS_variableExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_variableExpression GGS__list_variableExpression::
_operator_concat (const GGS__list_variableExpression & inOperand) const {
  GGS__list_variableExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_variableExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_variableExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariableName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_variableExpression  GGS__list_variableExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_variableExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_variableExpression  GGS__list_variableExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_variableExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_variableExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_variableExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_variableExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
_addModel (const GGS_variableExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
method_first (C_Compiler & _inLexique,
              GGS_variableExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
method_last (C_Compiler & _inLexique,
             GGS_variableExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_variableExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_variableExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_variableExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@variableExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_variableExpression GGS_variableExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_variableExpression result ;
  macroMyNew (result.mPointer, cPtr_variableExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_variableExpression::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_variableExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_variableExpression *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_variableExpression::actualTypeName (void) const {
 return "variableExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_variableExpression * GGS_variableExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_variableExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@selfInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfInExpression::
cPtr_selfInExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_selfInExpression::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_selfInExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @selfInExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_selfInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_selfInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "selfInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_selfInExpression * cPtr_selfInExpression::
_cloneObject (void) const {
  cPtr_selfInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_selfInExpression (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_selfInExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_selfInExpression::
_addAssign_operation (const GGS_selfInExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_selfInExpression GGS__list_selfInExpression::
_operator_concat (const GGS__list_selfInExpression & inOperand) const {
  GGS__list_selfInExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_selfInExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_selfInExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_selfInExpression  GGS__list_selfInExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_selfInExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_selfInExpression  GGS__list_selfInExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_selfInExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_selfInExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_selfInExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_selfInExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
_addModel (const GGS_selfInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
method_first (C_Compiler & _inLexique,
              GGS_selfInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
method_last (C_Compiler & _inLexique,
             GGS_selfInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_selfInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_selfInExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_selfInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@selfInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_selfInExpression GGS_selfInExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_selfInExpression result ;
  macroMyNew (result.mPointer, cPtr_selfInExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfInExpression::actualTypeName (void) const {
 return "selfInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfInExpression * GGS_selfInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_selfInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@hereExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpression::
cPtr_hereExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_hereExpression::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @hereExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_hereExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_hereExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "hereExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_hereExpression * cPtr_hereExpression::
_cloneObject (void) const {
  cPtr_hereExpression * _p = NULL ;
  macroMyNew (_p, cPtr_hereExpression (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_hereExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_hereExpression::
_addAssign_operation (const GGS_hereExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_hereExpression GGS__list_hereExpression::
_operator_concat (const GGS__list_hereExpression & inOperand) const {
  GGS__list_hereExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_hereExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_hereExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_hereExpression  GGS__list_hereExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_hereExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_hereExpression  GGS__list_hereExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_hereExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_hereExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_hereExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_hereExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
_addModel (const GGS_hereExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
method_first (C_Compiler & _inLexique,
              GGS_hereExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
method_last (C_Compiler & _inLexique,
             GGS_hereExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_hereExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_hereExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_hereExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@hereExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_hereExpression GGS_hereExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpression result ;
  macroMyNew (result.mPointer, cPtr_hereExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpression::actualTypeName (void) const {
 return "hereExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpression * GGS_hereExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_hereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@trueExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpression::
cPtr_trueExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_trueExpression::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @trueExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_trueExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_trueExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "trueExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_trueExpression * cPtr_trueExpression::
_cloneObject (void) const {
  cPtr_trueExpression * _p = NULL ;
  macroMyNew (_p, cPtr_trueExpression (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_trueExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_trueExpression::
_addAssign_operation (const GGS_trueExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_trueExpression GGS__list_trueExpression::
_operator_concat (const GGS__list_trueExpression & inOperand) const {
  GGS__list_trueExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_trueExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_trueExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_trueExpression  GGS__list_trueExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_trueExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_trueExpression  GGS__list_trueExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_trueExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_trueExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_trueExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_trueExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
_addModel (const GGS_trueExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
method_first (C_Compiler & _inLexique,
              GGS_trueExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
method_last (C_Compiler & _inLexique,
             GGS_trueExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_trueExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_trueExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_trueExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@trueExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trueExpression GGS_trueExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpression result ;
  macroMyNew (result.mPointer, cPtr_trueExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpression::actualTypeName (void) const {
 return "trueExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpression * GGS_trueExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_trueExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@falseExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpression::
cPtr_falseExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_falseExpression::
isEqualToObject (const cPtr_entity * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @falseExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_falseExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_falseExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "falseExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_falseExpression * cPtr_falseExpression::
_cloneObject (void) const {
  cPtr_falseExpression * _p = NULL ;
  macroMyNew (_p, cPtr_falseExpression (HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_falseExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
_internalAppendValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
_internalPrependValues () {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_falseExpression::
_addAssign_operation (const GGS_falseExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_falseExpression GGS__list_falseExpression::
_operator_concat (const GGS__list_falseExpression & inOperand) const {
  GGS__list_falseExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_falseExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_falseExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_falseExpression  GGS__list_falseExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_falseExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_falseExpression  GGS__list_falseExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_falseExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_falseExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_falseExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_falseExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
_addModel (const GGS_falseExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
method_first (C_Compiler & _inLexique,
              GGS_falseExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
method_last (C_Compiler & _inLexique,
             GGS_falseExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_falseExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_falseExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_falseExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@falseExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_falseExpression GGS_falseExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpression result ;
  macroMyNew (result.mPointer, cPtr_falseExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpression::actualTypeName (void) const {
 return "falseExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpression * GGS_falseExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_falseExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@literalCharExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpression::
cPtr_literalCharExpression (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalCharExpression * _p = dynamic_cast <const cPtr_literalCharExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalCharExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalCharExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalCharExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalCharExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalCharExpression * cPtr_literalCharExpression::
_cloneObject (void) const {
  cPtr_literalCharExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalCharExpression (mCharacter COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_literalCharExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
_internalAppendValues (const GGS_lchar & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
_internalPrependValues (const GGS_lchar & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalCharExpression::
_addAssign_operation (const GGS_literalCharExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalCharExpression GGS__list_literalCharExpression::
_operator_concat (const GGS__list_literalCharExpression & inOperand) const {
  GGS__list_literalCharExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalCharExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalCharExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCharacter) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalCharExpression  GGS__list_literalCharExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalCharExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalCharExpression  GGS__list_literalCharExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalCharExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalCharExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalCharExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalCharExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
_addModel (const GGS_literalCharExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
method_first (C_Compiler & _inLexique,
              GGS_literalCharExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
method_last (C_Compiler & _inLexique,
             GGS_literalCharExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalCharExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalCharExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalCharExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@literalCharExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalCharExpression GGS_literalCharExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpression result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_literalCharExpression::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpression *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpression::actualTypeName (void) const {
 return "literalCharExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpression * GGS_literalCharExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@literalStringExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpression::
cPtr_literalStringExpression (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mStringSequence (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalStringExpression * _p = dynamic_cast <const cPtr_literalStringExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStringSequence._operator_isEqual (_p->mStringSequence).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalStringExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStringSequence.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalStringExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalStringExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalStringExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalStringExpression * cPtr_literalStringExpression::
_cloneObject (void) const {
  cPtr_literalStringExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalStringExpression (mStringSequence COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_literalStringExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
_internalAppendValues (const GGS_stringlist & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
_internalPrependValues (const GGS_stringlist & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalStringExpression::
_addAssign_operation (const GGS_literalStringExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalStringExpression GGS__list_literalStringExpression::
_operator_concat (const GGS__list_literalStringExpression & inOperand) const {
  GGS__list_literalStringExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalStringExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalStringExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mStringSequence) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalStringExpression  GGS__list_literalStringExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalStringExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalStringExpression  GGS__list_literalStringExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalStringExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalStringExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalStringExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalStringExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
_addModel (const GGS_literalStringExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
method_first (C_Compiler & _inLexique,
              GGS_literalStringExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
method_last (C_Compiler & _inLexique,
             GGS_literalStringExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalStringExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalStringExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalStringExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@literalStringExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalStringExpression GGS_literalStringExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpression result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_literalStringExpression::
reader_mStringSequence (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpression *) mPointer)->mStringSequence ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpression::actualTypeName (void) const {
 return "literalStringExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpression * GGS_literalStringExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@literalDoubleExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpression::
cPtr_literalDoubleExpression (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalDoubleExpression * _p = dynamic_cast <const cPtr_literalDoubleExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalDoubleExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalDoubleExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalDoubleExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalDoubleExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalDoubleExpression * cPtr_literalDoubleExpression::
_cloneObject (void) const {
  cPtr_literalDoubleExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalDoubleExpression (mValue COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_literalDoubleExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
_internalAppendValues (const GGS_ldouble & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
_internalPrependValues (const GGS_ldouble & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalDoubleExpression::
_addAssign_operation (const GGS_literalDoubleExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalDoubleExpression GGS__list_literalDoubleExpression::
_operator_concat (const GGS__list_literalDoubleExpression & inOperand) const {
  GGS__list_literalDoubleExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalDoubleExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalDoubleExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalDoubleExpression  GGS__list_literalDoubleExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalDoubleExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalDoubleExpression  GGS__list_literalDoubleExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalDoubleExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalDoubleExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalDoubleExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalDoubleExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
_addModel (const GGS_literalDoubleExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
method_first (C_Compiler & _inLexique,
              GGS_literalDoubleExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
method_last (C_Compiler & _inLexique,
             GGS_literalDoubleExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalDoubleExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalDoubleExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalDoubleExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@literalDoubleExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalDoubleExpression GGS_literalDoubleExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpression result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_literalDoubleExpression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpression::actualTypeName (void) const {
 return "literalDoubleExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpression * GGS_literalDoubleExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@literalUIntExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpression::
cPtr_literalUIntExpression (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalUIntExpression * _p = dynamic_cast <const cPtr_literalUIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalUIntExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUIntExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUIntExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalUIntExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalUIntExpression * cPtr_literalUIntExpression::
_cloneObject (void) const {
  cPtr_literalUIntExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalUIntExpression (mValue COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_literalUIntExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
_internalAppendValues (const GGS_luint & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
_internalPrependValues (const GGS_luint & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalUIntExpression::
_addAssign_operation (const GGS_literalUIntExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalUIntExpression GGS__list_literalUIntExpression::
_operator_concat (const GGS__list_literalUIntExpression & inOperand) const {
  GGS__list_literalUIntExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalUIntExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalUIntExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalUIntExpression  GGS__list_literalUIntExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalUIntExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalUIntExpression  GGS__list_literalUIntExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalUIntExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalUIntExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalUIntExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalUIntExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
_addModel (const GGS_literalUIntExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
method_first (C_Compiler & _inLexique,
              GGS_literalUIntExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
method_last (C_Compiler & _inLexique,
             GGS_literalUIntExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalUIntExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUIntExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalUIntExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@literalUIntExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalUIntExpression GGS_literalUIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpression result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_literalUIntExpression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpression::actualTypeName (void) const {
 return "literalUIntExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpression * GGS_literalUIntExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@literalUInt64Expression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64Expression::
cPtr_literalUInt64Expression (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64Expression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalUInt64Expression * _p = dynamic_cast <const cPtr_literalUInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64Expression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalUInt64Expression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUInt64Expression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64Expression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUInt64Expression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64Expression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalUInt64Expression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalUInt64Expression * cPtr_literalUInt64Expression::
_cloneObject (void) const {
  cPtr_literalUInt64Expression * _p = NULL ;
  macroMyNew (_p, cPtr_literalUInt64Expression (mValue COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_literalUInt64Expression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
_internalAppendValues (const GGS_luint64 & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
_internalPrependValues (const GGS_luint64 & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalUInt64Expression::
_addAssign_operation (const GGS_literalUInt64Expression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalUInt64Expression GGS__list_literalUInt64Expression::
_operator_concat (const GGS__list_literalUInt64Expression & inOperand) const {
  GGS__list_literalUInt64Expression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalUInt64Expression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalUInt64Expression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalUInt64Expression  GGS__list_literalUInt64Expression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalUInt64Expression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalUInt64Expression  GGS__list_literalUInt64Expression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalUInt64Expression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalUInt64Expression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalUInt64Expression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalUInt64Expression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
_addModel (const GGS_literalUInt64Expression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
method_first (C_Compiler & _inLexique,
              GGS_literalUInt64Expression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
method_last (C_Compiler & _inLexique,
             GGS_literalUInt64Expression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalUInt64Expression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalUInt64Expression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalUInt64Expression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@literalUInt64Expression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalUInt64Expression GGS_literalUInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_literalUInt64Expression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64Expression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64Expression::actualTypeName (void) const {
 return "literalUInt64Expression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64Expression * GGS_literalUInt64Expression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@literalSIntExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpression::
cPtr_literalSIntExpression (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalSIntExpression * _p = dynamic_cast <const cPtr_literalSIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalSIntExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSIntExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSIntExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 12 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalSIntExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalSIntExpression * cPtr_literalSIntExpression::
_cloneObject (void) const {
  cPtr_literalSIntExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalSIntExpression (mValue COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_literalSIntExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
_internalAppendValues (const GGS_lsint & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
_internalPrependValues (const GGS_lsint & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalSIntExpression::
_addAssign_operation (const GGS_literalSIntExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalSIntExpression GGS__list_literalSIntExpression::
_operator_concat (const GGS__list_literalSIntExpression & inOperand) const {
  GGS__list_literalSIntExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalSIntExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalSIntExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalSIntExpression  GGS__list_literalSIntExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalSIntExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalSIntExpression  GGS__list_literalSIntExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalSIntExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalSIntExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalSIntExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalSIntExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
_addModel (const GGS_literalSIntExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
method_first (C_Compiler & _inLexique,
              GGS_literalSIntExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
method_last (C_Compiler & _inLexique,
             GGS_literalSIntExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalSIntExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSIntExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalSIntExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@literalSIntExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalSIntExpression GGS_literalSIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpression result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_literalSIntExpression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpression::actualTypeName (void) const {
 return "literalSIntExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpression * GGS_literalSIntExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@literalSInt64Expression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64Expression::
cPtr_literalSInt64Expression (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64Expression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalSInt64Expression * _p = dynamic_cast <const cPtr_literalSInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64Expression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalSInt64Expression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSInt64Expression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64Expression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSInt64Expression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 13 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64Expression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalSInt64Expression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_literalSInt64Expression * cPtr_literalSInt64Expression::
_cloneObject (void) const {
  cPtr_literalSInt64Expression * _p = NULL ;
  macroMyNew (_p, cPtr_literalSInt64Expression (mValue COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_literalSInt64Expression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
_internalAppendValues (const GGS_lsint64 & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
_internalPrependValues (const GGS_lsint64 & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_literalSInt64Expression::
_addAssign_operation (const GGS_literalSInt64Expression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_literalSInt64Expression GGS__list_literalSInt64Expression::
_operator_concat (const GGS__list_literalSInt64Expression & inOperand) const {
  GGS__list_literalSInt64Expression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_literalSInt64Expression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_literalSInt64Expression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_literalSInt64Expression  GGS__list_literalSInt64Expression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalSInt64Expression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_literalSInt64Expression  GGS__list_literalSInt64Expression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_literalSInt64Expression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_literalSInt64Expression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_literalSInt64Expression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_literalSInt64Expression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
_addModel (const GGS_literalSInt64Expression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
method_first (C_Compiler & _inLexique,
              GGS_literalSInt64Expression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
method_last (C_Compiler & _inLexique,
             GGS_literalSInt64Expression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalSInt64Expression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_literalSInt64Expression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalSInt64Expression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@literalSInt64Expression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalSInt64Expression GGS_literalSInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_literalSInt64Expression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64Expression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64Expression::actualTypeName (void) const {
 return "literalSInt64Expression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64Expression * GGS_literalSInt64Expression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@constructorExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpression::
cPtr_constructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mTypeName (argument_0),
mConstructorName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_constructorExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_constructorExpression * _p = dynamic_cast <const cPtr_constructorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstructorName._operator_isEqual (_p->mConstructorName).boolValue ()
         && mExpressions._operator_isEqual (_p->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @constructorExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstructorName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_constructorExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_constructorExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 14 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "constructorExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_constructorExpression * cPtr_constructorExpression::
_cloneObject (void) const {
  cPtr_constructorExpression * _p = NULL ;
  macroMyNew (_p, cPtr_constructorExpression (mTypeName, mConstructorName, mExpressions COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_constructorExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_constructorExpression::
_addAssign_operation (const GGS_constructorExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_constructorExpression GGS__list_constructorExpression::
_operator_concat (const GGS__list_constructorExpression & inOperand) const {
  GGS__list_constructorExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_constructorExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_constructorExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mConstructorName,
                                _p->mExpressions) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_constructorExpression  GGS__list_constructorExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_constructorExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_constructorExpression  GGS__list_constructorExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_constructorExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_constructorExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_constructorExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_constructorExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
_addModel (const GGS_constructorExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
method_first (C_Compiler & _inLexique,
              GGS_constructorExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
method_last (C_Compiler & _inLexique,
             GGS_constructorExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_constructorExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_constructorExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_constructorExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@constructorExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_constructorExpression GGS_constructorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpression result ;
  macroMyNew (result.mPointer, cPtr_constructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpression::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpression *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpression::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpression *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_constructorExpression::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpression *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpression::actualTypeName (void) const {
 return "constructorExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpression * GGS_constructorExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_constructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@readerCallExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpression::
cPtr_readerCallExpression (const GGS_semanticExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mReceiver (argument_0),
mReaderName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_readerCallExpression * _p = dynamic_cast <const cPtr_readerCallExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiver._operator_isEqual (_p->mReceiver).boolValue ()
         && mReaderName._operator_isEqual (_p->mReaderName).boolValue ()
         && mExpressions._operator_isEqual (_p->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @readerCallExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiver.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReaderName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_readerCallExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_readerCallExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 15 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "readerCallExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_readerCallExpression * cPtr_readerCallExpression::
_cloneObject (void) const {
  cPtr_readerCallExpression * _p = NULL ;
  macroMyNew (_p, cPtr_readerCallExpression (mReceiver, mReaderName, mExpressions COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_readerCallExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_readerCallExpression::
_addAssign_operation (const GGS_readerCallExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_readerCallExpression GGS__list_readerCallExpression::
_operator_concat (const GGS__list_readerCallExpression & inOperand) const {
  GGS__list_readerCallExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_readerCallExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_readerCallExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiver,
                                _p->mReaderName,
                                _p->mExpressions) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_readerCallExpression  GGS__list_readerCallExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_readerCallExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_readerCallExpression  GGS__list_readerCallExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_readerCallExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_readerCallExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_readerCallExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_readerCallExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
_addModel (const GGS_readerCallExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
method_first (C_Compiler & _inLexique,
              GGS_readerCallExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
method_last (C_Compiler & _inLexique,
             GGS_readerCallExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_readerCallExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_readerCallExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_readerCallExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@readerCallExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_readerCallExpression GGS_readerCallExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpression result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_readerCallExpression::
reader_mReceiver (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpression *) mPointer)->mReceiver ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readerCallExpression::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpression *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_readerCallExpression::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpression *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpression::actualTypeName (void) const {
 return "readerCallExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpression * GGS_readerCallExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_readerCallExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@optionExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionExpression::
cPtr_optionExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOptionComponentName (argument_0),
mOptionEntryName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_optionExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_optionExpression * _p = dynamic_cast <const cPtr_optionExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOptionComponentName._operator_isEqual (_p->mOptionComponentName).boolValue ()
         && mOptionEntryName._operator_isEqual (_p->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @optionExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionEntryName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_optionExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_optionExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 16 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "optionExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_optionExpression * cPtr_optionExpression::
_cloneObject (void) const {
  cPtr_optionExpression * _p = NULL ;
  macroMyNew (_p, cPtr_optionExpression (mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_optionExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_optionExpression::
_addAssign_operation (const GGS_optionExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_optionExpression GGS__list_optionExpression::
_operator_concat (const GGS__list_optionExpression & inOperand) const {
  GGS__list_optionExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_optionExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_optionExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOptionComponentName,
                                _p->mOptionEntryName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_optionExpression  GGS__list_optionExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_optionExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_optionExpression  GGS__list_optionExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_optionExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_optionExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_optionExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_optionExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
_addModel (const GGS_optionExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
method_first (C_Compiler & _inLexique,
              GGS_optionExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
method_last (C_Compiler & _inLexique,
             GGS_optionExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_optionExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_optionExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_optionExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@optionExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_optionExpression GGS_optionExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_optionExpression result ;
  macroMyNew (result.mPointer, cPtr_optionExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpression::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpression *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpression::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpression *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionExpression::actualTypeName (void) const {
 return "optionExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionExpression * GGS_optionExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_optionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@concatExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpression::
cPtr_concatExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_concatExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_concatExpression * _p = dynamic_cast <const cPtr_concatExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @concatExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_concatExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_concatExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 17 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "concatExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_concatExpression * cPtr_concatExpression::
_cloneObject (void) const {
  cPtr_concatExpression * _p = NULL ;
  macroMyNew (_p, cPtr_concatExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_concatExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_concatExpression::
_addAssign_operation (const GGS_concatExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_concatExpression GGS__list_concatExpression::
_operator_concat (const GGS__list_concatExpression & inOperand) const {
  GGS__list_concatExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_concatExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_concatExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_concatExpression  GGS__list_concatExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_concatExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_concatExpression  GGS__list_concatExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_concatExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_concatExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_concatExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_concatExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
_addModel (const GGS_concatExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
method_first (C_Compiler & _inLexique,
              GGS_concatExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
method_last (C_Compiler & _inLexique,
             GGS_concatExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_concatExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_concatExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_concatExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@concatExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_concatExpression GGS_concatExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpression result ;
  macroMyNew (result.mPointer, cPtr_concatExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_concatExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_concatExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_concatExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpression::actualTypeName (void) const {
 return "concatExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpression * GGS_concatExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_concatExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@orExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpression::
cPtr_orExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_orExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_orExpression * _p = dynamic_cast <const cPtr_orExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @orExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_orExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_orExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 18 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "orExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_orExpression * cPtr_orExpression::
_cloneObject (void) const {
  cPtr_orExpression * _p = NULL ;
  macroMyNew (_p, cPtr_orExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@_list_orExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_orExpression::
_addAssign_operation (const GGS_orExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_orExpression GGS__list_orExpression::
_operator_concat (const GGS__list_orExpression & inOperand) const {
  GGS__list_orExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_orExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_orExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_orExpression  GGS__list_orExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_orExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_orExpression  GGS__list_orExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_orExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_orExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_orExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_orExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
_addModel (const GGS_orExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
method_first (C_Compiler & _inLexique,
              GGS_orExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
method_last (C_Compiler & _inLexique,
             GGS_orExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_orExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_orExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_orExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@orExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_orExpression GGS_orExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_orExpression result ;
  macroMyNew (result.mPointer, cPtr_orExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_orExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_orExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_orExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpression::actualTypeName (void) const {
 return "orExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpression * GGS_orExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_orExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@xorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpression::
cPtr_xorExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_xorExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_xorExpression * _p = dynamic_cast <const cPtr_xorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @xorExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_xorExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_xorExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 19 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "xorExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_xorExpression * cPtr_xorExpression::
_cloneObject (void) const {
  cPtr_xorExpression * _p = NULL ;
  macroMyNew (_p, cPtr_xorExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_xorExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_xorExpression::
_addAssign_operation (const GGS_xorExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_xorExpression GGS__list_xorExpression::
_operator_concat (const GGS__list_xorExpression & inOperand) const {
  GGS__list_xorExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_xorExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_xorExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_xorExpression  GGS__list_xorExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_xorExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_xorExpression  GGS__list_xorExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_xorExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_xorExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_xorExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_xorExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
_addModel (const GGS_xorExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
method_first (C_Compiler & _inLexique,
              GGS_xorExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
method_last (C_Compiler & _inLexique,
             GGS_xorExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_xorExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_xorExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_xorExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@xorExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_xorExpression GGS_xorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpression result ;
  macroMyNew (result.mPointer, cPtr_xorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_xorExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_xorExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_xorExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpression::actualTypeName (void) const {
 return "xorExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpression * GGS_xorExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_xorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@andExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpression::
cPtr_andExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_andExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_andExpression * _p = dynamic_cast <const cPtr_andExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @andExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_andExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_andExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 20 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "andExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_andExpression * cPtr_andExpression::
_cloneObject (void) const {
  cPtr_andExpression * _p = NULL ;
  macroMyNew (_p, cPtr_andExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_andExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_andExpression::
_addAssign_operation (const GGS_andExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_andExpression GGS__list_andExpression::
_operator_concat (const GGS__list_andExpression & inOperand) const {
  GGS__list_andExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_andExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_andExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_andExpression  GGS__list_andExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_andExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_andExpression  GGS__list_andExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_andExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_andExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_andExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_andExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
_addModel (const GGS_andExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
method_first (C_Compiler & _inLexique,
              GGS_andExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
method_last (C_Compiler & _inLexique,
             GGS_andExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_andExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_andExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_andExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@andExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_andExpression GGS_andExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_andExpression result ;
  macroMyNew (result.mPointer, cPtr_andExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_andExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_andExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_andExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpression::actualTypeName (void) const {
 return "andExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpression * GGS_andExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_andExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@equalExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpression::
cPtr_equalExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_equalExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_equalExpression * _p = dynamic_cast <const cPtr_equalExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @equalExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_equalExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_equalExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 21 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "equalExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_equalExpression * cPtr_equalExpression::
_cloneObject (void) const {
  cPtr_equalExpression * _p = NULL ;
  macroMyNew (_p, cPtr_equalExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_equalExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_equalExpression::
_addAssign_operation (const GGS_equalExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_equalExpression GGS__list_equalExpression::
_operator_concat (const GGS__list_equalExpression & inOperand) const {
  GGS__list_equalExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_equalExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_equalExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_equalExpression  GGS__list_equalExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_equalExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_equalExpression  GGS__list_equalExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_equalExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_equalExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_equalExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_equalExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
_addModel (const GGS_equalExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
method_first (C_Compiler & _inLexique,
              GGS_equalExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
method_last (C_Compiler & _inLexique,
             GGS_equalExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_equalExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_equalExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_equalExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@equalExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_equalExpression GGS_equalExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpression result ;
  macroMyNew (result.mPointer, cPtr_equalExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_equalExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_equalExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_equalExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpression::actualTypeName (void) const {
 return "equalExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpression * GGS_equalExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_equalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@notEqualExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpression::
cPtr_notEqualExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_notEqualExpression * _p = dynamic_cast <const cPtr_notEqualExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @notEqualExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notEqualExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notEqualExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 22 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "notEqualExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_notEqualExpression * cPtr_notEqualExpression::
_cloneObject (void) const {
  cPtr_notEqualExpression * _p = NULL ;
  macroMyNew (_p, cPtr_notEqualExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_notEqualExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_notEqualExpression::
_addAssign_operation (const GGS_notEqualExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_notEqualExpression GGS__list_notEqualExpression::
_operator_concat (const GGS__list_notEqualExpression & inOperand) const {
  GGS__list_notEqualExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_notEqualExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_notEqualExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_notEqualExpression  GGS__list_notEqualExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_notEqualExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_notEqualExpression  GGS__list_notEqualExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_notEqualExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_notEqualExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_notEqualExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_notEqualExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
_addModel (const GGS_notEqualExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
method_first (C_Compiler & _inLexique,
              GGS_notEqualExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
method_last (C_Compiler & _inLexique,
             GGS_notEqualExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_notEqualExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notEqualExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_notEqualExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@notEqualExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_notEqualExpression GGS_notEqualExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpression result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notEqualExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_notEqualExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_notEqualExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpression::actualTypeName (void) const {
 return "notEqualExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpression * GGS_notEqualExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_notEqualExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@lowerOrEqualExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpression::
cPtr_lowerOrEqualExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lowerOrEqualExpression * _p = dynamic_cast <const cPtr_lowerOrEqualExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lowerOrEqualExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lowerOrEqualExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lowerOrEqualExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 23 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lowerOrEqualExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_lowerOrEqualExpression * cPtr_lowerOrEqualExpression::
_cloneObject (void) const {
  cPtr_lowerOrEqualExpression * _p = NULL ;
  macroMyNew (_p, cPtr_lowerOrEqualExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_lowerOrEqualExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_lowerOrEqualExpression::
_addAssign_operation (const GGS_lowerOrEqualExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_lowerOrEqualExpression GGS__list_lowerOrEqualExpression::
_operator_concat (const GGS__list_lowerOrEqualExpression & inOperand) const {
  GGS__list_lowerOrEqualExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_lowerOrEqualExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_lowerOrEqualExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_lowerOrEqualExpression  GGS__list_lowerOrEqualExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lowerOrEqualExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_lowerOrEqualExpression  GGS__list_lowerOrEqualExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lowerOrEqualExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_lowerOrEqualExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_lowerOrEqualExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_lowerOrEqualExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
_addModel (const GGS_lowerOrEqualExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
method_first (C_Compiler & _inLexique,
              GGS_lowerOrEqualExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
method_last (C_Compiler & _inLexique,
             GGS_lowerOrEqualExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lowerOrEqualExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_lowerOrEqualExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lowerOrEqualExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@lowerOrEqualExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpression GGS_lowerOrEqualExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpression result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lowerOrEqualExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_lowerOrEqualExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_lowerOrEqualExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpression::actualTypeName (void) const {
 return "lowerOrEqualExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpression * GGS_lowerOrEqualExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lowerOrEqualExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@greaterOrEqualExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpression::
cPtr_greaterOrEqualExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_greaterOrEqualExpression * _p = dynamic_cast <const cPtr_greaterOrEqualExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @greaterOrEqualExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_greaterOrEqualExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_greaterOrEqualExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 24 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "greaterOrEqualExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_greaterOrEqualExpression * cPtr_greaterOrEqualExpression::
_cloneObject (void) const {
  cPtr_greaterOrEqualExpression * _p = NULL ;
  macroMyNew (_p, cPtr_greaterOrEqualExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_greaterOrEqualExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_greaterOrEqualExpression::
_addAssign_operation (const GGS_greaterOrEqualExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_greaterOrEqualExpression GGS__list_greaterOrEqualExpression::
_operator_concat (const GGS__list_greaterOrEqualExpression & inOperand) const {
  GGS__list_greaterOrEqualExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_greaterOrEqualExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_greaterOrEqualExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_greaterOrEqualExpression  GGS__list_greaterOrEqualExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_greaterOrEqualExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_greaterOrEqualExpression  GGS__list_greaterOrEqualExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_greaterOrEqualExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_greaterOrEqualExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_greaterOrEqualExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_greaterOrEqualExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
_addModel (const GGS_greaterOrEqualExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
method_first (C_Compiler & _inLexique,
              GGS_greaterOrEqualExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
method_last (C_Compiler & _inLexique,
             GGS_greaterOrEqualExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_greaterOrEqualExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_greaterOrEqualExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_greaterOrEqualExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@greaterOrEqualExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpression GGS_greaterOrEqualExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpression result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_greaterOrEqualExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_greaterOrEqualExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_greaterOrEqualExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpression::actualTypeName (void) const {
 return "greaterOrEqualExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpression * GGS_greaterOrEqualExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_greaterOrEqualExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@strictGreaterExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpression::
cPtr_strictGreaterExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_strictGreaterExpression * _p = dynamic_cast <const cPtr_strictGreaterExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @strictGreaterExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictGreaterExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictGreaterExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 25 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "strictGreaterExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_strictGreaterExpression * cPtr_strictGreaterExpression::
_cloneObject (void) const {
  cPtr_strictGreaterExpression * _p = NULL ;
  macroMyNew (_p, cPtr_strictGreaterExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_strictGreaterExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_strictGreaterExpression::
_addAssign_operation (const GGS_strictGreaterExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_strictGreaterExpression GGS__list_strictGreaterExpression::
_operator_concat (const GGS__list_strictGreaterExpression & inOperand) const {
  GGS__list_strictGreaterExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_strictGreaterExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_strictGreaterExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_strictGreaterExpression  GGS__list_strictGreaterExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_strictGreaterExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_strictGreaterExpression  GGS__list_strictGreaterExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_strictGreaterExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_strictGreaterExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_strictGreaterExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_strictGreaterExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
_addModel (const GGS_strictGreaterExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
method_first (C_Compiler & _inLexique,
              GGS_strictGreaterExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
method_last (C_Compiler & _inLexique,
             GGS_strictGreaterExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_strictGreaterExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictGreaterExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_strictGreaterExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@strictGreaterExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_strictGreaterExpression GGS_strictGreaterExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpression result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictGreaterExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictGreaterExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictGreaterExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpression::actualTypeName (void) const {
 return "strictGreaterExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpression * GGS_strictGreaterExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_strictGreaterExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@strictLowerExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpression::
cPtr_strictLowerExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_strictLowerExpression * _p = dynamic_cast <const cPtr_strictLowerExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @strictLowerExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictLowerExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictLowerExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 26 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "strictLowerExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_strictLowerExpression * cPtr_strictLowerExpression::
_cloneObject (void) const {
  cPtr_strictLowerExpression * _p = NULL ;
  macroMyNew (_p, cPtr_strictLowerExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@_list_strictLowerExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_strictLowerExpression::
_addAssign_operation (const GGS_strictLowerExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_strictLowerExpression GGS__list_strictLowerExpression::
_operator_concat (const GGS__list_strictLowerExpression & inOperand) const {
  GGS__list_strictLowerExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_strictLowerExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_strictLowerExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_strictLowerExpression  GGS__list_strictLowerExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_strictLowerExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_strictLowerExpression  GGS__list_strictLowerExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_strictLowerExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_strictLowerExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_strictLowerExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_strictLowerExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
_addModel (const GGS_strictLowerExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
method_first (C_Compiler & _inLexique,
              GGS_strictLowerExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
method_last (C_Compiler & _inLexique,
             GGS_strictLowerExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_strictLowerExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_strictLowerExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_strictLowerExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@strictLowerExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_strictLowerExpression GGS_strictLowerExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpression result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictLowerExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictLowerExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictLowerExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpression::actualTypeName (void) const {
 return "strictLowerExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpression * GGS_strictLowerExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_strictLowerExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@leftShiftExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpression::
cPtr_leftShiftExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_leftShiftExpression * _p = dynamic_cast <const cPtr_leftShiftExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @leftShiftExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_leftShiftExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_leftShiftExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 27 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "leftShiftExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_leftShiftExpression * cPtr_leftShiftExpression::
_cloneObject (void) const {
  cPtr_leftShiftExpression * _p = NULL ;
  macroMyNew (_p, cPtr_leftShiftExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_leftShiftExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_leftShiftExpression::
_addAssign_operation (const GGS_leftShiftExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_leftShiftExpression GGS__list_leftShiftExpression::
_operator_concat (const GGS__list_leftShiftExpression & inOperand) const {
  GGS__list_leftShiftExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_leftShiftExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_leftShiftExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_leftShiftExpression  GGS__list_leftShiftExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_leftShiftExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_leftShiftExpression  GGS__list_leftShiftExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_leftShiftExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_leftShiftExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_leftShiftExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_leftShiftExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
_addModel (const GGS_leftShiftExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
method_first (C_Compiler & _inLexique,
              GGS_leftShiftExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
method_last (C_Compiler & _inLexique,
             GGS_leftShiftExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_leftShiftExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_leftShiftExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_leftShiftExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@leftShiftExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_leftShiftExpression GGS_leftShiftExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpression result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_leftShiftExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_leftShiftExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_leftShiftExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpression::actualTypeName (void) const {
 return "leftShiftExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpression * GGS_leftShiftExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_leftShiftExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@rightShiftExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpression::
cPtr_rightShiftExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_rightShiftExpression * _p = dynamic_cast <const cPtr_rightShiftExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @rightShiftExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_rightShiftExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_rightShiftExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 28 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "rightShiftExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_rightShiftExpression * cPtr_rightShiftExpression::
_cloneObject (void) const {
  cPtr_rightShiftExpression * _p = NULL ;
  macroMyNew (_p, cPtr_rightShiftExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_rightShiftExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_rightShiftExpression::
_addAssign_operation (const GGS_rightShiftExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_rightShiftExpression GGS__list_rightShiftExpression::
_operator_concat (const GGS__list_rightShiftExpression & inOperand) const {
  GGS__list_rightShiftExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_rightShiftExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_rightShiftExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_rightShiftExpression  GGS__list_rightShiftExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_rightShiftExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_rightShiftExpression  GGS__list_rightShiftExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_rightShiftExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_rightShiftExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_rightShiftExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_rightShiftExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
_addModel (const GGS_rightShiftExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
method_first (C_Compiler & _inLexique,
              GGS_rightShiftExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
method_last (C_Compiler & _inLexique,
             GGS_rightShiftExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_rightShiftExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_rightShiftExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_rightShiftExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@rightShiftExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rightShiftExpression GGS_rightShiftExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpression result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_rightShiftExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_rightShiftExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_rightShiftExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpression::actualTypeName (void) const {
 return "rightShiftExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpression * GGS_rightShiftExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_rightShiftExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@addExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpression::
cPtr_addExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_addExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_addExpression * _p = dynamic_cast <const cPtr_addExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @addExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_addExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_addExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 29 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "addExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_addExpression * cPtr_addExpression::
_cloneObject (void) const {
  cPtr_addExpression * _p = NULL ;
  macroMyNew (_p, cPtr_addExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_addExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_addExpression::
_addAssign_operation (const GGS_addExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_addExpression GGS__list_addExpression::
_operator_concat (const GGS__list_addExpression & inOperand) const {
  GGS__list_addExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_addExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_addExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_addExpression  GGS__list_addExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_addExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_addExpression  GGS__list_addExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_addExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_addExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_addExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_addExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
_addModel (const GGS_addExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
method_first (C_Compiler & _inLexique,
              GGS_addExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
method_last (C_Compiler & _inLexique,
             GGS_addExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_addExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_addExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_addExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@addExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_addExpression GGS_addExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addExpression result ;
  macroMyNew (result.mPointer, cPtr_addExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_addExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_addExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_addExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpression::actualTypeName (void) const {
 return "addExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpression * GGS_addExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_addExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@subExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpression::
cPtr_subExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_subExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_subExpression * _p = dynamic_cast <const cPtr_subExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @subExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_subExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_subExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 30 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "subExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_subExpression * cPtr_subExpression::
_cloneObject (void) const {
  cPtr_subExpression * _p = NULL ;
  macroMyNew (_p, cPtr_subExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_subExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_subExpression::
_addAssign_operation (const GGS_subExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_subExpression GGS__list_subExpression::
_operator_concat (const GGS__list_subExpression & inOperand) const {
  GGS__list_subExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_subExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_subExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_subExpression  GGS__list_subExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_subExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_subExpression  GGS__list_subExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_subExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_subExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_subExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_subExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
_addModel (const GGS_subExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
method_first (C_Compiler & _inLexique,
              GGS_subExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
method_last (C_Compiler & _inLexique,
             GGS_subExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_subExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_subExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_subExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@subExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_subExpression GGS_subExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_subExpression result ;
  macroMyNew (result.mPointer, cPtr_subExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_subExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_subExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_subExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpression::actualTypeName (void) const {
 return "subExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpression * GGS_subExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_subExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@multiplicationExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpression::
cPtr_multiplicationExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_multiplicationExpression * _p = dynamic_cast <const cPtr_multiplicationExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @multiplicationExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_multiplicationExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_multiplicationExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 31 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "multiplicationExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_multiplicationExpression * cPtr_multiplicationExpression::
_cloneObject (void) const {
  cPtr_multiplicationExpression * _p = NULL ;
  macroMyNew (_p, cPtr_multiplicationExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_multiplicationExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_multiplicationExpression::
_addAssign_operation (const GGS_multiplicationExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_multiplicationExpression GGS__list_multiplicationExpression::
_operator_concat (const GGS__list_multiplicationExpression & inOperand) const {
  GGS__list_multiplicationExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_multiplicationExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_multiplicationExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_multiplicationExpression  GGS__list_multiplicationExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_multiplicationExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_multiplicationExpression  GGS__list_multiplicationExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_multiplicationExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_multiplicationExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_multiplicationExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_multiplicationExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
_addModel (const GGS_multiplicationExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
method_first (C_Compiler & _inLexique,
              GGS_multiplicationExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
method_last (C_Compiler & _inLexique,
             GGS_multiplicationExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_multiplicationExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_multiplicationExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_multiplicationExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS entity '@multiplicationExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_multiplicationExpression GGS_multiplicationExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpression result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_multiplicationExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_multiplicationExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_multiplicationExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpression::actualTypeName (void) const {
 return "multiplicationExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpression * GGS_multiplicationExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_multiplicationExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@divisionExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpression::
cPtr_divisionExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_divisionExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_divisionExpression * _p = dynamic_cast <const cPtr_divisionExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @divisionExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_divisionExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_divisionExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 32 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "divisionExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_divisionExpression * cPtr_divisionExpression::
_cloneObject (void) const {
  cPtr_divisionExpression * _p = NULL ;
  macroMyNew (_p, cPtr_divisionExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@_list_divisionExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_divisionExpression::
_addAssign_operation (const GGS_divisionExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_divisionExpression GGS__list_divisionExpression::
_operator_concat (const GGS__list_divisionExpression & inOperand) const {
  GGS__list_divisionExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_divisionExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_divisionExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_divisionExpression  GGS__list_divisionExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_divisionExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_divisionExpression  GGS__list_divisionExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_divisionExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_divisionExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_divisionExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_divisionExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
_addModel (const GGS_divisionExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
method_first (C_Compiler & _inLexique,
              GGS_divisionExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
method_last (C_Compiler & _inLexique,
             GGS_divisionExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_divisionExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_divisionExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_divisionExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS entity '@divisionExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_divisionExpression GGS_divisionExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpression result ;
  macroMyNew (result.mPointer, cPtr_divisionExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_divisionExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_divisionExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_divisionExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpression::actualTypeName (void) const {
 return "divisionExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpression * GGS_divisionExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_divisionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@moduloExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpression::
cPtr_moduloExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_moduloExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_moduloExpression * _p = dynamic_cast <const cPtr_moduloExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @moduloExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_moduloExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_moduloExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 33 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "moduloExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_moduloExpression * cPtr_moduloExpression::
_cloneObject (void) const {
  cPtr_moduloExpression * _p = NULL ;
  macroMyNew (_p, cPtr_moduloExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_moduloExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_moduloExpression::
_addAssign_operation (const GGS_moduloExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_moduloExpression GGS__list_moduloExpression::
_operator_concat (const GGS__list_moduloExpression & inOperand) const {
  GGS__list_moduloExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_moduloExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_moduloExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_moduloExpression  GGS__list_moduloExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_moduloExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_moduloExpression  GGS__list_moduloExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_moduloExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_moduloExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_moduloExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_moduloExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
_addModel (const GGS_moduloExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
method_first (C_Compiler & _inLexique,
              GGS_moduloExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
method_last (C_Compiler & _inLexique,
             GGS_moduloExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_moduloExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_moduloExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_moduloExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@moduloExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_moduloExpression GGS_moduloExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpression result ;
  macroMyNew (result.mPointer, cPtr_moduloExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_moduloExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_moduloExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_moduloExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpression::actualTypeName (void) const {
 return "moduloExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpression * GGS_moduloExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_moduloExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@unaryMinusExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpression::
cPtr_unaryMinusExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_unaryMinusExpression * _p = dynamic_cast <const cPtr_unaryMinusExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @unaryMinusExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_unaryMinusExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_unaryMinusExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 34 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "unaryMinusExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_unaryMinusExpression * cPtr_unaryMinusExpression::
_cloneObject (void) const {
  cPtr_unaryMinusExpression * _p = NULL ;
  macroMyNew (_p, cPtr_unaryMinusExpression (mOperatorLocation, mExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@_list_unaryMinusExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_unaryMinusExpression::
_addAssign_operation (const GGS_unaryMinusExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_unaryMinusExpression GGS__list_unaryMinusExpression::
_operator_concat (const GGS__list_unaryMinusExpression & inOperand) const {
  GGS__list_unaryMinusExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_unaryMinusExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_unaryMinusExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_unaryMinusExpression  GGS__list_unaryMinusExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_unaryMinusExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_unaryMinusExpression  GGS__list_unaryMinusExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_unaryMinusExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_unaryMinusExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_unaryMinusExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_unaryMinusExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
_addModel (const GGS_unaryMinusExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
method_first (C_Compiler & _inLexique,
              GGS_unaryMinusExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
method_last (C_Compiler & _inLexique,
             GGS_unaryMinusExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_unaryMinusExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_unaryMinusExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_unaryMinusExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS entity '@unaryMinusExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_unaryMinusExpression GGS_unaryMinusExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpression result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_unaryMinusExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_unaryMinusExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpression::actualTypeName (void) const {
 return "unaryMinusExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpression * GGS_unaryMinusExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_unaryMinusExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@notExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpression::
cPtr_notExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_notExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_notExpression * _p = dynamic_cast <const cPtr_notExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @notExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 35 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "notExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_notExpression * cPtr_notExpression::
_cloneObject (void) const {
  cPtr_notExpression * _p = NULL ;
  macroMyNew (_p, cPtr_notExpression (mOperatorLocation, mExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@_list_notExpression'                         *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_notExpression::
_addAssign_operation (const GGS_notExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_notExpression GGS__list_notExpression::
_operator_concat (const GGS__list_notExpression & inOperand) const {
  GGS__list_notExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_notExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_notExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_notExpression  GGS__list_notExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_notExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_notExpression  GGS__list_notExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_notExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_notExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_notExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_notExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
_addModel (const GGS_notExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
method_first (C_Compiler & _inLexique,
              GGS_notExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
method_last (C_Compiler & _inLexique,
             GGS_notExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_notExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_notExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_notExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS entity '@notExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_notExpression GGS_notExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_notExpression result ;
  macroMyNew (result.mPointer, cPtr_notExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_notExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpression::actualTypeName (void) const {
 return "notExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpression * GGS_notExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_notExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@negateExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_negateExpression::
cPtr_negateExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_negateExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_negateExpression * _p = dynamic_cast <const cPtr_negateExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_negateExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @negateExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_negateExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_negateExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 36 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "negateExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_negateExpression * cPtr_negateExpression::
_cloneObject (void) const {
  cPtr_negateExpression * _p = NULL ;
  macroMyNew (_p, cPtr_negateExpression (mOperatorLocation, mExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_negateExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_negateExpression::
_addAssign_operation (const GGS_negateExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_negateExpression GGS__list_negateExpression::
_operator_concat (const GGS__list_negateExpression & inOperand) const {
  GGS__list_negateExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_negateExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_negateExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_negateExpression  GGS__list_negateExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_negateExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_negateExpression  GGS__list_negateExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_negateExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_negateExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_negateExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_negateExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
_addModel (const GGS_negateExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
method_first (C_Compiler & _inLexique,
              GGS_negateExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
method_last (C_Compiler & _inLexique,
             GGS_negateExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_negateExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_negateExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_negateExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@negateExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_negateExpression GGS_negateExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_negateExpression result ;
  macroMyNew (result.mPointer, cPtr_negateExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_negateExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_negateExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_negateExpression::actualTypeName (void) const {
 return "negateExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_negateExpression * GGS_negateExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_negateExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@varInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpression::
cPtr_varInExpression (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mVarName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_varInExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_varInExpression * _p = dynamic_cast <const cPtr_varInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVarName._operator_isEqual (_p->mVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @varInExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_varInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_varInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 37 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "varInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_varInExpression * cPtr_varInExpression::
_cloneObject (void) const {
  cPtr_varInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_varInExpression (mVarName COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_varInExpression'                        *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
_internalAppendValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
_internalPrependValues (const GGS_lstring & argument_0) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_varInExpression::
_addAssign_operation (const GGS_varInExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_varInExpression GGS__list_varInExpression::
_operator_concat (const GGS__list_varInExpression & inOperand) const {
  GGS__list_varInExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_varInExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_varInExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVarName) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_varInExpression  GGS__list_varInExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_varInExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_varInExpression  GGS__list_varInExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_varInExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_varInExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_varInExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_varInExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
_addModel (const GGS_varInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
method_first (C_Compiler & _inLexique,
              GGS_varInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
method_last (C_Compiler & _inLexique,
             GGS_varInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_varInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_varInExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_varInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS entity '@varInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_varInExpression GGS_varInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpression result ;
  macroMyNew (result.mPointer, cPtr_varInExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_varInExpression::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpression *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpression::actualTypeName (void) const {
 return "varInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpression * GGS_varInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_varInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@descriptionInExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_descriptionInExpression::
cPtr_descriptionInExpression (const GGS_semanticExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mReceiverExpression (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_descriptionInExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_descriptionInExpression * _p = dynamic_cast <const cPtr_descriptionInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mLocation._operator_isEqual (_p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_descriptionInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @descriptionInExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_descriptionInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_descriptionInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_descriptionInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 38 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_descriptionInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "descriptionInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_descriptionInExpression * cPtr_descriptionInExpression::
_cloneObject (void) const {
  cPtr_descriptionInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_descriptionInExpression (mReceiverExpression, mLocation COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@_list_descriptionInExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_location & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_location & argument_1) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_descriptionInExpression::
_addAssign_operation (const GGS_descriptionInExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_descriptionInExpression GGS__list_descriptionInExpression::
_operator_concat (const GGS__list_descriptionInExpression & inOperand) const {
  GGS__list_descriptionInExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_descriptionInExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_descriptionInExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mLocation) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_descriptionInExpression  GGS__list_descriptionInExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_descriptionInExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_descriptionInExpression  GGS__list_descriptionInExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_descriptionInExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_descriptionInExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_descriptionInExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_descriptionInExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
_addModel (const GGS_descriptionInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
method_first (C_Compiler & _inLexique,
              GGS_descriptionInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
method_last (C_Compiler & _inLexique,
             GGS_descriptionInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_descriptionInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_descriptionInExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_descriptionInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS entity '@descriptionInExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_descriptionInExpression GGS_descriptionInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_descriptionInExpression result ;
  macroMyNew (result.mPointer, cPtr_descriptionInExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_descriptionInExpression::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_descriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_descriptionInExpression *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_descriptionInExpression::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_descriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_descriptionInExpression *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_descriptionInExpression::actualTypeName (void) const {
 return "descriptionInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_descriptionInExpression * GGS_descriptionInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_descriptionInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@castInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInExpression::
cPtr_castInExpression (const GGS_semanticExpression & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mReceiverExpression (argument_0),
mUseKindOfClass (argument_1),
mTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_castInExpression::
isEqualToObject (const cPtr_entity * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_castInExpression * _p = dynamic_cast <const cPtr_castInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mUseKindOfClass._operator_isEqual (_p->mUseKindOfClass).boolValue ()
         && mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @castInExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 39 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "castInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

/*cPtr_castInExpression * cPtr_castInExpression::
_cloneObject (void) const {
  cPtr_castInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_castInExpression (mReceiverExpression, mUseKindOfClass, mTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return _p ;
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@_list_castInExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_semanticExpression & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_semanticExpression & argument_3) {
  cElement * nouvelElement = (cElement *) NULL ;
  macroMyNew (nouvelElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
} */

//---------------------------------------------------------------------------*

void GGS__list_castInExpression::
_addAssign_operation (const GGS_castInExpression & inObject) {
   _insulateList () ;
   _internalAppendItem (inObject._ptr ()) ;
}

//---------------------------------------------------------------------------*

GGS__list_castInExpression GGS__list_castInExpression::
_operator_concat (const GGS__list_castInExpression & inOperand) const {
  GGS__list_castInExpression result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cEntityListElement * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          macroValidPointer (p->ptr ()) ;
          result._internalAppendItem (p->ptr ()) ;
          p = p->internalNextItem () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS__list_castInExpression::
modifier_prependValue (C_Compiler & /* inLexique */,
                       const GGS_castInExpression & inObject
                       COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt () && inObject._isBuilt ()) {
    _insulateList () ;
    _internalPrependItem (inObject._ptr ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
_insulateList (void) {
  if (_shared ()) {
    cElement * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mUseKindOfClass,
                                _p->mTypeName,
                                _p->mErrorLocationExpression) ;
      _p = _p->nextObject () ;
    }
  }
} */

//---------------------------------------------------------------------------*

GGS__list_castInExpression  GGS__list_castInExpression::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_castInExpression result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS__list_castInExpression  GGS__list_castInExpression::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_castInExpression & inObject
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS__list_castInExpression result ;
  result._alloc () ;
  result._internalAppendItem (inObject._ptr ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS__list_castInExpression::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@_list_castInExpression", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
_addModel (const GGS_castInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
method_first (C_Compiler & _inLexique,
              GGS_castInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
method_last (C_Compiler & _inLexique,
             GGS_castInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_castInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS__list_castInExpression::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_castInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  cElement * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS entity '@castInExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInExpression GGS_castInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInExpression result ;
  macroMyNew (result.mPointer, cPtr_castInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInExpression::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInExpression::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInExpression::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInExpression::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInExpression::actualTypeName (void) const {
 return "castInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInExpression * GGS_castInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_castInExpression *) mPointer ;
  }
#endif

