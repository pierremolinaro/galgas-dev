//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'expressionMetamodel.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 15th, 2007, at 16h16'3"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "expressionMetamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "expressionMetamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ("expressionMetamodel", 40) ;

//---------------------------------------------------------------------------*

sint32 _metamodel_index_for_expressionMetamodel (void) {
  return gMetamodelManager.mMetamodelComponentIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@semanticExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpression::
cPtr_semanticExpression (LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_semanticExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @semanticExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_semanticExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 0 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "semanticExpression" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_semanticExpression * cPtr_semanticExpression::
_cloneObject (void) const {
  cPtr_semanticExpression * _p = NULL ;
  macroMyNew (_p, cPtr_semanticExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@semanticExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_semanticExpressionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionList::
_addAssign_operation (const GGS_semanticExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionList GGS_semanticExpressionList::
_operator_concat (const GGS_semanticExpressionList & inOperand) const {
  GGS_semanticExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_semanticExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionList  GGS_semanticExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionList  GGS_semanticExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_semanticExpressionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@semanticExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionList::
_addModel (const GGS_semanticExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_semanticExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_semanticExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_semanticExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_semanticExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_semanticExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_semanticExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_semanticExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_semanticExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_semanticExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_semanticExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const char * GGS_semanticExpression::actualTypeName (void) const {
 return "semanticExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpression * GGS_semanticExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_semanticExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@outExpressionListList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outExpressionList::
cPtr_outExpressionList (const GGS_semanticExpressionList & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mExpression (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_outExpressionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_outExpressionList * _p = dynamic_cast <const cPtr_outExpressionList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mExpression._operator_isEqual (_p->mExpression).boolValue ()
         && mEndOfExpressionLocation._operator_isEqual (_p->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outExpressionList::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @outExpressionList" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_outExpressionList::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outExpressionList::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_outExpressionList::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 1 ;
  if (inLevel > 0) {
    result = -1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outExpressionList::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "outExpressionList" ;
  if (inLevel > 0) {
    result = NULL ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_outExpressionList * cPtr_outExpressionList::
_cloneObject (void) const {
  cPtr_outExpressionList * _p = NULL ;
  macroMyNew (_p, cPtr_outExpressionList (mExpression, mEndOfExpressionLocation COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@outExpressionListList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_outExpressionListList::
_internalAppendValues (const GGS_semanticExpressionList & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_outExpressionListList::
_internalPrependValues (const GGS_semanticExpressionList & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_outExpressionListList::
_addAssign_operation (const GGS_outExpressionList & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_outExpressionList *) inElement.getPtr ())->mExpression,
                                ((cPtr_outExpressionList *) inElement.getPtr ())->mEndOfExpressionLocation) ;
  }
}

//---------------------------------------------------------------------------*

GGS_outExpressionListList GGS_outExpressionListList::
_operator_concat (const GGS_outExpressionListList & inOperand) const {
  GGS_outExpressionListList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_outExpressionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionList  p_0 = p->mExpression ;
          GGS_location  p_1 = p->mEndOfExpressionLocation ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_outExpressionListList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionList & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_outExpressionListList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mExpression,
                                _p->mEndOfExpressionLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_outExpressionListList  GGS_outExpressionListList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_outExpressionListList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionListList  GGS_outExpressionListList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpressionList & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_outExpressionListList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_outExpressionListList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@outExpressionListList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_outExpressionListList::
_addModel (const GGS_outExpressionList & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_outExpressionListList::
method_first (C_Compiler & _inLexique,
              GGS_outExpressionList & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_outExpressionListList::
method_last (C_Compiler & _inLexique,
             GGS_outExpressionList & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_outExpressionListList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_outExpressionList & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_outExpressionListList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_outExpressionList & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_outExpressionList::constructor_new (_inLexique,
       _p->mExpression,
       _p->mEndOfExpressionLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_outExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_outExpressionList GGS_outExpressionList::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionList & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outExpressionList result ;
  macroMyNew (result.mPointer, cPtr_outExpressionList (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionList  GGS_outExpressionList::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outExpressionList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outExpressionList *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_outExpressionList::
reader_mEndOfExpressionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outExpressionList *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outExpressionList *) mPointer)->mEndOfExpressionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outExpressionList::actualTypeName (void) const {
 return "outExpressionList" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outExpressionList * GGS_outExpressionList::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_outExpressionList *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@variableExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_variableExpression::
cPtr_variableExpression (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mVariableName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_variableExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_variableExpression * _p = dynamic_cast <const cPtr_variableExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableName._operator_isEqual (_p->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_variableExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @variableExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_variableExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_variableExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_variableExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 2 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_variableExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "variableExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_variableExpression * cPtr_variableExpression::
_cloneObject (void) const {
  cPtr_variableExpression * _p = NULL ;
  macroMyNew (_p, cPtr_variableExpression (mVariableName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@variableExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_variableExpressionList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_variableExpressionList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_variableExpressionList::
_addAssign_operation (const GGS_variableExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_variableExpression *) inElement.getPtr ())->mVariableName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_variableExpressionList GGS_variableExpressionList::
_operator_concat (const GGS_variableExpressionList & inOperand) const {
  GGS_variableExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_variableExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mVariableName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_variableExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariableName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_variableExpressionList  GGS_variableExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_variableExpressionList  GGS_variableExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_variableExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@variableExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_variableExpressionList::
_addModel (const GGS_variableExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_variableExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_variableExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_variableExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_variableExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_variableExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_variableExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_variableExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_variableExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_variableExpression::constructor_new (_inLexique,
       _p->mVariableName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_variableExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_variableExpression GGS_variableExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_variableExpression result ;
  macroMyNew (result.mPointer, cPtr_variableExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_variableExpression::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_variableExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_variableExpression *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_variableExpression::actualTypeName (void) const {
 return "variableExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_variableExpression * GGS_variableExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_variableExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@selfInExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfInExpression::
cPtr_selfInExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_selfInExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_selfInExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @selfInExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_selfInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_selfInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 3 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "selfInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_selfInExpression * cPtr_selfInExpression::
_cloneObject (void) const {
  cPtr_selfInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_selfInExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@selfInExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_selfInExpressionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_selfInExpressionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_selfInExpressionList::
_addAssign_operation (const GGS_selfInExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionList GGS_selfInExpressionList::
_operator_concat (const GGS_selfInExpressionList & inOperand) const {
  GGS_selfInExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_selfInExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_selfInExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_selfInExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionList  GGS_selfInExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_selfInExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionList  GGS_selfInExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_selfInExpressionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_selfInExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@selfInExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_selfInExpressionList::
_addModel (const GGS_selfInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_selfInExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_selfInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_selfInExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_selfInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_selfInExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_selfInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_selfInExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_selfInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_selfInExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_selfInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_selfInExpression GGS_selfInExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_selfInExpression result ;
  macroMyNew (result.mPointer, cPtr_selfInExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfInExpression::actualTypeName (void) const {
 return "selfInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfInExpression * GGS_selfInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_selfInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@hereExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpression::
cPtr_hereExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_hereExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @hereExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_hereExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_hereExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 4 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "hereExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_hereExpression * cPtr_hereExpression::
_cloneObject (void) const {
  cPtr_hereExpression * _p = NULL ;
  macroMyNew (_p, cPtr_hereExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@hereExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_hereExpressionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_hereExpressionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_hereExpressionList::
_addAssign_operation (const GGS_hereExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_hereExpressionList GGS_hereExpressionList::
_operator_concat (const GGS_hereExpressionList & inOperand) const {
  GGS_hereExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_hereExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_hereExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_hereExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_hereExpressionList  GGS_hereExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_hereExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionList  GGS_hereExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_hereExpressionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_hereExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@hereExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_hereExpressionList::
_addModel (const GGS_hereExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_hereExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_hereExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_hereExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_hereExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_hereExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_hereExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_hereExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_hereExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_hereExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_hereExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_hereExpression GGS_hereExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpression result ;
  macroMyNew (result.mPointer, cPtr_hereExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpression::actualTypeName (void) const {
 return "hereExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpression * GGS_hereExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_hereExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@trueExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpression::
cPtr_trueExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_trueExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @trueExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_trueExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_trueExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 5 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "trueExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_trueExpression * cPtr_trueExpression::
_cloneObject (void) const {
  cPtr_trueExpression * _p = NULL ;
  macroMyNew (_p, cPtr_trueExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@trueExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_trueExpressionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_trueExpressionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_trueExpressionList::
_addAssign_operation (const GGS_trueExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_trueExpressionList GGS_trueExpressionList::
_operator_concat (const GGS_trueExpressionList & inOperand) const {
  GGS_trueExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_trueExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_trueExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_trueExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_trueExpressionList  GGS_trueExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_trueExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionList  GGS_trueExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_trueExpressionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_trueExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@trueExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_trueExpressionList::
_addModel (const GGS_trueExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_trueExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_trueExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_trueExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_trueExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_trueExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_trueExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_trueExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_trueExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_trueExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_trueExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_trueExpression GGS_trueExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpression result ;
  macroMyNew (result.mPointer, cPtr_trueExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpression::actualTypeName (void) const {
 return "trueExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpression * GGS_trueExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_trueExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@falseExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpression::
cPtr_falseExpression (LOCATION_ARGS) :
cPtr_semanticExpression (THERE) {
}

//---------------------------------------------------------------------------*

bool cPtr_falseExpression::
isEqualToObject (const cListElement * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpression::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "-> instance of @falseExpression" ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_falseExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_falseExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 6 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "falseExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_falseExpression * cPtr_falseExpression::
_cloneObject (void) const {
  cPtr_falseExpression * _p = NULL ;
  macroMyNew (_p, cPtr_falseExpression (HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@falseExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_falseExpressionList::
_internalAppendValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_falseExpressionList::
_internalPrependValues () {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_falseExpressionList::
_addAssign_operation (const GGS_falseExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues () ;
  }
}

//---------------------------------------------------------------------------*

GGS_falseExpressionList GGS_falseExpressionList::
_operator_concat (const GGS_falseExpressionList & inOperand) const {
  GGS_falseExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_falseExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          result._internalAppendValues () ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_falseExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_falseExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues () ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_falseExpressionList  GGS_falseExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_falseExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionList  GGS_falseExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_falseExpressionList result ;
  result._alloc () ;
  result._internalAppendValues () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_falseExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@falseExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_falseExpressionList::
_addModel (const GGS_falseExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_falseExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_falseExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_falseExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_falseExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_falseExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_falseExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_falseExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_falseExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_falseExpression::constructor_new (_inLexique) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_falseExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_falseExpression GGS_falseExpression::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpression result ;
  macroMyNew (result.mPointer, cPtr_falseExpression (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpression::actualTypeName (void) const {
 return "falseExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpression * GGS_falseExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_falseExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@literalCharExpressionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpression::
cPtr_literalCharExpression (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalCharExpression * _p = dynamic_cast <const cPtr_literalCharExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCharacter._operator_isEqual (_p->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalCharExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCharacter.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalCharExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalCharExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 7 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalCharExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalCharExpression * cPtr_literalCharExpression::
_cloneObject (void) const {
  cPtr_literalCharExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalCharExpression (mCharacter COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@literalCharExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalCharExpressionList::
_internalAppendValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalCharExpressionList::
_internalPrependValues (const GGS_lchar & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalCharExpressionList::
_addAssign_operation (const GGS_literalCharExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalCharExpression *) inElement.getPtr ())->mCharacter) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionList GGS_literalCharExpressionList::
_operator_concat (const GGS_literalCharExpressionList & inOperand) const {
  GGS_literalCharExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalCharExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lchar  p_0 = p->mCharacter ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalCharExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lchar & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalCharExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCharacter) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionList  GGS_literalCharExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalCharExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionList  GGS_literalCharExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lchar & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalCharExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalCharExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalCharExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalCharExpressionList::
_addModel (const GGS_literalCharExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalCharExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalCharExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalCharExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalCharExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalCharExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalCharExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalCharExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalCharExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalCharExpression::constructor_new (_inLexique,
       _p->mCharacter) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_literalCharExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalCharExpression GGS_literalCharExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpression result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_literalCharExpression::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpression *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpression::actualTypeName (void) const {
 return "literalCharExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpression * GGS_literalCharExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalCharExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@literalStringExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpression::
cPtr_literalStringExpression (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mStringSequence (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalStringExpression * _p = dynamic_cast <const cPtr_literalStringExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mStringSequence._operator_isEqual (_p->mStringSequence).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalStringExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStringSequence.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalStringExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalStringExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 8 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalStringExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalStringExpression * cPtr_literalStringExpression::
_cloneObject (void) const {
  cPtr_literalStringExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalStringExpression (mStringSequence COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@literalStringExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalStringExpressionList::
_internalAppendValues (const GGS_stringlist & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalStringExpressionList::
_internalPrependValues (const GGS_stringlist & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalStringExpressionList::
_addAssign_operation (const GGS_literalStringExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalStringExpression *) inElement.getPtr ())->mStringSequence) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionList GGS_literalStringExpressionList::
_operator_concat (const GGS_literalStringExpressionList & inOperand) const {
  GGS_literalStringExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalStringExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_stringlist  p_0 = p->mStringSequence ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalStringExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_stringlist & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalStringExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mStringSequence) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionList  GGS_literalStringExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalStringExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionList  GGS_literalStringExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_stringlist & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalStringExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalStringExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalStringExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalStringExpressionList::
_addModel (const GGS_literalStringExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalStringExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalStringExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalStringExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalStringExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalStringExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalStringExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalStringExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalStringExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalStringExpression::constructor_new (_inLexique,
       _p->mStringSequence) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_literalStringExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalStringExpression GGS_literalStringExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpression result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_literalStringExpression::
reader_mStringSequence (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpression *) mPointer)->mStringSequence ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpression::actualTypeName (void) const {
 return "literalStringExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpression * GGS_literalStringExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalStringExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@literalDoubleExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpression::
cPtr_literalDoubleExpression (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalDoubleExpression * _p = dynamic_cast <const cPtr_literalDoubleExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalDoubleExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalDoubleExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalDoubleExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 9 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalDoubleExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalDoubleExpression * cPtr_literalDoubleExpression::
_cloneObject (void) const {
  cPtr_literalDoubleExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalDoubleExpression (mValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@literalDoubleExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalDoubleExpressionList::
_internalAppendValues (const GGS_ldouble & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalDoubleExpressionList::
_internalPrependValues (const GGS_ldouble & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalDoubleExpressionList::
_addAssign_operation (const GGS_literalDoubleExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalDoubleExpression *) inElement.getPtr ())->mValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionList GGS_literalDoubleExpressionList::
_operator_concat (const GGS_literalDoubleExpressionList & inOperand) const {
  GGS_literalDoubleExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalDoubleExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_ldouble  p_0 = p->mValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalDoubleExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_ldouble & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalDoubleExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionList  GGS_literalDoubleExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalDoubleExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionList  GGS_literalDoubleExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_ldouble & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalDoubleExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalDoubleExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalDoubleExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalDoubleExpressionList::
_addModel (const GGS_literalDoubleExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalDoubleExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalDoubleExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalDoubleExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalDoubleExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalDoubleExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalDoubleExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalDoubleExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalDoubleExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalDoubleExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_literalDoubleExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalDoubleExpression GGS_literalDoubleExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpression result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_literalDoubleExpression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpression::actualTypeName (void) const {
 return "literalDoubleExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpression * GGS_literalDoubleExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalDoubleExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@literalUIntExpressionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpression::
cPtr_literalUIntExpression (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalUIntExpression * _p = dynamic_cast <const cPtr_literalUIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalUIntExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUIntExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUIntExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 10 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalUIntExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalUIntExpression * cPtr_literalUIntExpression::
_cloneObject (void) const {
  cPtr_literalUIntExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalUIntExpression (mValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@literalUIntExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalUIntExpressionList::
_internalAppendValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalUIntExpressionList::
_internalPrependValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalUIntExpressionList::
_addAssign_operation (const GGS_literalUIntExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalUIntExpression *) inElement.getPtr ())->mValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionList GGS_literalUIntExpressionList::
_operator_concat (const GGS_literalUIntExpressionList & inOperand) const {
  GGS_literalUIntExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalUIntExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalUIntExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalUIntExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionList  GGS_literalUIntExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalUIntExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionList  GGS_literalUIntExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_luint & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalUIntExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalUIntExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalUIntExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalUIntExpressionList::
_addModel (const GGS_literalUIntExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalUIntExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalUIntExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalUIntExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalUIntExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalUIntExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalUIntExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalUIntExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalUIntExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_literalUIntExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalUIntExpression GGS_literalUIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpression result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_literalUIntExpression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpression::actualTypeName (void) const {
 return "literalUIntExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpression * GGS_literalUIntExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalUIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@literalUInt64ExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64Expression::
cPtr_literalUInt64Expression (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64Expression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalUInt64Expression * _p = dynamic_cast <const cPtr_literalUInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64Expression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalUInt64Expression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUInt64Expression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64Expression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalUInt64Expression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 11 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64Expression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalUInt64Expression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalUInt64Expression * cPtr_literalUInt64Expression::
_cloneObject (void) const {
  cPtr_literalUInt64Expression * _p = NULL ;
  macroMyNew (_p, cPtr_literalUInt64Expression (mValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@literalUInt64ExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalUInt64ExpressionList::
_internalAppendValues (const GGS_luint64 & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalUInt64ExpressionList::
_internalPrependValues (const GGS_luint64 & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalUInt64ExpressionList::
_addAssign_operation (const GGS_literalUInt64Expression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalUInt64Expression *) inElement.getPtr ())->mValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionList GGS_literalUInt64ExpressionList::
_operator_concat (const GGS_literalUInt64ExpressionList & inOperand) const {
  GGS_literalUInt64ExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalUInt64Expression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint64  p_0 = p->mValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalUInt64ExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint64 & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalUInt64ExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionList  GGS_literalUInt64ExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionList  GGS_literalUInt64ExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_luint64 & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalUInt64ExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalUInt64ExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalUInt64ExpressionList::
_addModel (const GGS_literalUInt64Expression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalUInt64ExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalUInt64Expression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalUInt64ExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalUInt64Expression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalUInt64ExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalUInt64Expression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalUInt64ExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalUInt64Expression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalUInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_literalUInt64Expression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalUInt64Expression GGS_literalUInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_literalUInt64Expression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64Expression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64Expression::actualTypeName (void) const {
 return "literalUInt64Expression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64Expression * GGS_literalUInt64Expression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalUInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@literalSIntExpressionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpression::
cPtr_literalSIntExpression (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalSIntExpression * _p = dynamic_cast <const cPtr_literalSIntExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalSIntExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSIntExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSIntExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 12 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalSIntExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalSIntExpression * cPtr_literalSIntExpression::
_cloneObject (void) const {
  cPtr_literalSIntExpression * _p = NULL ;
  macroMyNew (_p, cPtr_literalSIntExpression (mValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@literalSIntExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalSIntExpressionList::
_internalAppendValues (const GGS_lsint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalSIntExpressionList::
_internalPrependValues (const GGS_lsint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalSIntExpressionList::
_addAssign_operation (const GGS_literalSIntExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalSIntExpression *) inElement.getPtr ())->mValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionList GGS_literalSIntExpressionList::
_operator_concat (const GGS_literalSIntExpressionList & inOperand) const {
  GGS_literalSIntExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalSIntExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lsint  p_0 = p->mValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalSIntExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lsint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalSIntExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionList  GGS_literalSIntExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalSIntExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionList  GGS_literalSIntExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lsint & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalSIntExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalSIntExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalSIntExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalSIntExpressionList::
_addModel (const GGS_literalSIntExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalSIntExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalSIntExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalSIntExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalSIntExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalSIntExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalSIntExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalSIntExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalSIntExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSIntExpression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_literalSIntExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalSIntExpression GGS_literalSIntExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpression result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_literalSIntExpression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpression::actualTypeName (void) const {
 return "literalSIntExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpression * GGS_literalSIntExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalSIntExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@literalSInt64ExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64Expression::
cPtr_literalSInt64Expression (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64Expression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_literalSInt64Expression * _p = dynamic_cast <const cPtr_literalSInt64Expression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mValue._operator_isEqual (_p->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64Expression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @literalSInt64Expression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mValue.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSInt64Expression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64Expression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_literalSInt64Expression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 13 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64Expression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "literalSInt64Expression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_literalSInt64Expression * cPtr_literalSInt64Expression::
_cloneObject (void) const {
  cPtr_literalSInt64Expression * _p = NULL ;
  macroMyNew (_p, cPtr_literalSInt64Expression (mValue COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@literalSInt64ExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_literalSInt64ExpressionList::
_internalAppendValues (const GGS_lsint64 & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalSInt64ExpressionList::
_internalPrependValues (const GGS_lsint64 & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_literalSInt64ExpressionList::
_addAssign_operation (const GGS_literalSInt64Expression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_literalSInt64Expression *) inElement.getPtr ())->mValue) ;
  }
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionList GGS_literalSInt64ExpressionList::
_operator_concat (const GGS_literalSInt64ExpressionList & inOperand) const {
  GGS_literalSInt64ExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_literalSInt64Expression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lsint64  p_0 = p->mValue ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_literalSInt64ExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lsint64 & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_literalSInt64ExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mValue) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionList  GGS_literalSInt64ExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionList  GGS_literalSInt64ExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lsint64 & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_literalSInt64ExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@literalSInt64ExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_literalSInt64ExpressionList::
_addModel (const GGS_literalSInt64Expression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_literalSInt64ExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_literalSInt64Expression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalSInt64ExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_literalSInt64Expression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalSInt64ExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_literalSInt64Expression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_literalSInt64ExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_literalSInt64Expression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_literalSInt64Expression::constructor_new (_inLexique,
       _p->mValue) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_literalSInt64Expression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_literalSInt64Expression GGS_literalSInt64Expression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64Expression result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64Expression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_literalSInt64Expression::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64Expression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64Expression *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64Expression::actualTypeName (void) const {
 return "literalSInt64Expression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64Expression * GGS_literalSInt64Expression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_literalSInt64Expression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@constructorExpressionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpression::
cPtr_constructorExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mTypeName (argument_0),
mConstructorName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_constructorExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_constructorExpression * _p = dynamic_cast <const cPtr_constructorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mConstructorName._operator_isEqual (_p->mConstructorName).boolValue ()
         && mExpressions._operator_isEqual (_p->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @constructorExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstructorName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_constructorExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_constructorExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 14 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "constructorExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_constructorExpression * cPtr_constructorExpression::
_cloneObject (void) const {
  cPtr_constructorExpression * _p = NULL ;
  macroMyNew (_p, cPtr_constructorExpression (mTypeName, mConstructorName, mExpressions COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@constructorExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_constructorExpressionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorExpressionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorExpressionList::
_addAssign_operation (const GGS_constructorExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_constructorExpression *) inElement.getPtr ())->mTypeName,
                                ((cPtr_constructorExpression *) inElement.getPtr ())->mConstructorName,
                                ((cPtr_constructorExpression *) inElement.getPtr ())->mExpressions) ;
  }
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionList GGS_constructorExpressionList::
_operator_concat (const GGS_constructorExpressionList & inOperand) const {
  GGS_constructorExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_constructorExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mConstructorName ;
          GGS_outExpressionList  p_2 = p->mExpressions ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_constructorExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_outExpressionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_constructorExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mTypeName,
                                _p->mConstructorName,
                                _p->mExpressions) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionList  GGS_constructorExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionList  GGS_constructorExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_outExpressionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_constructorExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_constructorExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@constructorExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_constructorExpressionList::
_addModel (const GGS_constructorExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_constructorExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_constructorExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_constructorExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_constructorExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_constructorExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_constructorExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_constructorExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_constructorExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_constructorExpression::constructor_new (_inLexique,
       _p->mTypeName,
       _p->mConstructorName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_constructorExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_constructorExpression GGS_constructorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpression result ;
  macroMyNew (result.mPointer, cPtr_constructorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpression::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpression *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpression::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpression *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_constructorExpression::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpression *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpression::actualTypeName (void) const {
 return "constructorExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpression * GGS_constructorExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_constructorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@readerCallExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpression::
cPtr_readerCallExpression (const GGS_semanticExpression & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mReceiver (argument_0),
mReaderName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_readerCallExpression * _p = dynamic_cast <const cPtr_readerCallExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiver._operator_isEqual (_p->mReceiver).boolValue ()
         && mReaderName._operator_isEqual (_p->mReaderName).boolValue ()
         && mExpressions._operator_isEqual (_p->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @readerCallExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiver.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReaderName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpressions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_readerCallExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_readerCallExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 15 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "readerCallExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_readerCallExpression * cPtr_readerCallExpression::
_cloneObject (void) const {
  cPtr_readerCallExpression * _p = NULL ;
  macroMyNew (_p, cPtr_readerCallExpression (mReceiver, mReaderName, mExpressions COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@readerCallExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_readerCallExpressionList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_readerCallExpressionList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_outExpressionList & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_readerCallExpressionList::
_addAssign_operation (const GGS_readerCallExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_readerCallExpression *) inElement.getPtr ())->mReceiver,
                                ((cPtr_readerCallExpression *) inElement.getPtr ())->mReaderName,
                                ((cPtr_readerCallExpression *) inElement.getPtr ())->mExpressions) ;
  }
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionList GGS_readerCallExpressionList::
_operator_concat (const GGS_readerCallExpressionList & inOperand) const {
  GGS_readerCallExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_readerCallExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mReceiver ;
          GGS_lstring  p_1 = p->mReaderName ;
          GGS_outExpressionList  p_2 = p->mExpressions ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_readerCallExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_outExpressionList & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_readerCallExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiver,
                                _p->mReaderName,
                                _p->mExpressions) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionList  GGS_readerCallExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerCallExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionList  GGS_readerCallExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpression & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_outExpressionList & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_readerCallExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_readerCallExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@readerCallExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_readerCallExpressionList::
_addModel (const GGS_readerCallExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_readerCallExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_readerCallExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_readerCallExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_readerCallExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_readerCallExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_readerCallExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_readerCallExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_readerCallExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_readerCallExpression::constructor_new (_inLexique,
       _p->mReceiver,
       _p->mReaderName,
       _p->mExpressions) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_readerCallExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_readerCallExpression GGS_readerCallExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outExpressionList & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpression result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_readerCallExpression::
reader_mReceiver (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpression *) mPointer)->mReceiver ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readerCallExpression::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpression *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outExpressionList  GGS_readerCallExpression::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outExpressionList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpression *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpression::actualTypeName (void) const {
 return "readerCallExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpression * GGS_readerCallExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_readerCallExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@optionExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionExpression::
cPtr_optionExpression (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOptionComponentName (argument_0),
mOptionEntryName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_optionExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_optionExpression * _p = dynamic_cast <const cPtr_optionExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOptionComponentName._operator_isEqual (_p->mOptionComponentName).boolValue ()
         && mOptionEntryName._operator_isEqual (_p->mOptionEntryName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @optionExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOptionEntryName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_optionExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_optionExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 16 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "optionExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_optionExpression * cPtr_optionExpression::
_cloneObject (void) const {
  cPtr_optionExpression * _p = NULL ;
  macroMyNew (_p, cPtr_optionExpression (mOptionComponentName, mOptionEntryName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@optionExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_optionExpressionList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_optionExpressionList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_optionExpressionList::
_addAssign_operation (const GGS_optionExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_optionExpression *) inElement.getPtr ())->mOptionComponentName,
                                ((cPtr_optionExpression *) inElement.getPtr ())->mOptionEntryName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_optionExpressionList GGS_optionExpressionList::
_operator_concat (const GGS_optionExpressionList & inOperand) const {
  GGS_optionExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_optionExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOptionComponentName ;
          GGS_lstring  p_1 = p->mOptionEntryName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_optionExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_optionExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOptionComponentName,
                                _p->mOptionEntryName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_optionExpressionList  GGS_optionExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_optionExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionList  GGS_optionExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_optionExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@optionExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_optionExpressionList::
_addModel (const GGS_optionExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_optionExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_optionExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_optionExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_optionExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_optionExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_optionExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_optionExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_optionExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_optionExpression::constructor_new (_inLexique,
       _p->mOptionComponentName,
       _p->mOptionEntryName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_optionExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_optionExpression GGS_optionExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_optionExpression result ;
  macroMyNew (result.mPointer, cPtr_optionExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpression::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpression *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpression::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpression *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionExpression::actualTypeName (void) const {
 return "optionExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionExpression * GGS_optionExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_optionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@concatExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpression::
cPtr_concatExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_concatExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_concatExpression * _p = dynamic_cast <const cPtr_concatExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @concatExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_concatExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_concatExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 17 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "concatExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_concatExpression * cPtr_concatExpression::
_cloneObject (void) const {
  cPtr_concatExpression * _p = NULL ;
  macroMyNew (_p, cPtr_concatExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@concatExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_concatExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_concatExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_concatExpressionList::
_addAssign_operation (const GGS_concatExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_concatExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_concatExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_concatExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_concatExpressionList GGS_concatExpressionList::
_operator_concat (const GGS_concatExpressionList & inOperand) const {
  GGS_concatExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_concatExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_concatExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_concatExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_concatExpressionList  GGS_concatExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_concatExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionList  GGS_concatExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_concatExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_concatExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@concatExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_concatExpressionList::
_addModel (const GGS_concatExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_concatExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_concatExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_concatExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_concatExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_concatExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_concatExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_concatExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_concatExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_concatExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_concatExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_concatExpression GGS_concatExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpression result ;
  macroMyNew (result.mPointer, cPtr_concatExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_concatExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_concatExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_concatExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpression::actualTypeName (void) const {
 return "concatExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpression * GGS_concatExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_concatExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@orExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpression::
cPtr_orExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_orExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_orExpression * _p = dynamic_cast <const cPtr_orExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @orExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_orExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_orExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 18 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "orExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_orExpression * cPtr_orExpression::
_cloneObject (void) const {
  cPtr_orExpression * _p = NULL ;
  macroMyNew (_p, cPtr_orExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@orExpressionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_orExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_orExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_orExpressionList::
_addAssign_operation (const GGS_orExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_orExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_orExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_orExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_orExpressionList GGS_orExpressionList::
_operator_concat (const GGS_orExpressionList & inOperand) const {
  GGS_orExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_orExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_orExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_orExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_orExpressionList  GGS_orExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_orExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionList  GGS_orExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_orExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_orExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@orExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_orExpressionList::
_addModel (const GGS_orExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_orExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_orExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_orExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_orExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_orExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_orExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_orExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_orExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_orExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_orExpression'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_orExpression GGS_orExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_orExpression result ;
  macroMyNew (result.mPointer, cPtr_orExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_orExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_orExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_orExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpression::actualTypeName (void) const {
 return "orExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpression * GGS_orExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_orExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@xorExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpression::
cPtr_xorExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_xorExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_xorExpression * _p = dynamic_cast <const cPtr_xorExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @xorExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_xorExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_xorExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 19 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "xorExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_xorExpression * cPtr_xorExpression::
_cloneObject (void) const {
  cPtr_xorExpression * _p = NULL ;
  macroMyNew (_p, cPtr_xorExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@xorExpressionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_xorExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_xorExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_xorExpressionList::
_addAssign_operation (const GGS_xorExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_xorExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_xorExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_xorExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_xorExpressionList GGS_xorExpressionList::
_operator_concat (const GGS_xorExpressionList & inOperand) const {
  GGS_xorExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_xorExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_xorExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_xorExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_xorExpressionList  GGS_xorExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_xorExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionList  GGS_xorExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_xorExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_xorExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@xorExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_xorExpressionList::
_addModel (const GGS_xorExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_xorExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_xorExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_xorExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_xorExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_xorExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_xorExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_xorExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_xorExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_xorExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_xorExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_xorExpression GGS_xorExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpression result ;
  macroMyNew (result.mPointer, cPtr_xorExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_xorExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_xorExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_xorExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpression::actualTypeName (void) const {
 return "xorExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpression * GGS_xorExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_xorExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@andExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpression::
cPtr_andExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_andExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_andExpression * _p = dynamic_cast <const cPtr_andExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @andExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_andExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_andExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 20 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "andExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_andExpression * cPtr_andExpression::
_cloneObject (void) const {
  cPtr_andExpression * _p = NULL ;
  macroMyNew (_p, cPtr_andExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@andExpressionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_andExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_andExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_andExpressionList::
_addAssign_operation (const GGS_andExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_andExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_andExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_andExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_andExpressionList GGS_andExpressionList::
_operator_concat (const GGS_andExpressionList & inOperand) const {
  GGS_andExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_andExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_andExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_andExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_andExpressionList  GGS_andExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_andExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionList  GGS_andExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_andExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_andExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@andExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_andExpressionList::
_addModel (const GGS_andExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_andExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_andExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_andExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_andExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_andExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_andExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_andExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_andExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_andExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_andExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_andExpression GGS_andExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_andExpression result ;
  macroMyNew (result.mPointer, cPtr_andExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_andExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_andExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_andExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpression::actualTypeName (void) const {
 return "andExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpression * GGS_andExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_andExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@equalExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpression::
cPtr_equalExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_equalExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_equalExpression * _p = dynamic_cast <const cPtr_equalExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @equalExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_equalExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_equalExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 21 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "equalExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_equalExpression * cPtr_equalExpression::
_cloneObject (void) const {
  cPtr_equalExpression * _p = NULL ;
  macroMyNew (_p, cPtr_equalExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@equalExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_equalExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_equalExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_equalExpressionList::
_addAssign_operation (const GGS_equalExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_equalExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_equalExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_equalExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_equalExpressionList GGS_equalExpressionList::
_operator_concat (const GGS_equalExpressionList & inOperand) const {
  GGS_equalExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_equalExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_equalExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_equalExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_equalExpressionList  GGS_equalExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_equalExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionList  GGS_equalExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_equalExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_equalExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@equalExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_equalExpressionList::
_addModel (const GGS_equalExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_equalExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_equalExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_equalExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_equalExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_equalExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_equalExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_equalExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_equalExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_equalExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_equalExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_equalExpression GGS_equalExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpression result ;
  macroMyNew (result.mPointer, cPtr_equalExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_equalExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_equalExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_equalExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpression::actualTypeName (void) const {
 return "equalExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpression * GGS_equalExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_equalExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@notEqualExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpression::
cPtr_notEqualExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_notEqualExpression * _p = dynamic_cast <const cPtr_notEqualExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @notEqualExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notEqualExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notEqualExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 22 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "notEqualExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_notEqualExpression * cPtr_notEqualExpression::
_cloneObject (void) const {
  cPtr_notEqualExpression * _p = NULL ;
  macroMyNew (_p, cPtr_notEqualExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@notEqualExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_notEqualExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_notEqualExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_notEqualExpressionList::
_addAssign_operation (const GGS_notEqualExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_notEqualExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_notEqualExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_notEqualExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionList GGS_notEqualExpressionList::
_operator_concat (const GGS_notEqualExpressionList & inOperand) const {
  GGS_notEqualExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_notEqualExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_notEqualExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_notEqualExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionList  GGS_notEqualExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_notEqualExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionList  GGS_notEqualExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_notEqualExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_notEqualExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@notEqualExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_notEqualExpressionList::
_addModel (const GGS_notEqualExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_notEqualExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_notEqualExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_notEqualExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_notEqualExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_notEqualExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_notEqualExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_notEqualExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_notEqualExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_notEqualExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_notEqualExpression GGS_notEqualExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpression result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notEqualExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_notEqualExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_notEqualExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpression::actualTypeName (void) const {
 return "notEqualExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpression * GGS_notEqualExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_notEqualExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@lowerOrEqualExpressionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpression::
cPtr_lowerOrEqualExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_lowerOrEqualExpression * _p = dynamic_cast <const cPtr_lowerOrEqualExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @lowerOrEqualExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lowerOrEqualExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_lowerOrEqualExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 23 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "lowerOrEqualExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpression * cPtr_lowerOrEqualExpression::
_cloneObject (void) const {
  cPtr_lowerOrEqualExpression * _p = NULL ;
  macroMyNew (_p, cPtr_lowerOrEqualExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@lowerOrEqualExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_lowerOrEqualExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lowerOrEqualExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lowerOrEqualExpressionList::
_addAssign_operation (const GGS_lowerOrEqualExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_lowerOrEqualExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_lowerOrEqualExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_lowerOrEqualExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionList GGS_lowerOrEqualExpressionList::
_operator_concat (const GGS_lowerOrEqualExpressionList & inOperand) const {
  GGS_lowerOrEqualExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_lowerOrEqualExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lowerOrEqualExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lowerOrEqualExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionList  GGS_lowerOrEqualExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionList  GGS_lowerOrEqualExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lowerOrEqualExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@lowerOrEqualExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lowerOrEqualExpressionList::
_addModel (const GGS_lowerOrEqualExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_lowerOrEqualExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_lowerOrEqualExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lowerOrEqualExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_lowerOrEqualExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lowerOrEqualExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_lowerOrEqualExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_lowerOrEqualExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_lowerOrEqualExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_lowerOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_lowerOrEqualExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpression GGS_lowerOrEqualExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpression result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lowerOrEqualExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_lowerOrEqualExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_lowerOrEqualExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpression::actualTypeName (void) const {
 return "lowerOrEqualExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpression * GGS_lowerOrEqualExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_lowerOrEqualExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@greaterOrEqualExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpression::
cPtr_greaterOrEqualExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_greaterOrEqualExpression * _p = dynamic_cast <const cPtr_greaterOrEqualExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @greaterOrEqualExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_greaterOrEqualExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_greaterOrEqualExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 24 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "greaterOrEqualExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpression * cPtr_greaterOrEqualExpression::
_cloneObject (void) const {
  cPtr_greaterOrEqualExpression * _p = NULL ;
  macroMyNew (_p, cPtr_greaterOrEqualExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@greaterOrEqualExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_greaterOrEqualExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_greaterOrEqualExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_greaterOrEqualExpressionList::
_addAssign_operation (const GGS_greaterOrEqualExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_greaterOrEqualExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_greaterOrEqualExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_greaterOrEqualExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionList GGS_greaterOrEqualExpressionList::
_operator_concat (const GGS_greaterOrEqualExpressionList & inOperand) const {
  GGS_greaterOrEqualExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_greaterOrEqualExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_greaterOrEqualExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_greaterOrEqualExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionList  GGS_greaterOrEqualExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionList  GGS_greaterOrEqualExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_greaterOrEqualExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@greaterOrEqualExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_greaterOrEqualExpressionList::
_addModel (const GGS_greaterOrEqualExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_greaterOrEqualExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_greaterOrEqualExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_greaterOrEqualExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_greaterOrEqualExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_greaterOrEqualExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_greaterOrEqualExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_greaterOrEqualExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_greaterOrEqualExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_greaterOrEqualExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_greaterOrEqualExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpression GGS_greaterOrEqualExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpression result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_greaterOrEqualExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_greaterOrEqualExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_greaterOrEqualExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpression::actualTypeName (void) const {
 return "greaterOrEqualExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpression * GGS_greaterOrEqualExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_greaterOrEqualExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@strictGreaterExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpression::
cPtr_strictGreaterExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_strictGreaterExpression * _p = dynamic_cast <const cPtr_strictGreaterExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @strictGreaterExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictGreaterExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictGreaterExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 25 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "strictGreaterExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_strictGreaterExpression * cPtr_strictGreaterExpression::
_cloneObject (void) const {
  cPtr_strictGreaterExpression * _p = NULL ;
  macroMyNew (_p, cPtr_strictGreaterExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@strictGreaterExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_strictGreaterExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_strictGreaterExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_strictGreaterExpressionList::
_addAssign_operation (const GGS_strictGreaterExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_strictGreaterExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_strictGreaterExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_strictGreaterExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionList GGS_strictGreaterExpressionList::
_operator_concat (const GGS_strictGreaterExpressionList & inOperand) const {
  GGS_strictGreaterExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_strictGreaterExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_strictGreaterExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_strictGreaterExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionList  GGS_strictGreaterExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_strictGreaterExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionList  GGS_strictGreaterExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_strictGreaterExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_strictGreaterExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@strictGreaterExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_strictGreaterExpressionList::
_addModel (const GGS_strictGreaterExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_strictGreaterExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_strictGreaterExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_strictGreaterExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_strictGreaterExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_strictGreaterExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_strictGreaterExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_strictGreaterExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_strictGreaterExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictGreaterExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_strictGreaterExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_strictGreaterExpression GGS_strictGreaterExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpression result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictGreaterExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictGreaterExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictGreaterExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpression::actualTypeName (void) const {
 return "strictGreaterExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpression * GGS_strictGreaterExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_strictGreaterExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@strictLowerExpressionList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpression::
cPtr_strictLowerExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_strictLowerExpression * _p = dynamic_cast <const cPtr_strictLowerExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @strictLowerExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictLowerExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_strictLowerExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 26 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "strictLowerExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_strictLowerExpression * cPtr_strictLowerExpression::
_cloneObject (void) const {
  cPtr_strictLowerExpression * _p = NULL ;
  macroMyNew (_p, cPtr_strictLowerExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@strictLowerExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_strictLowerExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_strictLowerExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_strictLowerExpressionList::
_addAssign_operation (const GGS_strictLowerExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_strictLowerExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_strictLowerExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_strictLowerExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionList GGS_strictLowerExpressionList::
_operator_concat (const GGS_strictLowerExpressionList & inOperand) const {
  GGS_strictLowerExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_strictLowerExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_strictLowerExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_strictLowerExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionList  GGS_strictLowerExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_strictLowerExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionList  GGS_strictLowerExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_strictLowerExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_strictLowerExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@strictLowerExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_strictLowerExpressionList::
_addModel (const GGS_strictLowerExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_strictLowerExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_strictLowerExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_strictLowerExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_strictLowerExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_strictLowerExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_strictLowerExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_strictLowerExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_strictLowerExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_strictLowerExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_strictLowerExpression'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_strictLowerExpression GGS_strictLowerExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpression result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictLowerExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictLowerExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_strictLowerExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpression::actualTypeName (void) const {
 return "strictLowerExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpression * GGS_strictLowerExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_strictLowerExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@leftShiftExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpression::
cPtr_leftShiftExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_leftShiftExpression * _p = dynamic_cast <const cPtr_leftShiftExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @leftShiftExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_leftShiftExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_leftShiftExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 27 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "leftShiftExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_leftShiftExpression * cPtr_leftShiftExpression::
_cloneObject (void) const {
  cPtr_leftShiftExpression * _p = NULL ;
  macroMyNew (_p, cPtr_leftShiftExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@leftShiftExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_leftShiftExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_leftShiftExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_leftShiftExpressionList::
_addAssign_operation (const GGS_leftShiftExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_leftShiftExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_leftShiftExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_leftShiftExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionList GGS_leftShiftExpressionList::
_operator_concat (const GGS_leftShiftExpressionList & inOperand) const {
  GGS_leftShiftExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_leftShiftExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_leftShiftExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_leftShiftExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionList  GGS_leftShiftExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_leftShiftExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionList  GGS_leftShiftExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_leftShiftExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_leftShiftExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@leftShiftExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_leftShiftExpressionList::
_addModel (const GGS_leftShiftExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_leftShiftExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_leftShiftExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_leftShiftExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_leftShiftExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_leftShiftExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_leftShiftExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_leftShiftExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_leftShiftExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_leftShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_leftShiftExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_leftShiftExpression GGS_leftShiftExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpression result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_leftShiftExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_leftShiftExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_leftShiftExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpression::actualTypeName (void) const {
 return "leftShiftExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpression * GGS_leftShiftExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_leftShiftExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@rightShiftExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpression::
cPtr_rightShiftExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_rightShiftExpression * _p = dynamic_cast <const cPtr_rightShiftExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @rightShiftExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_rightShiftExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_rightShiftExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 28 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "rightShiftExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_rightShiftExpression * cPtr_rightShiftExpression::
_cloneObject (void) const {
  cPtr_rightShiftExpression * _p = NULL ;
  macroMyNew (_p, cPtr_rightShiftExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@rightShiftExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_rightShiftExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_rightShiftExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_rightShiftExpressionList::
_addAssign_operation (const GGS_rightShiftExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_rightShiftExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_rightShiftExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_rightShiftExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionList GGS_rightShiftExpressionList::
_operator_concat (const GGS_rightShiftExpressionList & inOperand) const {
  GGS_rightShiftExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_rightShiftExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_rightShiftExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_rightShiftExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionList  GGS_rightShiftExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_rightShiftExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionList  GGS_rightShiftExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_rightShiftExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_rightShiftExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@rightShiftExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_rightShiftExpressionList::
_addModel (const GGS_rightShiftExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_rightShiftExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_rightShiftExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_rightShiftExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_rightShiftExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_rightShiftExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_rightShiftExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_rightShiftExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_rightShiftExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_rightShiftExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_rightShiftExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_rightShiftExpression GGS_rightShiftExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpression result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_rightShiftExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_rightShiftExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_rightShiftExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpression::actualTypeName (void) const {
 return "rightShiftExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpression * GGS_rightShiftExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_rightShiftExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@addExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpression::
cPtr_addExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_addExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_addExpression * _p = dynamic_cast <const cPtr_addExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @addExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_addExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_addExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 29 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "addExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_addExpression * cPtr_addExpression::
_cloneObject (void) const {
  cPtr_addExpression * _p = NULL ;
  macroMyNew (_p, cPtr_addExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@addExpressionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_addExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_addExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_addExpressionList::
_addAssign_operation (const GGS_addExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_addExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_addExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_addExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_addExpressionList GGS_addExpressionList::
_operator_concat (const GGS_addExpressionList & inOperand) const {
  GGS_addExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_addExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_addExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_addExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_addExpressionList  GGS_addExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_addExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionList  GGS_addExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_addExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_addExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@addExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_addExpressionList::
_addModel (const GGS_addExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_addExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_addExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_addExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_addExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_addExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_addExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_addExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_addExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_addExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_addExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_addExpression GGS_addExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addExpression result ;
  macroMyNew (result.mPointer, cPtr_addExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_addExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_addExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_addExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpression::actualTypeName (void) const {
 return "addExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpression * GGS_addExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_addExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@subExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpression::
cPtr_subExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_subExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_subExpression * _p = dynamic_cast <const cPtr_subExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @subExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_subExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_subExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 30 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "subExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_subExpression * cPtr_subExpression::
_cloneObject (void) const {
  cPtr_subExpression * _p = NULL ;
  macroMyNew (_p, cPtr_subExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@subExpressionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_subExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_subExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_subExpressionList::
_addAssign_operation (const GGS_subExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_subExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_subExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_subExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_subExpressionList GGS_subExpressionList::
_operator_concat (const GGS_subExpressionList & inOperand) const {
  GGS_subExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_subExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_subExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_subExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_subExpressionList  GGS_subExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_subExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionList  GGS_subExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_subExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_subExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@subExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_subExpressionList::
_addModel (const GGS_subExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_subExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_subExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_subExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_subExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_subExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_subExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_subExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_subExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_subExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_subExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_subExpression GGS_subExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_subExpression result ;
  macroMyNew (result.mPointer, cPtr_subExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_subExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_subExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_subExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpression::actualTypeName (void) const {
 return "subExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpression * GGS_subExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_subExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@multiplicationExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpression::
cPtr_multiplicationExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_multiplicationExpression * _p = dynamic_cast <const cPtr_multiplicationExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @multiplicationExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_multiplicationExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_multiplicationExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 31 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "multiplicationExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_multiplicationExpression * cPtr_multiplicationExpression::
_cloneObject (void) const {
  cPtr_multiplicationExpression * _p = NULL ;
  macroMyNew (_p, cPtr_multiplicationExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@multiplicationExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_multiplicationExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiplicationExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiplicationExpressionList::
_addAssign_operation (const GGS_multiplicationExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_multiplicationExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_multiplicationExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_multiplicationExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionList GGS_multiplicationExpressionList::
_operator_concat (const GGS_multiplicationExpressionList & inOperand) const {
  GGS_multiplicationExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_multiplicationExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiplicationExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiplicationExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionList  GGS_multiplicationExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_multiplicationExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionList  GGS_multiplicationExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_multiplicationExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiplicationExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@multiplicationExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_multiplicationExpressionList::
_addModel (const GGS_multiplicationExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_multiplicationExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_multiplicationExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_multiplicationExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_multiplicationExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_multiplicationExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_multiplicationExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_multiplicationExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_multiplicationExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_multiplicationExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_multiplicationExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_multiplicationExpression GGS_multiplicationExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpression result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_multiplicationExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_multiplicationExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_multiplicationExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpression::actualTypeName (void) const {
 return "multiplicationExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpression * GGS_multiplicationExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_multiplicationExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@divisionExpressionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpression::
cPtr_divisionExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_divisionExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_divisionExpression * _p = dynamic_cast <const cPtr_divisionExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @divisionExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_divisionExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_divisionExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 32 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "divisionExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_divisionExpression * cPtr_divisionExpression::
_cloneObject (void) const {
  cPtr_divisionExpression * _p = NULL ;
  macroMyNew (_p, cPtr_divisionExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@divisionExpressionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_divisionExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_divisionExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_divisionExpressionList::
_addAssign_operation (const GGS_divisionExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_divisionExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_divisionExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_divisionExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionList GGS_divisionExpressionList::
_operator_concat (const GGS_divisionExpressionList & inOperand) const {
  GGS_divisionExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_divisionExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_divisionExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_divisionExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionList  GGS_divisionExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_divisionExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionList  GGS_divisionExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_divisionExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_divisionExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@divisionExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_divisionExpressionList::
_addModel (const GGS_divisionExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_divisionExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_divisionExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_divisionExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_divisionExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_divisionExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_divisionExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_divisionExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_divisionExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_divisionExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_divisionExpression'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_divisionExpression GGS_divisionExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpression result ;
  macroMyNew (result.mPointer, cPtr_divisionExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_divisionExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_divisionExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_divisionExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpression::actualTypeName (void) const {
 return "divisionExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpression * GGS_divisionExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_divisionExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@moduloExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpression::
cPtr_moduloExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1,
                                const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_moduloExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_moduloExpression * _p = dynamic_cast <const cPtr_moduloExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mLeftExpression._operator_isEqual (_p->mLeftExpression).boolValue ()
         && mRightExpression._operator_isEqual (_p->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @moduloExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLeftExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRightExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_moduloExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_moduloExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 33 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "moduloExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_moduloExpression * cPtr_moduloExpression::
_cloneObject (void) const {
  cPtr_moduloExpression * _p = NULL ;
  macroMyNew (_p, cPtr_moduloExpression (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@moduloExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_moduloExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_moduloExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1,
                    const GGS_semanticExpression & argument_2) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_moduloExpressionList::
_addAssign_operation (const GGS_moduloExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_moduloExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_moduloExpression *) inElement.getPtr ())->mLeftExpression,
                                ((cPtr_moduloExpression *) inElement.getPtr ())->mRightExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionList GGS_moduloExpressionList::
_operator_concat (const GGS_moduloExpressionList & inOperand) const {
  GGS_moduloExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_moduloExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mLeftExpression ;
          GGS_semanticExpression  p_2 = p->mRightExpression ;
          result._internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_moduloExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1,
                     const GGS_semanticExpression & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_moduloExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mLeftExpression,
                                _p->mRightExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionList  GGS_moduloExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_moduloExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionList  GGS_moduloExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1,
                           const GGS_semanticExpression & argument_2
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_moduloExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_moduloExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@moduloExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_moduloExpressionList::
_addModel (const GGS_moduloExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_moduloExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_moduloExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_moduloExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_moduloExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_moduloExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_moduloExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_moduloExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_moduloExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_moduloExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mLeftExpression,
       _p->mRightExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_moduloExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_moduloExpression GGS_moduloExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1,
                 const GGS_semanticExpression & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpression result ;
  macroMyNew (result.mPointer, cPtr_moduloExpression (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_moduloExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_moduloExpression::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpression *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_moduloExpression::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpression *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpression::actualTypeName (void) const {
 return "moduloExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpression * GGS_moduloExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_moduloExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@unaryMinusExpressionList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpression::
cPtr_unaryMinusExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_unaryMinusExpression * _p = dynamic_cast <const cPtr_unaryMinusExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @unaryMinusExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_unaryMinusExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_unaryMinusExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 34 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "unaryMinusExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_unaryMinusExpression * cPtr_unaryMinusExpression::
_cloneObject (void) const {
  cPtr_unaryMinusExpression * _p = NULL ;
  macroMyNew (_p, cPtr_unaryMinusExpression (mOperatorLocation, mExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@unaryMinusExpressionList'                      *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_unaryMinusExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unaryMinusExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_unaryMinusExpressionList::
_addAssign_operation (const GGS_unaryMinusExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_unaryMinusExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_unaryMinusExpression *) inElement.getPtr ())->mExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionList GGS_unaryMinusExpressionList::
_operator_concat (const GGS_unaryMinusExpressionList & inOperand) const {
  GGS_unaryMinusExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_unaryMinusExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mExpression ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_unaryMinusExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_unaryMinusExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionList  GGS_unaryMinusExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unaryMinusExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionList  GGS_unaryMinusExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_unaryMinusExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_unaryMinusExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@unaryMinusExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_unaryMinusExpressionList::
_addModel (const GGS_unaryMinusExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_unaryMinusExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_unaryMinusExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_unaryMinusExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_unaryMinusExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_unaryMinusExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_unaryMinusExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_unaryMinusExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_unaryMinusExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_unaryMinusExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_unaryMinusExpression'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_unaryMinusExpression GGS_unaryMinusExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpression result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_unaryMinusExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_unaryMinusExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpression::actualTypeName (void) const {
 return "unaryMinusExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpression * GGS_unaryMinusExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_unaryMinusExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@notExpressionList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpression::
cPtr_notExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_notExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_notExpression * _p = dynamic_cast <const cPtr_notExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @notExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_notExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 35 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "notExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_notExpression * cPtr_notExpression::
_cloneObject (void) const {
  cPtr_notExpression * _p = NULL ;
  macroMyNew (_p, cPtr_notExpression (mOperatorLocation, mExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@notExpressionList'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_notExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_notExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_notExpressionList::
_addAssign_operation (const GGS_notExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_notExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_notExpression *) inElement.getPtr ())->mExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_notExpressionList GGS_notExpressionList::
_operator_concat (const GGS_notExpressionList & inOperand) const {
  GGS_notExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_notExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mExpression ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_notExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_notExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_notExpressionList  GGS_notExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_notExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionList  GGS_notExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_notExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_notExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@notExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_notExpressionList::
_addModel (const GGS_notExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_notExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_notExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_notExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_notExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_notExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_notExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_notExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_notExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_notExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_notExpression'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_notExpression GGS_notExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_notExpression result ;
  macroMyNew (result.mPointer, cPtr_notExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_notExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpression::actualTypeName (void) const {
 return "notExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpression * GGS_notExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_notExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@negateExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_negateExpression::
cPtr_negateExpression (const GGS_location & argument_0,
                                const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_negateExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_negateExpression * _p = dynamic_cast <const cPtr_negateExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperatorLocation._operator_isEqual (_p->mOperatorLocation).boolValue ()
         && mExpression._operator_isEqual (_p->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_negateExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @negateExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOperatorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_negateExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_negateExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 36 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "negateExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_negateExpression * cPtr_negateExpression::
_cloneObject (void) const {
  cPtr_negateExpression * _p = NULL ;
  macroMyNew (_p, cPtr_negateExpression (mOperatorLocation, mExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@negateExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_negateExpressionList::
_internalAppendValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_negateExpressionList::
_internalPrependValues (const GGS_location & argument_0,
                    const GGS_semanticExpression & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_negateExpressionList::
_addAssign_operation (const GGS_negateExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_negateExpression *) inElement.getPtr ())->mOperatorLocation,
                                ((cPtr_negateExpression *) inElement.getPtr ())->mExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_negateExpressionList GGS_negateExpressionList::
_operator_concat (const GGS_negateExpressionList & inOperand) const {
  GGS_negateExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_negateExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mOperatorLocation ;
          GGS_semanticExpression  p_1 = p->mExpression ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_negateExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_semanticExpression & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_negateExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mOperatorLocation,
                                _p->mExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_negateExpressionList  GGS_negateExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_negateExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionList  GGS_negateExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_location & argument_0,
                           const GGS_semanticExpression & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_negateExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_negateExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@negateExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_negateExpressionList::
_addModel (const GGS_negateExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_negateExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_negateExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_negateExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_negateExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_negateExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_negateExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_negateExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_negateExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_negateExpression::constructor_new (_inLexique,
       _p->mOperatorLocation,
       _p->mExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_negateExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_negateExpression GGS_negateExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpression & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_negateExpression result ;
  macroMyNew (result.mPointer, cPtr_negateExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_negateExpression::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpression *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_negateExpression::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpression *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_negateExpression::actualTypeName (void) const {
 return "negateExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_negateExpression * GGS_negateExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_negateExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@varInExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpression::
cPtr_varInExpression (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mVarName (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_varInExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_varInExpression * _p = dynamic_cast <const cPtr_varInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVarName._operator_isEqual (_p->mVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @varInExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVarName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_varInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_varInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 37 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "varInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_varInExpression * cPtr_varInExpression::
_cloneObject (void) const {
  cPtr_varInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_varInExpression (mVarName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@varInExpressionList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_varInExpressionList::
_internalAppendValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varInExpressionList::
_internalPrependValues (const GGS_lstring & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_varInExpressionList::
_addAssign_operation (const GGS_varInExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_varInExpression *) inElement.getPtr ())->mVarName) ;
  }
}

//---------------------------------------------------------------------------*

GGS_varInExpressionList GGS_varInExpressionList::
_operator_concat (const GGS_varInExpressionList & inOperand) const {
  GGS_varInExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_varInExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mVarName ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_varInExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_varInExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVarName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_varInExpressionList  GGS_varInExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varInExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionList  GGS_varInExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_varInExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_varInExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@varInExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_varInExpressionList::
_addModel (const GGS_varInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_varInExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_varInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_varInExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_varInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_varInExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_varInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_varInExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_varInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_varInExpression::constructor_new (_inLexique,
       _p->mVarName) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_varInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_varInExpression GGS_varInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpression result ;
  macroMyNew (result.mPointer, cPtr_varInExpression (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_varInExpression::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpression *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpression::actualTypeName (void) const {
 return "varInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpression * GGS_varInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_varInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@descriptionInExpressionList'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_descriptionInExpression::
cPtr_descriptionInExpression (const GGS_semanticExpression & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mReceiverExpression (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_descriptionInExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_descriptionInExpression * _p = dynamic_cast <const cPtr_descriptionInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mLocation._operator_isEqual (_p->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_descriptionInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @descriptionInExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_descriptionInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_descriptionInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_descriptionInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 38 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_descriptionInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "descriptionInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_descriptionInExpression * cPtr_descriptionInExpression::
_cloneObject (void) const {
  cPtr_descriptionInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_descriptionInExpression (mReceiverExpression, mLocation COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@descriptionInExpressionList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_descriptionInExpressionList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_descriptionInExpressionList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_location & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_descriptionInExpressionList::
_addAssign_operation (const GGS_descriptionInExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_descriptionInExpression *) inElement.getPtr ())->mReceiverExpression,
                                ((cPtr_descriptionInExpression *) inElement.getPtr ())->mLocation) ;
  }
}

//---------------------------------------------------------------------------*

GGS_descriptionInExpressionList GGS_descriptionInExpressionList::
_operator_concat (const GGS_descriptionInExpressionList & inOperand) const {
  GGS_descriptionInExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_descriptionInExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mReceiverExpression ;
          GGS_location  p_1 = p->mLocation ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_descriptionInExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_descriptionInExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_descriptionInExpressionList  GGS_descriptionInExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_descriptionInExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_descriptionInExpressionList  GGS_descriptionInExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpression & argument_0,
                           const GGS_location & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_descriptionInExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_descriptionInExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@descriptionInExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_descriptionInExpressionList::
_addModel (const GGS_descriptionInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_descriptionInExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_descriptionInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_descriptionInExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_descriptionInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_descriptionInExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_descriptionInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_descriptionInExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_descriptionInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_descriptionInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mLocation) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_descriptionInExpression'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_descriptionInExpression GGS_descriptionInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_descriptionInExpression result ;
  macroMyNew (result.mPointer, cPtr_descriptionInExpression (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_descriptionInExpression::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_descriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_descriptionInExpression *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_descriptionInExpression::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_descriptionInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_descriptionInExpression *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_descriptionInExpression::actualTypeName (void) const {
 return "descriptionInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_descriptionInExpression * GGS_descriptionInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_descriptionInExpression *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@castInExpressionList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInExpression::
cPtr_castInExpression (const GGS_semanticExpression & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) :
cPtr_semanticExpression (THERE),
mReceiverExpression (argument_0),
mUseKindOfClass (argument_1),
mTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_castInExpression::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_castInExpression * _p = dynamic_cast <const cPtr_castInExpression *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mReceiverExpression._operator_isEqual (_p->mReceiverExpression).boolValue ()
         && mUseKindOfClass._operator_isEqual (_p->mUseKindOfClass).boolValue ()
         && mTypeName._operator_isEqual (_p->mTypeName).boolValue ()
         && mErrorLocationExpression._operator_isEqual (_p->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInExpression::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @castInExpression" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReceiverExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocationExpression.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInExpression::_metamodelComponentIndex (const sint32 inLevel) const {
  sint32 result = gMetamodelManager.mMetamodelComponentIndex ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentIndex (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpression::_metamodelComponentName (const sint32 inLevel) const {
  const char * result = gMetamodelManager.mMetamodelComponentName ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelComponentName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

sint32 cPtr_castInExpression::_metamodelClassID (const sint32 inLevel) const {
  sint32 result = 39 ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassID (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpression::_metamodelClassName (const sint32 inLevel) const {
  const char * result = "castInExpression" ;
  if (inLevel > 0) {
    result = cPtr_semanticExpression::_metamodelClassName (inLevel - 1) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

cPtr_castInExpression * cPtr_castInExpression::
_cloneObject (void) const {
  cPtr_castInExpression * _p = NULL ;
  macroMyNew (_p, cPtr_castInExpression (mReceiverExpression, mUseKindOfClass, mTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@castInExpressionList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_castInExpressionList::
_internalAppendValues (const GGS_semanticExpression & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_semanticExpression & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInExpressionList::
_internalPrependValues (const GGS_semanticExpression & argument_0,
                    const GGS_bool& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_semanticExpression & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInExpressionList::
_addAssign_operation (const GGS_castInExpression & inElement) {
  if (_isBuilt () && inElement._isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (((cPtr_castInExpression *) inElement.getPtr ())->mReceiverExpression,
                                ((cPtr_castInExpression *) inElement.getPtr ())->mUseKindOfClass,
                                ((cPtr_castInExpression *) inElement.getPtr ())->mTypeName,
                                ((cPtr_castInExpression *) inElement.getPtr ())->mErrorLocationExpression) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInExpressionList GGS_castInExpressionList::
_operator_concat (const GGS_castInExpressionList & inOperand) const {
  GGS_castInExpressionList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_castInExpression * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpression  p_0 = p->mReceiverExpression ;
          GGS_bool p_1 = p->mUseKindOfClass ;
          GGS_lstring  p_2 = p->mTypeName ;
          GGS_semanticExpression  p_3 = p->mErrorLocationExpression ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInExpressionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpression & argument_0,
                     const GGS_bool& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_semanticExpression & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInExpressionList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mReceiverExpression,
                                _p->mUseKindOfClass,
                                _p->mTypeName,
                                _p->mErrorLocationExpression) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInExpressionList  GGS_castInExpressionList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_castInExpressionList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionList  GGS_castInExpressionList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_semanticExpression & argument_0,
                           const GGS_bool& argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_semanticExpression & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_castInExpressionList result ;
  result._alloc () ;
  result._internalAppendValues (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInExpressionList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@castInExpressionList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_castInExpressionList::
_addModel (const GGS_castInExpression & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

/* void GGS_castInExpressionList::
method_first (C_Compiler & _inLexique,
              GGS_castInExpression & outElement
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_castInExpressionList::
method_last (C_Compiler & _inLexique,
             GGS_castInExpression & outElement
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_castInExpressionList::
modifier_popFirst (C_Compiler & _inLexique,
                   GGS_castInExpression & outElement
                   COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*

/* void GGS_castInExpressionList::
modifier_popLast (C_Compiler & _inLexique,
                  GGS_castInExpression & outElement
                  COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    outElement = GGS_castInExpression::constructor_new (_inLexique,
       _p->mReceiverExpression,
       _p->mUseKindOfClass,
       _p->mTypeName,
       _p->mErrorLocationExpression) ;
  }else{
    outElement._drop_operation () ;
  }
} */

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_castInExpression'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_castInExpression GGS_castInExpression::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpression & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpression & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInExpression result ;
  macroMyNew (result.mPointer, cPtr_castInExpression (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInExpression::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInExpression::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInExpression::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpression  GGS_castInExpression::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpression   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpression *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpression *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInExpression::actualTypeName (void) const {
 return "castInExpression" ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInExpression * GGS_castInExpression::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return (cPtr_castInExpression *) mPointer ;
  }
#endif

