//-----------------------------------------------------------------------------*
//                                                                             *
//                         File 'syntaxSignature.cpp'                          *
//                         Generated by version 2.6.0                          *
//                       july 14th, 2014, at 13h34'34"                         *
//                                                                             *
//-----------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "syntaxSignature.h"
#include "galgas2/C_Compiler.h"
#include "galgas2/C_galgas_io.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "utilities/C_PrologueEpilogue.h"

//-----------------------------------------------------------------------------*

#include "optionLL1grammar.h"
#include "templateGrammar.h"
#include "galgas_cli_options.h"
#include "grammarLL1grammar.h"
#include "syntaxSLRgrammar.h"
#include "lexiqueLL1grammar.h"
#include "semanticsSLRgrammar.h"


//-----------------------------------------------------------------------------*
//                                                                             *
//                 Function 'syntaxSignatureOfInstructionList'                 *
//                                                                             *
//-----------------------------------------------------------------------------*

GALGAS_semanticInstructionListForGeneration function_syntaxSignatureOfInstructionList (const GALGAS_string & constinArgument_inPosfix,
                                                                                       const GALGAS_semanticInstructionListForGeneration & constinArgument_inInstructionList,
                                                                                       C_Compiler * inCompiler
                                                                                       COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_semanticInstructionListForGeneration result_outResult ; // Returned variable
  result_outResult = GALGAS_semanticInstructionListForGeneration::constructor_emptyList (SOURCE_FILE ("syntaxSignature.gSemantics", 41)) ;
  cEnumerator_semanticInstructionListForGeneration enumerator_2367 (constinArgument_inInstructionList, kEnumeration_up) ;
  while (enumerator_2367.hasCurrentObject ()) {
    callCategoryMethod_appendSyntaxSignature ((const cPtr_semanticInstructionForGeneration *) enumerator_2367.current_mInstruction (HERE).ptr (), constinArgument_inPosfix, result_outResult, inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 43)) ;
    enumerator_2367.gotoNextObject () ;
  }
//---
  return result_outResult ;
}


//-----------------------------------------------------------------------------*
//  Function introspection                                                     *
//-----------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_syntaxSignatureOfInstructionList [3] = {
  & kTypeDescriptor_GALGAS_string,
  & kTypeDescriptor_GALGAS_semanticInstructionListForGeneration,
  NULL
} ;

//-----------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_syntaxSignatureOfInstructionList (C_Compiler * inCompiler,
                                                                                 const cObjectArray & inEffectiveParameterArray,
                                                                                 const GALGAS_location & /* §§ inErrorLocation */
                                                                                 COMMA_LOCATION_ARGS) {
  const GALGAS_string operand0 = GALGAS_string::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                               inCompiler
                                                               COMMA_THERE) ;
  const GALGAS_semanticInstructionListForGeneration operand1 = GALGAS_semanticInstructionListForGeneration::extractObject (inEffectiveParameterArray.objectAtIndex (1 COMMA_HERE),
                                                                                                                           inCompiler
                                                                                                                           COMMA_THERE) ;
  return function_syntaxSignatureOfInstructionList (operand0,
                                                    operand1,
                                                    inCompiler
                                                    COMMA_THERE).reader_object (THERE) ;
}

//-----------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_syntaxSignatureOfInstructionList ("syntaxSignatureOfInstructionList",
                                                                                  functionWithGenericHeader_syntaxSignatureOfInstructionList,
                                                                                  & kTypeDescriptor_GALGAS_semanticInstructionListForGeneration,
                                                                                  2,
                                                                                  functionArgs_syntaxSignatureOfInstructionList) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//                      Function 'compareSyntaxSignature'                      *
//                                                                             *
//-----------------------------------------------------------------------------*

GALGAS_bool function_compareSyntaxSignature (const GALGAS_semanticInstructionListForGeneration & constinArgument_inReferenceSignature,
                                             const GALGAS_semanticInstructionListForGeneration & constinArgument_inTestedSignature,
                                             const GALGAS_location & constinArgument_inErrorLocation,
                                             C_Compiler * inCompiler
                                             COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bool result_outOk ; // Returned variable
  result_outOk = GALGAS_bool (true) ;
  cEnumerator_semanticInstructionListForGeneration enumerator_7543 (constinArgument_inReferenceSignature, kEnumeration_up) ;
  cEnumerator_semanticInstructionListForGeneration enumerator_7569 (constinArgument_inTestedSignature, kEnumeration_up) ;
  bool bool_0 = result_outOk.isValidAndTrue () ;
  if (enumerator_7543.hasCurrentObject () && enumerator_7569.hasCurrentObject () && bool_0) {
    while (enumerator_7543.hasCurrentObject () && enumerator_7569.hasCurrentObject () && bool_0) {
      result_outOk = callCategoryReader_compareSyntaxInstruction ((const cPtr_semanticInstructionForGeneration *) enumerator_7543.current_mInstruction (HERE).ptr (), enumerator_7569.current_mInstruction (HERE), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 177)) ;
      enumerator_7543.gotoNextObject () ;
      enumerator_7569.gotoNextObject () ;
      if (enumerator_7543.hasCurrentObject () && enumerator_7569.hasCurrentObject ()) {
        bool_0 = result_outOk.isValidAndTrue () ;
      }
    }
  }
  const enumGalgasBool test_1 = result_outOk.operator_and (GALGAS_bool (kIsStrictInf, constinArgument_inReferenceSignature.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 179)).objectCompare (constinArgument_inTestedSignature.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 179)))) COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 179)).boolEnum () ;
  if (kBoolTrue == test_1) {
    GALGAS_semanticInstructionForGeneration var_instruction = constinArgument_inTestedSignature.reader_mInstructionAtIndex (constinArgument_inReferenceSignature.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 180)), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 180)) ;
    if (var_instruction.isValid ()) {
      if (NULL != dynamic_cast <const cPtr_syntaxInstructionForGeneration *> (var_instruction.ptr ())) {
        GALGAS_syntaxInstructionForGeneration cast_7960_si ((cPtr_syntaxInstructionForGeneration *) var_instruction.ptr ()) ;
        inCompiler->emitSemanticError (cast_7960_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 183)), GALGAS_string ("syntax signature error, exceeding instruction; this branch has more syntax instructions than reference branch")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 183)) ;
      }else{
        inCompiler->emitSemanticError (constinArgument_inErrorLocation, GALGAS_string ("internal error")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 187)) ;
      }
    }
  }else if (kBoolFalse == test_1) {
    const enumGalgasBool test_2 = result_outOk.operator_and (GALGAS_bool (kIsStrictSup, constinArgument_inReferenceSignature.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 189)).objectCompare (constinArgument_inTestedSignature.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 189)))) COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 189)).boolEnum () ;
    if (kBoolTrue == test_2) {
      inCompiler->emitSemanticError (constinArgument_inErrorLocation, GALGAS_string ("syntax signature error, missing instruction; this branch has less syntax instructions than reference branch")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 190)) ;
      GALGAS_semanticInstructionForGeneration var_instruction = constinArgument_inReferenceSignature.reader_mInstructionAtIndex (constinArgument_inTestedSignature.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 193)), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 193)) ;
      if (var_instruction.isValid ()) {
        if (NULL != dynamic_cast <const cPtr_syntaxInstructionForGeneration *> (var_instruction.ptr ())) {
          GALGAS_syntaxInstructionForGeneration cast_8623_si ((cPtr_syntaxInstructionForGeneration *) var_instruction.ptr ()) ;
          inCompiler->emitSemanticError (cast_8623_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 196)), GALGAS_string ("this is the syntax instruction in reference branch that corresponds to the first missing instruction")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 196)) ;
        }else{
          inCompiler->emitSemanticError (constinArgument_inErrorLocation, GALGAS_string ("internal error")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 200)) ;
        }
      }
    }
  }
//---
  return result_outOk ;
}


//-----------------------------------------------------------------------------*
//  Function introspection                                                     *
//-----------------------------------------------------------------------------*

static const C_galgas_type_descriptor * functionArgs_compareSyntaxSignature [4] = {
  & kTypeDescriptor_GALGAS_semanticInstructionListForGeneration,
  & kTypeDescriptor_GALGAS_semanticInstructionListForGeneration,
  & kTypeDescriptor_GALGAS_location,
  NULL
} ;

//-----------------------------------------------------------------------------*

static GALGAS_object functionWithGenericHeader_compareSyntaxSignature (C_Compiler * inCompiler,
                                                                       const cObjectArray & inEffectiveParameterArray,
                                                                       const GALGAS_location & /* §§ inErrorLocation */
                                                                       COMMA_LOCATION_ARGS) {
  const GALGAS_semanticInstructionListForGeneration operand0 = GALGAS_semanticInstructionListForGeneration::extractObject (inEffectiveParameterArray.objectAtIndex (0 COMMA_HERE),
                                                                                                                           inCompiler
                                                                                                                           COMMA_THERE) ;
  const GALGAS_semanticInstructionListForGeneration operand1 = GALGAS_semanticInstructionListForGeneration::extractObject (inEffectiveParameterArray.objectAtIndex (1 COMMA_HERE),
                                                                                                                           inCompiler
                                                                                                                           COMMA_THERE) ;
  const GALGAS_location operand2 = GALGAS_location::extractObject (inEffectiveParameterArray.objectAtIndex (2 COMMA_HERE),
                                                                   inCompiler
                                                                   COMMA_THERE) ;
  return function_compareSyntaxSignature (operand0,
                                          operand1,
                                          operand2,
                                          inCompiler
                                          COMMA_THERE).reader_object (THERE) ;
}

//-----------------------------------------------------------------------------*

C_galgas_function_descriptor functionDescriptor_compareSyntaxSignature ("compareSyntaxSignature",
                                                                        functionWithGenericHeader_compareSyntaxSignature,
                                                                        & kTypeDescriptor_GALGAS_bool,
                                                                        3,
                                                                        functionArgs_compareSyntaxSignature) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//  Category method '@semanticInstructionForGeneration appendSyntaxSignature'  *
//                                                                             *
//-----------------------------------------------------------------------------*



//-----------------------------------------------------------------------------*

static TC_UniqueArray <categoryMethodSignature_semanticInstructionForGeneration_appendSyntaxSignature> gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature ;

//-----------------------------------------------------------------------------*

void enterCategoryMethod_appendSyntaxSignature (const int32_t inClassIndex,
                                                categoryMethodSignature_semanticInstructionForGeneration_appendSyntaxSignature inMethod) {
  gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature.forceObjectAtIndex (inClassIndex, inMethod, NULL COMMA_HERE) ;
}

//-----------------------------------------------------------------------------*

void callCategoryMethod_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                               const GALGAS_string constin_inPosfix,
                                               GALGAS_semanticInstructionListForGeneration & io_ioInstructionListForGeneration,
                                               C_Compiler * inCompiler
                                               COMMA_LOCATION_ARGS) {
  if (NULL != inObject) {
    macroValidSharedObject (inObject, cPtr_semanticInstructionForGeneration) ;
    const C_galgas_type_descriptor * info = inObject->classDescriptor () ;
    const int32_t classIndex = info->mSlotID ;
    categoryMethodSignature_semanticInstructionForGeneration_appendSyntaxSignature f = NULL ;
    if (classIndex < gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature.count ()) {
      f = gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature (classIndex COMMA_HERE) ;
    }
    if (NULL == f) {
       const C_galgas_type_descriptor * p = info->mSuperclassDescriptor ;
       while ((NULL == f) && (NULL != p)) {
         if (p->mSlotID < gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature.count ()) {
           f = gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature (p->mSlotID COMMA_HERE) ;
         }
         p = p->mSuperclassDescriptor ;
       }
       gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature.forceObjectAtIndex (classIndex, f, NULL COMMA_HERE) ;
    }
    if (NULL == f) {
      fatalError ("FATAL CATEGORY METHOD CALL ERROR", __FILE__, __LINE__) ;
    }else{
      f (inObject, constin_inPosfix, io_ioInstructionListForGeneration, inCompiler COMMA_THERE) ;
    }
  }
}

//-----------------------------------------------------------------------------*

static void categoryMethod_semanticInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * /* inObject */,
                                                                                   const GALGAS_string /* constinArgument_inPosfix */,
                                                                                   GALGAS_semanticInstructionListForGeneration & /* ioArgument_ioInstructionListForGeneration */,
                                                                                   C_Compiler * /* inCompiler */
                                                                                   COMMA_UNUSED_LOCATION_ARGS) {
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_semanticInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_semanticInstructionForGeneration.mSlotID,
                                             categoryMethod_semanticInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

static void freeCategoryMethod_semanticInstructionForGeneration_appendSyntaxSignature (void) {
  gCategoryMethodTable_semanticInstructionForGeneration_appendSyntaxSignature.free () ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_semanticInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_semanticInstructionForGeneration_appendSyntaxSignature,
                                                                                   freeCategoryMethod_semanticInstructionForGeneration_appendSyntaxSignature) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@nonterminalInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_nonterminalInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                      const GALGAS_string constinArgument_inPosfix,
                                                                                      GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                      C_Compiler * /* inCompiler */
                                                                                      COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_nonterminalInstructionForGeneration * object = (const cPtr_nonterminalInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_nonterminalInstructionForGeneration) ;
  ioArgument_ioInstructionListForGeneration.addAssign_operation (GALGAS_nonterminalInstructionForGeneration::constructor_new (object->mAttribute_mInstructionLocation, object->mAttribute_mNonterminalName, constinArgument_inPosfix, GALGAS_actualParameterListForGeneration::constructor_emptyList (SOURCE_FILE ("syntaxSignature.gSemantics", 57)), GALGAS_grammarInstructionSyntaxDirectedTranslationResultNone::constructor_new (SOURCE_FILE ("syntaxSignature.gSemantics", 58))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 53))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 53)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_nonterminalInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_nonterminalInstructionForGeneration.mSlotID,
                                             categoryMethod_nonterminalInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_nonterminalInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_nonterminalInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@terminalCheckInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_terminalCheckInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                        const GALGAS_string /* constinArgument_inPosfix */,
                                                                                        GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                        C_Compiler * /* inCompiler */
                                                                                        COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_terminalCheckInstructionForGeneration * object = (const cPtr_terminalCheckInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_terminalCheckInstructionForGeneration) ;
  ioArgument_ioInstructionListForGeneration.addAssign_operation (GALGAS_terminalCheckInstructionForGeneration::constructor_new (object->mAttribute_mInstructionLocation, object->mAttribute_mTerminalName, object->mAttribute_mLexiqueIdentifier, GALGAS_terminalCheckAssignementList::constructor_emptyList (SOURCE_FILE ("syntaxSignature.gSemantics", 72)), object->mAttribute_mIndexingKeyList, GALGAS_grammarInstructionSyntaxDirectedTranslationResultNone::constructor_new (SOURCE_FILE ("syntaxSignature.gSemantics", 74)), GALGAS_grammarInstructionSyntaxDirectedTranslationResultNone::constructor_new (SOURCE_FILE ("syntaxSignature.gSemantics", 75))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 68))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 68)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_terminalCheckInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_terminalCheckInstructionForGeneration.mSlotID,
                                             categoryMethod_terminalCheckInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_terminalCheckInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_terminalCheckInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@repeatInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_repeatInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                 const GALGAS_string constinArgument_inPosfix,
                                                                                 GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                 C_Compiler * inCompiler
                                                                                 COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_repeatInstructionForGeneration * object = (const cPtr_repeatInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_repeatInstructionForGeneration) ;
  GALGAS_semanticInstructionListForGeneration var_repeated_5F_instructionList = function_syntaxSignatureOfInstructionList (constinArgument_inPosfix, object->mAttribute_m_5F_repeated_5F_instructionList, inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 85)) ;
  GALGAS_listOfSemanticInstructionListForGeneration var_listOfSemanticInstructionListForGeneration = GALGAS_listOfSemanticInstructionListForGeneration::constructor_emptyList (SOURCE_FILE ("syntaxSignature.gSemantics", 86)) ;
  cEnumerator_listOfSemanticInstructionListForGeneration enumerator_4176 (object->mAttribute_mListOfSemanticInstructionListForGeneration, kEnumeration_up) ;
  while (enumerator_4176.hasCurrentObject ()) {
    var_listOfSemanticInstructionListForGeneration.addAssign_operation (function_syntaxSignatureOfInstructionList (constinArgument_inPosfix, enumerator_4176.current_mInstructionList (HERE), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 89)), enumerator_4176.current_mEndOfInstructionList (HERE)  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 88)) ;
    enumerator_4176.gotoNextObject () ;
  }
  ioArgument_ioInstructionListForGeneration.addAssign_operation (GALGAS_repeatInstructionForGeneration::constructor_new (object->mAttribute_mInstructionLocation, object->mAttribute_mSyntaxComponentName, object->mAttribute_mChoiceIndex, var_repeated_5F_instructionList, object->mAttribute_mEndOfRepeatedInstructions, var_listOfSemanticInstructionListForGeneration  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 94))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 94)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_repeatInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_repeatInstructionForGeneration.mSlotID,
                                             categoryMethod_repeatInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_repeatInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_repeatInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@selectInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_selectInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                 const GALGAS_string constinArgument_inPosfix,
                                                                                 GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                 C_Compiler * inCompiler
                                                                                 COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_selectInstructionForGeneration * object = (const cPtr_selectInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_selectInstructionForGeneration) ;
  GALGAS_listOfSemanticInstructionListForGeneration var_listOfSemanticInstructionListForGeneration = GALGAS_listOfSemanticInstructionListForGeneration::constructor_emptyList (SOURCE_FILE ("syntaxSignature.gSemantics", 110)) ;
  cEnumerator_listOfSemanticInstructionListForGeneration enumerator_5031 (object->mAttribute_mListOfSemanticInstructionListForGeneration, kEnumeration_up) ;
  while (enumerator_5031.hasCurrentObject ()) {
    var_listOfSemanticInstructionListForGeneration.addAssign_operation (function_syntaxSignatureOfInstructionList (constinArgument_inPosfix, enumerator_5031.current_mInstructionList (HERE), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 113)), enumerator_5031.current_mEndOfInstructionList (HERE)  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 112)) ;
    enumerator_5031.gotoNextObject () ;
  }
  ioArgument_ioInstructionListForGeneration.addAssign_operation (GALGAS_selectInstructionForGeneration::constructor_new (object->mAttribute_mInstructionLocation, object->mAttribute_mSyntaxComponentName, object->mAttribute_mChoiceIndex, var_listOfSemanticInstructionListForGeneration  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 117))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 117)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_selectInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_selectInstructionForGeneration.mSlotID,
                                             categoryMethod_selectInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_selectInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_selectInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@parseRewindInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_parseRewindInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                      const GALGAS_string constinArgument_inPosfix,
                                                                                      GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                      C_Compiler * inCompiler
                                                                                      COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_parseRewindInstructionForGeneration * object = (const cPtr_parseRewindInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_parseRewindInstructionForGeneration) ;
  GALGAS_semanticInstructionListForGeneration var_instructionList ;
  GALGAS_location joker_5796_0 ; // Joker input parameter
  object->mAttribute_mListOfSemanticInstructionListForGeneration.method_first (var_instructionList, joker_5796_0, inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 132)) ;
  ioArgument_ioInstructionListForGeneration.dotAssign_operation (function_syntaxSignatureOfInstructionList (constinArgument_inPosfix, var_instructionList, inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 133))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 133)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_parseRewindInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_parseRewindInstructionForGeneration.mSlotID,
                                             categoryMethod_parseRewindInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_parseRewindInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_parseRewindInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@parseLoopInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_parseLoopInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                    const GALGAS_string constinArgument_inPosfix,
                                                                                    GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                    C_Compiler * inCompiler
                                                                                    COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_parseLoopInstructionForGeneration * object = (const cPtr_parseLoopInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_parseLoopInstructionForGeneration) ;
  ioArgument_ioInstructionListForGeneration.dotAssign_operation (function_syntaxSignatureOfInstructionList (constinArgument_inPosfix, object->mAttribute_mInstructionList, inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 142))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 142)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_parseLoopInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_parseLoopInstructionForGeneration.mSlotID,
                                             categoryMethod_parseLoopInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_parseLoopInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_parseLoopInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category method '@parseWhenInstructionForGeneration appendSyntaxSignature'*
//                                                                             *
//-----------------------------------------------------------------------------*

static void categoryMethod_parseWhenInstructionForGeneration_appendSyntaxSignature (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                    const GALGAS_string constinArgument_inPosfix,
                                                                                    GALGAS_semanticInstructionListForGeneration & ioArgument_ioInstructionListForGeneration,
                                                                                    C_Compiler * inCompiler
                                                                                    COMMA_UNUSED_LOCATION_ARGS) {
  const cPtr_parseWhenInstructionForGeneration * object = (const cPtr_parseWhenInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_parseWhenInstructionForGeneration) ;
  ioArgument_ioInstructionListForGeneration.dotAssign_operation (function_syntaxSignatureOfInstructionList (constinArgument_inPosfix, object->mAttribute_mInstructionList, inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 151))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 151)) ;
}
//-----------------------------------------------------------------------------*

static void defineCategoryMethod_parseWhenInstructionForGeneration_appendSyntaxSignature (void) {
  enterCategoryMethod_appendSyntaxSignature (kTypeDescriptor_GALGAS_parseWhenInstructionForGeneration.mSlotID,
                                             categoryMethod_parseWhenInstructionForGeneration_appendSyntaxSignature) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gMethod_parseWhenInstructionForGeneration_appendSyntaxSignature (defineCategoryMethod_parseWhenInstructionForGeneration_appendSyntaxSignature, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Category reader '@semanticInstructionForGeneration compareSyntaxInstruction' *
//                                                                             *
//-----------------------------------------------------------------------------*



//-----------------------------------------------------------------------------*

static TC_UniqueArray <categoryReaderSignature_semanticInstructionForGeneration_compareSyntaxInstruction> gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction ;

//-----------------------------------------------------------------------------*

void enterCategoryReader_compareSyntaxInstruction (const int32_t inClassIndex,
                                                   categoryReaderSignature_semanticInstructionForGeneration_compareSyntaxInstruction inReader) {
  gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction.forceObjectAtIndex (inClassIndex, inReader, NULL COMMA_HERE) ;
}

//-----------------------------------------------------------------------------*

GALGAS_bool callCategoryReader_compareSyntaxInstruction (const cPtr_semanticInstructionForGeneration * inObject,
                                                         const GALGAS_semanticInstructionForGeneration & in_inTestedInstruction,
                                                         C_Compiler * inCompiler
                                                         COMMA_LOCATION_ARGS) {
  GALGAS_bool result ;
//--- Find Reader
  if (NULL != inObject) {
    macroValidSharedObject (inObject, cPtr_semanticInstructionForGeneration) ;
    const C_galgas_type_descriptor * info = inObject->classDescriptor () ;
    const int32_t classIndex = info->mSlotID ;
    categoryReaderSignature_semanticInstructionForGeneration_compareSyntaxInstruction f = NULL ;
    if (classIndex < gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction.count ()) {
      f = gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction (classIndex COMMA_HERE) ;
    }
    if (NULL == f) {
       const C_galgas_type_descriptor * p = info->mSuperclassDescriptor ;
       while ((NULL == f) && (NULL != p)) {
         if (p->mSlotID < gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction.count ()) {
           f = gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction (p->mSlotID COMMA_HERE) ;
         }
         p = p->mSuperclassDescriptor ;
       }
       gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction.forceObjectAtIndex (classIndex, f, NULL COMMA_HERE) ;
    }
    if (NULL == f) {
      fatalError ("FATAL CATEGORY READER CALL ERROR", __FILE__, __LINE__) ;
    }else{
      result = f (inObject, in_inTestedInstruction, inCompiler COMMA_THERE) ;
    }
  }
  return result ;
}

//-----------------------------------------------------------------------------*

static GALGAS_bool categoryReader_semanticInstructionForGeneration_compareSyntaxInstruction (const cPtr_semanticInstructionForGeneration * /* inObject */,
                                                                                             const GALGAS_semanticInstructionForGeneration & /* constinArgument_inTestedInstruction */,
                                                                                             C_Compiler * /* inCompiler */
                                                                                             COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bool result_outOk ; // Returned variable
  result_outOk = GALGAS_bool (true) ;
//---
  return result_outOk ;
}


//-----------------------------------------------------------------------------*

static void defineCategoryReader_semanticInstructionForGeneration_compareSyntaxInstruction (void) {
  enterCategoryReader_compareSyntaxInstruction (kTypeDescriptor_GALGAS_semanticInstructionForGeneration.mSlotID,
                                                categoryReader_semanticInstructionForGeneration_compareSyntaxInstruction) ;
}

//-----------------------------------------------------------------------------*

static void freeCategoryReader_semanticInstructionForGeneration_compareSyntaxInstruction (void) {
  gCategoryReaderTable_semanticInstructionForGeneration_compareSyntaxInstruction.free () ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gReader_semanticInstructionForGeneration_compareSyntaxInstruction (defineCategoryReader_semanticInstructionForGeneration_compareSyntaxInstruction,
                                                                                      freeCategoryReader_semanticInstructionForGeneration_compareSyntaxInstruction) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category reader '@terminalCheckInstructionForGeneration compareSyntaxInstruction'*
//                                                                             *
//-----------------------------------------------------------------------------*

static GALGAS_bool categoryReader_terminalCheckInstructionForGeneration_compareSyntaxInstruction (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                                  const GALGAS_semanticInstructionForGeneration & constinArgument_inTestedInstruction,
                                                                                                  C_Compiler * inCompiler
                                                                                                  COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bool result_outOk ; // Returned variable
  const cPtr_terminalCheckInstructionForGeneration * object = (const cPtr_terminalCheckInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_terminalCheckInstructionForGeneration) ;
  if (constinArgument_inTestedInstruction.isValid ()) {
    if (NULL != dynamic_cast <const cPtr_terminalCheckInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_terminalCheckInstructionForGeneration cast_9195_si ((cPtr_terminalCheckInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      result_outOk = GALGAS_bool (kIsEqual, object->mAttribute_mTerminalName.reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 213)).objectCompare (cast_9195_si.reader_mTerminalName (SOURCE_FILE ("syntaxSignature.gSemantics", 213)).reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 213)))) ;
      const enumGalgasBool test_0 = result_outOk.operator_not (SOURCE_FILE ("syntaxSignature.gSemantics", 214)).boolEnum () ;
      if (kBoolTrue == test_0) {
        inCompiler->emitSemanticError (cast_9195_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 215)), GALGAS_string ("syntax signature error; the expected syntax instruction here is the '$").operator_concat (object->mAttribute_mTerminalName.reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 216))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 216)).operator_concat (GALGAS_string ("$' terminal check")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 216))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 215)) ;
      }
    }else if (NULL != dynamic_cast <const cPtr_syntaxInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_syntaxInstructionForGeneration cast_9510_si ((cPtr_syntaxInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      inCompiler->emitSemanticError (cast_9510_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 220)), GALGAS_string ("syntax signature error; the expected syntax instruction here is the '$").operator_concat (object->mAttribute_mTerminalName.reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 221))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 221)).operator_concat (GALGAS_string ("$' terminal check")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 221))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 220)) ;
      result_outOk = GALGAS_bool (false) ;
    }else{
      inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("internal error")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 225)) ;
      result_outOk = GALGAS_bool (false) ;
    }
  }
  const enumGalgasBool test_1 = result_outOk.operator_not (SOURCE_FILE ("syntaxSignature.gSemantics", 228)).boolEnum () ;
  if (kBoolTrue == test_1) {
    inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("reference syntax instruction is here")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 229)) ;
  }
//---
  return result_outOk ;
}


//-----------------------------------------------------------------------------*

static void defineCategoryReader_terminalCheckInstructionForGeneration_compareSyntaxInstruction (void) {
  enterCategoryReader_compareSyntaxInstruction (kTypeDescriptor_GALGAS_terminalCheckInstructionForGeneration.mSlotID,
                                                categoryReader_terminalCheckInstructionForGeneration_compareSyntaxInstruction) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gReader_terminalCheckInstructionForGeneration_compareSyntaxInstruction (defineCategoryReader_terminalCheckInstructionForGeneration_compareSyntaxInstruction, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category reader '@nonterminalInstructionForGeneration compareSyntaxInstruction'*
//                                                                             *
//-----------------------------------------------------------------------------*

static GALGAS_bool categoryReader_nonterminalInstructionForGeneration_compareSyntaxInstruction (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                                const GALGAS_semanticInstructionForGeneration & constinArgument_inTestedInstruction,
                                                                                                C_Compiler * inCompiler
                                                                                                COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bool result_outOk ; // Returned variable
  const cPtr_nonterminalInstructionForGeneration * object = (const cPtr_nonterminalInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_nonterminalInstructionForGeneration) ;
  if (constinArgument_inTestedInstruction.isValid ()) {
    if (NULL != dynamic_cast <const cPtr_nonterminalInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_nonterminalInstructionForGeneration cast_10226_si ((cPtr_nonterminalInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      result_outOk = GALGAS_bool (kIsEqual, object->mAttribute_mNonterminalName.objectCompare (cast_10226_si.reader_mNonterminalName (SOURCE_FILE ("syntaxSignature.gSemantics", 243)))) ;
      const enumGalgasBool test_0 = result_outOk.operator_not (SOURCE_FILE ("syntaxSignature.gSemantics", 244)).boolEnum () ;
      if (kBoolTrue == test_0) {
        inCompiler->emitSemanticError (cast_10226_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 245)), GALGAS_string ("syntax signature error; the expected syntax instruction here is the '<").operator_concat (object->mAttribute_mNonterminalName  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 246)).operator_concat (GALGAS_string (">' nonterminal invocation")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 246))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 245)) ;
      }
    }else if (NULL != dynamic_cast <const cPtr_syntaxInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_syntaxInstructionForGeneration cast_10540_si ((cPtr_syntaxInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      inCompiler->emitSemanticError (cast_10540_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 250)), GALGAS_string ("syntax signature error; the expected syntax instruction here is the '<").operator_concat (object->mAttribute_mNonterminalName  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 251)).operator_concat (GALGAS_string (">' nonterminal invocation")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 251))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 250)) ;
      result_outOk = GALGAS_bool (false) ;
    }else{
      inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("internal error")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 255)) ;
      result_outOk = GALGAS_bool (false) ;
    }
  }
  const enumGalgasBool test_1 = result_outOk.operator_not (SOURCE_FILE ("syntaxSignature.gSemantics", 258)).boolEnum () ;
  if (kBoolTrue == test_1) {
    inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("reference syntax instruction is here")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 259)) ;
  }
//---
  return result_outOk ;
}


//-----------------------------------------------------------------------------*

static void defineCategoryReader_nonterminalInstructionForGeneration_compareSyntaxInstruction (void) {
  enterCategoryReader_compareSyntaxInstruction (kTypeDescriptor_GALGAS_nonterminalInstructionForGeneration.mSlotID,
                                                categoryReader_nonterminalInstructionForGeneration_compareSyntaxInstruction) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gReader_nonterminalInstructionForGeneration_compareSyntaxInstruction (defineCategoryReader_nonterminalInstructionForGeneration_compareSyntaxInstruction, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category reader '@repeatInstructionForGeneration compareSyntaxInstruction'*
//                                                                             *
//-----------------------------------------------------------------------------*

static GALGAS_bool categoryReader_repeatInstructionForGeneration_compareSyntaxInstruction (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                           const GALGAS_semanticInstructionForGeneration & constinArgument_inTestedInstruction,
                                                                                           C_Compiler * inCompiler
                                                                                           COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bool result_outOk ; // Returned variable
  const cPtr_repeatInstructionForGeneration * object = (const cPtr_repeatInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_repeatInstructionForGeneration) ;
  if (constinArgument_inTestedInstruction.isValid ()) {
    if (NULL != dynamic_cast <const cPtr_repeatInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_repeatInstructionForGeneration cast_11257_si ((cPtr_repeatInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      result_outOk = function_compareSyntaxSignature (object->mAttribute_m_5F_repeated_5F_instructionList, cast_11257_si.reader_m_5F_repeated_5F_instructionList (SOURCE_FILE ("syntaxSignature.gSemantics", 273)), cast_11257_si.reader_mEndOfRepeatedInstructions (SOURCE_FILE ("syntaxSignature.gSemantics", 273)), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 273)) ;
      const enumGalgasBool test_0 = result_outOk.operator_and (GALGAS_bool (kIsNotEqual, object->mAttribute_mListOfSemanticInstructionListForGeneration.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 274)).objectCompare (cast_11257_si.reader_mListOfSemanticInstructionListForGeneration (SOURCE_FILE ("syntaxSignature.gSemantics", 274)).reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 274)))) COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 274)).boolEnum () ;
      if (kBoolTrue == test_0) {
        inCompiler->emitSemanticError (cast_11257_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 275)), GALGAS_string ("syntax signature error; the reference 'repeat' instruction has ").operator_concat (object->mAttribute_mListOfSemanticInstructionListForGeneration.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 277)).reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 277))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 276)).operator_concat (GALGAS_string (" 'while' branche(s), but this instruction has ")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 277)).operator_concat (cast_11257_si.reader_mListOfSemanticInstructionListForGeneration (SOURCE_FILE ("syntaxSignature.gSemantics", 279)).reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 279)).reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 279))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 278))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 275)) ;
        result_outOk = GALGAS_bool (false) ;
      }
      cEnumerator_listOfSemanticInstructionListForGeneration enumerator_11952 (object->mAttribute_mListOfSemanticInstructionListForGeneration, kEnumeration_up) ;
      cEnumerator_listOfSemanticInstructionListForGeneration enumerator_12009 (cast_11257_si.reader_mListOfSemanticInstructionListForGeneration (SOURCE_FILE ("syntaxSignature.gSemantics", 283)), kEnumeration_up) ;
      bool bool_1 = result_outOk.isValidAndTrue () ;
      if (enumerator_11952.hasCurrentObject () && enumerator_12009.hasCurrentObject () && bool_1) {
        while (enumerator_11952.hasCurrentObject () && enumerator_12009.hasCurrentObject () && bool_1) {
          result_outOk = function_compareSyntaxSignature (enumerator_11952.current_mInstructionList (HERE), enumerator_12009.current_mInstructionList (HERE), enumerator_12009.current_mEndOfInstructionList (HERE), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 284)) ;
          enumerator_11952.gotoNextObject () ;
          enumerator_12009.gotoNextObject () ;
          if (enumerator_11952.hasCurrentObject () && enumerator_12009.hasCurrentObject ()) {
            bool_1 = result_outOk.isValidAndTrue () ;
          }
        }
      }
    }else if (NULL != dynamic_cast <const cPtr_syntaxInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_syntaxInstructionForGeneration cast_12214_si ((cPtr_syntaxInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      inCompiler->emitSemanticError (cast_12214_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 287)), GALGAS_string ("syntax signature error; the expected syntax instruction here is a 'repeat' instruction")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 287)) ;
      result_outOk = GALGAS_bool (false) ;
    }else{
      inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("internal error")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 292)) ;
      result_outOk = GALGAS_bool (false) ;
    }
  }
  const enumGalgasBool test_2 = result_outOk.operator_not (SOURCE_FILE ("syntaxSignature.gSemantics", 295)).boolEnum () ;
  if (kBoolTrue == test_2) {
    inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("reference syntax instruction is here")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 296)) ;
  }
//---
  return result_outOk ;
}


//-----------------------------------------------------------------------------*

static void defineCategoryReader_repeatInstructionForGeneration_compareSyntaxInstruction (void) {
  enterCategoryReader_compareSyntaxInstruction (kTypeDescriptor_GALGAS_repeatInstructionForGeneration.mSlotID,
                                                categoryReader_repeatInstructionForGeneration_compareSyntaxInstruction) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gReader_repeatInstructionForGeneration_compareSyntaxInstruction (defineCategoryReader_repeatInstructionForGeneration_compareSyntaxInstruction, NULL) ;

//-----------------------------------------------------------------------------*
//                                                                             *
//Overriding category reader '@selectInstructionForGeneration compareSyntaxInstruction'*
//                                                                             *
//-----------------------------------------------------------------------------*

static GALGAS_bool categoryReader_selectInstructionForGeneration_compareSyntaxInstruction (const cPtr_semanticInstructionForGeneration * inObject,
                                                                                           const GALGAS_semanticInstructionForGeneration & constinArgument_inTestedInstruction,
                                                                                           C_Compiler * inCompiler
                                                                                           COMMA_UNUSED_LOCATION_ARGS) {
  GALGAS_bool result_outOk ; // Returned variable
  const cPtr_selectInstructionForGeneration * object = (const cPtr_selectInstructionForGeneration *) inObject ;
  macroValidSharedObject (object, cPtr_selectInstructionForGeneration) ;
  if (constinArgument_inTestedInstruction.isValid ()) {
    if (NULL != dynamic_cast <const cPtr_selectInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_selectInstructionForGeneration cast_12898_si ((cPtr_selectInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      result_outOk = GALGAS_bool (true) ;
      const enumGalgasBool test_0 = result_outOk.operator_and (GALGAS_bool (kIsNotEqual, object->mAttribute_mListOfSemanticInstructionListForGeneration.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 311)).objectCompare (cast_12898_si.reader_mListOfSemanticInstructionListForGeneration (SOURCE_FILE ("syntaxSignature.gSemantics", 311)).reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 311)))) COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 311)).boolEnum () ;
      if (kBoolTrue == test_0) {
        inCompiler->emitSemanticError (cast_12898_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 312)), GALGAS_string ("syntax signature error; the reference 'select' instruction has ").operator_concat (object->mAttribute_mListOfSemanticInstructionListForGeneration.reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 314)).reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 314))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 313)).operator_concat (GALGAS_string (" 'while' branche(s), but this instruction has ")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 314)).operator_concat (cast_12898_si.reader_mListOfSemanticInstructionListForGeneration (SOURCE_FILE ("syntaxSignature.gSemantics", 316)).reader_length (SOURCE_FILE ("syntaxSignature.gSemantics", 316)).reader_string (SOURCE_FILE ("syntaxSignature.gSemantics", 316))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 315))  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 312)) ;
        result_outOk = GALGAS_bool (false) ;
      }
      cEnumerator_listOfSemanticInstructionListForGeneration enumerator_13479 (object->mAttribute_mListOfSemanticInstructionListForGeneration, kEnumeration_up) ;
      cEnumerator_listOfSemanticInstructionListForGeneration enumerator_13536 (cast_12898_si.reader_mListOfSemanticInstructionListForGeneration (SOURCE_FILE ("syntaxSignature.gSemantics", 320)), kEnumeration_up) ;
      bool bool_1 = result_outOk.isValidAndTrue () ;
      if (enumerator_13479.hasCurrentObject () && enumerator_13536.hasCurrentObject () && bool_1) {
        while (enumerator_13479.hasCurrentObject () && enumerator_13536.hasCurrentObject () && bool_1) {
          result_outOk = function_compareSyntaxSignature (enumerator_13479.current_mInstructionList (HERE), enumerator_13536.current_mInstructionList (HERE), enumerator_13536.current_mEndOfInstructionList (HERE), inCompiler COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 321)) ;
          enumerator_13479.gotoNextObject () ;
          enumerator_13536.gotoNextObject () ;
          if (enumerator_13479.hasCurrentObject () && enumerator_13536.hasCurrentObject ()) {
            bool_1 = result_outOk.isValidAndTrue () ;
          }
        }
      }
    }else if (NULL != dynamic_cast <const cPtr_syntaxInstructionForGeneration *> (constinArgument_inTestedInstruction.ptr ())) {
      GALGAS_syntaxInstructionForGeneration cast_13741_si ((cPtr_syntaxInstructionForGeneration *) constinArgument_inTestedInstruction.ptr ()) ;
      inCompiler->emitSemanticError (cast_13741_si.reader_mInstructionLocation (SOURCE_FILE ("syntaxSignature.gSemantics", 324)), GALGAS_string ("syntax signature error; the expected syntax instruction here is a 'select' instruction")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 324)) ;
      result_outOk = GALGAS_bool (false) ;
    }else{
      inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("internal error")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 329)) ;
      result_outOk = GALGAS_bool (false) ;
    }
  }
  const enumGalgasBool test_2 = result_outOk.operator_not (SOURCE_FILE ("syntaxSignature.gSemantics", 332)).boolEnum () ;
  if (kBoolTrue == test_2) {
    inCompiler->emitSemanticError (object->mAttribute_mInstructionLocation, GALGAS_string ("reference syntax instruction is here")  COMMA_SOURCE_FILE ("syntaxSignature.gSemantics", 333)) ;
  }
//---
  return result_outOk ;
}


//-----------------------------------------------------------------------------*

static void defineCategoryReader_selectInstructionForGeneration_compareSyntaxInstruction (void) {
  enterCategoryReader_compareSyntaxInstruction (kTypeDescriptor_GALGAS_selectInstructionForGeneration.mSlotID,
                                                categoryReader_selectInstructionForGeneration_compareSyntaxInstruction) ;
}

//-----------------------------------------------------------------------------*

C_PrologueEpilogue gReader_selectInstructionForGeneration_compareSyntaxInstruction (defineCategoryReader_selectInstructionForGeneration_compareSyntaxInstruction, NULL) ;

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2


