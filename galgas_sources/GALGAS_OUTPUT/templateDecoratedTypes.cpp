//---------------------------------------------------------------------------*
//                                                                           *
//                    File 'templateDecoratedTypes.cpp'                      *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 1st, 2010, at 21h23'8"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "templateDecoratedTypes.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "templateDecoratedTypes.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_templateInstructionStringForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionStringForGeneration::
cPtr_templateInstructionStringForGeneration (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE),
mTemplateString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionStringForGeneration * GGS_templateInstructionStringForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionStringForGeneration) ;
    return (cPtr_templateInstructionStringForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionStringForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionStringForGeneration * ptr = dynamic_cast <const cPtr_templateInstructionStringForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTemplateString.operator_isEqual (ptr->mTemplateString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionStringForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionStringForGeneration:"
           << mTemplateString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionStringForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionStringForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionStringForGeneration (& typeid (cPtr_templateInstructionStringForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionStringForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionStringForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionStringForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionStringForGeneration (mTemplateString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_templateInstructionStringForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionStringForGeneration ("templateInstructionStringForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionStringForGeneration::
GGS_templateInstructionStringForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionStringForGeneration::
GGS_templateInstructionStringForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionStringForGeneration GGS_templateInstructionStringForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionStringForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionStringForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionStringForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionStringForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionStringForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionStringForGeneration GGS_templateInstructionStringForGeneration::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionStringForGeneration result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionStringForGeneration (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionStringForGeneration::
reader_mTemplateString (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionStringForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionStringForGeneration *) mPointer)->mTemplateString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionStringForGeneration::actualTypeName (void) const {
  return "templateInstructionStringForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionStringForGeneration ("templateInstructionStringForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionStringForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionStringForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionStringForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionStringForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionStringForGeneration GGS_templateInstructionStringForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionStringForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionStringForGeneration * p = dynamic_cast <const GGS_templateInstructionStringForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionStringForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionStringForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionStringForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         class 'cPtr_templateInstructionExpressionForGeneration'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionExpressionForGeneration::
cPtr_templateInstructionExpressionForGeneration (const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionExpressionForGeneration * GGS_templateInstructionExpressionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionExpressionForGeneration) ;
    return (cPtr_templateInstructionExpressionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionExpressionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionExpressionForGeneration * ptr = dynamic_cast <const cPtr_templateInstructionExpressionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionExpressionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionExpressionForGeneration:"
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionExpressionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionExpressionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionExpressionForGeneration (& typeid (cPtr_templateInstructionExpressionForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionExpressionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionExpressionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionExpressionForGeneration (mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      GALGAS class 'GGS_templateInstructionExpressionForGeneration'        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionExpressionForGeneration ("templateInstructionExpressionForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionForGeneration::
GGS_templateInstructionExpressionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionForGeneration::
GGS_templateInstructionExpressionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionExpressionForGeneration GGS_templateInstructionExpressionForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpressionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionExpressionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionExpressionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionExpressionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionExpressionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionForGeneration GGS_templateInstructionExpressionForGeneration::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpressionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionExpressionForGeneration (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_templateInstructionExpressionForGeneration::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionExpressionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionExpressionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionExpressionForGeneration::actualTypeName (void) const {
  return "templateInstructionExpressionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionExpressionForGeneration ("templateInstructionExpressionForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionExpressionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionExpressionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionExpressionForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionExpressionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionForGeneration GGS_templateInstructionExpressionForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpressionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionExpressionForGeneration * p = dynamic_cast <const GGS_templateInstructionExpressionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionExpressionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionExpressionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionExpressionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_templateBlockInstructionForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateBlockInstructionForGeneration::
cPtr_templateBlockInstructionForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_location & argument_1,
                                const GGS_templateInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE),
mExpression (argument_0),
mLocation (argument_1),
mBlockInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateBlockInstructionForGeneration * GGS_templateBlockInstructionForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateBlockInstructionForGeneration) ;
    return (cPtr_templateBlockInstructionForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateBlockInstructionForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateBlockInstructionForGeneration * ptr = dynamic_cast <const cPtr_templateBlockInstructionForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mBlockInstructionList.operator_isEqual (ptr->mBlockInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateBlockInstructionForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateBlockInstructionForGeneration:"
           << mExpression.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mBlockInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateBlockInstructionForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateBlockInstructionForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateBlockInstructionForGeneration (& typeid (cPtr_templateBlockInstructionForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateBlockInstructionForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateBlockInstructionForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateBlockInstructionForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateBlockInstructionForGeneration (mExpression, mLocation, mBlockInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_templateBlockInstructionForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateBlockInstructionForGeneration ("templateBlockInstructionForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionForGeneration::
GGS_templateBlockInstructionForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionForGeneration::
GGS_templateBlockInstructionForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateBlockInstructionForGeneration GGS_templateBlockInstructionForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstructionForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateBlockInstructionForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateBlockInstructionForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateBlockInstructionForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateBlockInstructionForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionForGeneration GGS_templateBlockInstructionForGeneration::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_location & argument_1,
                 const GGS_templateInstructionListForGeneration & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstructionForGeneration result ;
  macroMyNew (result.mPointer, cPtr_templateBlockInstructionForGeneration (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_templateBlockInstructionForGeneration::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateBlockInstructionForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateBlockInstructionForGeneration::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateBlockInstructionForGeneration *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateBlockInstructionForGeneration::
reader_mBlockInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstructionForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateBlockInstructionForGeneration *) mPointer)->mBlockInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateBlockInstructionForGeneration::actualTypeName (void) const {
  return "templateBlockInstructionForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateBlockInstructionForGeneration ("templateBlockInstructionForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateBlockInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateBlockInstructionForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateBlockInstructionForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateBlockInstructionForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionForGeneration GGS_templateBlockInstructionForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstructionForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateBlockInstructionForGeneration * p = dynamic_cast <const GGS_templateBlockInstructionForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateBlockInstructionForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateBlockInstructionForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateBlockInstructionForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      class 'cPtr_templateInstructionGetColumnLocationForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionGetColumnLocationForGeneration::
cPtr_templateInstructionGetColumnLocationForGeneration (LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionGetColumnLocationForGeneration * GGS_templateInstructionGetColumnLocationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionGetColumnLocationForGeneration) ;
    return (cPtr_templateInstructionGetColumnLocationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionGetColumnLocationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionGetColumnLocationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstructionGetColumnLocationForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGetColumnLocationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGetColumnLocationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionGetColumnLocationForGeneration (& typeid (cPtr_templateInstructionGetColumnLocationForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionGetColumnLocationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionGetColumnLocationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   GALGAS class 'GGS_templateInstructionGetColumnLocationForGeneration'    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionGetColumnLocationForGeneration ("templateInstructionGetColumnLocationForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationForGeneration::
GGS_templateInstructionGetColumnLocationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationForGeneration::
GGS_templateInstructionGetColumnLocationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionGetColumnLocationForGeneration GGS_templateInstructionGetColumnLocationForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGetColumnLocationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionGetColumnLocationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionGetColumnLocationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionGetColumnLocationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionGetColumnLocationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_templateInstructionGetColumnLocationForGeneration * gSingleton_templateInstructionGetColumnLocationForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationForGeneration GGS_templateInstructionGetColumnLocationForGeneration::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGetColumnLocationForGeneration result ;
  if (NULL == gSingleton_templateInstructionGetColumnLocationForGeneration) {
    macroMyNew (gSingleton_templateInstructionGetColumnLocationForGeneration, cPtr_templateInstructionGetColumnLocationForGeneration (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_templateInstructionGetColumnLocationForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionGetColumnLocationForGeneration::actualTypeName (void) const {
  return "templateInstructionGetColumnLocationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionGetColumnLocationForGeneration ("templateInstructionGetColumnLocationForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionGetColumnLocationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionGetColumnLocationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionGetColumnLocationForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionGetColumnLocationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationForGeneration GGS_templateInstructionGetColumnLocationForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGetColumnLocationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionGetColumnLocationForGeneration * p = dynamic_cast <const GGS_templateInstructionGetColumnLocationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionGetColumnLocationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionGetColumnLocationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionGetColumnLocationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     class 'cPtr_templateInstructionGotoColumnLocationForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionGotoColumnLocationForGeneration::
cPtr_templateInstructionGotoColumnLocationForGeneration (LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionGotoColumnLocationForGeneration * GGS_templateInstructionGotoColumnLocationForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionGotoColumnLocationForGeneration) ;
    return (cPtr_templateInstructionGotoColumnLocationForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionGotoColumnLocationForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionGotoColumnLocationForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstructionGotoColumnLocationForGeneration:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGotoColumnLocationForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGotoColumnLocationForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionGotoColumnLocationForGeneration (& typeid (cPtr_templateInstructionGotoColumnLocationForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionGotoColumnLocationForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionGotoColumnLocationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  GALGAS class 'GGS_templateInstructionGotoColumnLocationForGeneration'    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionGotoColumnLocationForGeneration ("templateInstructionGotoColumnLocationForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationForGeneration::
GGS_templateInstructionGotoColumnLocationForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationForGeneration::
GGS_templateInstructionGotoColumnLocationForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionGotoColumnLocationForGeneration GGS_templateInstructionGotoColumnLocationForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGotoColumnLocationForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionGotoColumnLocationForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionGotoColumnLocationForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionGotoColumnLocationForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionGotoColumnLocationForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_templateInstructionGotoColumnLocationForGeneration * gSingleton_templateInstructionGotoColumnLocationForGeneration = NULL ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationForGeneration GGS_templateInstructionGotoColumnLocationForGeneration::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGotoColumnLocationForGeneration result ;
  if (NULL == gSingleton_templateInstructionGotoColumnLocationForGeneration) {
    macroMyNew (gSingleton_templateInstructionGotoColumnLocationForGeneration, cPtr_templateInstructionGotoColumnLocationForGeneration (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_templateInstructionGotoColumnLocationForGeneration) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionGotoColumnLocationForGeneration::actualTypeName (void) const {
  return "templateInstructionGotoColumnLocationForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionGotoColumnLocationForGeneration ("templateInstructionGotoColumnLocationForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionGotoColumnLocationForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionGotoColumnLocationForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionGotoColumnLocationForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionGotoColumnLocationForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationForGeneration GGS_templateInstructionGotoColumnLocationForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGotoColumnLocationForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionGotoColumnLocationForGeneration * p = dynamic_cast <const GGS_templateInstructionGotoColumnLocationForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionGotoColumnLocationForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionGotoColumnLocationForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionGotoColumnLocationForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_templateInstructionForeachForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionForeachForGeneration::
cPtr_templateInstructionForeachForGeneration (const GGS_bool& argument_0,
                                const GGS_semanticExpressionForGeneration & argument_1,
                                const GGS_string& argument_2,
                                const GGS_templateInstructionListForGeneration & argument_3,
                                const GGS_templateInstructionListForGeneration & argument_4,
                                const GGS_string& argument_5,
                                const GGS_templateInstructionListForGeneration & argument_6,
                                const GGS_templateInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE),
mIsAscending (argument_0),
mExpression (argument_1),
mEnumeratorCppName (argument_2),
mBeforeInstructionList (argument_3),
mDoInstructionList (argument_4),
mIndexCppName (argument_5),
mBetweenInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionForeachForGeneration * GGS_templateInstructionForeachForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionForeachForGeneration) ;
    return (cPtr_templateInstructionForeachForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionForeachForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionForeachForGeneration * ptr = dynamic_cast <const cPtr_templateInstructionForeachForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mEnumeratorCppName.operator_isEqual (ptr->mEnumeratorCppName).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mIndexCppName.operator_isEqual (ptr->mIndexCppName).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionForeachForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionForeachForGeneration:"
           << mIsAscending.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1)
           << mEnumeratorCppName.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mIndexCppName.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForeachForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForeachForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionForeachForGeneration (& typeid (cPtr_templateInstructionForeachForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionForeachForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionForeachForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionForeachForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionForeachForGeneration (mIsAscending, mExpression, mEnumeratorCppName, mBeforeInstructionList, mDoInstructionList, mIndexCppName, mBetweenInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_templateInstructionForeachForGeneration'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionForeachForGeneration ("templateInstructionForeachForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachForGeneration::
GGS_templateInstructionForeachForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachForGeneration::
GGS_templateInstructionForeachForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionForeachForGeneration GGS_templateInstructionForeachForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeachForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionForeachForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionForeachForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionForeachForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachForGeneration GGS_templateInstructionForeachForGeneration::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_semanticExpressionForGeneration & argument_1,
                 const GGS_string& argument_2,
                 const GGS_templateInstructionListForGeneration & argument_3,
                 const GGS_templateInstructionListForGeneration & argument_4,
                 const GGS_string& argument_5,
                 const GGS_templateInstructionListForGeneration & argument_6,
                 const GGS_templateInstructionListForGeneration & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeachForGeneration result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionForeachForGeneration (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateInstructionForeachForGeneration::
reader_mIsAscending (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mIsAscending ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_templateInstructionForeachForGeneration::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionForeachForGeneration::
reader_mEnumeratorCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mEnumeratorCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionForeachForGeneration::
reader_mBeforeInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionForeachForGeneration::
reader_mDoInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionForeachForGeneration::
reader_mIndexCppName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mIndexCppName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionForeachForGeneration::
reader_mBetweenInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionForeachForGeneration::
reader_mAfterInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachForGeneration *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionForeachForGeneration::actualTypeName (void) const {
  return "templateInstructionForeachForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionForeachForGeneration ("templateInstructionForeachForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionForeachForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionForeachForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionForeachForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionForeachForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachForGeneration GGS_templateInstructionForeachForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeachForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionForeachForGeneration * p = dynamic_cast <const GGS_templateInstructionForeachForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionForeachForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionForeachForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionForeachForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Element of list '@templateInstructionIfBranchListForGeneration'       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionIfBranchListForGeneration::
elementOf_GGS_templateInstructionIfBranchListForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionIfBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionIfBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_templateInstructionIfBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionIfBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           List '@templateInstructionIfBranchListForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionIfBranchListForGeneration ("templateInstructionIfBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
internalAppendValues (const GGS_semanticExpressionForGeneration & argument_0,
                    const GGS_templateInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
internalPrependValues (const GGS_semanticExpressionForGeneration & argument_0,
                    const GGS_templateInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
addAssign_operation (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration GGS_templateInstructionIfBranchListForGeneration::
operator_concat (const GGS_templateInstructionIfBranchListForGeneration & inOperand) const {
  GGS_templateInstructionIfBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
dotAssign_operation (const GGS_templateInstructionIfBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionIfBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionForGeneration  p_0 = p->mExpression ;
          GGS_templateInstructionListForGeneration  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_semanticExpressionForGeneration & argument_0,
                     const GGS_templateInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration  GGS_templateInstructionIfBranchListForGeneration::
constructor_emptyList (void) {
  GGS_templateInstructionIfBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration  GGS_templateInstructionIfBranchListForGeneration::
constructor_listWithValue (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1) {
  GGS_templateInstructionIfBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
internalSubListWithRange (GGS_templateInstructionIfBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration GGS_templateInstructionIfBranchListForGeneration::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration GGS_templateInstructionIfBranchListForGeneration::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionIfBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionIfBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
method_first (C_CompilerEx & inLexique,
              GGS_semanticExpressionForGeneration & _out_0,
              GGS_templateInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
method_last (C_CompilerEx & inLexique,
             GGS_semanticExpressionForGeneration & _out_0,
             GGS_templateInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_semanticExpressionForGeneration & _out_0,
                 GGS_templateInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_semanticExpressionForGeneration & _out_0,
                GGS_templateInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_templateInstructionIfBranchListForGeneration::
reader_mExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionIfBranchListForGeneration::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
modifier_setMExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_semanticExpressionForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListForGeneration::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionForGeneration  & GGS_templateInstructionIfBranchListForGeneration::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionListForGeneration  & GGS_templateInstructionIfBranchListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionIfBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionIfBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionIfBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration GGS_templateInstructionIfBranchListForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionIfBranchListForGeneration * p = dynamic_cast <const GGS_templateInstructionIfBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionIfBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionIfBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionIfBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_templateInstructionIfForGeneration'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionIfForGeneration::
cPtr_templateInstructionIfForGeneration (const GGS_templateInstructionIfBranchListForGeneration & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE),
mTemplateInstructionIfBranchList (argument_0),
mElseInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionIfForGeneration * GGS_templateInstructionIfForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionIfForGeneration) ;
    return (cPtr_templateInstructionIfForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionIfForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionIfForGeneration * ptr = dynamic_cast <const cPtr_templateInstructionIfForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTemplateInstructionIfBranchList.operator_isEqual (ptr->mTemplateInstructionIfBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionIfForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionIfForGeneration:"
           << mTemplateInstructionIfBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionIfForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionIfForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionIfForGeneration (& typeid (cPtr_templateInstructionIfForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionIfForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionIfForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionIfForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionIfForGeneration (mTemplateInstructionIfBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_templateInstructionIfForGeneration'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionIfForGeneration ("templateInstructionIfForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionIfForGeneration::
GGS_templateInstructionIfForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfForGeneration::
GGS_templateInstructionIfForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionIfForGeneration GGS_templateInstructionIfForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionIfForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionIfForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionIfForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionIfForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfForGeneration GGS_templateInstructionIfForGeneration::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateInstructionIfBranchListForGeneration & argument_0,
                 const GGS_templateInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfForGeneration result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionIfForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListForGeneration  GGS_templateInstructionIfForGeneration::
reader_mTemplateInstructionIfBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionIfForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionIfForGeneration *) mPointer)->mTemplateInstructionIfBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionIfForGeneration::
reader_mElseInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionIfForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionIfForGeneration *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionIfForGeneration::actualTypeName (void) const {
  return "templateInstructionIfForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionIfForGeneration ("templateInstructionIfForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionIfForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionIfForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionIfForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionIfForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfForGeneration GGS_templateInstructionIfForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionIfForGeneration * p = dynamic_cast <const GGS_templateInstructionIfForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionIfForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionIfForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionIfForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Element of list '@templateInstructionSwitchBranchListForGeneration'     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionSwitchBranchListForGeneration::
elementOf_GGS_templateInstructionSwitchBranchListForGeneration (const GGS_lstringlist & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mConstantList (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionSwitchBranchListForGeneration::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionSwitchBranchListForGeneration * ptr = dynamic_cast <const elementOf_GGS_templateInstructionSwitchBranchListForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionSwitchBranchListForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         List '@templateInstructionSwitchBranchListForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionSwitchBranchListForGeneration ("templateInstructionSwitchBranchListForGeneration", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_templateInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_templateInstructionListForGeneration & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration GGS_templateInstructionSwitchBranchListForGeneration::
operator_concat (const GGS_templateInstructionSwitchBranchListForGeneration & inOperand) const {
  GGS_templateInstructionSwitchBranchListForGeneration result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
dotAssign_operation (const GGS_templateInstructionSwitchBranchListForGeneration inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionSwitchBranchListForGeneration * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mConstantList ;
          GGS_templateInstructionListForGeneration  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_templateInstructionListForGeneration & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantList,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration  GGS_templateInstructionSwitchBranchListForGeneration::
constructor_emptyList (void) {
  GGS_templateInstructionSwitchBranchListForGeneration result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration  GGS_templateInstructionSwitchBranchListForGeneration::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_templateInstructionListForGeneration & argument_1) {
  GGS_templateInstructionSwitchBranchListForGeneration result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
internalSubListWithRange (GGS_templateInstructionSwitchBranchListForGeneration & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantList, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration GGS_templateInstructionSwitchBranchListForGeneration::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionSwitchBranchListForGeneration result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration GGS_templateInstructionSwitchBranchListForGeneration::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionSwitchBranchListForGeneration result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionSwitchBranchListForGeneration::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionSwitchBranchListForGeneration", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
method_first (C_CompilerEx & inLexique,
              GGS_lstringlist & _out_0,
              GGS_templateInstructionListForGeneration & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
method_last (C_CompilerEx & inLexique,
             GGS_lstringlist & _out_0,
             GGS_templateInstructionListForGeneration & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_templateInstructionListForGeneration & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstringlist & _out_0,
                GGS_templateInstructionListForGeneration & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_templateInstructionSwitchBranchListForGeneration::
reader_mConstantListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListForGeneration  GGS_templateInstructionSwitchBranchListForGeneration::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListForGeneration  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
modifier_setMConstantListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListForGeneration::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateInstructionListForGeneration  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_templateInstructionSwitchBranchListForGeneration::cEnumerator::_mConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionListForGeneration  & GGS_templateInstructionSwitchBranchListForGeneration::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionSwitchBranchListForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionSwitchBranchListForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionSwitchBranchListForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration GGS_templateInstructionSwitchBranchListForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchBranchListForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionSwitchBranchListForGeneration * p = dynamic_cast <const GGS_templateInstructionSwitchBranchListForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionSwitchBranchListForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionSwitchBranchListForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionSwitchBranchListForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_templateInstructionSwitchForGeneration'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionSwitchForGeneration::
cPtr_templateInstructionSwitchForGeneration (const GGS_semanticExpressionForGeneration & argument_0,
                                const GGS_templateInstructionSwitchBranchListForGeneration & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionForGeneration (THERE),
mSwitchExpression (argument_0),
mTemplateInstructionSwitchBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionSwitchForGeneration * GGS_templateInstructionSwitchForGeneration::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionSwitchForGeneration) ;
    return (cPtr_templateInstructionSwitchForGeneration *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionSwitchForGeneration::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionSwitchForGeneration * ptr = dynamic_cast <const cPtr_templateInstructionSwitchForGeneration *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mTemplateInstructionSwitchBranchList.operator_isEqual (ptr->mTemplateInstructionSwitchBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionSwitchForGeneration::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionSwitchForGeneration:"
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mTemplateInstructionSwitchBranchList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionSwitchForGeneration::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionSwitchForGeneration::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionSwitchForGeneration (& typeid (cPtr_templateInstructionSwitchForGeneration), & typeid (cPtr_templateInstructionForGeneration), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionSwitchForGeneration::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionSwitchForGeneration ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionSwitchForGeneration::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionSwitchForGeneration (mSwitchExpression, mTemplateInstructionSwitchBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_templateInstructionSwitchForGeneration'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionSwitchForGeneration ("templateInstructionSwitchForGeneration", true, & kTypeDescriptor_GGS_templateInstructionForGeneration) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchForGeneration::
GGS_templateInstructionSwitchForGeneration (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchForGeneration::
GGS_templateInstructionSwitchForGeneration (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionSwitchForGeneration GGS_templateInstructionSwitchForGeneration::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchForGeneration result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionSwitchForGeneration *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionSwitchForGeneration) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionSwitchForGeneration (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionSwitchForGeneration),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchForGeneration GGS_templateInstructionSwitchForGeneration::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_semanticExpressionForGeneration & argument_0,
                 const GGS_templateInstructionSwitchBranchListForGeneration & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchForGeneration result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionSwitchForGeneration (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionForGeneration  GGS_templateInstructionSwitchForGeneration::
reader_mSwitchExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionSwitchForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionSwitchForGeneration *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListForGeneration  GGS_templateInstructionSwitchForGeneration::
reader_mTemplateInstructionSwitchBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionSwitchBranchListForGeneration   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionSwitchForGeneration *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionSwitchForGeneration *) mPointer)->mTemplateInstructionSwitchBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionSwitchForGeneration::actualTypeName (void) const {
  return "templateInstructionSwitchForGeneration" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionSwitchForGeneration ("templateInstructionSwitchForGeneration", gClassInfoFor__templateInstructionForGeneration, & kTypeDescriptor_GGS_templateInstructionSwitchForGeneration) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionSwitchForGeneration::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionSwitchForGeneration * p = NULL ;
    macroMyNew (p, GGS_templateInstructionSwitchForGeneration (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchForGeneration GGS_templateInstructionSwitchForGeneration::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchForGeneration result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionSwitchForGeneration * p = dynamic_cast <const GGS_templateInstructionSwitchForGeneration *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionSwitchForGeneration, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionSwitchForGeneration::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionSwitchForGeneration ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_templateDecoratedTypes (void) {
  macroReleaseObject (gSingleton_templateInstructionGetColumnLocationForGeneration) ;
  macroReleaseObject (gSingleton_templateInstructionGotoColumnLocationForGeneration) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_templateDecoratedTypes (NULL, epilogueRoutineFor_templateDecoratedTypes) ;

//---------------------------------------------------------------------------*

